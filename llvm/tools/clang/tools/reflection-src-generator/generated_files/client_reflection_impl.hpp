//===---------------- client_reflection_impl.hpp ----------------===//
//
//    AUTO-GENERATED -- DO NOT EDIT THIS FILE DIRECTLY
//
//===----------------------------------------------===//
#ifndef CPPX_META_client_reflection_impl_HPP
#define CPPX_META_client_reflection_impl_HPP

#include <cstdint> //for intptr_t
#include <utility> //for std::move
#include <cassert>

#define PP_EXPAND(...) __VA_ARGS__
#define PP_UNCNDL_REMOVE_PARENS(x) PP_EXPAND x

#ifdef __CONSUMER_SUPPORTS_REFLECTION_AND_META__
#   define M_template       template
#   define M_tbeg           <
#   define M_rtpack(Zs)     intptr_t... Zs
#   define M_c              , 
#   define M_pack(Zs)       Zs...
#   define M_tend           >
#   define M_getPtrVal_T_value  refldetail::getPtrVal<T>::value
#   define IFMETA_ELSE(MP_compiler_version, MP_idehlpr_version/*ignored*/)\
      PP_UNCNDL_REMOVE_PARENS(MP_compiler_version)
    /// DWR HACK so we can get non-static fields (for accessing with . or ->
    /// syntax, instead of :: syntax); we were getting errors using decltype
    /// on the __reflect_prop/cast statements but this fixes it.
#   define M_REFLTYPED_FIELD(MP_name, MP_idehlpr_t/*ignored*/, .../*expr*/)\
      private: static constexpr auto S_ ## MP_name = __VA_ARGS__;\
      public: decltype(S_ ## MP_name) MP_name = S_ ## MP_name;
    /**/
#   define RANGECLASS_SIZE_AND_GET(RKname, ElemT/*unused*/)\
            static constexpr size_t _size_() {\
              return __reflect_range_size(reflenums::RK_ ## RKname, reflenums::RKname::_this_, Xs...);\
            }\
            template<size_t _N_>\
            static constexpr auto _get_() {\
              return __reflect_range_nth(reflenums::RK_ ## RKname, reflenums::RKname::_this_, Xs..., _N_);\
            }
    /**/
#   define DEF_RANGE_REFLECTION_TUPLE(MemName, MethodSig, ElemT/*unused*/, InitArgs, ParamArgs)\
        template<intptr_t... Xs>\
        struct MemName ## _tuple {\
            static constexpr size_t _size_() {\
              return __reflect_range_size(\
                PP_UNCNDL_REMOVE_PARENS(InitArgs) PP_UNCNDL_REMOVE_PARENS(ParamArgs) );\
            }\
            template<size_t _N_>\
            static constexpr auto _get_() {\
              return __reflect_range_nth(\
                PP_UNCNDL_REMOVE_PARENS(InitArgs), _N_ PP_UNCNDL_REMOVE_PARENS(ParamArgs) );\
            }\
        };\
    /**/
#   define RANGE_REFLECTION(ClassName, MemName, MethodSig, ElemT, InitArgs, ParamArgs)\
        MethodSig -> typename ClassName:: template MemName ## _tuple<Xs...> { return {}; }
    /**/
#else //just code-completing
#   define M_template         
#   define M_tbeg             
#   define M_rtpack(Zs)       
#   define M_c                
#   define M_pack(Zs)         
#   define M_tend             
#   define M_getPtrVal_T_value  true
#   define IFMETA_ELSE(MP_compiler_version/*ignored*/, MP_idehlpr_version)\
      PP_UNCNDL_REMOVE_PARENS(MP_idehlpr_version)
#   define M_REFLTYPED_FIELD(MP_name, MP_idehlpr_t, .../*ignored*/)\
      PP_UNCNDL_REMOVE_PARENS(MP_idehlpr_t) MP_name;
    /**/
#   define DUMMY_ITERATOR_BEGIN_END(...)\
      private:\
          struct iterator_t {\
              constexpr __VA_ARGS__ operator*() const;\
              constexpr iterator_t &operator++();\
              constexpr iterator_t operator++(int);\
              constexpr bool operator==(const iterator_t &other) const;\
              constexpr bool operator!=(const iterator_t &other) const;\
          };\
      public:\
          iterator_t begin() const;\
          iterator_t end() const;
    /**/
#   define RANGECLASS_SIZE_AND_GET(RKname, ...) DUMMY_ITERATOR_BEGIN_END(__VA_ARGS__)
#   define DEF_RANGE_REFLECTION_TUPLE(MemName, MethodSig, ElemT/*unused*/, InitArgs, ParamArgs)
#   define RANGE_REFLECTION(ClassName, MemName, MethodSig, ElemT, InitArgs, ParamArgs)\
    MethodSig {\
      class dummy_range {\
          DUMMY_ITERATOR_BEGIN_END(PP_UNCNDL_REMOVE_PARENS(ElemT))\
      };\
      return dummy_range();\
    }
#   define DONT_USE \
      static_assert(false && "Not intended to be used, just to aid the IDE with code completion. "\
                  "You must #define __CONSUMER_SUPPORTS_REFLECTION_AND_META__ during actual compilation to turn the real implem on.")


#endif // end of stuff used when not really __CONSUMER_SUPPORTS_REFLECTION_AND_META__; 
       // rather, just helping IDE with code completion

#define M_template_rtpack(Xs)    M_template M_tbeg M_rtpack(Xs) M_tend
#define M_targpack(Xs)           M_tbeg M_pack(Xs) M_tend


/////// CASTING SUPPORT /////////


// COPIED FROM llvm/Support/Compiler.h:
# define LLVM_NODISCARD [[nodiscard]]

namespace llvm {

// COPIED FROM llvm/Support/type_traits:

/// If T is a pointer, just return it. If it is not, return T&.
template<typename T, typename Enable = void>
struct add_lvalue_reference_if_not_pointer {
  using type = T &;
};

template<typename T>
struct add_lvalue_reference_if_not_pointer<
        T, typename std::enable_if<std::is_pointer<T>::value>::type> {
  using type = T;
};

/// If T is a pointer to X, return a pointer to const X. If it is not,
/// return const T.
template<typename T, typename Enable = void>
struct add_const_past_pointer {
  using type = const T;
};

template<typename T>
struct add_const_past_pointer<
        T, typename std::enable_if<std::is_pointer<T>::value>::type> {
  using type = const typename std::remove_pointer<T>::type *;
};

// FROM llvm/Support/Casting.h:

//===----------------------------------------------------------------------===//
//                          isa<x> Support Templates
//===----------------------------------------------------------------------===//

/// Define a template that can be specialized by smart pointers to reflect the
/// fact that they are automatically dereferenced, and are not involved with the
/// template selection process...  the default implementation is a noop.
template<typename From>
struct simplify_type {
  using SimpleType = From; // The real type this represents...

  // An accessor to get the real value...
  static constexpr SimpleType &getSimplifiedValue(From &Val) { return Val; }
};

template<typename From>
struct simplify_type<const From> {
  using NonConstSimpleType = typename simplify_type<From>::SimpleType;
  using SimpleType =
  typename add_const_past_pointer<NonConstSimpleType>::type;
  using RetType =
  typename add_lvalue_reference_if_not_pointer<SimpleType>::type;

  static constexpr RetType getSimplifiedValue(const From &Val) {
    return simplify_type<From>::getSimplifiedValue(const_cast<From &>(Val));
  }
};

template<class X>
struct is_simple_type {
  static const bool value =
          std::is_same<X, typename simplify_type<X>::SimpleType>::value;
};

// The core of the implementation of isa<X> is here; To and From should be
// the names of classes.  This template can be specialized to customize the
// implementation of isa<> without rewriting it from scratch.
template<typename To, typename From, typename Enabler = void>
struct isa_impl {
  static constexpr bool doit(const From &Val) {
    return To::classof(&Val);
    // ^ NB: every castable reflection type needs a
    // static bool classof(...) member function reflected!
  }
};

/// Always allow upcasts, and perform no dynamic check for them.
template<typename To, typename From>
struct isa_impl<
        To, From, typename std::enable_if<std::is_base_of<To, From>::value>::type> {
  static constexpr bool doit(const From &) { return true; }
};

template<typename To, typename From>
struct isa_impl_cl {
  static constexpr bool doit(const From &Val) {
    return isa_impl<To, From>::doit(Val);
  }
};

template<typename To, typename From>
struct isa_impl_cl<To, const From> {
  static constexpr bool doit(const From &Val) {
    return isa_impl<To, From>::doit(Val);
  }
};


template<typename To, typename From>
struct isa_impl_cl<To, From *> {
  static constexpr bool doit(const From *Val) {
    assert(Val && "isa<> used on a null pointer");
    return isa_impl<To, From>::doit(*Val);
  }
};

template<typename To, typename From>
struct isa_impl_cl<To, From *const> {
  static constexpr bool doit(const From *Val) {
    assert(Val && "isa<> used on a null pointer");
    return isa_impl<To, From>::doit(*Val);
  }
};

template<typename To, typename From>
struct isa_impl_cl<To, const From *> {
  static constexpr bool doit(const From *Val) {
    assert(Val && "isa<> used on a null pointer");
    return isa_impl<To, From>::doit(*Val);
  }
};

template<typename To, typename From>
struct isa_impl_cl<To, const From *const> {
  static constexpr bool doit(const From *Val) {
    assert(Val && "isa<> used on a null pointer");
    return isa_impl<To, From>::doit(*Val);
  }
};

template<typename To, typename From, typename SimpleFrom>
struct isa_impl_wrap {
  // When From != SimplifiedType, we can simplify the type some more by using
  // the simplify_type template.
  static constexpr bool doit(const From &Val) {
    return isa_impl_wrap<To, SimpleFrom,
            typename simplify_type<SimpleFrom>::SimpleType>::doit(
            simplify_type<const From>::getSimplifiedValue(Val));
  }
};

template<typename To, typename FromTy>
struct isa_impl_wrap<To, FromTy, FromTy> {
  // When From == SimpleType, we are as simple as we are going to get.
  static constexpr bool doit(const FromTy &Val) {
    return isa_impl_cl<To, FromTy>::doit(Val);
  }
};

/// isa<X> - Return true if the parameter to the template is an instance of the
/// template type argument.  Used like this:
///
///  if (isa<Type>(myVal)) { ... }
///
template <class X, class Y> LLVM_NODISCARD constexpr bool isa(const Y &Val) {
  return isa_impl_wrap<X, const Y,
          typename simplify_type<const Y>::SimpleType>::doit(Val);
}

} // end namespace llvm




namespace cppx {

namespace meta {


namespace refldetail {

/// A number generated while building the version of Clang
/// which this reflection info was generated.  Reflection will
/// not be permitted unless this number matches that of the 
/// compiler.
static const unsigned __reflheaderid__ = 9271;


template<typename T> struct ptrwrp;
template<typename T> struct getPtrVal;

template< template<intptr_t...> class TMPL
        , intptr_t PtrVal >
struct getPtrVal<TMPL</*IsPtr=*/1, PtrVal>> {
  static constexpr intptr_t value = PtrVal;
};

template<typename T>
struct getPtrVal<ptrwrp<T>> {
  static constexpr intptr_t value = getPtrVal<T>::value;
};


/// ptrwrp_to_ptrs: helps us implement get() in ptrwrp so that
/// it removes all ptrwrp wrappings, replacing them with pointers.
/// e.g. ptrwrp_full_unwrp(ptrwrp<ptrwrp<A>> obj) returns obj of
/// type A**. We need this to permit proper derived->base conversions
/// for accessing proper function overloads from ptrwrp param types.
template<typename T>
constexpr auto ptrwrp_to_ptrs(ptrwrp<T> t) {
  return ptrwrp_full_get(t.get());
}
template<typename T>
constexpr auto ptrwrp_to_ptrs(const ptrwrp<T> *t) {
  return &ptrwrp_full_get(t->get());
}
template<typename T>
constexpr auto ptrwrp_to_ptrs(ptrwrp<T> *t) {
  return &ptrwrp_full_get(t->get());
}
template<typename T>
constexpr auto ptrwrp_to_ptrs(const T *t) {
  return t;
}
template<typename T>
constexpr auto ptrwrp_to_ptrs(T *t) {
  return t;
}

/// e.g.:
/// FunctionDecl*  <=>  ptrwrp<FunctionDecl::impl<Xs...>>
template<typename T>
class ptrwrp {
  T t;
public:
  constexpr T operator*() const noexcept { return t; }
    //^NB no need for ref return; reflection T behaves like a ref naturally
  constexpr const T * operator->() const noexcept { return &t; }
  constexpr T * operator->() noexcept { return &t; }
  constexpr auto get() const { return ptrwrp_to_ptrs(&t); }
  constexpr operator bool() const {
    return M_getPtrVal_T_value;
  }
  constexpr operator intptr_t() const {//TODO explicit perhaps
    return M_getPtrVal_T_value;
  }
  constexpr ptrwrp(T t = {}) : t(t) {}
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::ptrwrp(", (const char *)t, ")");
  }) , ( { return ""; } ) )
};
//Deduction guide: used by operator const char*() above:
IFMETA_ELSE( (template<typename T> ptrwrp(T t) -> ptrwrp<T>;), () )

} //namespace refldetail

#ifdef __CONSUMER_SUPPORTS_REFLECTION_AND_META__
  /// isa<X> - Return true if the parameter to the template is an instance of the
  /// template type argument.  Used like this:
  ///
  ///  if (isa<Tmpl>(myVal)) { ... }
  ///
  template< template<intptr_t...> class To
          , template<intptr_t...> class From
          , intptr_t... Xs >
  LLVM_NODISCARD constexpr bool isa(refldetail::ptrwrp<From<Xs...>> Val) {
    return ::llvm::isa<To<Xs...>>(Val.get());
  }

  /// cast<To> - Return the argument parameter cast to the specified type.  This
  /// casting operator asserts that the type is correct, so it does not return null
  /// on failure.  It does not allow a null argument (use cast_or_null for that).
  /// It is typically used like this:
  ///
  ///  cast<CXXRecordDecl>(myReflDecl)->bases()
  ///
  /// Note that cast may change the pointer value due to alignment issues --
  /// rather than messing around with that here we let clang handle it
  /// via __reflect_cast with an auto return type.
  template< template<intptr_t...> class To
          , template<intptr_t...> class From
          , intptr_t X >
  constexpr auto cast(const refldetail::ptrwrp<From</*IsPtr=*/1, X>> &Val) {
    return __reflect_cast(From<1,0>::ReflObjKind, To<1,0>::ReflObjKind, /*dyn=*/0, X);
  }

  /// Special case: for a non-ptrwrp argument (usually a non-pointer),
  /// just do a traditional slice if its possible.
  template< template<intptr_t...> class To
          , template<intptr_t...> class From
          , intptr_t... Xs >
  constexpr To<Xs...> cast(const From<Xs...> &Val) {
    static_assert(std::is_base_of<To<Xs...>, From<Xs...>>::value,
                  "Invalid reflection slice");
    return Val;
  }

  /// dyn_cast<To> -
  /// Return the argument parameter cast to the specified type.  This
  /// casting operator returns null if the argument is of the wrong type, so it can
  /// be used to test for a type as well as cast if successful.  This should be
  /// used in the context of an if statement like this:
  ///
  ///  if (auto RD = dyn_cast<CXXRecordDecl>(myReflectedDecl)) { ... }
  ///
  template< template<intptr_t...> class To
          , template<intptr_t...> class From
          , intptr_t X >
  constexpr auto dyn_cast(const refldetail::ptrwrp<From</*IsPtr=*/1, X>> &Val) {
    return __reflect_cast(From<1,0>::ReflObjKind, To<1,0>::ReflObjKind, /*dyn=*/1, X);
  }

#else
  template<typename To, typename From>
  constexpr bool isa(const From *from) { return true; }
  template<typename To, typename From>
  constexpr const To *cast(const From *from) { return (const To *)0; }
  template<typename To, typename From>
  constexpr const To *dyn_cast(const From *from) { return cast<To>(from); }
  
  //Non-const overloads (only needed to help IDE):
  template<typename To, typename From>
  constexpr To *cast(From *from) { return (To *)0; }
  template<typename To, typename From>
  constexpr refldetail::ptrwrp<To> cast(refldetail::ptrwrp<From> from) { return {}; }
  template<typename To, typename From>
  constexpr To cast(From from) { return from; }
  template<typename To, typename From>
  constexpr To *dyn_cast(From *from) { return cast<To>(from); }
  template<typename To, typename From>
  constexpr refldetail::ptrwrp<To> dyn_cast(refldetail::ptrwrp<From> from) { return cast<To>(from); }

  /// We define reflexpr(x) as a macro for non-meta-supporters, that returns
  /// a pointer to a dummy type instructing the user to properly cast it.
  /// Note that it doens't matter that this dummy type isn't related to the
  /// the types we cast to, as our dummy cast implems above don't do any actual
  /// casting; their goal here is to just helping the IDE navigate the types,
  /// without resorting to casting nullptrs (which raises other errors).
# define reflexpr(...)  (&cppx::meta::DfltNonnullObj<cppx::meta::_RememberToManuallyCastReflexprForNow_>)

  /// Cast this to whatever makes sense in the context; e.g. `cast<CXXRecordDecl>(reflexpr(SomeClass))`.
  /// Not necessary to compile, but definitely a good practice to help the IDE help you.
  /// We return a base Decl by default, since that's usually what you reflect,
  /// but sometimes a reflection will return a type;
  /// e.g. `template<typename T> MyMetaCls { auto proto_t_refl = reflexpr(T); };
  /// In such cases it's even more important to cast the reflexpr to avoid user confusion.
  struct _RememberToManuallyCastReflexprForNow_ {
    constexpr _RememberToManuallyCastReflexprForNow_() {}
  };
  template<typename T> T DfltNonnullObj;


  // While we're here let's also define __concatenate and __metaparse_expr for non-supporters:
# define __concatenate(...) ""
# define __metaparse_expr(expr, /**type*/...) (__VA_ARGS__)0

#endif

/// Turns a parameter pack of integers into a string literal, each int separated by a comma.
/// Needed to define the operator const char*()'s for each reflection type.
template<intptr_t... Xs>
struct concat_ints_w_commas;

template<intptr_t X, intptr_t... Xs>
struct concat_ints_w_commas<X, Xs...> {
  static constexpr const char *value = __concatenate(X, ",", concat_ints_w_commas<Xs...>::value);
};

template<intptr_t X>
struct concat_ints_w_commas<X> {
  static constexpr const char *value = __concatenate(X); //need __concatenate to turn the int into a string
};
namespace reflenums {

enum ReflectionObjKind {
  RK_none = 0,
  RK_llvm__APInt,
  RK_llvm__APInt__ms,
  RK_llvm__APInt__mu,
  RK_llvm__APFloatBase,
  RK_llvm__APFloat,
  RK_llvm__APSInt,
  RK_clang__APValue,
  RK_clang__APValue__LValueBase,
  RK_clang__DiagnosticOptions,
  RK_clang__FileID,
  RK_clang__SourceLocation,
  RK_clang__SourceRange,
  RK_clang__CharSourceRange,
  RK_clang__PresumedLoc,
  RK_clang__FullSourceLoc,
  RK_llvm__DebugEpochBase,
  RK_clang__FixItHint,
  RK_clang__DiagnosticsEngine,
  RK_clang__DiagnosticBuilder,
  RK_clang__DiagnosticConsumer,
  RK_clang__IdentifierInfo,
  RK_clang__IdentifierInfoLookup,
  RK_clang__IdentifierTable,
  RK_clang__Selector,
  RK_clang__SelectorTable,
  RK_clang__PartialDiagnostic,
  RK_clang__DeclarationName,
  RK_clang__DeclarationNameLoc,
  RK_clang__DeclarationNameInfo,
  RK_llvm__raw_ostream,
  RK_llvm__VersionTuple,
  RK_clang__Decl,
  RK_clang__DeclContextLookupResult,
  RK_clang__DeclContext,
  RK_clang__CharUnits,
  RK_clang__FileSystemOptions,
  RK_llvm__Twine,
  RK_llvm__sys__fs__UniqueID,
  RK_llvm__MemoryBuffer,
  RK_llvm__MemoryBufferRef,
  RK_clang__DirectoryEntry,
  RK_clang__FileEntry,
  RK_clang__FileManager,
  RK_clang__ASTFileSignature,
  RK_clang__Module,
  RK_clang__Module__Header,
  RK_clang__Module__DirectoryName,
  RK_clang__ExternalASTSource,
  RK_clang__ExternalASTSource__MemoryBufferSizes,
  RK_llvm__FoldingSetBase,
  RK_llvm__FoldingSetBase__Node,
  RK_llvm__FoldingSetNodeIDRef,
  RK_llvm__FoldingSetNodeID,
  RK_clang__NestedNameSpecifier,
  RK_clang__NestedNameSpecifierLoc,
  RK_clang__UncommonTemplateNameStorage,
  RK_clang__OverloadedTemplateStorage,
  RK_clang__SubstTemplateTemplateParmPackStorage,
  RK_clang__TemplateName,
  RK_clang__SubstTemplateTemplateParmStorage,
  RK_clang__QualifiedTemplateName,
  RK_clang__DependentTemplateName,
  RK_clang__LinkageInfo,
  RK_clang__Qualifiers,
  RK_clang__SplitQualType,
  RK_clang__QualType,
  RK_clang__ExtQualsTypeCommonBase,
  RK_clang__Type,
  RK_clang__BuiltinType,
  RK_clang__ComplexType,
  RK_clang__ParenType,
  RK_clang__PointerType,
  RK_clang__AdjustedType,
  RK_clang__DecayedType,
  RK_clang__BlockPointerType,
  RK_clang__ReferenceType,
  RK_clang__LValueReferenceType,
  RK_clang__RValueReferenceType,
  RK_clang__MemberPointerType,
  RK_clang__ArrayType,
  RK_clang__ConstantArrayType,
  RK_clang__IncompleteArrayType,
  RK_clang__VariableArrayType,
  RK_clang__DependentSizedArrayType,
  RK_clang__DependentAddressSpaceType,
  RK_clang__DependentSizedExtVectorType,
  RK_clang__VectorType,
  RK_clang__DependentVectorType,
  RK_clang__ExtVectorType,
  RK_clang__FunctionType,
  RK_clang__FunctionType__ExtInfo,
  RK_clang__FunctionNoProtoType,
  RK_clang__FunctionProtoType,
  RK_clang__FunctionProtoType__ExtParameterInfo,
  RK_clang__FunctionProtoType__ExceptionSpecInfo,
  RK_clang__FunctionProtoType__ExtProtoInfo,
  RK_clang__UnresolvedUsingType,
  RK_clang__TypedefType,
  RK_clang__TypeOfExprType,
  RK_clang__TypeOfType,
  RK_clang__DecltypeType,
  RK_clang__ReflectedType,
  RK_clang__UnaryTransformType,
  RK_clang__TagType,
  RK_clang__RecordType,
  RK_clang__EnumType,
  RK_clang__AttributedType,
  RK_clang__TemplateTypeParmType,
  RK_clang__SubstTemplateTypeParmType,
  RK_clang__SubstTemplateTypeParmPackType,
  RK_clang__DeducedType,
  RK_clang__AutoType,
  RK_clang__DeducedTemplateSpecializationType,
  RK_clang__TemplateSpecializationType,
  RK_clang__InjectedClassNameType,
  RK_clang__TypeWithKeyword,
  RK_clang__ElaboratedType,
  RK_clang__DependentNameType,
  RK_clang__DependentTemplateSpecializationType,
  RK_clang__PackExpansionType,
  RK_clang__ObjCTypeParamType,
  RK_clang__ObjCObjectType,
  RK_clang__ObjCInterfaceType,
  RK_clang__ObjCObjectPointerType,
  RK_clang__AtomicType,
  RK_clang__PipeType,
  RK_clang__TypeSourceInfo,
  RK_clang__TranslationUnitDecl,
  RK_clang__PragmaCommentDecl,
  RK_clang__PragmaDetectMismatchDecl,
  RK_clang__ExternCContextDecl,
  RK_clang__NamedDecl,
  RK_clang__LabelDecl,
  RK_clang__NamespaceDecl,
  RK_clang__ValueDecl,
  RK_clang__DeclaratorDecl,
  RK_clang__EvaluatedStmt,
  RK_clang__VarDecl,
  RK_clang__ImplicitParamDecl,
  RK_clang__ParmVarDecl,
  RK_clang__FunctionDecl,
  RK_clang__FieldDecl,
  RK_clang__EnumConstantDecl,
  RK_clang__IndirectFieldDecl,
  RK_clang__TypeDecl,
  RK_clang__TypedefNameDecl,
  RK_clang__TypedefDecl,
  RK_clang__TypeAliasDecl,
  RK_clang__TagDecl,
  RK_clang__EnumDecl,
  RK_clang__RecordDecl,
  RK_clang__FileScopeAsmDecl,
  RK_clang__BlockDecl,
  RK_clang__BlockDecl__Capture,
  RK_clang__CapturedDecl,
  RK_clang__ImportDecl,
  RK_clang__ExportDecl,
  RK_clang__EmptyDecl,
  RK_clang__DeclGroup,
  RK_clang__DeclGroupRef,
  RK_clang__Stmt,
  RK_clang__Stmt__EmptyShell,
  RK_clang__DeclStmt,
  RK_clang__NullStmt,
  RK_clang__CompoundStmt,
  RK_clang__SwitchCase,
  RK_clang__CaseStmt,
  RK_clang__DefaultStmt,
  RK_clang__LabelStmt,
  RK_clang__AttributedStmt,
  RK_clang__IfStmt,
  RK_clang__SwitchStmt,
  RK_clang__WhileStmt,
  RK_clang__DoStmt,
  RK_clang__ForStmt,
  RK_clang__GotoStmt,
  RK_clang__IndirectGotoStmt,
  RK_clang__ContinueStmt,
  RK_clang__BreakStmt,
  RK_clang__ReturnStmt,
  RK_clang__AsmStmt,
  RK_clang__GCCAsmStmt,
  RK_clang__MSAsmStmt,
  RK_clang__SEHExceptStmt,
  RK_clang__SEHFinallyStmt,
  RK_clang__SEHTryStmt,
  RK_clang__SEHLeaveStmt,
  RK_clang__CapturedStmt,
  RK_clang__CapturedStmt__Capture,
  RK_clang__TemplateArgument,
  RK_clang__TemplateArgumentLocInfo,
  RK_clang__TemplateArgumentLoc,
  RK_clang__TemplateArgumentListInfo,
  RK_clang__ASTTemplateArgumentListInfo,
  RK_clang__TypeLoc,
  RK_clang__UnqualTypeLoc,
  RK_clang__CommentOptions,
  RK_clang__comments__CommandInfo,
  RK_clang__comments__CommandTraits,
  RK_llvm__Triple,
  RK_clang__ObjCRuntime,
  RK_clang__SanitizerSet,
  RK_clang__LangOptionsBase,
  RK_clang__LangOptions,
  RK_clang__FPOptions,
  RK_clang__PrinterHelper,
  RK_clang__PrintingPolicy,
  RK_clang__SrcMgr__ContentCache,
  RK_clang__SrcMgr__FileInfo,
  RK_clang__SrcMgr__ExpansionInfo,
  RK_clang__SrcMgr__SLocEntry,
  RK_clang__SourceManager,
  RK_clang__RawComment,
  RK_clang__SanitizerBlacklist,
  RK_clang__TargetCXXABI,
  RK_clang__OpenCLOptions,
  RK_clang__TargetOptions,
  RK_llvm__Type,
  RK_llvm__IntegerType,
  RK_llvm__CompositeType,
  RK_llvm__StructType,
  RK_llvm__PointerType,
  RK_llvm__DataLayout,
  RK_llvm__StructLayout,
  RK_clang__TargetInfo,
  RK_clang__TargetInfo__ConstraintInfo,
  RK_clang__XRayFunctionFilter,
  RK_clang__TypeInfo,
  RK_clang__ASTContext,
  RK_clang__DeclAccessPair,
  RK_clang__UnresolvedSetIterator,
  RK_clang__UnresolvedSetImpl,
  RK_clang__Expr,
  RK_clang__Expr__Classification,
  RK_clang__Expr__EvalStatus,
  RK_clang__Expr__EvalResult,
  RK_clang__OpaqueValueExpr,
  RK_clang__DeclRefExpr,
  RK_clang__PredefinedExpr,
  RK_clang__APIntStorage,
  RK_clang__IntegerLiteral,
  RK_clang__FixedPointLiteral,
  RK_clang__CharacterLiteral,
  RK_clang__FloatingLiteral,
  RK_clang__ImaginaryLiteral,
  RK_clang__StringLiteral,
  RK_clang__ParenExpr,
  RK_clang__UnaryOperator,
  RK_clang__OffsetOfNode,
  RK_clang__OffsetOfExpr,
  RK_clang__UnaryExprOrTypeTraitExpr,
  RK_clang__ArraySubscriptExpr,
  RK_clang__CallExpr,
  RK_clang__MemberExpr,
  RK_clang__CompoundLiteralExpr,
  RK_clang__CastExpr,
  RK_clang__ImplicitCastExpr,
  RK_clang__ExplicitCastExpr,
  RK_clang__CStyleCastExpr,
  RK_clang__BinaryOperator,
  RK_clang__CompoundAssignOperator,
  RK_clang__AbstractConditionalOperator,
  RK_clang__ConditionalOperator,
  RK_clang__BinaryConditionalOperator,
  RK_clang__AddrLabelExpr,
  RK_clang__StmtExpr,
  RK_clang__ShuffleVectorExpr,
  RK_clang__ConvertVectorExpr,
  RK_clang__ChooseExpr,
  RK_clang__GNUNullExpr,
  RK_clang__VAArgExpr,
  RK_clang__InitListExpr,
  RK_clang__DesignatedInitExpr,
  RK_clang__DesignatedInitExpr__Designator,
  RK_clang__NoInitExpr,
  RK_clang__DesignatedInitUpdateExpr,
  RK_clang__ArrayInitLoopExpr,
  RK_clang__ArrayInitIndexExpr,
  RK_clang__ImplicitValueInitExpr,
  RK_clang__ParenListExpr,
  RK_clang__GenericSelectionExpr,
  RK_clang__ExtVectorElementExpr,
  RK_clang__BlockExpr,
  RK_clang__AsTypeExpr,
  RK_clang__PseudoObjectExpr,
  RK_clang__AtomicExpr,
  RK_clang__TypoExpr,
  RK_clang__Attr,
  RK_clang__InheritableAttr,
  RK_clang__ExternalSourceSymbolAttr,
  RK_clang__MSInheritanceAttr,
  RK_clang__MSVtorDispAttr,
  RK_clang__LambdaCapture,
  RK_clang__AccessSpecDecl,
  RK_clang__CXXBaseSpecifier,
  RK_clang__CXXRecordDecl,
  RK_clang__CXXDeductionGuideDecl,
  RK_clang__CXXMethodDecl,
  RK_clang__CXXCtorInitializer,
  RK_clang__InheritedConstructor,
  RK_clang__CXXConstructorDecl,
  RK_clang__CXXDestructorDecl,
  RK_clang__CXXConversionDecl,
  RK_clang__LinkageSpecDecl,
  RK_clang__UsingDirectiveDecl,
  RK_clang__NamespaceAliasDecl,
  RK_clang__UsingShadowDecl,
  RK_clang__ConstructorUsingShadowDecl,
  RK_clang__UsingDecl,
  RK_clang__UsingPackDecl,
  RK_clang__UnresolvedUsingValueDecl,
  RK_clang__UnresolvedUsingTypenameDecl,
  RK_clang__StaticAssertDecl,
  RK_clang__BindingDecl,
  RK_clang__DecompositionDecl,
  RK_clang__MSPropertyDecl,
  RK_clang__ConstexprDecl,
  RK_clang__TemplateParameterList,
  RK_clang__TemplateArgumentList,
  RK_clang__TemplateDecl,
  RK_clang__FunctionTemplateSpecializationInfo,
  RK_clang__MemberSpecializationInfo,
  RK_clang__DependentFunctionTemplateSpecializationInfo,
  RK_clang__RedeclarableTemplateDecl,
  RK_clang__FunctionTemplateDecl,
  RK_clang__TemplateTypeParmDecl,
  RK_clang__NonTypeTemplateParmDecl,
  RK_clang__TemplateTemplateParmDecl,
  RK_clang__BuiltinTemplateDecl,
  RK_clang__ClassTemplateSpecializationDecl,
  RK_clang__ClassTemplatePartialSpecializationDecl,
  RK_clang__ClassTemplateDecl,
  RK_clang__FriendTemplateDecl,
  RK_clang__TypeAliasTemplateDecl,
  RK_clang__ClassScopeFunctionSpecializationDecl,
  RK_clang__VarTemplateSpecializationDecl,
  RK_clang__VarTemplatePartialSpecializationDecl,
  RK_clang__VarTemplateDecl,
  RK_clang__FriendDecl,
  RK_clang__ObjCListBase,
  RK_clang__ObjCProtocolList,
  RK_clang__ObjCMethodDecl,
  RK_clang__ObjCTypeParamDecl,
  RK_clang__ObjCTypeParamList,
  RK_clang__ObjCPropertyDecl,
  RK_clang__ObjCContainerDecl,
  RK_clang__ObjCInterfaceDecl,
  RK_clang__ObjCIvarDecl,
  RK_clang__ObjCAtDefsFieldDecl,
  RK_clang__ObjCProtocolDecl,
  RK_clang__ObjCCategoryDecl,
  RK_clang__ObjCImplDecl,
  RK_clang__ObjCCategoryImplDecl,
  RK_clang__ObjCImplementationDecl,
  RK_clang__ObjCCompatibleAliasDecl,
  RK_clang__ObjCPropertyImplDecl,
  RK_clang__OMPThreadPrivateDecl,
  RK_clang__OMPDeclareReductionDecl,
  RK_clang__OMPCapturedExprDecl,
  RK_clang__CXXOperatorCallExpr,
  RK_clang__CXXMemberCallExpr,
  RK_clang__CUDAKernelCallExpr,
  RK_clang__CXXNamedCastExpr,
  RK_clang__CXXStaticCastExpr,
  RK_clang__CXXDynamicCastExpr,
  RK_clang__CXXReinterpretCastExpr,
  RK_clang__CXXConstCastExpr,
  RK_clang__UserDefinedLiteral,
  RK_clang__CXXBoolLiteralExpr,
  RK_clang__CXXNullPtrLiteralExpr,
  RK_clang__CXXStdInitializerListExpr,
  RK_clang__CXXTypeidExpr,
  RK_clang__MSPropertyRefExpr,
  RK_clang__MSPropertySubscriptExpr,
  RK_clang__CXXUuidofExpr,
  RK_clang__CXXThisExpr,
  RK_clang__CXXThrowExpr,
  RK_clang__CXXDefaultArgExpr,
  RK_clang__CXXDefaultInitExpr,
  RK_clang__CXXTemporary,
  RK_clang__CXXBindTemporaryExpr,
  RK_clang__CXXConstructExpr,
  RK_clang__CXXInheritedCtorInitExpr,
  RK_clang__CXXFunctionalCastExpr,
  RK_clang__CXXTemporaryObjectExpr,
  RK_clang__LambdaExpr,
  RK_clang__CXXScalarValueInitExpr,
  RK_clang__CXXNewExpr,
  RK_clang__CXXDeleteExpr,
  RK_clang__CXXPseudoDestructorExpr,
  RK_clang__TypeTraitExpr,
  RK_clang__ArrayTypeTraitExpr,
  RK_clang__ExpressionTraitExpr,
  RK_clang__OverloadExpr,
  RK_clang__OverloadExpr__FindResult,
  RK_clang__UnresolvedLookupExpr,
  RK_clang__DependentScopeDeclRefExpr,
  RK_clang__ExprWithCleanups,
  RK_clang__CXXUnresolvedConstructExpr,
  RK_clang__CXXDependentScopeMemberExpr,
  RK_clang__UnresolvedMemberExpr,
  RK_clang__CXXNoexceptExpr,
  RK_clang__PackExpansionExpr,
  RK_clang__SizeOfPackExpr,
  RK_clang__SubstNonTypeTemplateParmExpr,
  RK_clang__SubstNonTypeTemplateParmPackExpr,
  RK_clang__FunctionParmPackExpr,
  RK_clang__MaterializeTemporaryExpr,
  RK_clang__CXXFoldExpr,
  RK_clang__CoroutineSuspendExpr,
  RK_clang__CoawaitExpr,
  RK_clang__DependentCoawaitExpr,
  RK_clang__CoyieldExpr,
  RK_clang__ReflectionExpr,
  RK_clang__CompilerMessageExpr,
  RK_clang__CompilerDiagnosticExpr,
  RK_clang__CXXMetaparseExpr,
  RK_clang__ReflectionTraitExpr,
  RK_clang__ReflectNewExpr,
  RK_clang__ReflectDeleteExpr,
  RK_clang__CXXConstantExpr,
  RK_clang__CXXDependentIdExpr,
  RK_clang__CXXConcatenateExpr,
  RK_clang__ObjCStringLiteral,
  RK_clang__ObjCBoolLiteralExpr,
  RK_clang__ObjCBoxedExpr,
  RK_clang__ObjCArrayLiteral,
  RK_clang__ObjCDictionaryElement,
  RK_clang__ObjCDictionaryLiteral,
  RK_clang__ObjCEncodeExpr,
  RK_clang__ObjCSelectorExpr,
  RK_clang__ObjCProtocolExpr,
  RK_clang__ObjCIvarRefExpr,
  RK_clang__ObjCPropertyRefExpr,
  RK_clang__ObjCSubscriptRefExpr,
  RK_clang__ObjCMessageExpr,
  RK_clang__ObjCIsaExpr,
  RK_clang__ObjCIndirectCopyRestoreExpr,
  RK_clang__ObjCBridgedCastExpr,
  RK_clang__ObjCAvailabilityCheckExpr,
  RK_clang__OMPArraySectionExpr,
  RK_clang__CXXCatchStmt,
  RK_clang__CXXTryStmt,
  RK_clang__CXXForRangeStmt,
  RK_clang__CXXExpansionStmt,
  RK_clang__CXXTupleExpansionStmt,
  RK_clang__CXXPackExpansionStmt,
  RK_clang__MSDependentExistsStmt,
  RK_clang__CoroutineBodyStmt,
  RK_clang__CoroutineBodyStmt__CtorArgs,
  RK_clang__CoreturnStmt,
  RK_clang__CXXQueueMetaparseStmt,
  RK_clang__ObjCForCollectionStmt,
  RK_clang__ObjCAtCatchStmt,
  RK_clang__ObjCAtFinallyStmt,
  RK_clang__ObjCAtTryStmt,
  RK_clang__ObjCAtSynchronizedStmt,
  RK_clang__ObjCAtThrowStmt,
  RK_clang__ObjCAutoreleasePoolStmt,
  RK_clang__OMPClause,
  RK_clang__OMPExecutableDirective,
  RK_clang__OMPParallelDirective,
  RK_clang__OMPLoopDirective,
  RK_clang__OMPSimdDirective,
  RK_clang__OMPForDirective,
  RK_clang__OMPForSimdDirective,
  RK_clang__OMPSectionsDirective,
  RK_clang__OMPSectionDirective,
  RK_clang__OMPSingleDirective,
  RK_clang__OMPMasterDirective,
  RK_clang__OMPCriticalDirective,
  RK_clang__OMPParallelForDirective,
  RK_clang__OMPParallelForSimdDirective,
  RK_clang__OMPParallelSectionsDirective,
  RK_clang__OMPTaskDirective,
  RK_clang__OMPTaskyieldDirective,
  RK_clang__OMPBarrierDirective,
  RK_clang__OMPTaskwaitDirective,
  RK_clang__OMPTaskgroupDirective,
  RK_clang__OMPFlushDirective,
  RK_clang__OMPOrderedDirective,
  RK_clang__OMPAtomicDirective,
  RK_clang__OMPTargetDirective,
  RK_clang__OMPTargetDataDirective,
  RK_clang__OMPTargetEnterDataDirective,
  RK_clang__OMPTargetExitDataDirective,
  RK_clang__OMPTargetParallelDirective,
  RK_clang__OMPTargetParallelForDirective,
  RK_clang__OMPTeamsDirective,
  RK_clang__OMPCancellationPointDirective,
  RK_clang__OMPCancelDirective,
  RK_clang__OMPTaskLoopDirective,
  RK_clang__OMPTaskLoopSimdDirective,
  RK_clang__OMPDistributeDirective,
  RK_clang__OMPTargetUpdateDirective,
  RK_clang__OMPDistributeParallelForDirective,
  RK_clang__OMPDistributeParallelForSimdDirective,
  RK_clang__OMPDistributeSimdDirective,
  RK_clang__OMPTargetParallelForSimdDirective,
  RK_clang__OMPTargetSimdDirective,
  RK_clang__OMPTeamsDistributeDirective,
  RK_clang__OMPTeamsDistributeSimdDirective,
  RK_clang__OMPTeamsDistributeParallelForSimdDirective,
  RK_clang__OMPTeamsDistributeParallelForDirective,
  RK_clang__OMPTargetTeamsDirective,
  RK_clang__OMPTargetTeamsDistributeDirective,
  RK_clang__OMPTargetTeamsDistributeParallelForDirective,
  RK_clang__OMPTargetTeamsDistributeParallelForSimdDirective,
  RK_clang__OMPTargetTeamsDistributeSimdDirective,
  RK_clang__StoredDeclsMap,
  RK_clang__DependentDiagnostic,
  RK_reflcontainers__VectorStr,
  RK_reflcontainers__VectorInt,
  RK_reflcontainers__SetInt,
  RK_reflcontainers__SetStr,
  RK_reflcontainers__IntIntPair,
  RK_reflcontainers__IntStrPair,
  RK_reflcontainers__StrIntPair,
  RK_reflcontainers__StrStrPair,
  RK_reflcontainers__MapIntStr,
  RK_reflcontainers__MapStrInt,
  RK_reflcontainers__MapStrStr,
  RK_reflcontainers__MapIntInt,
}; //enum ReflectionObjKind


  namespace llvm__APInt {
    enum memnames {
      needsCleanup,
      Profile,
      isNegative,
      isNonNegative,
      isSignBitSet,
      isSignBitClear,
      isStrictlyPositive,
      isAllOnesValue,
      isNullValue,
      isOneValue,
      isMaxValue,
      isMaxSignedValue,
      isMinValue,
      isMinSignedValue,
      isIntN,
      isSignedIntN,
      isPowerOf2,
      isSignMask,
      getBoolValue,
      getLimitedValue,
      isSplat,
      isMask,
      isMask1,
      isShiftedMask,
      isSameValue,
      getRawData,
      operator_not,
      urem,
      srem,
      udivrem,
      sdivrem,
      operator_sub,
      operator_eq_eq,
      operator_eq_eq1,
      eq,
      operator_not_eq,
      operator_not_eq1,
      ne,
      ult,
      ult1,
      slt,
      slt1,
      ule,
      ule1,
      sle,
      sle1,
      ugt,
      ugt1,
      sgt,
      sgt1,
      uge,
      uge1,
      sge,
      sge1,
      intersects,
      isSubsetOf,
      getBitWidth,
      getNumWords,
      getNumWords1,
      getActiveBits,
      getActiveWords,
      getMinSignedBits,
      getZExtValue,
      getSExtValue,
      getBitsNeeded,
      countLeadingZeros,
      countLeadingOnes,
      getNumSignBits,
      countTrailingZeros,
      countTrailingOnes,
      countPopulation,
      print,
      toString,
      roundToDouble,
      roundToDouble1,
      signedRoundToDouble,
      bitsToDouble,
      bitsToFloat,
      logBase2,
      ceilLogBase2,
      nearestLogBase2,
      exactLogBase2,
      magic,
      magicu,
      tcSet,
      tcAssign,
      tcIsZero,
      tcExtractBit,
      tcExtract,
      tcSetBit,
      tcClearBit,
      tcLSB,
      tcMSB,
      tcNegate,
      tcAdd,
      tcAddPart,
      tcSubtract,
      tcSubtractPart,
      tcMultiplyPart,
      tcMultiply,
      tcFullMultiply,
      tcDivide,
      tcShiftLeft,
      tcShiftRight,
      tcAnd,
      tcOr,
      tcXor,
      tcComplement,
      tcCompare,
      tcIncrement,
      tcDecrement,
      tcSetLeastSignificantBits,
      dump,
    };
    static const unsigned _total_num_mems_ = dump + 1;
  }
  namespace llvm__APInt__ms {
    enum memnames {
      s,
    };
    static const unsigned _total_num_mems_ = s + 1;
  }
  namespace llvm__APInt__mu {
    enum memnames {
      a,
      s,
    };
    static const unsigned _total_num_mems_ = s + 1;
  }
  namespace llvm__APFloatBase {
    enum memnames {
    };
    static const unsigned _total_num_mems_ = 0;
  }
  namespace llvm__APFloat {
    enum memnames {
      needsCleanup,
      Profile,
      convertToInteger,
      convertToDouble,
      convertToFloat,
      compare,
      bitwiseIsEqual,
      isExactlyValue,
      convertToHexString,
      isZero,
      isInfinity,
      isNaN,
      isNegative,
      isDenormal,
      isSignaling,
      isNormal,
      isFinite,
      getCategory,
      isNonZero,
      isFiniteNonZero,
      isPosZero,
      isNegZero,
      isSmallest,
      isLargest,
      isInteger,
      print,
      dump,
      getExactInverse,
    };
    static const unsigned _total_num_mems_ = getExactInverse + 1;
  }
  namespace llvm__APSInt {
    enum memnames {
      isSigned,
      isUnsigned,
      toString,
      getExtValue,
      trunc,
      extend,
      extOrTrunc,
      operator_mod,
      operator_div,
      operator_gr_gr,
      operator_less,
      operator_gr,
      operator_less_eq,
      operator_gr_eq,
      operator_eq_eq,
      operator_not_eq,
      operator_eq_eq1,
      operator_not_eq1,
      operator_less_eq1,
      operator_gr_eq1,
      operator_less1,
      operator_gr1,
      operator_less_less,
      operator_minus,
      operator_and,
      operator_or,
      operator_exp,
      operator_star,
      operator_plus,
      operator_minus1,
      operator_tilde,
      getMaxValue,
      getMinValue,
      isSameValue,
      compareValues,
      get,
      getUnsigned,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__APValue {
    enum memnames {
      needsCleanup,
      getKind,
      isUninit,
      isInt,
      isFloat,
      isComplexInt,
      isComplexFloat,
      isLValue,
      isVector,
      isArray,
      isStruct,
      isUnion,
      isMemberPointer,
      isAddrLabelDiff,
      dump,
      dump1,
      printPretty,
      getAsString,
      getInt,
      getFloat,
      getComplexIntReal,
      getComplexIntImag,
      getComplexFloatReal,
      getComplexFloatImag,
      getLValueBase,
      getLValueOffset,
      isLValueOnePastTheEnd,
      hasLValuePath,
      getLValueCallIndex,
      getLValueVersion,
      isNullPointer,
      getVectorElt,
      getVectorLength,
      getArrayInitializedElt,
      hasArrayFiller,
      getArrayFiller,
      getArrayInitializedElts,
      getArraySize,
      getStructNumBases,
      getStructNumFields,
      getStructBase,
      getStructField,
      getUnionField,
      getUnionValue,
      getMemberPointerDecl,
      isMemberPointerToDerivedMember,
      getMemberPointerPath,
      getAddrLabelDiffLHS,
      getAddrLabelDiffRHS,
    };
    static const unsigned _total_num_mems_ = getAddrLabelDiffRHS + 1;
  }
  namespace clang__APValue__LValueBase {
    enum memnames {
      getOpaqueValue,
      isNull,
      operator_bool,
      getCallIndex,
      getVersion,
      operator_eq_eq,
    };
    static const unsigned _total_num_mems_ = operator_eq_eq + 1;
  }
  namespace clang__DiagnosticOptions {
    enum memnames {
      Retain,
      Release,
      IgnoreWarnings,
      NoRewriteMacros,
      Pedantic,
      PedanticErrors,
      ShowColumn,
      ShowLocation,
      AbsolutePath,
      ShowCarets,
      ShowFixits,
      ShowSourceRanges,
      ShowParseableFixits,
      ShowPresumedLoc,
      ShowOptionNames,
      ShowNoteIncludeStack,
      ShowCategories,
      ShowColors,
      VerifyDiagnostics,
      ElideType,
      ShowTemplateTree,
      CLFallbackMode,
      ErrorLimit,
      MacroBacktraceLimit,
      TemplateBacktraceLimit,
      ConstexprBacktraceLimit,
      SpellCheckingLimit,
      SnippetLineLimit,
      TabStop,
      MessageLength,
      getFormat,
      getShowOverloads,
      getVerifyIgnoreUnexpected,
    };
    static const unsigned _total_num_mems_ = getVerifyIgnoreUnexpected + 1;
  }
  namespace clang__FileID {
    enum memnames {
      isValid,
      isInvalid,
      operator_eq_eq,
      operator_less,
      operator_less_eq,
      operator_not_eq,
      operator_gr,
      operator_gr_eq,
      getSentinel,
      getHashValue,
    };
    static const unsigned _total_num_mems_ = getHashValue + 1;
  }
  namespace clang__SourceLocation {
    enum memnames {
      isFileID,
      isMacroID,
      isValid,
      isInvalid,
      getLocWithOffset,
      getRawEncoding,
      getFromRawEncoding,
      getPtrEncoding,
      getFromPtrEncoding,
      isPairOfFileLocations,
      print,
      printToString,
      dump,
    };
    static const unsigned _total_num_mems_ = dump + 1;
  }
  namespace clang__SourceRange {
    enum memnames {
      getBegin,
      getEnd,
      isValid,
      isInvalid,
      operator_eq_eq,
      operator_not_eq,
    };
    static const unsigned _total_num_mems_ = operator_not_eq + 1;
  }
  namespace clang__CharSourceRange {
    enum memnames {
      getTokenRange,
      getCharRange,
      getTokenRange1,
      getCharRange1,
      isTokenRange,
      isCharRange,
      getBegin,
      getEnd,
      getAsRange,
      isValid,
      isInvalid,
    };
    static const unsigned _total_num_mems_ = isInvalid + 1;
  }
  namespace clang__PresumedLoc {
    enum memnames {
      isInvalid,
      isValid,
      getFilename,
      getLine,
      getColumn,
      getIncludeLoc,
    };
    static const unsigned _total_num_mems_ = getIncludeLoc + 1;
  }
  namespace clang__FullSourceLoc {
    enum memnames {
      hasManager,
      getManager,
      getFileID,
      getExpansionLoc,
      getSpellingLoc,
      getFileLoc,
      getPresumedLoc,
      isMacroArgExpansion,
      getImmediateMacroCallerLoc,
      getFileOffset,
      getExpansionLineNumber,
      getExpansionColumnNumber,
      getSpellingLineNumber,
      getSpellingColumnNumber,
      getCharacterData,
      getLineNumber,
      getColumnNumber,
      getFileEntry,
      getBufferData,
      isInSystemHeader,
      isBeforeInTranslationUnitThan,
      isBeforeInTranslationUnitThan1,
      dump,
      operator_eq_eq,
      operator_not_eq,
    };
    static const unsigned _total_num_mems_ = operator_not_eq + 1;
  }
  namespace llvm__DebugEpochBase {
    enum memnames {
    };
    static const unsigned _total_num_mems_ = 0;
  }
  namespace clang__FixItHint {
    enum memnames {
      RemoveRange,
      InsertFromRange,
      BeforePreviousInsertions,
      isNull,
      CreateInsertionFromRange,
      CreateRemoval,
      CreateRemoval1,
    };
    static const unsigned _total_num_mems_ = CreateRemoval1 + 1;
  }
  namespace clang__DiagnosticsEngine {
    enum memnames {
      Retain,
      Release,
      dump,
      dump1,
      getDiagnosticOptions,
      getClient,
      ownsClient,
      hasSourceManager,
      getSourceManager,
      getTemplateBacktraceLimit,
      getConstexprBacktraceLimit,
      getIgnoreAllWarnings,
      getEnableAllWarnings,
      getWarningsAsErrors,
      getErrorsAsFatal,
      getSuppressSystemWarnings,
      getSuppressAllDiagnostics,
      getShowOverloads,
      isLastDiagnosticIgnored,
      getExtensionHandlingBehavior,
      hasErrorOccurred,
      hasUncompilableErrorOccurred,
      hasFatalErrorOccurred,
      hasUnrecoverableErrorOccurred,
      getNumWarnings,
      isIgnored,
      getDiagnosticLevel,
      isDiagnosticInFlight,
      getFlagValue,
    };
    static const unsigned _total_num_mems_ = getFlagValue + 1;
  }
  namespace clang__DiagnosticBuilder {
    enum memnames {
      setForceEmit,
      operator_bool,
      AddString,
      AddTaggedVal,
      AddSourceRange,
      AddFixItHint,
      addFlagValue,
    };
    static const unsigned _total_num_mems_ = addFlagValue + 1;
  }
  namespace clang__DiagnosticConsumer {
    enum memnames {
      getNumErrors,
      getNumWarnings,
      IncludeInDiagnosticCounts,
    };
    static const unsigned _total_num_mems_ = IncludeInDiagnosticCounts + 1;
  }
  namespace clang__IdentifierInfo {
    enum memnames {
      isStr,
      getNameStart,
      getLength,
      getName,
      hasMacroDefinition,
      hadMacroDefinition,
      getTokenID,
      hasRevertedTokenIDToIdentifier,
      getPPKeywordID,
      getObjCKeywordID,
      hasRevertedBuiltin,
      getBuiltinID,
      getObjCOrBuiltinID,
      isExtensionToken,
      isFutureCompatKeyword,
      isPoisoned,
      isCPlusPlusOperatorKeyword,
      isKeyword,
      isCPlusPlusKeyword,
      isHandleIdentifierCase,
      isFromAST,
      hasChangedSinceDeserialization,
      hasFETokenInfoChangedSinceDeserialization,
      isOutOfDate,
      isModulesImport,
      isEditorPlaceholder,
      operator_less,
    };
    static const unsigned _total_num_mems_ = operator_less + 1;
  }
  namespace clang__IdentifierInfoLookup {
    enum memnames {
    };
    static const unsigned _total_num_mems_ = 0;
  }
  namespace clang__IdentifierTable {
    enum memnames {
      getExternalIdentifierLookup,
      size,
      PrintStats,
    };
    static const unsigned _total_num_mems_ = PrintStats + 1;
  }
  namespace clang__Selector {
    enum memnames {
      operator_eq_eq,
      operator_not_eq,
      getAsOpaquePtr,
      isNull,
      isKeywordSelector,
      isUnarySelector,
      getNumArgs,
      getIdentifierInfoForSlot,
      getNameForSlot,
      getAsString,
      print,
      dump,
      getMethodFamily,
      getStringFormatFamily,
      getEmptyMarker,
      getTombstoneMarker,
      getInstTypeMethodFamily,
    };
    static const unsigned _total_num_mems_ = getInstTypeMethodFamily + 1;
  }
  namespace clang__SelectorTable {
    enum memnames {
      getTotalMemory,
      constructSetterSelector,
      getPropertyNameFromSetterSelector,
    };
    static const unsigned _total_num_mems_ = getPropertyNameFromSetterSelector + 1;
  }
  namespace clang__PartialDiagnostic {
    enum memnames {
      getDiagID,
      AddTaggedVal,
      AddString,
      Emit,
      hasStorage,
      getNumArgs,
      operator_less_less,
      operator_less_less1,
      operator_less_less2,
      operator_less_less3,
      operator_less_less4,
      operator_less_less5,
      operator_less_less6,
      operator_less_less7,
    };
    static const unsigned _total_num_mems_ = operator_less_less7 + 1;
  }
  namespace clang__DeclarationName {
    enum memnames {
      getUsingDirectiveName,
      operator_bool,
      isEmpty,
      isIdentifier,
      isObjCZeroArgSelector,
      isObjCOneArgSelector,
      getNameKind,
      isDependentName,
      getAsString,
      getAsIdentifierInfo,
      getAsOpaqueInteger,
      getAsOpaquePtr,
      getFromOpaquePtr,
      getFromOpaqueInteger,
      getCXXNameType,
      getCXXDeductionGuideTemplate,
      getCXXOverloadedOperator,
      getCXXLiteralIdentifier,
      getCXXIdExprArguments,
      getObjCSelector,
      operator_eq_eq,
      operator_not_eq,
      getEmptyMarker,
      getTombstoneMarker,
      compare,
      dump,
    };
    static const unsigned _total_num_mems_ = dump + 1;
  }
  namespace clang__DeclarationNameLoc {
    enum memnames {
    };
    static const unsigned _total_num_mems_ = 0;
  }
  namespace clang__DeclarationNameInfo {
    enum memnames {
      getName,
      getLoc,
      getInfo,
      getNamedTypeInfo,
      getCXXOperatorNameRange,
      getCXXLiteralOperatorNameLoc,
      getCXXIdExprNameRange,
      isInstantiationDependent,
      containsUnexpandedParameterPack,
      getAsString,
      printName,
      getBeginLoc,
      getSourceRange,
      getLocStart,
      getLocEnd,
      getEndLoc,
    };
    static const unsigned _total_num_mems_ = getEndLoc + 1;
  }
  namespace llvm__raw_ostream {
    enum memnames {
      tell,
      GetBufferSize,
      GetNumBytesInBuffer,
      is_displayed,
      has_colors,
    };
    static const unsigned _total_num_mems_ = has_colors + 1;
  }
  namespace llvm__VersionTuple {
    enum memnames {
      empty,
      getMajor,
      operator_eq_eq,
      operator_not_eq,
      operator_less,
      operator_gr,
      operator_less_eq,
      operator_gr_eq,
      getAsString,
    };
    static const unsigned _total_num_mems_ = getAsString + 1;
  }
  namespace clang__Decl {
    enum memnames {
      getSourceRange,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getLocation,
      getKind,
      getDeclKindName,
      getNextDeclInContext,
      getDeclContext,
      getNonClosureContext,
      getTranslationUnitDecl,
      isInAnonymousNamespace,
      isInStdNamespace,
      getASTContext,
      getAccess,
      getAccessUnsafe,
      hasAttrs,
      attrs,
      getMaxAlignment,
      isInvalidDecl,
      isImplicit,
      isUsed,
      isReferenced,
      isThisDeclarationReferenced,
      instantiationsWillNeedParsing,
      isTopLevelDeclInObjCContainer,
      getExternalSourceSymbolAttr,
      isModulePrivate,
      isExported,
      hasDefiningAttr,
      getDefiningAttr,
      getVersionIntroduced,
      isWeakImported,
      isFromASTFile,
      getGlobalID,
      getOwningModuleID,
      getImportedOwningModule,
      getLocalOwningModule,
      hasOwningModule,
      getOwningModule,
      getOwningModuleForLinkage,
      isHidden,
      getModuleOwnershipKind,
      getIdentifierNamespace,
      isInIdentifierNamespace,
      getIdentifierNamespaceForKind,
      hasTagIdentifierNamespace,
      isTagIdentifierNamespace,
      getLexicalDeclContext,
      isOutOfLine,
      isTemplated,
      isDefinedOutsideFunctionOrMethod,
      isLexicallyWithinFunctionOrMethod,
      getParentFunctionOrMethod,
      getCanonicalDecl,
      isCanonicalDecl,
      redecls,
      getPreviousDecl,
      isFirstDecl,
      getMostRecentDecl,
      getBody,
      hasBody,
      getBodyRBrace,
      add,
      EnableStatistics,
      PrintStats,
      isTemplateParameter,
      isTemplateParameterPack,
      isParameterPack,
      isTemplateDecl,
      isFunctionOrFunctionTemplate,
      getDescribedTemplate,
      getAsFunction,
      getFriendObjectKind,
      classofKind,
      print,
      print1,
      printGroup,
      dump,
      dumpColor,
      dump1,
      getFunctionType,
    };
    static const unsigned _total_num_mems_ = getFunctionType + 1;
  }
  namespace clang__DeclContextLookupResult {
    enum memnames {
      _this_,
      empty,
      data,
      size,
      front,
      back,
      operator_sub,
      slice,
    };
    static const unsigned _total_num_mems_ = slice + 1;
  }
  namespace clang__DeclContext {
    enum memnames {
      getDeclKind,
      getDeclKindName,
      getParent,
      getLexicalParent,
      getLookupParent,
      getParentASTContext,
      isClosure,
      isObjCContainer,
      isFunctionOrMethod,
      isLookupContext,
      isFileContext,
      isTranslationUnit,
      isRecord,
      isNamespace,
      isStdNamespace,
      isInlineNamespace,
      isDependentContext,
      isTransparentContext,
      isExternCContext,
      getExternCContext,
      isExternCXXContext,
      Equals,
      Encloses,
      getNonClosureAncestor,
      getPrimaryContext,
      getRedeclContext,
      getEnclosingNamespaceContext,
      getOuterLexicalRecordContext,
      InEnclosingNamespaceSetOf,
      decls,
      decls_empty,
      noload_decls,
      containsDecl,
      containsDeclAndLoad,
      lookup,
      lookups,
      ddiags,
      getLookupPtr,
      hasExternalLexicalStorage,
      hasExternalVisibleStorage,
      isDeclInLexicalTraversal,
      shouldUseQualifiedLookup,
      classof,
      classof1,
      dumpDeclContext,
      dumpLookups,
      dumpLookups1,
    };
    static const unsigned _total_num_mems_ = dumpLookups1 + 1;
  }
  namespace clang__CharUnits {
    enum memnames {
      Zero,
      One,
      fromQuantity,
      operator_eq_eq,
      operator_not_eq,
      operator_less,
      operator_less_eq,
      operator_gr,
      operator_gr_eq,
      isZero,
      isOne,
      isPositive,
      isNegative,
      isPowerOfTwo,
      isMultipleOf,
      operator_star,
      operator_div,
      operator_div1,
      operator_mod,
      operator_mod1,
      operator_plus,
      operator_minus,
      operator_minus1,
      getQuantity,
      alignTo,
      alignmentAtOffset,
      alignmentOfArrayElement,
    };
    static const unsigned _total_num_mems_ = alignmentOfArrayElement + 1;
  }
  namespace clang__FileSystemOptions {
    enum memnames {
    };
    static const unsigned _total_num_mems_ = 0;
  }
  namespace llvm__Twine {
    enum memnames {
      isTriviallyEmpty,
      isSingleStringRef,
      str,
      getSingleStringRef,
      print,
      dump,
      printRepr,
      dumpRepr,
    };
    static const unsigned _total_num_mems_ = dumpRepr + 1;
  }
  namespace llvm__sys__fs__UniqueID {
    enum memnames {
      operator_eq_eq,
      operator_not_eq,
      operator_less,
      getDevice,
      getFile,
    };
    static const unsigned _total_num_mems_ = getFile + 1;
  }
  namespace llvm__MemoryBuffer {
    enum memnames {
      getBufferStart,
      getBufferEnd,
      getBufferSize,
      getBuffer,
      getBufferIdentifier,
      getBufferKind,
      getMemBufferRef,
    };
    static const unsigned _total_num_mems_ = getMemBufferRef + 1;
  }
  namespace llvm__MemoryBufferRef {
    enum memnames {
      getBuffer,
      getBufferIdentifier,
      getBufferStart,
      getBufferEnd,
      getBufferSize,
    };
    static const unsigned _total_num_mems_ = getBufferSize + 1;
  }
  namespace clang__DirectoryEntry {
    enum memnames {
      getName,
    };
    static const unsigned _total_num_mems_ = getName + 1;
  }
  namespace clang__FileEntry {
    enum memnames {
      getName,
      tryGetRealPathName,
      isValid,
      getSize,
      getUID,
      getUniqueID,
      isInPCH,
      getModificationTime,
      getDir,
      operator_less,
      isNamedPipe,
      closeFile,
    };
    static const unsigned _total_num_mems_ = closeFile + 1;
  }
  namespace clang__FileManager {
    enum memnames {
      Retain,
      Release,
      getFileSystemOpts,
      modifyFileEntry,
      PrintStats,
    };
    static const unsigned _total_num_mems_ = PrintStats + 1;
  }
  namespace clang__ASTFileSignature {
    enum memnames {
      _this_,
      cbegin,
      cend,
      size,
      max_size,
      empty,
      operator_sub,
      at,
      front,
      back,
      data,
      operator_bool,
    };
    static const unsigned _total_num_mems_ = operator_bool + 1;
  }
  namespace clang__Module {
    enum memnames {
      DefinitionLoc,
      Kind,
      Parent,
      Directory,
      Signature,
      ShadowingModule,
      IsMissingRequirement,
      HasIncompatibleModuleFile,
      IsAvailable,
      IsFromModuleFile,
      IsFramework,
      IsExplicit,
      IsSystem,
      IsExternC,
      IsInferred,
      InferSubmodules,
      InferExplicitSubmodules,
      InferExportWildcard,
      ConfigMacrosExhaustive,
      NoUndeclaredIncludes,
      ModuleMapIsPrivate,
      NameVisibility,
      InferredSubmoduleLoc,
      UseExportAsModuleLinkName,
      isAvailable,
      isSubModule,
      isSubModuleOf,
      isPartOfFramework,
      isSubFramework,
      getFullModuleName,
      getTopLevelModule,
      getTopLevelModuleName,
      getASTFile,
      getUmbrellaDir,
      getUmbrellaHeader,
      hasUmbrellaDir,
      directlyUses,
      isModuleVisible,
      getVisibilityID,
      submodules,
      getModuleInputBufferName,
      print,
      dump,
    };
    static const unsigned _total_num_mems_ = dump + 1;
  }
  namespace clang__Module__Header {
    enum memnames {
      Entry,
    };
    static const unsigned _total_num_mems_ = Entry + 1;
  }
  namespace clang__Module__DirectoryName {
    enum memnames {
      Entry,
    };
    static const unsigned _total_num_mems_ = Entry + 1;
  }
  namespace clang__ExternalASTSource {
    enum memnames {
      Retain,
      Release,
      getGeneration,
      getMemoryBufferSizes,
      getMemoryBufferSizes1,
    };
    static const unsigned _total_num_mems_ = getMemoryBufferSizes1 + 1;
  }
  namespace clang__ExternalASTSource__MemoryBufferSizes {
    enum memnames {
      malloc_bytes,
      mmap_bytes,
    };
    static const unsigned _total_num_mems_ = mmap_bytes + 1;
  }
  namespace llvm__FoldingSetBase {
    enum memnames {
      size,
      empty,
    };
    static const unsigned _total_num_mems_ = empty + 1;
  }
  namespace llvm__FoldingSetBase__Node {
    enum memnames {
      getNextInBucket,
    };
    static const unsigned _total_num_mems_ = getNextInBucket + 1;
  }
  namespace llvm__FoldingSetNodeIDRef {
    enum memnames {
      ComputeHash,
      operator_eq_eq,
      operator_not_eq,
      operator_less,
      getData,
      getSize,
    };
    static const unsigned _total_num_mems_ = getSize + 1;
  }
  namespace llvm__FoldingSetNodeID {
    enum memnames {
      ComputeHash,
      operator_eq_eq,
      operator_eq_eq1,
      operator_not_eq,
      operator_not_eq1,
      operator_less,
      operator_less1,
    };
    static const unsigned _total_num_mems_ = operator_less1 + 1;
  }
  namespace clang__NestedNameSpecifier {
    enum memnames {
      Create,
      Create1,
      Create2,
      Create3,
      Create4,
      GlobalSpecifier,
      SuperSpecifier,
      getPrefix,
      getKind,
      getAsIdentifier,
      getAsNamespace,
      getAsNamespaceAlias,
      getAsRecordDecl,
      getAsType,
      isDependent,
      isInstantiationDependent,
      containsUnexpandedParameterPack,
      print,
      Profile,
      dump,
      dump1,
    };
    static const unsigned _total_num_mems_ = dump1 + 1;
  }
  namespace clang__NestedNameSpecifierLoc {
    enum memnames {
      operator_bool,
      hasQualifier,
      getNestedNameSpecifier,
      getOpaqueData,
      getSourceRange,
      getLocalSourceRange,
      getBeginLoc,
      getEndLoc,
      getLocalBeginLoc,
      getLocalEndLoc,
      getPrefix,
      getTypeLoc,
      getDataLength,
      operator_eq_eq,
      operator_not_eq,
    };
    static const unsigned _total_num_mems_ = operator_not_eq + 1;
  }
  namespace clang__UncommonTemplateNameStorage {
    enum memnames {
      size,
    };
    static const unsigned _total_num_mems_ = size + 1;
  }
  namespace clang__OverloadedTemplateStorage {
    enum memnames {
      _this_,
    };
    static const unsigned _total_num_mems_ = 0;
  }
  namespace clang__SubstTemplateTemplateParmPackStorage {
    enum memnames {
      getParameterPack,
      getArgumentPack,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__TemplateName {
    enum memnames {
      isNull,
      getKind,
      getAsTemplateDecl,
      getAsOverloadedTemplate,
      getAsSubstTemplateTemplateParm,
      getAsSubstTemplateTemplateParmPack,
      getAsQualifiedTemplateName,
      getAsDependentTemplateName,
      getUnderlying,
      getNameToSubstitute,
      isDependent,
      isInstantiationDependent,
      containsUnexpandedParameterPack,
      print,
      dump,
      dump1,
      getAsVoidPointer,
      getFromVoidPointer,
    };
    static const unsigned _total_num_mems_ = getFromVoidPointer + 1;
  }
  namespace clang__SubstTemplateTemplateParmStorage {
    enum memnames {
      getParameter,
      getReplacement,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__QualifiedTemplateName {
    enum memnames {
      getQualifier,
      hasTemplateKeyword,
      getDecl,
      getTemplateDecl,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__DependentTemplateName {
    enum memnames {
      getQualifier,
      isIdentifier,
      getIdentifier,
      isOverloadedOperator,
      getOperator,
      Profile,
      Profile1,
    };
    static const unsigned _total_num_mems_ = Profile1 + 1;
  }
  namespace clang__LinkageInfo {
    enum memnames {
      external,
      internal,
      uniqueExternal,
      none,
      visible_none,
      getLinkage,
      getVisibility,
      isVisibilityExplicit,
    };
    static const unsigned _total_num_mems_ = isVisibilityExplicit + 1;
  }
  namespace clang__Qualifiers {
    enum memnames {
      removeCommonQualifiers,
      fromFastMask,
      fromCVRMask,
      fromCVRUMask,
      fromOpaqueValue,
      getAsOpaqueValue,
      hasConst,
      hasVolatile,
      hasRestrict,
      hasCVRQualifiers,
      getCVRQualifiers,
      hasUnaligned,
      hasObjCGCAttr,
      getObjCGCAttr,
      withoutObjCGCAttr,
      withoutObjCLifetime,
      hasObjCLifetime,
      getObjCLifetime,
      hasNonTrivialObjCLifetime,
      hasStrongOrWeakObjCLifetime,
      hasAddressSpace,
      getAddressSpace,
      hasTargetSpecificAddressSpace,
      getAddressSpaceAttributePrintValue,
      hasFastQualifiers,
      getFastQualifiers,
      hasNonFastQualifiers,
      getNonFastQualifiers,
      hasQualifiers,
      empty,
      isAddressSpaceSupersetOf,
      compatiblyIncludes,
      compatiblyIncludesObjCLifetime,
      isStrictSupersetOf,
      operator_eq_eq,
      operator_not_eq,
      operator_bool,
      operator_plus,
      operator_minus,
      getAsString,
      getAsString1,
      isEmptyWhenPrinted,
      print,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__SplitQualType {
    enum memnames {
      Ty,
      Quals,
      getSingleStepDesugaredType,
      operator_eq_eq,
      operator_not_eq,
    };
    static const unsigned _total_num_mems_ = operator_not_eq + 1;
  }
  namespace clang__QualType {
    enum memnames {
      getLocalFastQualifiers,
      getTypePtr,
      getTypePtrOrNull,
      getBaseTypeIdentifier,
      split,
      getAsOpaquePtr,
      getFromOpaquePtr,
      operator_star,
      operator_arrow,
      isCanonical,
      isCanonicalAsParam,
      isNull,
      isLocalConstQualified,
      isConstQualified,
      isLocalRestrictQualified,
      isRestrictQualified,
      isLocalVolatileQualified,
      isVolatileQualified,
      hasLocalQualifiers,
      hasQualifiers,
      hasLocalNonFastQualifiers,
      getLocalQualifiers,
      getQualifiers,
      getLocalCVRQualifiers,
      getCVRQualifiers,
      isConstant,
      isPODType,
      isCXX98PODType,
      isCXX11PODType,
      isTrivialType,
      isTriviallyCopyableType,
      mayBeDynamicClass,
      mayBeNotDynamicClass,
      withConst,
      withVolatile,
      withRestrict,
      withCVRQualifiers,
      withFastQualifiers,
      withExactLocalFastQualifiers,
      withoutLocalFastQualifiers,
      getCanonicalType,
      getLocalUnqualifiedType,
      getUnqualifiedType,
      getSplitUnqualifiedType,
      isMoreQualifiedThan,
      isAtLeastAsQualifiedAs,
      getNonReferenceType,
      getNonLValueExprType,
      getDesugaredType,
      getSplitDesugaredType,
      getSingleStepDesugaredType,
      IgnoreParens,
      operator_eq_eq,
      operator_not_eq,
      getAsString,
      getAsString1,
      getAsString2,
      getAsString3,
      getAsString_NoPrependScope,
      print,
      print1,
      print2,
      dump,
      dump1,
      dump2,
      Profile,
      getAddressSpace,
      getObjCGCAttr,
      isObjCGCWeak,
      isObjCGCStrong,
      getObjCLifetime,
      hasNonTrivialObjCLifetime,
      hasStrongOrWeakObjCLifetime,
      isNonWeakInMRRWithObjCWeak,
      isNonTrivialToPrimitiveDefaultInitialize,
      isNonTrivialToPrimitiveCopy,
      isNonTrivialToPrimitiveDestructiveMove,
      isDestructedType,
      isCForbiddenLValueType,
      substObjCMemberType,
      stripObjCKindOfType,
      getAtomicUnqualifiedType,
    };
    static const unsigned _total_num_mems_ = getAtomicUnqualifiedType + 1;
  }
  namespace clang__ExtQualsTypeCommonBase {
    enum memnames {
    };
    static const unsigned _total_num_mems_ = 0;
  }
  namespace clang__Type {
    enum memnames {
      getTypeClass,
      isFromAST,
      containsUnexpandedParameterPack,
      isCanonicalUnqualified,
      getLocallyUnqualifiedSingleStepDesugaredType,
      isIncompleteType,
      isIncompleteOrObjectType,
      isObjectType,
      isLiteralType,
      isStandardLayoutType,
      isBuiltinType,
      isSpecificBuiltinType,
      isPlaceholderType,
      getAsPlaceholderType,
      isSpecificPlaceholderType,
      isNonOverloadPlaceholderType,
      isIntegerType,
      isEnumeralType,
      isScopedEnumeralType,
      isBooleanType,
      isCharType,
      isWideCharType,
      isChar8Type,
      isChar16Type,
      isChar32Type,
      isAnyCharacterType,
      isIntegralType,
      isIntegralOrEnumerationType,
      isIntegralOrUnscopedEnumerationType,
      isRealFloatingType,
      isComplexType,
      isAnyComplexType,
      isFloatingType,
      isHalfType,
      isFloat16Type,
      isFloat128Type,
      isRealType,
      isArithmeticType,
      isVoidType,
      isScalarType,
      isAggregateType,
      isFundamentalType,
      isCompoundType,
      isFunctionType,
      isFunctionNoProtoType,
      isFunctionProtoType,
      isPointerType,
      isAnyPointerType,
      isBlockPointerType,
      isVoidPointerType,
      isReferenceType,
      isLValueReferenceType,
      isRValueReferenceType,
      isFunctionPointerType,
      isMemberPointerType,
      isMemberFunctionPointerType,
      isMemberDataPointerType,
      isArrayType,
      isConstantArrayType,
      isIncompleteArrayType,
      isVariableArrayType,
      isDependentSizedArrayType,
      isRecordType,
      isClassType,
      isStructureType,
      isObjCBoxableRecordType,
      isInterfaceType,
      isStructureOrClassType,
      isUnionType,
      isReflectedType,
      isComplexIntegerType,
      isVectorType,
      isExtVectorType,
      isDependentAddressSpaceType,
      isObjCObjectPointerType,
      isObjCRetainableType,
      isObjCLifetimeType,
      isObjCIndirectLifetimeType,
      isObjCNSObjectType,
      isObjCIndependentClassType,
      isObjCObjectType,
      isObjCQualifiedInterfaceType,
      isObjCQualifiedIdType,
      isObjCQualifiedClassType,
      isObjCObjectOrInterfaceType,
      isObjCIdType,
      isObjCInertUnsafeUnretainedType,
      isObjCIdOrObjectKindOfType,
      isObjCClassType,
      isObjCClassOrClassKindOfType,
      isBlockCompatibleObjCPointerType,
      isObjCSelType,
      isObjCBuiltinType,
      isObjCARCBridgableType,
      isCARCBridgableType,
      isTemplateTypeParmType,
      isNullPtrType,
      isAlignValT,
      isStdByteType,
      isAtomicType,
      isOCLImage1dROType,
      isOCLImage1dArrayROType,
      isOCLImage1dBufferROType,
      isOCLImage2dROType,
      isOCLImage2dArrayROType,
      isOCLImage2dDepthROType,
      isOCLImage2dArrayDepthROType,
      isOCLImage2dMSAAROType,
      isOCLImage2dArrayMSAAROType,
      isOCLImage2dMSAADepthROType,
      isOCLImage2dArrayMSAADepthROType,
      isOCLImage3dROType,
      isOCLImage1dWOType,
      isOCLImage1dArrayWOType,
      isOCLImage1dBufferWOType,
      isOCLImage2dWOType,
      isOCLImage2dArrayWOType,
      isOCLImage2dDepthWOType,
      isOCLImage2dArrayDepthWOType,
      isOCLImage2dMSAAWOType,
      isOCLImage2dArrayMSAAWOType,
      isOCLImage2dMSAADepthWOType,
      isOCLImage2dArrayMSAADepthWOType,
      isOCLImage3dWOType,
      isOCLImage1dRWType,
      isOCLImage1dArrayRWType,
      isOCLImage1dBufferRWType,
      isOCLImage2dRWType,
      isOCLImage2dArrayRWType,
      isOCLImage2dDepthRWType,
      isOCLImage2dArrayDepthRWType,
      isOCLImage2dMSAARWType,
      isOCLImage2dArrayMSAARWType,
      isOCLImage2dMSAADepthRWType,
      isOCLImage2dArrayMSAADepthRWType,
      isOCLImage3dRWType,
      isImageType,
      isSamplerT,
      isEventT,
      isClkEventT,
      isQueueT,
      isReserveIDT,
      isPipeType,
      isOpenCLSpecificType,
      isObjCARCImplicitlyUnretainedType,
      getObjCARCImplicitLifetime,
      getScalarTypeKind,
      isDependentType,
      isInstantiationDependentType,
      isUndeducedType,
      isVariablyModifiedType,
      hasSizedVLAType,
      hasUnnamedOrLocalType,
      isOverloadableType,
      isElaboratedTypeSpecifier,
      canDecayToPointerType,
      hasPointerRepresentation,
      hasObjCPointerRepresentation,
      hasIntegerRepresentation,
      hasSignedIntegerRepresentation,
      hasUnsignedIntegerRepresentation,
      hasFloatingRepresentation,
      getAsStructureType,
      getAsUnionType,
      getAsComplexIntegerType,
      getAsObjCInterfaceType,
      getAsObjCInterfacePointerType,
      getAsObjCQualifiedIdType,
      getAsObjCQualifiedClassType,
      getAsObjCQualifiedInterfaceType,
      getAsCXXRecordDecl,
      getAsRecordDecl,
      getAsTagDecl,
      getPointeeCXXRecordDecl,
      getContainedDeducedType,
      getContainedAutoType,
      hasAutoForTrailingReturnType,
      getAsArrayTypeUnsafe,
      castAsArrayTypeUnsafe,
      getBaseElementTypeUnsafe,
      getArrayElementTypeNoTypeQual,
      getPointeeOrArrayElementType,
      getPointeeType,
      getUnqualifiedDesugaredType,
      isPromotableIntegerType,
      isSignedIntegerType,
      isUnsignedIntegerType,
      isSignedIntegerOrEnumerationType,
      isUnsignedIntegerOrEnumerationType,
      isFixedPointType,
      isSaturatedFixedPointType,
      isUnsaturatedFixedPointType,
      isSignedFixedPointType,
      isUnsignedFixedPointType,
      isConstantSizeType,
      isSpecifierType,
      getLinkage,
      getVisibility,
      isVisibilityExplicit,
      getLinkageAndVisibility,
      isLinkageValid,
      canHaveNullability,
      acceptsObjCTypeParams,
      getTypeClassName,
      getCanonicalTypeInternal,
      dump,
      dump1,
    };
    static const unsigned _total_num_mems_ = dump1 + 1;
  }
  namespace clang__BuiltinType {
    enum memnames {
      getKind,
      getName,
      getNameAsCString,
      isSugared,
      desugar,
      isInteger,
      isSignedInteger,
      isUnsignedInteger,
      isFloatingPoint,
      isPlaceholderTypeKind,
      isPlaceholderType,
      isNonOverloadPlaceholderType,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ComplexType {
    enum memnames {
      getElementType,
      isSugared,
      desugar,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ParenType {
    enum memnames {
      getInnerType,
      isSugared,
      desugar,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__PointerType {
    enum memnames {
      getPointeeType,
      isAddressSpaceOverlapping,
      isSugared,
      desugar,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__AdjustedType {
    enum memnames {
      getOriginalType,
      getAdjustedType,
      isSugared,
      desugar,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__DecayedType {
    enum memnames {
      getDecayedType,
      getPointeeType,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__BlockPointerType {
    enum memnames {
      getPointeeType,
      isSugared,
      desugar,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ReferenceType {
    enum memnames {
      isSpelledAsLValue,
      isInnerRef,
      getPointeeTypeAsWritten,
      getPointeeType,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__LValueReferenceType {
    enum memnames {
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__RValueReferenceType {
    enum memnames {
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__MemberPointerType {
    enum memnames {
      getPointeeType,
      isMemberFunctionPointer,
      isMemberDataPointer,
      getClass,
      getMostRecentCXXRecordDecl,
      isSugared,
      desugar,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ArrayType {
    enum memnames {
      getElementType,
      getSizeModifier,
      getIndexTypeQualifiers,
      getIndexTypeCVRQualifiers,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ConstantArrayType {
    enum memnames {
      getSize,
      isSugared,
      desugar,
      getNumAddressingBits,
      getMaxSizeBits,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__IncompleteArrayType {
    enum memnames {
      isSugared,
      desugar,
      classof,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__VariableArrayType {
    enum memnames {
      getSizeExpr,
      getBracketsRange,
      getLBracketLoc,
      getRBracketLoc,
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__DependentSizedArrayType {
    enum memnames {
      getSizeExpr,
      getBracketsRange,
      getLBracketLoc,
      getRBracketLoc,
      isSugared,
      desugar,
      classof,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__DependentAddressSpaceType {
    enum memnames {
      getAddrSpaceExpr,
      getPointeeType,
      getAttributeLoc,
      isSugared,
      desugar,
      classof,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__DependentSizedExtVectorType {
    enum memnames {
      getSizeExpr,
      getElementType,
      getAttributeLoc,
      isSugared,
      desugar,
      classof,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__VectorType {
    enum memnames {
      getElementType,
      getNumElements,
      isVectorSizeTooLarge,
      isSugared,
      desugar,
      getVectorKind,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__DependentVectorType {
    enum memnames {
      getSizeExpr,
      getElementType,
      getAttributeLoc,
      getVectorKind,
      isSugared,
      desugar,
      classof,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__ExtVectorType {
    enum memnames {
      getPointAccessorIdx,
      getNumericAccessorIdx,
      getAccessorIdx,
      isAccessorWithinNumElements,
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__FunctionType {
    enum memnames {
      getReturnType,
      getHasRegParm,
      getRegParmType,
      getNoReturnAttr,
      getCallConv,
      getExtInfo,
      isConst,
      isVolatile,
      isRestrict,
      getCallResultType,
      getNameForCallConv,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__FunctionType__ExtInfo {
    enum memnames {
      getNoReturn,
      getProducesResult,
      getNoCallerSavedRegs,
      getNoCfCheck,
      getHasRegParm,
      getRegParm,
      getCC,
      operator_eq_eq,
      operator_not_eq,
      withNoReturn,
      withProducesResult,
      withNoCallerSavedRegs,
      withNoCfCheck,
      withRegParm,
      withCallingConv,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__FunctionNoProtoType {
    enum memnames {
      isSugared,
      desugar,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__FunctionProtoType {
    enum memnames {
      getNumParams,
      getParamType,
      getParamTypes,
      getExtProtoInfo,
      getExceptionSpecType,
      hasExceptionSpec,
      hasDynamicExceptionSpec,
      hasNoexceptExceptionSpec,
      hasDependentExceptionSpec,
      hasInstantiationDependentExceptionSpec,
      getNumExceptions,
      getExceptionType,
      getNoexceptExpr,
      getExceptionSpecDecl,
      getExceptionSpecTemplate,
      canThrow,
      isNothrow,
      isVariadic,
      isTemplateVariadic,
      hasTrailingReturn,
      getTypeQuals,
      getRefQualifier,
      param_types,
      exceptions,
      hasExtParameterInfos,
      getExtParameterInfos,
      getExtParameterInfosOrNull,
      getExtParameterInfo,
      getParameterABI,
      isParamConsumed,
      isSugared,
      desugar,
      printExceptionSpecification,
      classof,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__FunctionProtoType__ExtParameterInfo {
    enum memnames {
      getABI,
      withABI,
      isConsumed,
      withIsConsumed,
      hasPassObjectSize,
      withHasPassObjectSize,
      isNoEscape,
      withIsNoEscape,
      getOpaqueValue,
      getFromOpaqueValue,
      operator_eq_eq,
      operator_not_eq,
    };
    static const unsigned _total_num_mems_ = operator_not_eq + 1;
  }
  namespace clang__FunctionProtoType__ExceptionSpecInfo {
    enum memnames {
      Type,
      NoexceptExpr,
      SourceDecl,
      SourceTemplate,
    };
    static const unsigned _total_num_mems_ = SourceTemplate + 1;
  }
  namespace clang__FunctionProtoType__ExtProtoInfo {
    enum memnames {
      ExtInfo,
      Variadic,
      HasTrailingReturn,
      TypeQuals,
      RefQualifier,
      ExceptionSpec,
      ExtParameterInfos,
    };
    static const unsigned _total_num_mems_ = ExtParameterInfos + 1;
  }
  namespace clang__UnresolvedUsingType {
    enum memnames {
      getDecl,
      isSugared,
      desugar,
      classof,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__TypedefType {
    enum memnames {
      getDecl,
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__TypeOfExprType {
    enum memnames {
      getUnderlyingExpr,
      desugar,
      isSugared,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__TypeOfType {
    enum memnames {
      getUnderlyingType,
      desugar,
      isSugared,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__DecltypeType {
    enum memnames {
      getUnderlyingExpr,
      getUnderlyingType,
      desugar,
      isSugared,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ReflectedType {
    enum memnames {
      getTypeReflection,
      getUnderlyingType,
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__UnaryTransformType {
    enum memnames {
      isSugared,
      desugar,
      getUnderlyingType,
      getBaseType,
      getUTTKind,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__TagType {
    enum memnames {
      getDecl,
      isBeingDefined,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__RecordType {
    enum memnames {
      getDecl,
      hasConstFields,
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__EnumType {
    enum memnames {
      getDecl,
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__AttributedType {
    enum memnames {
      getAttrKind,
      getModifiedType,
      getEquivalentType,
      isSugared,
      desugar,
      isQualifier,
      isMSTypeSpec,
      isCallingConv,
      getNullabilityAttrKind,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__TemplateTypeParmType {
    enum memnames {
      getDepth,
      getIndex,
      isParameterPack,
      getDecl,
      getIdentifier,
      isSugared,
      desugar,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__SubstTemplateTypeParmType {
    enum memnames {
      getReplacedParameter,
      getReplacementType,
      isSugared,
      desugar,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__SubstTemplateTypeParmPackType {
    enum memnames {
      getIdentifier,
      getReplacedParameter,
      isSugared,
      desugar,
      getArgumentPack,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__DeducedType {
    enum memnames {
      isSugared,
      desugar,
      getDeducedType,
      isDeduced,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__AutoType {
    enum memnames {
      isDecltypeAuto,
      getKeyword,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__DeducedTemplateSpecializationType {
    enum memnames {
      getTemplateName,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__TemplateSpecializationType {
    enum memnames {
      _this_,
      isCurrentInstantiation,
      isTypeAlias,
      getAliasedType,
      getTemplateName,
      getArgs,
      getNumArgs,
      getArg,
      template_arguments,
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__InjectedClassNameType {
    enum memnames {
      getInjectedSpecializationType,
      getInjectedTST,
      getTemplateName,
      getDecl,
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__TypeWithKeyword {
    enum memnames {
      getKeyword,
      getKeywordForTypeSpec,
      getTagTypeKindForTypeSpec,
      getKeywordForTagTypeKind,
      getTagTypeKindForKeyword,
      KeywordIsTagTypeKind,
      getKeywordName,
      getTagTypeKindName,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ElaboratedType {
    enum memnames {
      getQualifier,
      getNamedType,
      desugar,
      isSugared,
      getOwnedTagDecl,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__DependentNameType {
    enum memnames {
      getQualifier,
      getIdentifier,
      isSugared,
      desugar,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__DependentTemplateSpecializationType {
    enum memnames {
      _this_,
      getQualifier,
      getIdentifier,
      getArgs,
      getNumArgs,
      getArg,
      template_arguments,
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__PackExpansionType {
    enum memnames {
      getPattern,
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCTypeParamType {
    enum memnames {
      quals,
      qual_empty,
      getNumProtocols,
      getProtocol,
      getProtocols,
      isSugared,
      desugar,
      classof,
      getDecl,
    };
    static const unsigned _total_num_mems_ = getDecl + 1;
  }
  namespace clang__ObjCObjectType {
    enum memnames {
      quals,
      qual_empty,
      getNumProtocols,
      getProtocol,
      getProtocols,
      getBaseType,
      isObjCId,
      isObjCClass,
      isObjCUnqualifiedId,
      isObjCUnqualifiedClass,
      isObjCUnqualifiedIdOrClass,
      isObjCQualifiedId,
      isObjCQualifiedClass,
      getInterface,
      isSpecialized,
      isSpecializedAsWritten,
      isUnspecialized,
      isUnspecializedAsWritten,
      getTypeArgs,
      getTypeArgsAsWritten,
      isKindOfTypeAsWritten,
      isKindOfType,
      getSuperClassType,
      stripObjCKindOfTypeAndQuals,
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCInterfaceType {
    enum memnames {
      getDecl,
      isSugared,
      desugar,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCObjectPointerType {
    enum memnames {
      getPointeeType,
      getObjectType,
      getInterfaceType,
      getInterfaceDecl,
      isObjCIdType,
      isObjCClassType,
      isObjCIdOrClassType,
      isObjCQualifiedIdType,
      isObjCQualifiedClassType,
      isKindOfType,
      isSpecialized,
      isSpecializedAsWritten,
      isUnspecialized,
      isUnspecializedAsWritten,
      getTypeArgs,
      getTypeArgsAsWritten,
      quals,
      qual_empty,
      getNumProtocols,
      getProtocol,
      isSugared,
      desugar,
      getSuperClassType,
      stripObjCKindOfTypeAndQuals,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__AtomicType {
    enum memnames {
      getValueType,
      isSugared,
      desugar,
      Profile,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__PipeType {
    enum memnames {
      getElementType,
      isSugared,
      desugar,
      Profile,
      classof,
      isReadOnly,
    };
    static const unsigned _total_num_mems_ = isReadOnly + 1;
  }
  namespace clang__TypeSourceInfo {
    enum memnames {
      getType,
      getTypeLoc,
    };
    static const unsigned _total_num_mems_ = getTypeLoc + 1;
  }
  namespace clang__TranslationUnitDecl {
    enum memnames {
      getASTContext,
      getAnonymousNamespace,
      Create,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__PragmaCommentDecl {
    enum memnames {
      CreateDeserialized,
      getCommentKind,
      getArg,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__PragmaDetectMismatchDecl {
    enum memnames {
      CreateDeserialized,
      getName,
      getValue,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ExternCContextDecl {
    enum memnames {
      Create,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__NamedDecl {
    enum memnames {
      getIdentifier,
      getName,
      getNameAsString,
      printName,
      getDeclName,
      printQualifiedName,
      printQualifiedName1,
      getQualifiedNameAsString,
      getNameForDiagnostic,
      declarationReplaces,
      hasLinkage,
      isCXXClassMember,
      isCXXInstanceMember,
      getLinkageInternal,
      getFormalLinkage,
      hasExternalFormalLinkage,
      isExternallyVisible,
      isExternallyDeclarable,
      getVisibility,
      getLinkageAndVisibility,
      isLinkageValid,
      hasLinkageBeenComputed,
      getUnderlyingDecl,
      getMostRecentDecl,
      getObjCFStringFormattingFamily,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__LabelDecl {
    enum memnames {
      Create,
      Create1,
      CreateDeserialized,
      getStmt,
      isGnuLocal,
      getSourceRange,
      isMSAsmLabel,
      isResolvedMSAsmLabel,
      getMSAsmLabel,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__NamespaceDecl {
    enum memnames {
      getPreviousDecl,
      getFirstDecl,
      getMostRecentDecl,
      Create,
      CreateDeserialized,
      isAnonymousNamespace,
      isInline,
      getOriginalNamespace,
      isOriginalNamespace,
      getAnonymousNamespace,
      getCanonicalDecl,
      getSourceRange,
      getLocStart,
      getBeginLoc,
      getRBraceLoc,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ValueDecl {
    enum memnames {
      getType,
      isWeak,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__DeclaratorDecl {
    enum memnames {
      getTypeSourceInfo,
      getInnerLocStart,
      getOuterLocStart,
      getSourceRange,
      getLocStart,
      getBeginLoc,
      getQualifier,
      getQualifierLoc,
      getNumTemplateParameterLists,
      getTemplateParameterList,
      getTypeSpecStartLoc,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__EvaluatedStmt {
    enum memnames {
      WasEvaluated,
      IsEvaluating,
      CheckedICE,
      CheckingICE,
      IsICE,
      Value,
    };
    static const unsigned _total_num_mems_ = Value + 1;
  }
  namespace clang__VarDecl {
    enum memnames {
      getPreviousDecl,
      getFirstDecl,
      getMostRecentDecl,
      getStorageClassSpecifierString,
      Create,
      Create1,
      CreateDeserialized,
      getSourceRange,
      getStorageClass,
      getTSCSpec,
      getTLSKind,
      hasLocalStorage,
      isStaticLocal,
      hasExternalStorage,
      hasGlobalStorage,
      getStorageDuration,
      getLanguageLinkage,
      isExternC,
      isInExternCContext,
      isInExternCXXContext,
      isLocalVarDecl,
      isLocalVarDeclOrParm,
      isFunctionOrMethodVarDecl,
      isStaticDataMember,
      getCanonicalDecl,
      isThisDeclarationADefinition,
      isThisDeclarationADefinition1,
      hasDefinition,
      hasDefinition1,
      getActingDefinition,
      getDefinition,
      getDefinition1,
      isOutOfLine,
      isFileVarDecl,
      getAnyInitializer,
      getAnyInitializer1,
      hasInit,
      getInit,
      isUsableInConstantExpressions,
      ensureEvaluatedStmt,
      evaluateValue,
      getEvaluatedValue,
      isInitKnownICE,
      isInitICE,
      checkInitIsICE,
      getInitStyle,
      isDirectInit,
      isThisDeclarationADemotedDefinition,
      isExceptionVariable,
      isNRVOVariable,
      isCXXForRangeDecl,
      isObjCForDecl,
      isARCPseudoStrong,
      isInline,
      isInlineSpecified,
      isConstexpr,
      isInitCapture,
      isPreviousDeclInSameBlockScope,
      getTemplateInstantiationPattern,
      getInstantiatedFromStaticDataMember,
      getTemplateSpecializationKind,
      getPointOfInstantiation,
      getMemberSpecializationInfo,
      getDescribedVarTemplate,
      isKnownToBeDefined,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ImplicitParamDecl {
    enum memnames {
      Create,
      Create1,
      CreateDeserialized,
      getParameterKind,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ParmVarDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getSourceRange,
      isObjCMethodParameter,
      getFunctionScopeDepth,
      getFunctionScopeIndex,
      getObjCDeclQualifier,
      isKNRPromoted,
      getDefaultArg,
      getDefaultArgRange,
      getUninstantiatedDefaultArg,
      hasDefaultArg,
      hasUnparsedDefaultArg,
      hasUninstantiatedDefaultArg,
      hasInheritedDefaultArg,
      getOriginalType,
      isParameterPack,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__FunctionDecl {
    enum memnames {
      getPreviousDecl,
      getFirstDecl,
      getMostRecentDecl,
      Create,
      Create1,
      CreateDeserialized,
      getNameInfo,
      getNameForDiagnostic,
      getSourceRange,
      hasBody,
      hasBody1,
      hasTrivialBody,
      isDefined,
      isDefined1,
      getDefinition,
      getBody,
      getBody1,
      isThisDeclarationADefinition,
      doesThisDeclarationHaveABody,
      isVariadic,
      isVirtualAsWritten,
      isPure,
      isLateTemplateParsed,
      isTrivial,
      isTrivialForCall,
      isDefaulted,
      isExplicitlyDefaulted,
      hasImplicitReturnZero,
      hasPrototype,
      hasWrittenPrototype,
      hasInheritedPrototype,
      isConstexpr,
      instantiationIsPending,
      usesSEHTry,
      isDeleted,
      isDeletedAsWritten,
      isMain,
      isMSVCRTEntryPoint,
      isReservedGlobalPlacementOperator,
      isReplaceableGlobalAllocationFunction,
      isDestroyingOperatorDelete,
      getLanguageLinkage,
      isExternC,
      isInExternCContext,
      isInExternCXXContext,
      isGlobal,
      isNoReturn,
      hasSkippedBody,
      willHaveBody,
      isMetaprogram,
      isMultiVersion,
      isCPUDispatchMultiVersion,
      isCPUSpecificMultiVersion,
      getCanonicalDecl,
      getBuiltinID,
      parameters,
      param_empty,
      param_size,
      getNumParams,
      getParamDecl,
      getMinRequiredArguments,
      getReturnType,
      getReturnTypeSourceRange,
      getExceptionSpecSourceRange,
      getCallResultType,
      getUnusedResultAttr,
      hasUnusedResultAttr,
      getStorageClass,
      isInlineSpecified,
      isInlined,
      isInlineDefinitionExternallyVisible,
      isMSExternInline,
      doesDeclarationForceExternallyVisibleDefinition,
      isOverloadedOperator,
      getOverloadedOperator,
      getLiteralIdentifier,
      getInstantiatedFromMemberFunction,
      getTemplatedKind,
      getMemberSpecializationInfo,
      getDescribedFunctionTemplate,
      isFunctionTemplateSpecialization,
      getClassScopeSpecializationPattern,
      getTemplateSpecializationInfo,
      isImplicitlyInstantiable,
      isTemplateInstantiation,
      getTemplateInstantiationPattern,
      getPrimaryTemplate,
      getTemplateSpecializationArgs,
      getTemplateSpecializationArgsAsWritten,
      getDependentSpecializationInfo,
      getTemplateSpecializationKind,
      getPointOfInstantiation,
      isOutOfLine,
      getMemoryFunctionKind,
      getODRHash,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__FieldDecl {
    enum memnames {
      getFirstDecl,
      Create,
      Create1,
      CreateDeserialized,
      getFieldIndex,
      isMutable,
      isBitField,
      isUnnamedBitfield,
      isAnonymousStructOrUnion,
      getBitWidth,
      getBitWidthValue,
      isZeroLengthBitField,
      getInClassInitStyle,
      hasInClassInitializer,
      getInClassInitializer,
      hasCapturedVLAType,
      getCapturedVLAType,
      getParent,
      getSourceRange,
      getCanonicalDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__EnumConstantDecl {
    enum memnames {
      getFirstDecl,
      Create,
      CreateDeserialized,
      getInitExpr,
      getInitVal,
      getSourceRange,
      getCanonicalDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__IndirectFieldDecl {
    enum memnames {
      getFirstDecl,
      CreateDeserialized,
      chain,
      getChainingSize,
      getAnonField,
      getVarDecl,
      getCanonicalDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__TypeDecl {
    enum memnames {
      getTypeForDecl,
      getLocStart,
      getBeginLoc,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__TypedefNameDecl {
    enum memnames {
      getPreviousDecl,
      getFirstDecl,
      getMostRecentDecl,
      isModed,
      getTypeSourceInfo,
      getUnderlyingType,
      getCanonicalDecl,
      getAnonDeclWithTypedefName,
      isTransparentTag,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__TypedefDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__TypeAliasDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getSourceRange,
      getDescribedAliasTemplate,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__TagDecl {
    enum memnames {
      getPreviousDecl,
      getFirstDecl,
      getMostRecentDecl,
      getBraceRange,
      getInnerLocStart,
      getOuterLocStart,
      getSourceRange,
      getCanonicalDecl,
      isThisDeclarationADefinition,
      isCompleteDefinition,
      isCompleteDefinitionRequired,
      isBeingDefined,
      isEmbeddedInDeclarator,
      isFreeStanding,
      isDependentType,
      getDefinition,
      getKindName,
      getTagKind,
      isStruct,
      isInterface,
      isClass,
      isUnion,
      isEnum,
      hasNameForLinkage,
      getTypedefNameForAnonDecl,
      getQualifier,
      getQualifierLoc,
      getNumTemplateParameterLists,
      getTemplateParameterList,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__EnumDecl {
    enum memnames {
      getCanonicalDecl,
      getPreviousDecl,
      getMostRecentDecl,
      getDefinition,
      Create,
      CreateDeserialized,
      enumerators,
      getPromotionType,
      getIntegerType,
      getIntegerTypeSourceInfo,
      getIntegerTypeRange,
      getNumPositiveBits,
      getNumNegativeBits,
      isScoped,
      isScopedUsingClassTag,
      isFixed,
      isComplete,
      isClosed,
      isClosedFlag,
      isClosedNonFlag,
      getTemplateInstantiationPattern,
      getInstantiatedFromMemberEnum,
      getTemplateSpecializationKind,
      getMemberSpecializationInfo,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__RecordDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getPreviousDecl,
      getMostRecentDecl,
      hasFlexibleArrayMember,
      isAnonymousStructOrUnion,
      hasObjectMember,
      hasVolatileMember,
      hasLoadedFieldsFromExternalStorage,
      isNonTrivialToPrimitiveDefaultInitialize,
      isNonTrivialToPrimitiveCopy,
      isNonTrivialToPrimitiveDestroy,
      canPassInRegisters,
      getArgPassingRestrictions,
      isParamDestroyedInCallee,
      isInjectedClassName,
      isLambda,
      isCapturedRecord,
      getDefinition,
      fields,
      field_empty,
      classof,
      classofKind,
      isMsStruct,
      mayInsertExtraPadding,
      findFirstNamedDataMember,
    };
    static const unsigned _total_num_mems_ = findFirstNamedDataMember + 1;
  }
  namespace clang__FileScopeAsmDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getAsmLoc,
      getRParenLoc,
      getSourceRange,
      getAsmString,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__BlockDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getCaretLocation,
      isVariadic,
      getCompoundBody,
      getBody,
      getSignatureAsWritten,
      parameters,
      param_empty,
      param_size,
      getNumParams,
      getParamDecl,
      hasCaptures,
      getNumCaptures,
      captures,
      capturesCXXThis,
      blockMissingReturnType,
      isConversionFromLambda,
      doesNotEscape,
      capturesVariable,
      getBlockManglingNumber,
      getBlockManglingContextDecl,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__BlockDecl__Capture {
    enum memnames {
      getVariable,
      isByRef,
      isNested,
      hasCopyExpr,
      getCopyExpr,
    };
    static const unsigned _total_num_mems_ = getCopyExpr + 1;
  }
  namespace clang__CapturedDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getBody,
      isNothrow,
      getNumParams,
      getParam,
      parameters,
      getContextParam,
      getContextParamPosition,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ImportDecl {
    enum memnames {
      CreateImplicit,
      CreateDeserialized,
      getImportedModule,
      getIdentifierLocs,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ExportDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getExportLoc,
      getRBraceLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__EmptyDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__DeclGroup {
    enum memnames {
      Create,
      size,
      operator_sub,
    };
    static const unsigned _total_num_mems_ = operator_sub + 1;
  }
  namespace clang__DeclGroupRef {
    enum memnames {
      _this_,
      Create,
      isNull,
      isSingleDecl,
      isDeclGroup,
      getSingleDecl,
      getDeclGroup,
      getAsOpaquePtr,
      getFromOpaquePtr,
    };
    static const unsigned _total_num_mems_ = getFromOpaquePtr + 1;
  }
  namespace clang__Stmt {
    enum memnames {
      operator_new,
      operator_new1,
      operator_new2,
      operator_delete,
      operator_delete1,
      operator_delete2,
      operator_delete3,
      getStmtClass,
      getStmtClassName,
      getSourceRange,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      addStmtClass,
      EnableStatistics,
      PrintStats,
      dump,
      dump1,
      dump2,
      dump3,
      dumpColor,
      dumpPretty,
      printPretty,
      viewAST,
      IgnoreImplicit,
      IgnoreContainers,
      stripLabelLikeStatements,
      children,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__Stmt__EmptyShell {
    enum memnames {
    };
    static const unsigned _total_num_mems_ = 0;
  }
  namespace clang__DeclStmt {
    enum memnames {
      isSingleDecl,
      getSingleDecl,
      getDeclGroup,
      getStartLoc,
      getEndLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      classof,
      decls,
    };
    static const unsigned _total_num_mems_ = decls + 1;
  }
  namespace clang__NullStmt {
    enum memnames {
      getSemiLoc,
      hasLeadingEmptyMacro,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CompoundStmt {
    enum memnames {
      CreateEmpty,
      body_empty,
      size,
      body,
      body_front,
      body_back,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getLBracLoc,
      getRBracLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__SwitchCase {
    enum memnames {
      getNextSwitchCase,
      getKeywordLoc,
      getColonLoc,
      getSubStmt,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CaseStmt {
    enum memnames {
      getCaseLoc,
      getEllipsisLoc,
      getColonLoc,
      getLHS,
      getRHS,
      getSubStmt,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__DefaultStmt {
    enum memnames {
      getSubStmt,
      getDefaultLoc,
      getColonLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__LabelStmt {
    enum memnames {
      getIdentLoc,
      getDecl,
      getName,
      getSubStmt,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__AttributedStmt {
    enum memnames {
      CreateEmpty,
      getAttrLoc,
      getAttrs,
      getSubStmt,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__IfStmt {
    enum memnames {
      getConditionVariable,
      getConditionVariableDeclStmt,
      getInit,
      getCond,
      getThen,
      getElse,
      getIfLoc,
      getElseLoc,
      isConstexpr,
      isObjCAvailabilityCheck,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__SwitchStmt {
    enum memnames {
      getConditionVariable,
      getConditionVariableDeclStmt,
      getInit,
      getCond,
      getBody,
      getSwitchCaseList,
      getSwitchLoc,
      isAllEnumCasesCovered,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__WhileStmt {
    enum memnames {
      getConditionVariable,
      getConditionVariableDeclStmt,
      getCond,
      getBody,
      getWhileLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__DoStmt {
    enum memnames {
      getCond,
      getBody,
      getDoLoc,
      getWhileLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ForStmt {
    enum memnames {
      getConditionVariable,
      getConditionVariableDeclStmt,
      getInit,
      getCond,
      getInc,
      getBody,
      getForLoc,
      getLParenLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__GotoStmt {
    enum memnames {
      getLabel,
      getGotoLoc,
      getLabelLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__IndirectGotoStmt {
    enum memnames {
      getGotoLoc,
      getStarLoc,
      getTarget,
      getConstantTarget,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ContinueStmt {
    enum memnames {
      getContinueLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__BreakStmt {
    enum memnames {
      getBreakLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ReturnStmt {
    enum memnames {
      getRetValue,
      getReturnLoc,
      getNRVOCandidate,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__AsmStmt {
    enum memnames {
      getAsmLoc,
      isSimple,
      isVolatile,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      generateAsmString,
      getNumOutputs,
      getOutputConstraint,
      isOutputPlusConstraint,
      getOutputExpr,
      getNumPlusOperands,
      getNumInputs,
      getInputConstraint,
      getInputExpr,
      getNumClobbers,
      getClobber,
      classof,
      inputs,
      outputs,
    };
    static const unsigned _total_num_mems_ = outputs + 1;
  }
  namespace clang__GCCAsmStmt {
    enum memnames {
      getRParenLoc,
      getAsmString,
      generateAsmString,
      getOutputIdentifier,
      getOutputName,
      getOutputConstraint,
      getOutputConstraintLiteral,
      getOutputExpr,
      getInputIdentifier,
      getInputName,
      getInputConstraint,
      getInputConstraintLiteral,
      getInputExpr,
      getNamedOperand,
      getClobber,
      getClobberStringLiteral,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__MSAsmStmt {
    enum memnames {
      getLBraceLoc,
      getEndLoc,
      hasBraces,
      getAsmString,
      generateAsmString,
      getOutputConstraint,
      getOutputExpr,
      getInputConstraint,
      getInputExpr,
      getAllConstraints,
      getClobbers,
      getAllExprs,
      getClobber,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__SEHExceptStmt {
    enum memnames {
      Create,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getExceptLoc,
      getEndLoc,
      getFilterExpr,
      getBlock,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__SEHFinallyStmt {
    enum memnames {
      Create,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getFinallyLoc,
      getEndLoc,
      getBlock,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__SEHTryStmt {
    enum memnames {
      Create,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getTryLoc,
      getEndLoc,
      getIsCXXTry,
      getTryBlock,
      getHandler,
      getExceptHandler,
      getFinallyHandler,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__SEHLeaveStmt {
    enum memnames {
      getLeaveLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CapturedStmt {
    enum memnames {
      CreateDeserialized,
      getCapturedStmt,
      getCapturedDecl,
      getCapturedRegionKind,
      getCapturedRecordDecl,
      capturesVariable,
      captures,
      capture_size,
      capture_inits,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CapturedStmt__Capture {
    enum memnames {
      getCaptureKind,
      getLocation,
      capturesThis,
      capturesVariable,
      capturesVariableByCopy,
      capturesVariableArrayType,
      getCapturedVar,
    };
    static const unsigned _total_num_mems_ = getCapturedVar + 1;
  }
  namespace clang__TemplateArgument {
    enum memnames {
      getEmptyPack,
      getKind,
      isNull,
      isDependent,
      isInstantiationDependent,
      containsUnexpandedParameterPack,
      isPackExpansion,
      getAsType,
      getAsDecl,
      getParamTypeForDecl,
      getNullPtrType,
      getAsTemplate,
      getAsTemplateOrTemplatePattern,
      getAsIntegral,
      getIntegralType,
      getNonTypeTemplateArgumentType,
      getAsExpr,
      pack_elements,
      pack_size,
      getPackAsArray,
      structurallyEquals,
      getPackExpansionPattern,
      print,
      dump,
      dump1,
      Profile,
    };
    static const unsigned _total_num_mems_ = Profile + 1;
  }
  namespace clang__TemplateArgumentLocInfo {
    enum memnames {
      getAsTypeSourceInfo,
      getAsExpr,
      getTemplateQualifierLoc,
      getTemplateNameLoc,
      getTemplateEllipsisLoc,
    };
    static const unsigned _total_num_mems_ = getTemplateEllipsisLoc + 1;
  }
  namespace clang__TemplateArgumentLoc {
    enum memnames {
      getLocation,
      getSourceRange,
      getArgument,
      getLocInfo,
      getTypeSourceInfo,
      getSourceExpression,
      getSourceDeclExpression,
      getSourceNullPtrExpression,
      getSourceIntegralExpression,
      getTemplateQualifierLoc,
      getTemplateNameLoc,
      getTemplateEllipsisLoc,
    };
    static const unsigned _total_num_mems_ = getTemplateEllipsisLoc + 1;
  }
  namespace clang__TemplateArgumentListInfo {
    enum memnames {
      getLAngleLoc,
      getRAngleLoc,
      size,
      getArgumentArray,
      arguments,
      operator_sub,
    };
    static const unsigned _total_num_mems_ = operator_sub + 1;
  }
  namespace clang__ASTTemplateArgumentListInfo {
    enum memnames {
      LAngleLoc,
      RAngleLoc,
      NumTemplateArgs,
      getTemplateArgs,
      arguments,
      operator_sub,
      Create,
    };
    static const unsigned _total_num_mems_ = Create + 1;
  }
  namespace clang__TypeLoc {
    enum memnames {
      getTypeLocClass,
      isNull,
      operator_bool,
      getFullDataSizeForType,
      getLocalAlignmentForType,
      getType,
      getTypePtr,
      getOpaqueData,
      getBeginLoc,
      getEndLoc,
      getSourceRange,
      getLocStart,
      getLocEnd,
      getLocalSourceRange,
      getFullDataSize,
      getNextTypeLoc,
      getUnqualifiedLoc,
      IgnoreParens,
      findExplicitQualifierLoc,
      initialize,
      operator_eq_eq,
      operator_not_eq,
      findNullabilityLoc,
    };
    static const unsigned _total_num_mems_ = findNullabilityLoc + 1;
  }
  namespace clang__UnqualTypeLoc {
    enum memnames {
      getTypePtr,
      getTypeLocClass,
    };
    static const unsigned _total_num_mems_ = getTypeLocClass + 1;
  }
  namespace clang__CommentOptions {
    enum memnames {
      ParseAllComments,
    };
    static const unsigned _total_num_mems_ = ParseAllComments + 1;
  }
  namespace clang__comments__CommandInfo {
    enum memnames {
      getID,
      Name,
      EndCommandName,
      ID,
      NumArgs,
      IsInlineCommand,
      IsBlockCommand,
      IsBriefCommand,
      IsReturnsCommand,
      IsParamCommand,
      IsTParamCommand,
      IsThrowsCommand,
      IsDeprecatedCommand,
      IsHeaderfileCommand,
      IsEmptyParagraphAllowed,
      IsVerbatimBlockCommand,
      IsVerbatimBlockEndCommand,
      IsVerbatimLineCommand,
      IsDeclarationCommand,
      IsFunctionDeclarationCommand,
      IsRecordLikeDetailCommand,
      IsRecordLikeDeclarationCommand,
      IsUnknownCommand,
    };
    static const unsigned _total_num_mems_ = IsUnknownCommand + 1;
  }
  namespace clang__comments__CommandTraits {
    enum memnames {
      getCommandInfo,
      getBuiltinCommandInfo,
    };
    static const unsigned _total_num_mems_ = getBuiltinCommandInfo + 1;
  }
  namespace llvm__Triple {
    enum memnames {
      operator_eq_eq,
      operator_not_eq,
      normalize,
      normalize1,
      getArch,
      getSubArch,
      getVendor,
      getOS,
      hasEnvironment,
      getEnvironment,
      getObjectFormat,
      getOSMajorVersion,
      getArchName,
      getVendorName,
      getOSName,
      getEnvironmentName,
      getOSAndEnvironmentName,
      isArch64Bit,
      isArch32Bit,
      isArch16Bit,
      isOSVersionLT,
      isOSVersionLT1,
      isMacOSXVersionLT,
      isMacOSX,
      isiOS,
      isTvOS,
      isWatchOS,
      isWatchABI,
      isOSDarwin,
      isSimulatorEnvironment,
      isOSNetBSD,
      isOSOpenBSD,
      isOSFreeBSD,
      isOSFuchsia,
      isOSDragonFly,
      isOSSolaris,
      isOSIAMCU,
      isOSUnknown,
      isGNUEnvironment,
      isOSContiki,
      isOSHaiku,
      isWindowsMSVCEnvironment,
      isKnownWindowsMSVCEnvironment,
      isWindowsCoreCLREnvironment,
      isWindowsItaniumEnvironment,
      isWindowsCygwinEnvironment,
      isWindowsGNUEnvironment,
      isOSCygMing,
      isOSMSVCRT,
      isOSWindows,
      isOSNaCl,
      isOSLinux,
      isOSKFreeBSD,
      isOSGlibc,
      isOSBinFormatELF,
      isOSBinFormatCOFF,
      isOSBinFormatMachO,
      isOSBinFormatWasm,
      isPS4CPU,
      isPS4,
      isAndroid,
      isAndroidVersionLT,
      isMusl,
      isNVPTX,
      isThumb,
      isARM,
      isAArch64,
      isMIPS32,
      isMIPS64,
      isMIPS,
      supportsCOMDAT,
      hasDefaultEmulatedTLS,
      get32BitArchVariant,
      get64BitArchVariant,
      getBigEndianArchVariant,
      getLittleEndianArchVariant,
      getARMCPUForArch,
      isLittleEndian,
      isCompatibleWith,
      merge,
      getArchTypeName,
      getArchTypePrefix,
      getVendorTypeName,
      getOSTypeName,
      getEnvironmentTypeName,
      getArchTypeForLLVMName,
    };
    static const unsigned _total_num_mems_ = getArchTypeForLLVMName + 1;
  }
  namespace clang__ObjCRuntime {
    enum memnames {
      getKind,
      getVersion,
      isNonFragile,
      isFragile,
      isGNUFamily,
      isNeXTFamily,
      allowsARC,
      hasNativeARC,
      hasOptimizedSetter,
      allowsWeak,
      hasNativeWeak,
      hasSubscripting,
      allowsSizeofAlignof,
      allowsPointerArithmetic,
      isSubscriptPointerArithmetic,
      hasTerminate,
      hasWeakClassImport,
      hasUnwindExceptions,
      hasAtomicCopyHelper,
      hasARCUnsafeClaimAutoreleasedReturnValue,
      hasEmptyCollections,
      getAsString,
      operator_eq_eq,
      operator_not_eq,
    };
    static const unsigned _total_num_mems_ = operator_not_eq + 1;
  }
  namespace clang__SanitizerSet {
    enum memnames {
      has,
      hasOneOf,
      empty,
      Mask,
    };
    static const unsigned _total_num_mems_ = Mask + 1;
  }
  namespace clang__LangOptionsBase {
    enum memnames {
      C99,
      C11,
      C17,
      MSVCCompat,
      MicrosoftExt,
      AsmBlocks,
      Borland,
      CPlusPlus,
      CPlusPlus11,
      CPlusPlus14,
      CPlusPlus17,
      CPlusPlus2a,
      ObjC1,
      ObjC2,
      ObjCDefaultSynthProperties,
      EncodeExtendedBlockSig,
      ObjCInferRelatedResultType,
      AppExt,
      Trigraphs,
      LineComment,
      Bool,
      Half,
      WChar,
      Char8,
      DeclSpecKeyword,
      DollarIdents,
      AsmPreprocessor,
      GNUMode,
      GNUKeywords,
      ImplicitInt,
      Digraphs,
      HexFloats,
      CXXOperatorNames,
      AppleKext,
      PascalStrings,
      WritableStrings,
      ConstStrings,
      LaxVectorConversions,
      AltiVec,
      ZVector,
      Exceptions,
      ObjCExceptions,
      CXXExceptions,
      DWARFExceptions,
      SjLjExceptions,
      SEHExceptions,
      ExternCNoUnwind,
      TraditionalCPP,
      RTTI,
      RTTIData,
      MSBitfields,
      Freestanding,
      NoBuiltin,
      NoMathBuiltin,
      GNUAsm,
      CoroutinesTS,
      RelaxedTemplateTemplateArgs,
      DoubleSquareBracketAttributes,
      ThreadsafeStatics,
      POSIXThreads,
      Blocks,
      EmitAllDecls,
      MathErrno,
      HeinousExtensions,
      Modules,
      ModulesTS,
      CompilingPCH,
      BuildingPCHWithObjectFile,
      ModulesDeclUse,
      ModulesSearchAll,
      ModulesStrictDeclUse,
      ModulesErrorRecovery,
      ImplicitModules,
      ModulesLocalVisibility,
      Optimize,
      OptimizeSize,
      Static,
      PackStruct,
      MaxTypeAlign,
      AlignDouble,
      PICLevel,
      PIE,
      GNUInline,
      NoInlineDefine,
      Deprecated,
      FastMath,
      FiniteMathOnly,
      UnsafeFPMath,
      ObjCGCBitmapPrint,
      AccessControl,
      CharIsSigned,
      WCharSize,
      WCharIsSigned,
      ShortEnums,
      OpenCL,
      OpenCLVersion,
      OpenCLCPlusPlus,
      OpenCLCPlusPlusVersion,
      NativeHalfType,
      NativeHalfArgsAndReturns,
      HalfArgsAndReturns,
      CUDA,
      HIP,
      OpenMP,
      OpenMPSimd,
      OpenMPUseTLS,
      OpenMPIsDevice,
      OpenMPCUDAMode,
      OpenMPHostCXXExceptions,
      RenderScript,
      CUDAIsDevice,
      CUDAAllowVariadicFunctions,
      CUDAHostDeviceConstexpr,
      CUDADeviceApproxTranscendentals,
      CUDARelocatableDeviceCode,
      SizedDeallocation,
      AlignedAllocation,
      AlignedAllocationUnavailable,
      NewAlignOverride,
      ConceptsTS,
      Reflection,
      ModulesCodegen,
      ModulesDebugInfo,
      ElideConstructors,
      DumpRecordLayouts,
      DumpRecordLayoutsSimple,
      DumpVTableLayouts,
      NoConstantCFStrings,
      InlineVisibilityHidden,
      ParseUnknownAnytype,
      DebuggerSupport,
      DebuggerCastResultToId,
      DebuggerObjCLiteral,
      SpellChecking,
      SinglePrecisionConstants,
      FastRelaxedMath,
      NoBitFieldTypeAlign,
      HexagonQdsp6Compat,
      ObjCAutoRefCount,
      ObjCWeakRuntime,
      ObjCWeak,
      ObjCSubscriptingLegacyRuntime,
      CFProtectionBranch,
      FakeAddressSpaceMap,
      IncludeDefaultHeader,
      DelayedTemplateParsing,
      BlocksRuntimeOptional,
      CompleteMemberPointers,
      ArrowDepth,
      InstantiationDepth,
      ConstexprCallDepth,
      ConstexprStepLimit,
      BracketDepth,
      NumLargeByValueCopy,
      MSCompatibilityVersion,
      VtorDispMode,
      ApplePragmaPack,
      RetainCommentsFromSystemHeaders,
      SanitizeAddressFieldPadding,
      XRayInstrument,
      XRayAlwaysEmitCustomEvents,
      XRayAlwaysEmitTypedEvents,
      ForceEmitVTables,
      AllowEditorPlaceholders,
      FunctionAlignment,
      FixedPoint,
      PaddingOnUnsignedFixedPoint,
    };
    static const unsigned _total_num_mems_ = PaddingOnUnsignedFixedPoint + 1;
  }
  namespace clang__LangOptions {
    enum memnames {
      Sanitize,
      ObjCRuntime,
      CommentOpts,
      IsHeaderFile,
      getCompilingModule,
      getMSPointerToMemberRepresentationMethod,
      getDefaultCallingConv,
      getDefaultFPContractMode,
      getAddressSpaceMapMangling,
      getGC,
      getValueVisibilityMode,
      getTypeVisibilityMode,
      getStackProtector,
      getSignedOverflowBehavior,
      getClangABICompat,
      isCompilingModule,
      trackLocalOwningModule,
      isSignedOverflowDefined,
      isSubscriptPointerArithmetic,
      isCompatibleWithMSVC,
      isNoBuiltinFunc,
      allowsNonTrivialObjCLifetimeQualifiers,
      assumeFunctionsAreConvergent,
      getOpenCLVersionTuple,
    };
    static const unsigned _total_num_mems_ = getOpenCLVersionTuple + 1;
  }
  namespace clang__FPOptions {
    enum memnames {
      allowFPContractWithinStatement,
      allowFPContractAcrossStatement,
      getInt,
    };
    static const unsigned _total_num_mems_ = getInt + 1;
  }
  namespace clang__PrinterHelper {
    enum memnames {
    };
    static const unsigned _total_num_mems_ = 0;
  }
  namespace clang__PrintingPolicy {
    enum memnames {
      Indentation,
      SuppressSpecifiers,
      SuppressTagKeyword,
      IncludeTagDefinition,
      SuppressScope,
      SuppressUnwrittenScope,
      SuppressInitializers,
      ConstantArraySizeAsWritten,
      AnonymousTagLocations,
      SuppressStrongLifetime,
      SuppressLifetimeQualifiers,
      SuppressTemplateArgsInCXXConstructors,
      Bool,
      Restrict,
      Alignof,
      UnderscoreAlignof,
      UseVoidForZeroParams,
      TerseOutput,
      PolishForDeclaration,
      Half,
      MSWChar,
      IncludeNewlines,
      MSVCFormatting,
      ConstantsAsWritten,
      SuppressImplicitBase,
      FullyQualifiedName,
    };
    static const unsigned _total_num_mems_ = FullyQualifiedName + 1;
  }
  namespace clang__SrcMgr__ContentCache {
    enum memnames {
      OrigEntry,
      ContentsEntry,
      SourceLineCache,
      NumLines,
      BufferOverridden,
      IsSystemFile,
      IsTransient,
      getBuffer,
      getSize,
      getSizeBytesMapped,
      getMemoryBufferKind,
      getRawBuffer,
      isBufferInvalid,
      shouldFreeBuffer,
    };
    static const unsigned _total_num_mems_ = shouldFreeBuffer + 1;
  }
  namespace clang__SrcMgr__FileInfo {
    enum memnames {
      get,
      getIncludeLoc,
      getContentCache,
      getFileCharacteristic,
      hasLineDirectives,
    };
    static const unsigned _total_num_mems_ = hasLineDirectives + 1;
  }
  namespace clang__SrcMgr__ExpansionInfo {
    enum memnames {
      getSpellingLoc,
      getExpansionLocStart,
      getExpansionLocEnd,
      isExpansionTokenRange,
      getExpansionLocRange,
      isMacroArgExpansion,
      isMacroBodyExpansion,
      isFunctionMacroExpansion,
      create,
      createForMacroArg,
      createForTokenSplit,
    };
    static const unsigned _total_num_mems_ = createForTokenSplit + 1;
  }
  namespace clang__SrcMgr__SLocEntry {
    enum memnames {
      getOffset,
      isExpansion,
      isFile,
      getFile,
      getExpansion,
      get,
      get1,
    };
    static const unsigned _total_num_mems_ = get1 + 1;
  }
  namespace clang__SourceManager {
    enum memnames {
      Retain,
      Release,
      getDiagnostics,
      getFileManager,
      userFilesAreVolatile,
      getMainFileID,
      getPreambleFileID,
      isFileOverridden,
      getBuffer,
      getBuffer1,
      getFileEntryForID,
      getFileEntryForSLocEntry,
      getBufferData,
      getNumCreatedFIDsForFileID,
      setNumCreatedFIDsForFileID,
      getFileID,
      getFilename,
      getLocForStartOfFile,
      getLocForEndOfFile,
      getIncludeLoc,
      getExpansionLoc,
      getFileLoc,
      getImmediateExpansionRange,
      getExpansionRange,
      getExpansionRange1,
      getExpansionRange2,
      getSpellingLoc,
      getImmediateSpellingLoc,
      getComposedLoc,
      getFileOffset,
      isMacroArgExpansion,
      isMacroBodyExpansion,
      isAtStartOfImmediateMacroExpansion,
      isAtEndOfImmediateMacroExpansion,
      isInSLocAddrSpace,
      isInSameSLocAddrSpace,
      getCharacterData,
      getColumnNumber,
      getSpellingColumnNumber,
      getExpansionColumnNumber,
      getPresumedColumnNumber,
      getLineNumber,
      getSpellingLineNumber,
      getExpansionLineNumber,
      getPresumedLineNumber,
      getBufferName,
      getFileCharacteristic,
      getPresumedLoc,
      isInMainFile,
      isWrittenInSameFile,
      isWrittenInMainFile,
      isInSystemHeader,
      isInExternCSystemHeader,
      isInSystemMacro,
      getFileIDSize,
      isInFileID,
      hasLineTable,
      getContentCacheSize,
      getDataStructureSizes,
      translateFileLineCol,
      translateFile,
      translateLineCol,
      getMacroArgExpandedLocation,
      isBeforeInTranslationUnit,
      isBeforeInSLocAddrSpace,
      isBeforeInSLocAddrSpace1,
      isPointWithin,
      hasFileInfo,
      PrintStats,
      dump,
      local_sloc_entry_size,
      getLocalSLocEntry,
      loaded_sloc_entry_size,
      getLoadedSLocEntry,
      getSLocEntry,
      getNextLocalOffset,
      isLoadedSourceLocation,
      isLocalSourceLocation,
      isLoadedFileID,
      isLocalFileID,
      getImmediateMacroCallerLoc,
      getTopMacroCallerLoc,
    };
    static const unsigned _total_num_mems_ = getTopMacroCallerLoc + 1;
  }
  namespace clang__RawComment {
    enum memnames {
      getKind,
      isInvalid,
      isMerged,
      isAttached,
      isTrailingComment,
      isAlmostTrailingComment,
      isOrdinary,
      isDocumentation,
      getRawText,
      getSourceRange,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getBriefText,
      getFormattedText,
    };
    static const unsigned _total_num_mems_ = getFormattedText + 1;
  }
  namespace clang__SanitizerBlacklist {
    enum memnames {
      isBlacklistedGlobal,
      isBlacklistedType,
      isBlacklistedFunction,
      isBlacklistedFile,
      isBlacklistedLocation,
    };
    static const unsigned _total_num_mems_ = isBlacklistedLocation + 1;
  }
  namespace clang__TargetCXXABI {
    enum memnames {
      getKind,
      isItaniumFamily,
      isMicrosoft,
      areMemberFunctionsAligned,
      areArgsDestroyedLeftToRightInCallee,
      hasConstructorVariants,
      hasPrimaryVBases,
      hasKeyFunctions,
      canKeyFunctionBeInline,
      getTailPaddingUseRules,
      operator_eq_eq,
      operator_not_eq,
    };
    static const unsigned _total_num_mems_ = operator_not_eq + 1;
  }
  namespace clang__OpenCLOptions {
    enum memnames {
      isKnown,
      isEnabled,
      isSupported,
      isSupportedCore,
      isSupportedExtension,
    };
    static const unsigned _total_num_mems_ = isSupportedExtension + 1;
  }
  namespace clang__TargetOptions {
    enum memnames {
      EABIVersion,
      SupportedOpenCLOptions,
      ForceEnableInt128,
      NVPTXUseShortPointers,
    };
    static const unsigned _total_num_mems_ = NVPTXUseShortPointers + 1;
  }
  namespace llvm__Type {
    enum memnames {
      print,
      dump,
      getTypeID,
      isVoidTy,
      isHalfTy,
      isFloatTy,
      isDoubleTy,
      isX86_FP80Ty,
      isFP128Ty,
      isPPC_FP128Ty,
      isFloatingPointTy,
      isX86_MMXTy,
      isFPOrFPVectorTy,
      isLabelTy,
      isMetadataTy,
      isTokenTy,
      isIntegerTy,
      isIntegerTy1,
      isIntOrIntVectorTy,
      isIntOrIntVectorTy1,
      isIntOrPtrTy,
      isFunctionTy,
      isStructTy,
      isArrayTy,
      isPointerTy,
      isPtrOrPtrVectorTy,
      isVectorTy,
      canLosslesslyBitCastTo,
      isEmptyTy,
      isFirstClassType,
      isSingleValueType,
      isAggregateType,
      getPrimitiveSizeInBits,
      getScalarSizeInBits,
      getFPMantissaWidth,
      getScalarType,
      subtypes,
      getContainedType,
      getNumContainedTypes,
      getIntegerBitWidth,
      getFunctionParamType,
      getFunctionNumParams,
      isFunctionVarArg,
      getStructName,
      getStructNumElements,
      getStructElementType,
      getSequentialElementType,
      getArrayNumElements,
      getArrayElementType,
      getVectorNumElements,
      getVectorElementType,
      getPointerElementType,
      getPointerAddressSpace,
      getPointerTo,
    };
    static const unsigned _total_num_mems_ = getPointerTo + 1;
  }
  namespace llvm__IntegerType {
    enum memnames {
      getBitWidth,
      getBitMask,
      getSignBit,
      isPowerOf2ByteWidth,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace llvm__CompositeType {
    enum memnames {
      getTypeAtIndex,
      indexValid,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace llvm__StructType {
    enum memnames {
      isPacked,
      isLiteral,
      isOpaque,
      hasName,
      getName,
      isValidElementType,
      elements,
      isLayoutIdentical,
      getNumElements,
      getElementType,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace llvm__PointerType {
    enum memnames {
      get,
      getUnqual,
      getElementType,
      isValidElementType,
      isLoadableOrStorableType,
      getAddressSpace,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace llvm__DataLayout {
    enum memnames {
      operator_eq_eq,
      operator_not_eq,
      isLittleEndian,
      isBigEndian,
      isDefault,
      isLegalInteger,
      isIllegalInteger,
      exceedsNaturalStackAlignment,
      getStackAlignment,
      getAllocaAddrSpace,
      getProgramAddressSpace,
      hasMicrosoftFastStdCallMangling,
      doNotMangleLeadingQuestionMark,
      hasLinkerPrivateGlobalPrefix,
      getLinkerPrivateGlobalPrefix,
      getGlobalPrefix,
      getPrivateGlobalPrefix,
      getManglingComponent,
      fitsInLegalInteger,
      getPointerABIAlignment,
      getPointerPrefAlignment,
      getPointerSize,
      getIndexSize,
      getNonIntegralAddressSpaces,
      isNonIntegralPointerType,
      isNonIntegralPointerType1,
      getPointerSizeInBits,
      getIndexSizeInBits,
      getPointerTypeSizeInBits,
      getIndexTypeSizeInBits,
      getPointerTypeSize,
      getTypeSizeInBits,
      getTypeStoreSize,
      getTypeStoreSizeInBits,
      getTypeAllocSize,
      getTypeAllocSizeInBits,
      getABITypeAlignment,
      getABIIntegerTypeAlignment,
      getPrefTypeAlignment,
      getPreferredTypeAlignmentShift,
      getIntPtrType,
      getLargestLegalIntTypeSizeInBits,
      getIndexType,
      getStructLayout,
    };
    static const unsigned _total_num_mems_ = getStructLayout + 1;
  }
  namespace llvm__StructLayout {
    enum memnames {
      getSizeInBytes,
      getSizeInBits,
      getAlignment,
      hasPadding,
      getElementContainingOffset,
      getElementOffset,
      getElementOffsetInBits,
    };
    static const unsigned _total_num_mems_ = getElementOffsetInBits + 1;
  }
  namespace clang__TargetInfo {
    enum memnames {
      Retain,
      Release,
      getTargetOpts,
      getSizeType,
      getSignedSizeType,
      getIntMaxType,
      getUIntMaxType,
      getPtrDiffType,
      getUnsignedPtrDiffType,
      getIntPtrType,
      getUIntPtrType,
      getWCharType,
      getWIntType,
      getChar16Type,
      getChar32Type,
      getInt64Type,
      getUInt64Type,
      getSigAtomicType,
      getProcessIDType,
      getCorrespondingUnsignedType,
      getTypeWidth,
      getIntTypeByWidth,
      getLeastIntTypeByWidth,
      getRealTypeByWidth,
      getTypeAlign,
      isTypeSigned,
      getPointerWidth,
      getPointerAlign,
      getMaxPointerWidth,
      getNullPointerValue,
      getBoolWidth,
      getBoolAlign,
      getCharWidth,
      getCharAlign,
      getShortWidth,
      getShortAlign,
      getIntWidth,
      getIntAlign,
      getLongWidth,
      getLongAlign,
      getLongLongWidth,
      getLongLongAlign,
      getShortAccumWidth,
      getShortAccumAlign,
      getAccumWidth,
      getAccumAlign,
      getLongAccumWidth,
      getLongAccumAlign,
      getShortFractWidth,
      getShortFractAlign,
      getFractWidth,
      getFractAlign,
      getLongFractWidth,
      getLongFractAlign,
      getShortAccumScale,
      getShortAccumIBits,
      getAccumScale,
      getAccumIBits,
      getLongAccumScale,
      getLongAccumIBits,
      getUnsignedShortAccumScale,
      getUnsignedShortAccumIBits,
      getUnsignedAccumScale,
      getUnsignedAccumIBits,
      getUnsignedLongAccumScale,
      getUnsignedLongAccumIBits,
      getShortFractScale,
      getFractScale,
      getLongFractScale,
      getUnsignedShortFractScale,
      getUnsignedFractScale,
      getUnsignedLongFractScale,
      hasInt128Type,
      hasLegalHalfType,
      hasFloat128Type,
      getSuitableAlign,
      getDefaultAlignForAttributeAligned,
      getMinGlobalAlign,
      getNewAlign,
      getWCharWidth,
      getWCharAlign,
      getChar16Width,
      getChar16Align,
      getChar32Width,
      getChar32Align,
      getHalfWidth,
      getHalfAlign,
      getFloatWidth,
      getFloatAlign,
      getDoubleWidth,
      getDoubleAlign,
      getLongDoubleWidth,
      getLongDoubleAlign,
      getFloat128Width,
      getFloat128Align,
      useFloat128ManglingForLongDouble,
      getFloatEvalMethod,
      getLargeArrayMinWidth,
      getLargeArrayAlign,
      getMaxAtomicPromoteWidth,
      getMaxAtomicInlineWidth,
      hasBuiltinAtomic,
      getMaxVectorAlign,
      getSimdDefaultAlign,
      getIntMaxTWidth,
      getUnwindWordWidth,
      getRegisterWidth,
      getMCountName,
      useSignedCharForObjCBool,
      useBitFieldTypeAlignment,
      useZeroLengthBitfieldAlignment,
      getZeroLengthBitfieldBoundary,
      useExplicitBitFieldAlignment,
      hasAlignMac68kSupport,
      getTypeName,
      getTypeConstantSuffix,
      getTypeFormatModifier,
      useObjCFPRetForRealType,
      useObjCFP2RetForComplexLongDouble,
      useFP16ConversionIntrinsics,
      useAddressSpaceMapMangling,
      isCLZForZeroUndef,
      getBuiltinVaListKind,
      hasBuiltinMSVaList,
      isRenderScriptTarget,
      isValidClobber,
      isValidGCCRegisterName,
      getNormalizedGCCRegisterName,
      getConstraintRegister,
      validateOutputConstraint,
      validateOutputSize,
      validateInputSize,
      getClobbers,
      isNan2008,
      getTriple,
      getDataLayout,
      hasProtectedVisibility,
      isValidSectionSpecifier,
      getABI,
      getCXXABI,
      isValidCPUName,
      isValidFeatureName,
      hasFeature,
      supportsMultiVersioning,
      validateCpuSupports,
      multiVersionSortPriority,
      validateCpuIs,
      validateCPUSpecificCPUDispatch,
      CPUSpecificManglingCharacter,
      getRegParmMax,
      isTLSSupported,
      getMaxTLSAlign,
      isVLASupported,
      isSEHTrySupported,
      hasNoAsmVariants,
      getEHDataRegisterNumber,
      getStaticInitSectionSpecifier,
      getPlatformName,
      getPlatformMinVersion,
      isBigEndian,
      isLittleEndian,
      getDefaultCallingConv,
      checkCallingConvention,
      getCallingConvKind,
      hasSjLjLowering,
      checkCFProtectionBranchSupported,
      checkCFProtectionReturnSupported,
      allowsLargerPreferedTypeAlignment,
      getSupportedOpenCLOpts,
      getOpenCLTypeAddrSpace,
      getVtblPtrAddressSpace,
      validateTarget,
    };
    static const unsigned _total_num_mems_ = validateTarget + 1;
  }
  namespace clang__TargetInfo__ConstraintInfo {
    enum memnames {
      Flags,
      TiedOperand,
      isReadWrite,
      allowsRegister,
      allowsMemory,
      hasMatchingInput,
      hasTiedOperand,
      getTiedOperand,
      requiresImmediateConstant,
      isValidAsmImmediate,
    };
    static const unsigned _total_num_mems_ = isValidAsmImmediate + 1;
  }
  namespace clang__XRayFunctionFilter {
    enum memnames {
      shouldImbueFunction,
      shouldImbueFunctionsInFile,
      shouldImbueLocation,
    };
    static const unsigned _total_num_mems_ = shouldImbueLocation + 1;
  }
  namespace clang__TypeInfo {
    enum memnames {
      Width,
      Align,
      AlignIsRequired,
    };
    static const unsigned _total_num_mems_ = AlignIsRequired + 1;
  }
  namespace clang__ASTContext {
    enum memnames {
      Retain,
      Release,
      Idents,
      Selectors,
      getPrintingPolicy,
      getSourceManager,
      Allocate,
      Deallocate,
      getASTAllocatedMemory,
      getSideTableAllocatedMemory,
      getTargetInfo,
      getAuxTargetInfo,
      getIntTypeForBitwidth,
      getRealTypeForBitwidth,
      AtomicUsesUnsupportedLibcall,
      getLangOpts,
      getSanitizerBlacklist,
      getXRayFilter,
      getDiagnostics,
      getFullLoc,
      CommentsLoaded,
      getRawCommentForDeclNoCache,
      getRawCommentForAnyRedecl,
      getCommentCommandTraits,
      overridden_methods_size,
      getNextLocalImport,
      local_imports,
      getTranslationUnitDecl,
      getExternCContextDecl,
      getMakeIntegerSeqDecl,
      getTypePackElementDecl,
      AutoDeductTy,
      AutoRRefDeductTy,
      VaListTagDecl,
      getExternalSource,
      PrintStats,
      getInt128Decl,
      getUInt128Decl,
      getAddrSpaceQualType,
      removeAddrSpaceQualType,
      getObjCGCQualType,
      getRestrictType,
      getVolatileType,
      getConstType,
      getComplexType,
      getPointerType,
      getAdjustedType,
      getDecayedType,
      getAtomicType,
      getBlockPointerType,
      getBlockDescriptorType,
      getReadPipeType,
      getWritePipeType,
      getBlockDescriptorExtendedType,
      getOpenCLTypeKind,
      getOpenCLTypeAddrSpace,
      getLValueReferenceType,
      getRValueReferenceType,
      getMemberPointerType,
      getVariableArrayType,
      getDependentSizedArrayType,
      getIncompleteArrayType,
      getConstantArrayType,
      getVariableArrayDecayedType,
      getVectorType,
      getDependentVectorType,
      getExtVectorType,
      getDependentSizedExtVectorType,
      getDependentAddressSpaceType,
      getFunctionNoProtoType,
      getFunctionNoProtoType1,
      adjustStringLiteralBaseType,
      getTypeDeclType,
      getTypedefType,
      getRecordType,
      getEnumType,
      getInjectedClassNameType,
      getSubstTemplateTypeParmType,
      getTemplateTypeParmType,
      getTemplateSpecializationType,
      getTemplateSpecializationTypeInfo,
      getParenType,
      getElaboratedType,
      getDependentNameType,
      getDependentTemplateSpecializationType,
      getObjCInterfaceType,
      getObjCObjectType,
      getObjCObjectPointerType,
      getTypeOfExprType,
      getTypeOfType,
      getDecltypeType,
      getReflectedType,
      getUnaryTransformType,
      getAutoType,
      getAutoDeductType,
      getAutoRRefDeductType,
      getDeducedTemplateSpecializationType,
      getTagDeclType,
      getWCharType,
      getWideCharType,
      getSignedWCharType,
      getUnsignedWCharType,
      getWIntType,
      getIntPtrType,
      getUIntPtrType,
      getPointerDiffType,
      getUnsignedPointerDiffType,
      getProcessIDType,
      getCFConstantStringType,
      getObjCSuperType,
      getRawCFConstantStringType,
      getCFConstantStringDecl,
      getCFConstantStringTagDecl,
      getObjCConstantStringInterface,
      getObjCNSStringType,
      getObjCIdRedefinitionType,
      getObjCClassRedefinitionType,
      getObjCSelRedefinitionType,
      getBoolName,
      getMakeIntegerSeqName,
      getTypePackElementName,
      getFILEType,
      getjmp_bufType,
      getsigjmp_bufType,
      getucontext_tType,
      getLogicalOperationType,
      getLegacyIntegralTypeEncoding,
      getObjCEncodingForFunctionDecl,
      getObjCEncodingForMethodDecl,
      getObjCEncodingForBlock,
      getObjCEncodingForPropertyDecl,
      ProtocolCompatibleWithProtocol,
      getObjCPropertyImplDeclForPropertyDecl,
      getObjCEncodingTypeSize,
      getObjCIdDecl,
      getObjCIdType,
      getObjCSelDecl,
      getObjCSelType,
      getObjCClassDecl,
      getObjCClassType,
      getObjCProtocolDecl,
      getBOOLDecl,
      getBOOLType,
      getObjCProtoType,
      getBuiltinVaListDecl,
      getBuiltinVaListType,
      getVaListTagDecl,
      getBuiltinMSVaListDecl,
      getBuiltinMSVaListType,
      canBuiltinBeRedeclared,
      getCVRQualifiedType,
      getQualifiedType,
      getQualifiedType1,
      getQualifiedType2,
      getUnqualifiedObjCPointerType,
      getFixedPointScale,
      getFixedPointIBits,
      getNameForTemplate,
      getOverloadedTemplateName,
      getQualifiedTemplateName,
      getDependentTemplateName,
      getDependentTemplateName1,
      getSubstTemplateTemplateParm,
      getSubstTemplateTemplateParmPack,
      getObjCGCAttrKind,
      isObjCNSObjectType,
      getTypeInfo,
      getTypeInfo1,
      getOpenMPDefaultSimdAlign,
      getTypeSize,
      getTypeSize1,
      getCharWidth,
      toCharUnitsFromBits,
      toBits,
      getTypeSizeInChars,
      getTypeSizeInChars1,
      getTypeAlign,
      getTypeAlign1,
      getTypeUnadjustedAlign,
      getTypeUnadjustedAlign1,
      getTypeAlignIfKnown,
      getTypeAlignInChars,
      getTypeAlignInChars1,
      getTypeUnadjustedAlignInChars,
      getTypeUnadjustedAlignInChars1,
      isAlignmentRequired,
      isAlignmentRequired1,
      getPreferredTypeAlign,
      getTargetDefaultAlignForAttributeAligned,
      getAlignOfGlobalVar,
      getAlignOfGlobalVarInChars,
      getDeclAlign,
      DumpRecordLayout,
      getOffsetOfBaseWithVBPtr,
      getFieldOffset,
      lookupFieldBitOffset,
      isNearlyEmpty,
      CountNonClassIvars,
      hasUniqueObjectRepresentations,
      getCanonicalType,
      hasSameType,
      hasSameType1,
      hasSameUnqualifiedType,
      hasSameNullabilityTypeQualifier,
      getCanonicalNestedNameSpecifier,
      getDefaultCallingConvention,
      getCanonicalTemplateName,
      getCanonicalTemplateArgument,
      getAsArrayType,
      getAsConstantArrayType,
      getAsVariableArrayType,
      getAsIncompleteArrayType,
      getAsDependentSizedArrayType,
      getBaseElementType,
      getBaseElementType1,
      getConstantArrayElementCount,
      getAdjustedParameterType,
      getSignatureParameterType,
      getExceptionObjectType,
      getArrayDecayedType,
      getPromotedIntegerType,
      getInnerObjCOwnership,
      isPromotableBitField,
      getIntegerTypeOrder,
      getFloatingTypeOrder,
      getFloatingTypeOfSizeWithinDomain,
      getTargetAddressSpace,
      getTargetAddressSpace1,
      getTargetAddressSpace2,
      getTargetNullPointerValue,
      addressSpaceMapManglingFor,
      isObjCIdType,
      isObjCClassType,
      isObjCSelType,
      getIntWidth,
      getCorrespondingUnsignedType,
      getCorrespondingSaturatedType,
      MakeIntValue,
      getObjCMethodRedeclaration,
      getObjContainingInterface,
      CreateTypeSourceInfo,
      getTrivialTypeSourceInfo,
      GetGVALinkageForFunction,
      getManglingNumber,
      getStaticLocalNumber,
      getParameterIndex,
      isMSStaticDataMemberInlineDefinition,
      getInlineVariableDefinitionKind,
    };
    static const unsigned _total_num_mems_ = getInlineVariableDefinitionKind + 1;
  }
  namespace clang__DeclAccessPair {
    enum memnames {
      make,
      getDecl,
      getAccess,
      operator_arrow,
    };
    static const unsigned _total_num_mems_ = operator_arrow + 1;
  }
  namespace clang__UnresolvedSetIterator {
    enum memnames {
      operator_plus,
      operator_plus1,
      operator_minus,
      operator_not_eq,
      operator_gr,
      operator_less_eq,
      operator_gr_eq,
      operator_arrow,
      operator_minus1,
      operator_eq_eq,
      operator_less,
      operator_star,
      getDecl,
      setDecl,
      getAccess,
      getPair,
    };
    static const unsigned _total_num_mems_ = getPair + 1;
  }
  namespace clang__UnresolvedSetImpl {
    enum memnames {
      _this_,
      empty,
      size,
      operator_sub,
    };
    static const unsigned _total_num_mems_ = operator_sub + 1;
  }
  namespace clang__Expr {
    enum memnames {
      getType,
      isValueDependent,
      isTypeDependent,
      isInstantiationDependent,
      containsUnexpandedParameterPack,
      getExprLoc,
      isUnusedResultAWarning,
      isLValue,
      isRValue,
      isXValue,
      isGLValue,
      ClassifyLValue,
      isModifiableLvalue,
      Classify,
      ClassifyModifiable,
      getValueKindForType,
      getValueKind,
      getObjectKind,
      isOrdinaryOrBitFieldObject,
      refersToBitField,
      getSourceBitField,
      getReferencedDeclOfCallee,
      getObjCProperty,
      isObjCSelfExpr,
      refersToVectorElement,
      refersToGlobalRegisterVar,
      hasPlaceholderType,
      hasPlaceholderType1,
      isKnownToHaveBooleanValue,
      isIntegerConstantExpr,
      isIntegerConstantExpr1,
      isCXX98IntegralConstantExpr,
      isCXX11ConstantExpr,
      isConstantInitializer,
      EvaluateAsRValue,
      EvaluateAsInt,
      EvaluateAsString,
      EvaluateAsVoid,
      EvaluateAsFloat,
      isEvaluatable,
      HasSideEffects,
      hasNonTrivialCall,
      EvaluateForOverflow,
      EvaluateAsLValue,
      EvaluateAsConstantExpr,
      isNullPointerConstant,
      isOBJCGCCandidate,
      isBoundMemberFunction,
      findBoundMemberType,
      IgnoreImplicit,
      IgnoreConversionOperator,
      IgnoreParenImpCasts,
      IgnoreParenLValueCasts,
      ignoreParenBaseCasts,
      isDefaultArgument,
      isTemporaryObject,
      isImplicitCXXThis,
      IgnoreImpCasts,
      IgnoreParens,
      IgnoreParenCasts,
      IgnoreCasts,
      IgnoreParenNoopCasts,
      getBestDynamicClassType,
      getBestDynamicClassTypeExpr,
      skipRValueSubobjectAdjustments,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__Expr__Classification {
    enum memnames {
      getKind,
      getModifiable,
      isLValue,
      isXValue,
      isGLValue,
      isPRValue,
      isRValue,
      isModifiable,
      makeSimpleLValue,
    };
    static const unsigned _total_num_mems_ = makeSimpleLValue + 1;
  }
  namespace clang__Expr__EvalStatus {
    enum memnames {
      HasSideEffects,
      HasUndefinedBehavior,
      hasSideEffects,
    };
    static const unsigned _total_num_mems_ = hasSideEffects + 1;
  }
  namespace clang__Expr__EvalResult {
    enum memnames {
      isGlobalLValue,
    };
    static const unsigned _total_num_mems_ = isGlobalLValue + 1;
  }
  namespace clang__OpaqueValueExpr {
    enum memnames {
      findInCopyConstruct,
      getLocation,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getExprLoc,
      children,
      getSourceExpr,
      isUnique,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__DeclRefExpr {
    enum memnames {
      Create,
      Create1,
      CreateEmpty,
      getDecl,
      getNameInfo,
      getLocation,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      hasQualifier,
      getQualifierLoc,
      getQualifier,
      getFoundDecl,
      hasTemplateKWAndArgsInfo,
      getTemplateKeywordLoc,
      getLAngleLoc,
      getRAngleLoc,
      hasTemplateKeyword,
      hasExplicitTemplateArgs,
      copyTemplateArgumentsInto,
      getTemplateArgs,
      getNumTemplateArgs,
      template_arguments,
      hadMultipleCandidates,
      refersToEnclosingVariableOrCapture,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__PredefinedExpr {
    enum memnames {
      getIdentType,
      getLocation,
      getFunctionName,
      getIdentTypeName,
      ComputeName,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__APIntStorage {
    enum memnames {
    };
    static const unsigned _total_num_mems_ = 0;
  }
  namespace clang__IntegerLiteral {
    enum memnames {
      Create,
      Create1,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getLocation,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__FixedPointLiteral {
    enum memnames {
      CreateFromRawInt,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getLocation,
      classof,
      getValueAsString,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__CharacterLiteral {
    enum memnames {
      getLocation,
      getKind,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getValue,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__FloatingLiteral {
    enum memnames {
      Create,
      Create1,
      isExact,
      getValueAsApproximateDouble,
      getLocation,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__ImaginaryLiteral {
    enum memnames {
      getSubExpr,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__StringLiteral {
    enum memnames {
      CreateEmpty,
      getString,
      getBytes,
      outputString,
      getCodeUnit,
      getByteLength,
      getLength,
      getCharByteWidth,
      getKind,
      isAscii,
      isWide,
      isUTF8,
      isUTF16,
      isUTF32,
      isPascal,
      containsNonAscii,
      containsNonAsciiOrNull,
      getNumConcatenated,
      getStrTokenLoc,
      getLocationOfByte,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__ParenExpr {
    enum memnames {
      getSubExpr,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getLParen,
      getRParen,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__UnaryOperator {
    enum memnames {
      getOpcode,
      getSubExpr,
      getOperatorLoc,
      canOverflow,
      isPostfix,
      isPrefix,
      isPrefix1,
      isPostfix1,
      isIncrementOp,
      isIncrementOp1,
      isDecrementOp,
      isDecrementOp1,
      isIncrementDecrementOp,
      isIncrementDecrementOp1,
      isArithmeticOp,
      isArithmeticOp1,
      getOpcodeStr,
      getOverloadedOpcode,
      getOverloadedOperator,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getExprLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__OffsetOfNode {
    enum memnames {
      getKind,
      getArrayExprIndex,
      getField,
      getFieldName,
      getBase,
      getSourceRange,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
    };
    static const unsigned _total_num_mems_ = getEndLoc + 1;
  }
  namespace clang__OffsetOfExpr {
    enum memnames {
      CreateEmpty,
      getOperatorLoc,
      getRParenLoc,
      getTypeSourceInfo,
      getComponent,
      getNumComponents,
      getIndexExpr,
      getNumExpressions,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__UnaryExprOrTypeTraitExpr {
    enum memnames {
      getKind,
      isArgumentType,
      getArgumentType,
      getArgumentTypeInfo,
      getArgumentExpr,
      getTypeOfArgument,
      getOperatorLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__ArraySubscriptExpr {
    enum memnames {
      getLHS,
      getRHS,
      getBase,
      getIdx,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getRBracketLoc,
      getExprLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__CallExpr {
    enum memnames {
      getCallee,
      getCalleeDecl,
      getDirectCallee,
      getNumArgs,
      getArgs,
      getArg,
      arguments,
      getNumCommas,
      getBuiltinCallee,
      isUnevaluatedBuiltinCall,
      getCallReturnType,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      isBuiltinAssumeFalse,
      isCallToStdMove,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__MemberExpr {
    enum memnames {
      Create,
      getBase,
      getMemberDecl,
      getFoundDecl,
      hasQualifier,
      getQualifierLoc,
      getQualifier,
      getTemplateKeywordLoc,
      getLAngleLoc,
      getRAngleLoc,
      hasTemplateKeyword,
      hasExplicitTemplateArgs,
      copyTemplateArgumentsInto,
      getTemplateArgs,
      getNumTemplateArgs,
      template_arguments,
      getMemberNameInfo,
      getOperatorLoc,
      isArrow,
      getMemberLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getExprLoc,
      isImplicitAccess,
      hadMultipleCandidates,
      performsVirtualDispatch,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__CompoundLiteralExpr {
    enum memnames {
      getInitializer,
      isFileScope,
      getLParenLoc,
      getTypeSourceInfo,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__CastExpr {
    enum memnames {
      getCastKind,
      getCastKindName,
      getCastKindName1,
      getSubExpr,
      getSubExprAsWritten,
      getConversionFunction,
      path_empty,
      path_size,
      getTargetUnionField,
      getTargetFieldForToUnionCast,
      getTargetFieldForToUnionCast1,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__ImplicitCastExpr {
    enum memnames {
      isPartOfExplicitCast,
      CreateEmpty,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ExplicitCastExpr {
    enum memnames {
      getTypeInfoAsWritten,
      getTypeAsWritten,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CStyleCastExpr {
    enum memnames {
      CreateEmpty,
      getLParenLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__BinaryOperator {
    enum memnames {
      getExprLoc,
      getOperatorLoc,
      getOpcode,
      getLHS,
      getRHS,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getOpcodeStr,
      getOpcodeStr1,
      getOverloadedOpcode,
      getOverloadedOperator,
      isPtrMemOp,
      isMultiplicativeOp,
      isMultiplicativeOp1,
      isAdditiveOp,
      isAdditiveOp1,
      isShiftOp,
      isShiftOp1,
      isBitwiseOp,
      isBitwiseOp1,
      isRelationalOp,
      isRelationalOp1,
      isEqualityOp,
      isEqualityOp1,
      isComparisonOp,
      isComparisonOp1,
      negateComparisonOp,
      reverseComparisonOp,
      isLogicalOp,
      isLogicalOp1,
      isAssignmentOp,
      isAssignmentOp1,
      isCompoundAssignmentOp,
      isCompoundAssignmentOp1,
      getOpForCompoundAssignment,
      isShiftAssignOp,
      isShiftAssignOp1,
      isNullPointerArithmeticExtension,
      classof,
      children,
      getFPFeatures,
      isFPContractableWithinStatement,
    };
    static const unsigned _total_num_mems_ = isFPContractableWithinStatement + 1;
  }
  namespace clang__CompoundAssignOperator {
    enum memnames {
      getComputationLHSType,
      getComputationResultType,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__AbstractConditionalOperator {
    enum memnames {
      getCond,
      getTrueExpr,
      getFalseExpr,
      getQuestionLoc,
      getColonLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ConditionalOperator {
    enum memnames {
      getCond,
      getTrueExpr,
      getFalseExpr,
      getLHS,
      getRHS,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__BinaryConditionalOperator {
    enum memnames {
      getCommon,
      getOpaqueValue,
      getCond,
      getTrueExpr,
      getFalseExpr,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__AddrLabelExpr {
    enum memnames {
      getAmpAmpLoc,
      getLabelLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getLabel,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__StmtExpr {
    enum memnames {
      getSubStmt,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getLParenLoc,
      getRParenLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__ShuffleVectorExpr {
    enum memnames {
      getBuiltinLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      getNumSubExprs,
      getExpr,
      getShuffleMaskIdx,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__ConvertVectorExpr {
    enum memnames {
      getSrcExpr,
      getTypeSourceInfo,
      getBuiltinLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__ChooseExpr {
    enum memnames {
      isConditionTrue,
      isConditionDependent,
      getChosenSubExpr,
      getCond,
      getLHS,
      getRHS,
      getBuiltinLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__GNUNullExpr {
    enum memnames {
      getTokenLocation,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__VAArgExpr {
    enum memnames {
      getSubExpr,
      isMicrosoftABI,
      getWrittenTypeInfo,
      getBuiltinLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__InitListExpr {
    enum memnames {
      _this_,
      getNumInits,
      getInits,
      inits,
      getInit,
      getArrayFiller,
      hasArrayFiller,
      getInitializedFieldInUnion,
      isExplicit,
      isStringLiteralInit,
      isTransparent,
      isIdiomaticZeroInitializer,
      getLBraceLoc,
      getRBraceLoc,
      isSemanticForm,
      getSemanticForm,
      isSyntacticForm,
      getSyntacticForm,
      hadArrayRangeDesignator,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__DesignatedInitExpr {
    enum memnames {
      CreateEmpty,
      size,
      designators,
      getDesignator,
      getArrayIndex,
      getArrayRangeStart,
      getArrayRangeEnd,
      getEqualOrColonLoc,
      usesGNUSyntax,
      getInit,
      getNumSubExprs,
      getSubExpr,
      getDesignatorsSourceRange,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__DesignatedInitExpr__Designator {
    enum memnames {
      isFieldDesignator,
      isArrayDesignator,
      isArrayRangeDesignator,
      getFieldName,
      getField,
      getDotLoc,
      getFieldLoc,
      getLBracketLoc,
      getRBracketLoc,
      getEllipsisLoc,
      getFirstExprIndex,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
    };
    static const unsigned _total_num_mems_ = getSourceRange + 1;
  }
  namespace clang__NoInitExpr {
    enum memnames {
      classof,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__DesignatedInitUpdateExpr {
    enum memnames {
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      getBase,
      getUpdater,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__ArrayInitLoopExpr {
    enum memnames {
      getCommonExpr,
      getSubExpr,
      classof,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__ArrayInitIndexExpr {
    enum memnames {
      classof,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__ImplicitValueInitExpr {
    enum memnames {
      classof,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__ParenListExpr {
    enum memnames {
      getNumExprs,
      getExpr,
      getLParenLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__GenericSelectionExpr {
    enum memnames {
      getNumAssocs,
      getGenericLoc,
      getDefaultLoc,
      getRParenLoc,
      getAssocExpr,
      getAssocExprs,
      getAssocTypeSourceInfo,
      getAssocTypeSourceInfos,
      getAssocType,
      getControllingExpr,
      isResultDependent,
      getResultIndex,
      getResultExpr,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__ExtVectorElementExpr {
    enum memnames {
      getBase,
      getAccessor,
      getAccessorLoc,
      getNumElements,
      containsDuplicateElements,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      isArrow,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__BlockExpr {
    enum memnames {
      getBlockDecl,
      getCaretLocation,
      getBody,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getFunctionType,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__AsTypeExpr {
    enum memnames {
      getSrcExpr,
      getBuiltinLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__PseudoObjectExpr {
    enum memnames {
      Create,
      getSyntacticForm,
      getResultExprIndex,
      getResultExpr,
      getNumSemanticExprs,
      semantics,
      getSemanticExpr,
      getExprLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      children,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__AtomicExpr {
    enum memnames {
      getNumSubExprs,
      getPtr,
      getOrder,
      getScope,
      getVal1,
      getOrderFail,
      getVal2,
      getWeak,
      getValueType,
      getOp,
      getNumSubExprs1,
      getSubExprs,
      isVolatile,
      isCmpXChg,
      isOpenCL,
      getBuiltinLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      children,
    };
    static const unsigned _total_num_mems_ = children + 1;
  }
  namespace clang__TypoExpr {
    enum memnames {
      children,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__Attr {
    enum memnames {
      operator_new,
      operator_delete,
      getKind,
      getSpellingListIndex,
      getSpelling,
      getLocation,
      getRange,
      isInherited,
      isImplicit,
      isPackExpansion,
      clone,
      isLateParsed,
      printPretty,
    };
    static const unsigned _total_num_mems_ = printPretty + 1;
  }
  namespace clang__InheritableAttr {
    enum memnames {
      shouldInheritEvenIfAlreadyPresent,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ExternalSourceSymbolAttr {
    enum memnames {
      clone,
      printPretty,
      getSpelling,
      getLanguage,
      getLanguageLength,
      getDefinedIn,
      getDefinedInLength,
      getGeneratedDeclaration,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__MSInheritanceAttr {
    enum memnames {
      CreateImplicit,
      CreateImplicit1,
      clone,
      printPretty,
      getSpelling,
      getSemanticSpelling,
      getBestCase,
      hasVBPtrOffsetField,
      hasNVOffsetField,
      hasVBTableOffsetField,
      hasOnlyOneField,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__MSVtorDispAttr {
    enum memnames {
      CreateImplicit,
      clone,
      printPretty,
      getSpelling,
      getVdm,
      getVtorDispMode,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__LambdaCapture {
    enum memnames {
      getCaptureKind,
      capturesThis,
      capturesVariable,
      capturesVLAType,
      getCapturedVar,
      isImplicit,
      isExplicit,
      getLocation,
      isPackExpansion,
      getEllipsisLoc,
    };
    static const unsigned _total_num_mems_ = getEllipsisLoc + 1;
  }
  namespace clang__AccessSpecDecl {
    enum memnames {
      getAccessSpecifierLoc,
      getColonLoc,
      getSourceRange,
      Create,
      CreateDeserialized,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__CXXBaseSpecifier {
    enum memnames {
      getSourceRange,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getBaseTypeLoc,
      isVirtual,
      isBaseOfClass,
      isPackExpansion,
      getInheritConstructors,
      getEllipsisLoc,
      getAccessSpecifier,
      getAccessSpecifierAsWritten,
      getType,
      getTypeSourceInfo,
    };
    static const unsigned _total_num_mems_ = getTypeSourceInfo + 1;
  }
  namespace clang__CXXRecordDecl {
    enum memnames {
      getCanonicalDecl,
      getPreviousDecl,
      getMostRecentDecl,
      getMostRecentNonInjectedDecl,
      getDefinition,
      hasDefinition,
      Create,
      CreateLambda,
      CreateDeserialized,
      isDynamicClass,
      mayBeDynamicClass,
      mayBeNonDynamicClass,
      isParsingBaseSpecifiers,
      isInstantiation,
      getODRHash,
      getNumBases,
      bases,
      getNumVBases,
      vbases,
      hasAnyDependentBases,
      methods,
      ctors,
      friends,
      hasFriends,
      defaultedCopyConstructorIsDeleted,
      defaultedMoveConstructorIsDeleted,
      defaultedDestructorIsDeleted,
      hasSimpleCopyConstructor,
      hasSimpleMoveConstructor,
      hasSimpleMoveAssignment,
      hasSimpleDestructor,
      hasDefaultConstructor,
      needsImplicitDefaultConstructor,
      hasUserDeclaredConstructor,
      hasUserProvidedDefaultConstructor,
      hasUserDeclaredCopyConstructor,
      needsImplicitCopyConstructor,
      needsOverloadResolutionForCopyConstructor,
      implicitCopyConstructorHasConstParam,
      hasCopyConstructorWithConstParam,
      hasUserDeclaredMoveOperation,
      hasUserDeclaredMoveConstructor,
      hasMoveConstructor,
      needsImplicitMoveConstructor,
      needsOverloadResolutionForMoveConstructor,
      hasUserDeclaredCopyAssignment,
      needsImplicitCopyAssignment,
      needsOverloadResolutionForCopyAssignment,
      implicitCopyAssignmentHasConstParam,
      hasCopyAssignmentWithConstParam,
      hasUserDeclaredMoveAssignment,
      hasMoveAssignment,
      needsImplicitMoveAssignment,
      needsOverloadResolutionForMoveAssignment,
      hasUserDeclaredDestructor,
      needsImplicitDestructor,
      needsOverloadResolutionForDestructor,
      isLambda,
      isGenericLambda,
      getLambdaCallOperator,
      getLambdaStaticInvoker,
      getGenericLambdaTemplateParameterList,
      getLambdaCaptureDefault,
      captures,
      isAggregate,
      hasInClassInitializer,
      hasUninitializedReferenceMember,
      isPOD,
      isCLike,
      isEmpty,
      hasDirectFields,
      isPolymorphic,
      isAbstract,
      isStandardLayout,
      isCXX11StandardLayout,
      hasMutableFields,
      hasVariantMembers,
      hasTrivialDefaultConstructor,
      hasNonTrivialDefaultConstructor,
      hasConstexprNonCopyMoveConstructor,
      defaultedDefaultConstructorIsConstexpr,
      hasConstexprDefaultConstructor,
      hasTrivialCopyConstructor,
      hasTrivialCopyConstructorForCall,
      hasNonTrivialCopyConstructor,
      hasNonTrivialCopyConstructorForCall,
      hasTrivialMoveConstructor,
      hasTrivialMoveConstructorForCall,
      hasNonTrivialMoveConstructor,
      hasNonTrivialMoveConstructorForCall,
      hasTrivialCopyAssignment,
      hasNonTrivialCopyAssignment,
      hasTrivialMoveAssignment,
      hasNonTrivialMoveAssignment,
      hasTrivialDestructor,
      hasTrivialDestructorForCall,
      hasNonTrivialDestructor,
      hasNonTrivialDestructorForCall,
      allowConstDefaultInit,
      hasIrrelevantDestructor,
      hasNonLiteralTypeFieldsOrBases,
      hasInheritedConstructor,
      hasInheritedAssignment,
      isTriviallyCopyable,
      isTrivial,
      isLiteral,
      getInstantiatedFromMemberClass,
      getMemberSpecializationInfo,
      getDescribedClassTemplate,
      getTemplateSpecializationKind,
      getTemplateInstantiationPattern,
      getDestructor,
      isAnyDestructorNoReturn,
      isLocalClass,
      isCurrentInstantiation,
      isDerivedFrom,
      isVirtuallyDerivedFrom,
      isProvablyNotDerivedFrom,
      viewInheritance,
      MergeAccess,
      mayBeAbstract,
      getLambdaManglingNumber,
      getLambdaContextDecl,
      getMSInheritanceModel,
      calculateInheritanceModel,
      nullFieldOffsetIsZero,
      getMSVtorDispMode,
      isDependentLambda,
      getLambdaTypeInfo,
      isInterfaceLike,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__CXXDeductionGuideDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      isExplicit,
      isExplicitSpecified,
      getDeducedTemplate,
      isCopyDeductionCandidate,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__CXXMethodDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      isStatic,
      isInstance,
      isStaticOverloadedOperator,
      isConst,
      isVolatile,
      isVirtual,
      getDevirtualizedMethod,
      isUsualDeallocationFunction,
      isCopyAssignmentOperator,
      isMoveAssignmentOperator,
      getCanonicalDecl,
      getMostRecentDecl,
      isUserProvided,
      size_overridden_methods,
      getParent,
      getThisType,
      getTypeQualifiers,
      getRefQualifier,
      hasInlineBody,
      isLambdaStaticInvoker,
      getCorrespondingMethodInClass,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__CXXCtorInitializer {
    enum memnames {
      isBaseInitializer,
      isMemberInitializer,
      isAnyMemberInitializer,
      isIndirectMemberInitializer,
      isInClassMemberInitializer,
      isDelegatingInitializer,
      isPackExpansion,
      getEllipsisLoc,
      getBaseClassLoc,
      getBaseClass,
      isBaseVirtual,
      getTypeSourceInfo,
      getMember,
      getAnyMember,
      getIndirectMember,
      getMemberLocation,
      getSourceLocation,
      getSourceRange,
      isWritten,
      getSourceOrder,
      getLParenLoc,
      getRParenLoc,
      getInit,
    };
    static const unsigned _total_num_mems_ = getInit + 1;
  }
  namespace clang__InheritedConstructor {
    enum memnames {
      operator_bool,
      getShadowDecl,
      getConstructor,
    };
    static const unsigned _total_num_mems_ = getConstructor + 1;
  }
  namespace clang__CXXConstructorDecl {
    enum memnames {
      CreateDeserialized,
      Create,
      inits,
      getNumCtorInitializers,
      isExplicitSpecified,
      isExplicit,
      isDelegatingConstructor,
      getTargetConstructor,
      isDefaultConstructor,
      isCopyConstructor,
      isMoveConstructor,
      isCopyOrMoveConstructor,
      isConvertingConstructor,
      isSpecializationCopyingObject,
      isInheritingConstructor,
      getInheritedConstructor,
      getCanonicalDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__CXXDestructorDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getOperatorDelete,
      getOperatorDeleteThisArg,
      getCanonicalDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__CXXConversionDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      isExplicitSpecified,
      isExplicit,
      getConversionType,
      isLambdaToBlockPointerConversion,
      getCanonicalDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__LinkageSpecDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getLanguage,
      hasBraces,
      getExternLoc,
      getRBraceLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__UsingDirectiveDecl {
    enum memnames {
      getQualifierLoc,
      getQualifier,
      getNominatedNamespaceAsWritten,
      getNominatedNamespace,
      getCommonAncestor,
      getUsingLoc,
      getNamespaceKeyLocation,
      getIdentLocation,
      Create,
      CreateDeserialized,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__NamespaceAliasDecl {
    enum memnames {
      getPreviousDecl,
      getFirstDecl,
      getMostRecentDecl,
      Create,
      CreateDeserialized,
      getCanonicalDecl,
      getQualifierLoc,
      getQualifier,
      getNamespace,
      getAliasLoc,
      getNamespaceLoc,
      getTargetNameLoc,
      getAliasedNamespace,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__UsingShadowDecl {
    enum memnames {
      getPreviousDecl,
      getFirstDecl,
      getMostRecentDecl,
      Create,
      CreateDeserialized,
      getCanonicalDecl,
      getTargetDecl,
      getUsingDecl,
      getNextUsingShadowDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ConstructorUsingShadowDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getParent,
      getNominatedBaseClassShadowDecl,
      getConstructedBaseClassShadowDecl,
      getNominatedBaseClass,
      getConstructedBaseClass,
      constructsVirtualBase,
      getConstructor,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__UsingDecl {
    enum memnames {
      getFirstDecl,
      getUsingLoc,
      getQualifierLoc,
      getQualifier,
      getNameInfo,
      isAccessDeclaration,
      hasTypename,
      shadows,
      shadow_size,
      Create,
      CreateDeserialized,
      getSourceRange,
      getCanonicalDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__UsingPackDecl {
    enum memnames {
      getFirstDecl,
      getInstantiatedFromUsingDecl,
      expansions,
      CreateDeserialized,
      getSourceRange,
      getCanonicalDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__UnresolvedUsingValueDecl {
    enum memnames {
      getFirstDecl,
      getUsingLoc,
      isAccessDeclaration,
      getQualifierLoc,
      getQualifier,
      getNameInfo,
      isPackExpansion,
      getEllipsisLoc,
      Create,
      CreateDeserialized,
      getSourceRange,
      getCanonicalDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__UnresolvedUsingTypenameDecl {
    enum memnames {
      getFirstDecl,
      getUsingLoc,
      getTypenameLoc,
      getQualifierLoc,
      getQualifier,
      getNameInfo,
      isPackExpansion,
      getEllipsisLoc,
      Create,
      CreateDeserialized,
      getCanonicalDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__StaticAssertDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getAssertExpr,
      getMessage,
      isFailed,
      getRParenLoc,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__BindingDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getBinding,
      getHoldingVar,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__DecompositionDecl {
    enum memnames {
      CreateDeserialized,
      bindings,
      printName,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__MSPropertyDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      classof,
      hasGetter,
      getGetterId,
      hasSetter,
      getSetterId,
    };
    static const unsigned _total_num_mems_ = getSetterId + 1;
  }
  namespace clang__ConstexprDecl {
    enum memnames {
      getLambdaExpr,
      isDependent,
      CreateDeserialized,
      hasFunctionRepresentation,
      hasLambdaRepresentation,
      getFunctionDecl,
      getClosureDecl,
      getClosureCallOperator,
      hasBody,
      getBody,
      getCallExpr,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__TemplateParameterList {
    enum memnames {
      _this_,
      size,
      asArray,
      getParam,
      getMinRequiredArguments,
      getDepth,
      containsUnexpandedParameterPack,
      getRequiresClause,
      getTemplateLoc,
      getLAngleLoc,
      getRAngleLoc,
      getSourceRange,
    };
    static const unsigned _total_num_mems_ = getSourceRange + 1;
  }
  namespace clang__TemplateArgumentList {
    enum memnames {
      get,
      operator_sub,
      asArray,
      size,
      data,
    };
    static const unsigned _total_num_mems_ = data + 1;
  }
  namespace clang__TemplateDecl {
    enum memnames {
      getTemplateParameters,
      getRequiresClause,
      getAssociatedConstraints,
      getTemplatedDecl,
      classof,
      classofKind,
      getSourceRange,
    };
    static const unsigned _total_num_mems_ = getSourceRange + 1;
  }
  namespace clang__FunctionTemplateSpecializationInfo {
    enum memnames {
      Create,
      Function,
      TemplateArguments,
      TemplateArgumentsAsWritten,
      PointOfInstantiation,
      getTemplate,
      getTemplateSpecializationKind,
      isExplicitSpecialization,
      isExplicitInstantiationOrSpecialization,
      getPointOfInstantiation,
    };
    static const unsigned _total_num_mems_ = getPointOfInstantiation + 1;
  }
  namespace clang__MemberSpecializationInfo {
    enum memnames {
      getInstantiatedFrom,
      getTemplateSpecializationKind,
      isExplicitSpecialization,
      getPointOfInstantiation,
    };
    static const unsigned _total_num_mems_ = getPointOfInstantiation + 1;
  }
  namespace clang__DependentFunctionTemplateSpecializationInfo {
    enum memnames {
      Create,
      getNumTemplates,
      getTemplate,
      getTemplateArgs,
      getNumTemplateArgs,
      getTemplateArg,
      getLAngleLoc,
      getRAngleLoc,
    };
    static const unsigned _total_num_mems_ = getRAngleLoc + 1;
  }
  namespace clang__RedeclarableTemplateDecl {
    enum memnames {
      getPreviousDecl,
      getFirstDecl,
      getMostRecentDecl,
      getCanonicalDecl,
      isMemberSpecialization,
      getInstantiatedFromMemberTemplate,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__FunctionTemplateDecl {
    enum memnames {
      LoadLazySpecializations,
      getTemplatedDecl,
      isThisDeclarationADefinition,
      getCanonicalDecl,
      getPreviousDecl,
      getMostRecentDecl,
      getInstantiatedFromMemberTemplate,
      specializations,
      Create,
      CreateDeserialized,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__TemplateTypeParmDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      wasDeclaredWithTypename,
      hasDefaultArgument,
      getDefaultArgument,
      getDefaultArgumentInfo,
      getDefaultArgumentLoc,
      defaultArgumentWasInherited,
      getDepth,
      getIndex,
      isParameterPack,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__NonTypeTemplateParmDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      CreateDeserialized1,
      getSourceRange,
      hasDefaultArgument,
      getDefaultArgument,
      getDefaultArgumentLoc,
      defaultArgumentWasInherited,
      isParameterPack,
      isPackExpansion,
      isExpandedParameterPack,
      getNumExpansionTypes,
      getExpansionType,
      getExpansionTypeSourceInfo,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__TemplateTemplateParmDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      CreateDeserialized1,
      isParameterPack,
      isPackExpansion,
      isExpandedParameterPack,
      getNumExpansionTemplateParameters,
      getExpansionTemplateParameters,
      hasDefaultArgument,
      getDefaultArgument,
      getDefaultArgumentLoc,
      defaultArgumentWasInherited,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__BuiltinTemplateDecl {
    enum memnames {
      classof,
      classofKind,
      getSourceRange,
    };
    static const unsigned _total_num_mems_ = getSourceRange + 1;
  }
  namespace clang__ClassTemplateSpecializationDecl {
    enum memnames {
      CreateDeserialized,
      getNameForDiagnostic,
      getSpecializedTemplate,
      getTemplateArgs,
      getSpecializationKind,
      isExplicitSpecialization,
      isExplicitInstantiationOrSpecialization,
      getPointOfInstantiation,
      getTemplateInstantiationArgs,
      getTypeAsWritten,
      getExternLoc,
      getTemplateKeywordLoc,
      getSourceRange,
      Profile,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ClassTemplatePartialSpecializationDecl {
    enum memnames {
      CreateDeserialized,
      getTemplateParameters,
      getTemplateArgsAsWritten,
      getInstantiatedFromMember,
      getInstantiatedFromMemberTemplate,
      getInjectedSpecializationType,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ClassTemplateDecl {
    enum memnames {
      LoadLazySpecializations,
      getTemplatedDecl,
      isThisDeclarationADefinition,
      Create,
      CreateDeserialized,
      getCanonicalDecl,
      getPreviousDecl,
      getMostRecentDecl,
      getInstantiatedFromMemberTemplate,
      specializations,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__FriendTemplateDecl {
    enum memnames {
      CreateDeserialized,
      getFriendType,
      getFriendDecl,
      getFriendLoc,
      getTemplateParameterList,
      getNumTemplateParameters,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__TypeAliasTemplateDecl {
    enum memnames {
      getTemplatedDecl,
      getCanonicalDecl,
      getPreviousDecl,
      getInstantiatedFromMemberTemplate,
      Create,
      CreateDeserialized,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ClassScopeFunctionSpecializationDecl {
    enum memnames {
      getSpecialization,
      hasExplicitTemplateArgs,
      templateArgs,
      Create,
      CreateDeserialized,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__VarTemplateSpecializationDecl {
    enum memnames {
      CreateDeserialized,
      getNameForDiagnostic,
      getSpecializedTemplate,
      getTemplateArgs,
      getTemplateArgsInfo,
      getSpecializationKind,
      isExplicitSpecialization,
      isExplicitInstantiationOrSpecialization,
      getPointOfInstantiation,
      getTemplateInstantiationArgs,
      getTypeAsWritten,
      getExternLoc,
      getTemplateKeywordLoc,
      Profile,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__VarTemplatePartialSpecializationDecl {
    enum memnames {
      CreateDeserialized,
      getTemplateParameters,
      getTemplateArgsAsWritten,
      getInstantiatedFromMember,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__VarTemplateDecl {
    enum memnames {
      LoadLazySpecializations,
      getTemplatedDecl,
      isThisDeclarationADefinition,
      Create,
      CreateDeserialized,
      getCanonicalDecl,
      getPreviousDecl,
      getMostRecentDecl,
      getInstantiatedFromMemberTemplate,
      specializations,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__FriendDecl {
    enum memnames {
      CreateDeserialized,
      getFriendType,
      getFriendTypeNumTemplateParameterLists,
      getFriendTypeTemplateParameterList,
      getFriendDecl,
      getFriendLoc,
      getSourceRange,
      isUnsupportedFriend,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCListBase {
    enum memnames {
      size,
      empty,
    };
    static const unsigned _total_num_mems_ = empty + 1;
  }
  namespace clang__ObjCProtocolList {
    enum memnames {
      _this_,
      operator_sub,
    };
    static const unsigned _total_num_mems_ = operator_sub + 1;
  }
  namespace clang__ObjCMethodDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getCanonicalDecl,
      getObjCDeclQualifier,
      hasRelatedResultType,
      isRedeclaration,
      getDeclaratorEndLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
      getSelectorStartLoc,
      getSelectorLoc,
      getNumSelectorLocs,
      getClassInterface,
      getSelector,
      getReturnType,
      getReturnTypeSourceRange,
      getSendResultType,
      getSendResultType1,
      getReturnTypeSourceInfo,
      param_size,
      parameters,
      getSelfDecl,
      getCmdDecl,
      getMethodFamily,
      isInstanceMethod,
      isVariadic,
      isClassMethod,
      isPropertyAccessor,
      isDefined,
      isOverriding,
      hasSkippedBody,
      findPropertyDecl,
      getImplementationControl,
      isOptional,
      isThisDeclarationADesignatedInitializer,
      isDesignatedInitializerForTheInterface,
      hasBody,
      getBody,
      isThisDeclarationADefinition,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCTypeParamDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getSourceRange,
      getVariance,
      getVarianceLoc,
      getIndex,
      hasExplicitBound,
      getColonLoc,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCTypeParamList {
    enum memnames {
      _this_,
      size,
      front,
      back,
      getLAngleLoc,
      getRAngleLoc,
      getSourceRange,
    };
    static const unsigned _total_num_mems_ = getSourceRange + 1;
  }
  namespace clang__ObjCPropertyDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getAtLoc,
      getLParenLoc,
      getTypeSourceInfo,
      getType,
      getUsageType,
      getPropertyAttributes,
      getPropertyAttributesAsWritten,
      isReadOnly,
      isAtomic,
      isRetaining,
      isInstanceProperty,
      isClassProperty,
      getQueryKind,
      getQueryKind1,
      getSetterKind,
      getGetterName,
      getGetterNameLoc,
      getSetterName,
      getSetterNameLoc,
      getGetterMethodDecl,
      getSetterMethodDecl,
      getPropertyImplementation,
      isOptional,
      getPropertyIvarDecl,
      getSourceRange,
      getDefaultSynthIvarName,
      findPropertyDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCContainerDecl {
    enum memnames {
      properties,
      instance_properties,
      class_properties,
      methods,
      instance_methods,
      class_methods,
      getMethod,
      getInstanceMethod,
      getClassMethod,
      HasUserDeclaredSetterMethod,
      getIvarDecl,
      FindPropertyDeclaration,
      getAtStartLoc,
      getAtEndRange,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCInterfaceDecl {
    enum memnames {
      getPreviousDecl,
      getFirstDecl,
      getMostRecentDecl,
      Create,
      CreateDeserialized,
      getTypeParamList,
      getTypeParamListAsWritten,
      getSourceRange,
      hasDesignatedInitializers,
      declaresOrInheritsDesignatedInitializers,
      getReferencedProtocols,
      getImplementation,
      FindCategoryDeclaration,
      getCategoryInstanceMethod,
      getCategoryClassMethod,
      getCategoryMethod,
      protocols,
      protocol_locs,
      all_referenced_protocols,
      ivars,
      ivar_size,
      ivar_empty,
      getObjCRuntimeNameAsString,
      isDesignatedInitializer,
      isThisDeclarationADefinition,
      hasDefinition,
      getDefinition,
      getSuperClassType,
      getSuperClassTInfo,
      getSuperClass,
      visible_categories,
      visible_categories_empty,
      known_categories,
      known_categories_empty,
      visible_extensions,
      visible_extensions_empty,
      known_extensions,
      known_extensions_empty,
      getCategoryListRaw,
      FindPropertyVisibleInPrimaryClass,
      isSuperClassOf,
      isArcWeakrefUnavailable,
      isObjCRequiresPropertyDefs,
      lookupMethod,
      lookupInstanceMethod,
      lookupClassMethod,
      lookupPrivateMethod,
      lookupPropertyAccessor,
      getEndOfDefinitionLoc,
      getSuperClassLoc,
      isImplicitInterfaceDecl,
      getCanonicalDecl,
      getTypeForDecl,
      setTypeForDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCIvarDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getContainingInterface,
      getNextIvar,
      getAccessControl,
      getCanonicalAccessControl,
      getSynthesize,
      getUsageType,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCAtDefsFieldDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCProtocolDecl {
    enum memnames {
      getPreviousDecl,
      getFirstDecl,
      getMostRecentDecl,
      Create,
      CreateDeserialized,
      getReferencedProtocols,
      protocols,
      protocol_locs,
      protocol_size,
      lookupMethod,
      lookupInstanceMethod,
      lookupClassMethod,
      hasDefinition,
      getDefinition,
      isThisDeclarationADefinition,
      getObjCRuntimeNameAsString,
      getSourceRange,
      getCanonicalDecl,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCCategoryDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getClassInterface,
      getTypeParamList,
      getImplementation,
      getReferencedProtocols,
      protocols,
      protocol_size,
      protocol_locs,
      getNextClassCategory,
      getNextClassCategoryRaw,
      IsClassExtension,
      ivars,
      ivar_size,
      ivar_empty,
      getCategoryNameLoc,
      getIvarLBraceLoc,
      getIvarRBraceLoc,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCImplDecl {
    enum memnames {
      getClassInterface,
      FindPropertyImplDecl,
      FindPropertyImplIvarDecl,
      property_impls,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCCategoryImplDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getCategoryDecl,
      getCategoryNameLoc,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCImplementationDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      inits,
      getNumIvarInitializers,
      hasNonZeroConstructors,
      hasDestructors,
      getIdentifier,
      getName,
      getNameAsString,
      getObjCRuntimeNameAsString,
      getSuperClass,
      getSuperClassLoc,
      getIvarLBraceLoc,
      getIvarRBraceLoc,
      ivars,
      ivar_size,
      ivar_empty,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCCompatibleAliasDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getClassInterface,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__ObjCPropertyImplDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getSourceRange,
      getLocStart,
      getBeginLoc,
      getPropertyDecl,
      getPropertyImplementation,
      getPropertyIvarDecl,
      getPropertyIvarDeclLoc,
      isIvarNameSpecified,
      getGetterCXXConstructor,
      getSetterCXXAssignment,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__OMPThreadPrivateDecl {
    enum memnames {
      CreateDeserialized,
      varlist_size,
      varlist_empty,
      varlists,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__OMPDeclareReductionDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getCombiner,
      getInitializer,
      getInitializerKind,
      getPrevDeclInScope,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__OMPCapturedExprDecl {
    enum memnames {
      Create,
      CreateDeserialized,
      getSourceRange,
      classof,
      classofKind,
    };
    static const unsigned _total_num_mems_ = classofKind + 1;
  }
  namespace clang__CXXOperatorCallExpr {
    enum memnames {
      getOperator,
      isAssignmentOp,
      isAssignmentOp1,
      isInfixBinaryOp,
      getOperatorLoc,
      getExprLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
      classof,
      getFPFeatures,
      isFPContractableWithinStatement,
    };
    static const unsigned _total_num_mems_ = isFPContractableWithinStatement + 1;
  }
  namespace clang__CXXMemberCallExpr {
    enum memnames {
      getImplicitObjectArgument,
      getMethodDecl,
      getRecordDecl,
      getExprLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CUDAKernelCallExpr {
    enum memnames {
      getConfig,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXNamedCastExpr {
    enum memnames {
      getCastName,
      getOperatorLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getAngleBrackets,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXStaticCastExpr {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXDynamicCastExpr {
    enum memnames {
      CreateEmpty,
      isAlwaysNull,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXReinterpretCastExpr {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXConstCastExpr {
    enum memnames {
      Create,
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__UserDefinedLiteral {
    enum memnames {
      getLiteralOperatorKind,
      getCookedLiteral,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getUDSuffixLoc,
      getUDSuffix,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXBoolLiteralExpr {
    enum memnames {
      getValue,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getLocation,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXNullPtrLiteralExpr {
    enum memnames {
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getLocation,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXStdInitializerListExpr {
    enum memnames {
      getSubExpr,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXTypeidExpr {
    enum memnames {
      isPotentiallyEvaluated,
      isTypeOperand,
      getTypeOperand,
      getTypeOperandSourceInfo,
      getExprOperand,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__MSPropertyRefExpr {
    enum memnames {
      getSourceRange,
      isImplicitAccess,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
      getBaseExpr,
      getPropertyDecl,
      isArrow,
      getMemberLoc,
      getQualifierLoc,
    };
    static const unsigned _total_num_mems_ = getQualifierLoc + 1;
  }
  namespace clang__MSPropertySubscriptExpr {
    enum memnames {
      getBase,
      getIdx,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getRBracketLoc,
      getExprLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXUuidofExpr {
    enum memnames {
      isTypeOperand,
      getTypeOperand,
      getTypeOperandSourceInfo,
      getExprOperand,
      getUuidStr,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXThisExpr {
    enum memnames {
      getLocation,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      isImplicit,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXThrowExpr {
    enum memnames {
      getSubExpr,
      getThrowLoc,
      isThrownVariableInScope,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXDefaultArgExpr {
    enum memnames {
      Create,
      getParam,
      getExpr,
      getUsedLocation,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getExprLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXDefaultInitExpr {
    enum memnames {
      Create,
      getField,
      getExpr,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXTemporary {
    enum memnames {
      Create,
      getDestructor,
    };
    static const unsigned _total_num_mems_ = getDestructor + 1;
  }
  namespace clang__CXXBindTemporaryExpr {
    enum memnames {
      Create,
      getTemporary,
      getSubExpr,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXConstructExpr {
    enum memnames {
      getConstructor,
      getLocation,
      isElidable,
      hadMultipleCandidates,
      isListInitialization,
      isStdInitListInitialization,
      requiresZeroInitialization,
      getConstructionKind,
      arguments,
      getArgs,
      getNumArgs,
      getArg,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getParenOrBraceRange,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXInheritedCtorInitExpr {
    enum memnames {
      getConstructor,
      constructsVBase,
      getConstructionKind,
      inheritedFromVBase,
      getLocation,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXFunctionalCastExpr {
    enum memnames {
      CreateEmpty,
      getLParenLoc,
      getRParenLoc,
      isListInitialization,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXTemporaryObjectExpr {
    enum memnames {
      getTypeSourceInfo,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__LambdaExpr {
    enum memnames {
      CreateDeserialized,
      getCaptureDefault,
      getCaptureDefaultLoc,
      isInitCapture,
      captures,
      capture_size,
      explicit_captures,
      implicit_captures,
      capture_inits,
      getIntroducerRange,
      getLambdaClass,
      getCallOperator,
      getTemplateParameterList,
      isGenericLambda,
      getBody,
      isMutable,
      hasExplicitParameters,
      hasExplicitResultType,
      classof,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
    };
    static const unsigned _total_num_mems_ = getEndLoc + 1;
  }
  namespace clang__CXXScalarValueInitExpr {
    enum memnames {
      getTypeSourceInfo,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXNewExpr {
    enum memnames {
      getAllocatedType,
      getAllocatedTypeSourceInfo,
      shouldNullCheckAllocation,
      getOperatorNew,
      getOperatorDelete,
      isArray,
      getArraySize,
      getNumPlacementArgs,
      getPlacementArg,
      isParenTypeId,
      getTypeIdParens,
      isGlobalNew,
      hasInitializer,
      getInitializationStyle,
      getInitializer,
      getConstructExpr,
      passAlignment,
      doesUsualArrayDeleteWantSize,
      placement_arguments,
      getStartLoc,
      getBeginLoc,
      getEndLoc,
      getDirectInitRange,
      getSourceRange,
      getLocStart,
      getLocEnd,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXDeleteExpr {
    enum memnames {
      isGlobalDelete,
      isArrayForm,
      isArrayFormAsWritten,
      doesUsualArrayDeleteWantSize,
      getOperatorDelete,
      getArgument,
      getDestroyedType,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXPseudoDestructorExpr {
    enum memnames {
      getBase,
      hasQualifier,
      getQualifierLoc,
      getQualifier,
      isArrow,
      getOperatorLoc,
      getScopeTypeInfo,
      getColonColonLoc,
      getTildeLoc,
      getDestroyedTypeInfo,
      getDestroyedTypeIdentifier,
      getDestroyedType,
      getDestroyedTypeLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__TypeTraitExpr {
    enum memnames {
      CreateDeserialized,
      getTrait,
      getValue,
      getNumArgs,
      getArg,
      getArgs,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ArrayTypeTraitExpr {
    enum memnames {
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getTrait,
      getQueriedType,
      getQueriedTypeSourceInfo,
      getValue,
      getDimensionExpression,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ExpressionTraitExpr {
    enum memnames {
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getTrait,
      getQueriedExpression,
      getValue,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OverloadExpr {
    enum memnames {
      find,
      getNamingClass,
      decls,
      getNumDecls,
      getNameInfo,
      getName,
      getNameLoc,
      getQualifier,
      getQualifierLoc,
      getTemplateKeywordLoc,
      getLAngleLoc,
      getRAngleLoc,
      hasTemplateKeyword,
      hasExplicitTemplateArgs,
      getTemplateArgs,
      getNumTemplateArgs,
      template_arguments,
      copyTemplateArgumentsInto,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OverloadExpr__FindResult {
    enum memnames {
      Expression,
      IsAddressOfOperand,
      HasFormOfMemberPointer,
    };
    static const unsigned _total_num_mems_ = HasFormOfMemberPointer + 1;
  }
  namespace clang__UnresolvedLookupExpr {
    enum memnames {
      Create,
      Create1,
      CreateEmpty,
      requiresADL,
      isOverloaded,
      getNamingClass,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__DependentScopeDeclRefExpr {
    enum memnames {
      Create,
      CreateEmpty,
      getNameInfo,
      getDeclName,
      getLocation,
      getQualifierLoc,
      getQualifier,
      getTemplateKeywordLoc,
      getLAngleLoc,
      getRAngleLoc,
      hasTemplateKeyword,
      hasExplicitTemplateArgs,
      copyTemplateArgumentsInto,
      getTemplateArgs,
      getNumTemplateArgs,
      template_arguments,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ExprWithCleanups {
    enum memnames {
      Create,
      getObjects,
      getNumObjects,
      getObject,
      getSubExpr,
      cleanupsHaveSideEffects,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXUnresolvedConstructExpr {
    enum memnames {
      CreateEmpty,
      getTypeAsWritten,
      getTypeSourceInfo,
      getLParenLoc,
      getRParenLoc,
      isListInitialization,
      arg_size,
      getArg,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXDependentScopeMemberExpr {
    enum memnames {
      Create,
      CreateEmpty,
      isImplicitAccess,
      getBase,
      getBaseType,
      isArrow,
      getOperatorLoc,
      getQualifier,
      getQualifierLoc,
      getFirstQualifierFoundInScope,
      getMemberNameInfo,
      getMember,
      getMemberLoc,
      getTemplateKeywordLoc,
      getLAngleLoc,
      getRAngleLoc,
      hasTemplateKeyword,
      hasExplicitTemplateArgs,
      copyTemplateArgumentsInto,
      getTemplateArgs,
      getNumTemplateArgs,
      template_arguments,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__UnresolvedMemberExpr {
    enum memnames {
      Create,
      CreateEmpty,
      isImplicitAccess,
      getBase,
      getBaseType,
      hasUnresolvedUsing,
      isArrow,
      getOperatorLoc,
      getNamingClass,
      getMemberNameInfo,
      getMemberName,
      getMemberLoc,
      getExprLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXNoexceptExpr {
    enum memnames {
      getOperand,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
      getValue,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__PackExpansionExpr {
    enum memnames {
      getPattern,
      getEllipsisLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__SizeOfPackExpr {
    enum memnames {
      CreateDeserialized,
      getOperatorLoc,
      getPackLoc,
      getRParenLoc,
      getPack,
      getPackLength,
      isPartiallySubstituted,
      getPartialArguments,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__SubstNonTypeTemplateParmExpr {
    enum memnames {
      getNameLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getReplacement,
      getParameter,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__SubstNonTypeTemplateParmPackExpr {
    enum memnames {
      getParameterPack,
      getParameterPackLocation,
      getArgumentPack,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__FunctionParmPackExpr {
    enum memnames {
      _this_,
      CreateEmpty,
      getParameterPack,
      getParameterPackLocation,
      getNumExpansions,
      getExpansion,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__MaterializeTemporaryExpr {
    enum memnames {
      getTemporary,
      GetTemporaryExpr,
      getStorageDuration,
      getExtendingDecl,
      getManglingNumber,
      isBoundToLvalueReference,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXFoldExpr {
    enum memnames {
      getLHS,
      getRHS,
      isRightFold,
      isLeftFold,
      getPattern,
      getInit,
      getEllipsisLoc,
      getOperator,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CoroutineSuspendExpr {
    enum memnames {
      getKeywordLoc,
      getCommonExpr,
      getOpaqueValue,
      getReadyExpr,
      getSuspendExpr,
      getResumeExpr,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CoawaitExpr {
    enum memnames {
      getOperand,
      isImplicit,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__DependentCoawaitExpr {
    enum memnames {
      getOperand,
      getOperatorCoawaitLookup,
      getKeywordLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CoyieldExpr {
    enum memnames {
      getOperand,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ReflectionExpr {
    enum memnames {
      isReflexpr,
      hasTypeOperand,
      hasExpressionOperand,
      getTypeOperand,
      getExpressionOperand,
      getOperatorLoc,
      getLocStart,
      getLocEnd,
    };
    static const unsigned _total_num_mems_ = getLocEnd + 1;
  }
  namespace clang__CompilerMessageExpr {
    enum memnames {
      Create,
      CreateEmpty,
      getMessage,
      getKWLoc,
      getRParenLoc,
      getLocStart,
      getLocEnd,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CompilerDiagnosticExpr {
    enum memnames {
      CreateEmpty,
      getKWLoc,
      getRParenLoc,
      arg_size,
      getArgs,
      getArg,
      isError,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXMetaparseExpr {
    enum memnames {
      getExprSrcCode,
      getLocStart,
      getLocEnd,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ReflectionTraitExpr {
    enum memnames {
      getTraitKind,
      getNumArgs,
      getArg,
      getArgs,
      getKWLoc,
      getRParenLoc,
      getLocStart,
      getLocEnd,
      getASTContext_p,
      getObjKind,
      callbacksAreSet,
      readyToConvertToStringLiteral,
      getMemNum,
      isPtr,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ReflectNewExpr {
    enum memnames {
      getNumArgs,
      getArg,
      getArgs,
      getObjKind,
      getTraitLoc,
      getRParenLoc,
      getLocStart,
      getLocEnd,
    };
    static const unsigned _total_num_mems_ = getLocEnd + 1;
  }
  namespace clang__ReflectDeleteExpr {
    enum memnames {
      getNumArgs,
      getArg,
      getArgs,
      getObjKind,
      getTraitLoc,
      getRParenLoc,
      getLocStart,
      getLocEnd,
    };
    static const unsigned _total_num_mems_ = getLocEnd + 1;
  }
  namespace clang__CXXConstantExpr {
    enum memnames {
      getExpression,
      getValue,
      getLocStart,
      getLocEnd,
      children,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXDependentIdExpr {
    enum memnames {
      getNameInfo,
      getLocStart,
      getLocEnd,
      getSourceRange,
      children,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXConcatenateExpr {
    enum memnames {
      getNumOperands,
      getOperand,
      getOperands,
      children,
      getIntroLoc,
      getLocStart,
      getLocEnd,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCStringLiteral {
    enum memnames {
      getString,
      getAtLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCBoolLiteralExpr {
    enum memnames {
      getValue,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getLocation,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCBoxedExpr {
    enum memnames {
      getSubExpr,
      getBoxingMethod,
      getAtLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCArrayLiteral {
    enum memnames {
      CreateEmpty,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
      getElements,
      getNumElements,
      getElement,
      getArrayWithObjectsMethod,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCDictionaryElement {
    enum memnames {
      Key,
      Value,
      EllipsisLoc,
      isPackExpansion,
    };
    static const unsigned _total_num_mems_ = isPackExpansion + 1;
  }
  namespace clang__ObjCDictionaryLiteral {
    enum memnames {
      CreateEmpty,
      getNumElements,
      getKeyValueElement,
      getDictWithObjectsMethod,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCEncodeExpr {
    enum memnames {
      getAtLoc,
      getRParenLoc,
      getEncodedType,
      getEncodedTypeSourceInfo,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCSelectorExpr {
    enum memnames {
      getSelector,
      getAtLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getNumArgs,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCProtocolExpr {
    enum memnames {
      getProtocol,
      getProtocolIdLoc,
      getAtLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCIvarRefExpr {
    enum memnames {
      getDecl,
      getBase,
      isArrow,
      isFreeIvar,
      getLocation,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getOpLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCPropertyRefExpr {
    enum memnames {
      isImplicitProperty,
      isExplicitProperty,
      getExplicitProperty,
      getImplicitPropertyGetter,
      getImplicitPropertySetter,
      getGetterSelector,
      getSetterSelector,
      isMessagingGetter,
      isMessagingSetter,
      getBase,
      getLocation,
      getReceiverLocation,
      getSuperReceiverType,
      getClassReceiver,
      isObjectReceiver,
      isSuperReceiver,
      isClassReceiver,
      getReceiverType,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCSubscriptRefExpr {
    enum memnames {
      getRBracket,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getBaseExpr,
      getKeyExpr,
      getAtIndexMethodDecl,
      setAtIndexMethodDecl,
      isArraySubscriptRefExpr,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCMessageExpr {
    enum memnames {
      CreateEmpty,
      isImplicit,
      getReceiverKind,
      getReceiverRange,
      isInstanceMessage,
      isClassMessage,
      getInstanceReceiver,
      getClassReceiver,
      getClassReceiverTypeInfo,
      getSuperLoc,
      getReceiverType,
      getReceiverInterface,
      getSuperType,
      getSelector,
      getMethodDecl,
      getMethodFamily,
      getNumArgs,
      getArgs,
      getArg,
      isDelegateInitCall,
      getLeftLoc,
      getRightLoc,
      getSelectorStartLoc,
      getSelectorLoc,
      getNumSelectorLocs,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      arguments,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCIsaExpr {
    enum memnames {
      getBase,
      isArrow,
      getIsaMemberLoc,
      getOpLoc,
      getLocStart,
      getBeginLoc,
      getBaseLocEnd,
      getLocEnd,
      getEndLoc,
      getExprLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCIndirectCopyRestoreExpr {
    enum memnames {
      getSubExpr,
      shouldCopy,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getExprLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCBridgedCastExpr {
    enum memnames {
      getLParenLoc,
      getBridgeKind,
      getBridgeKindName,
      getBridgeKeywordLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCAvailabilityCheckExpr {
    enum memnames {
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getSourceRange,
      hasVersion,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPArraySectionExpr {
    enum memnames {
      getBase,
      getBaseOriginalType,
      getLowerBound,
      getLength,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getColonLoc,
      getRBracketLoc,
      getExprLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXCatchStmt {
    enum memnames {
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getCatchLoc,
      getExceptionDecl,
      getCaughtType,
      getHandlerBlock,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXTryStmt {
    enum memnames {
      Create,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getTryLoc,
      getEndLoc,
      getTryBlock,
      getNumHandlers,
      getHandler,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXForRangeStmt {
    enum memnames {
      getLoopVariable,
      getRangeInit,
      getRangeStmt,
      getBeginStmt,
      getEndStmt,
      getCond,
      getInc,
      getLoopVarStmt,
      getBody,
      getForLoc,
      getCoawaitLoc,
      getColonLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXExpansionStmt {
    enum memnames {
      getRangeVarStmt,
      getRangeVariable,
      getLoopVarStmt,
      getLoopVariable,
      getBody,
      getSize,
      getInstantiatedStatements,
      getForLoc,
      getEllipsisLoc,
      getColonLoc,
      getRParenLoc,
      getLocStart,
      getLocEnd,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXTupleExpansionStmt {
    enum memnames {
      getRangeVarStmt,
      getRangeInit,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXPackExpansionStmt {
    enum memnames {
      getUnexpandedPack,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__MSDependentExistsStmt {
    enum memnames {
      getKeywordLoc,
      isIfExists,
      isIfNotExists,
      getQualifierLoc,
      getNameInfo,
      getSubStmt,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CoroutineBodyStmt {
    enum memnames {
      Create,
      Create1,
      hasDependentPromiseType,
      getBody,
      getPromiseDeclStmt,
      getPromiseDecl,
      getInitSuspendStmt,
      getFinalSuspendStmt,
      getExceptionHandler,
      getFallthroughHandler,
      getAllocate,
      getDeallocate,
      getReturnValueInit,
      getResultDecl,
      getReturnStmt,
      getReturnStmtOnAllocFailure,
      getParamMoves,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CoroutineBodyStmt__CtorArgs {
    enum memnames {
      Body,
      Promise,
      InitialSuspend,
      FinalSuspend,
      OnException,
      OnFallthrough,
      Allocate,
      Deallocate,
      ReturnValue,
      ResultDecl,
      ReturnStmt,
      ReturnStmtOnAllocFailure,
    };
    static const unsigned _total_num_mems_ = ReturnStmtOnAllocFailure + 1;
  }
  namespace clang__CoreturnStmt {
    enum memnames {
      getKeywordLoc,
      getOperand,
      getPromiseCall,
      isImplicit,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__CXXQueueMetaparseStmt {
    enum memnames {
      getNewSrcCode,
      getIntroLoc,
      getLocStart,
      getLocEnd,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCForCollectionStmt {
    enum memnames {
      getElement,
      getCollection,
      getBody,
      getForLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCAtCatchStmt {
    enum memnames {
      getCatchBody,
      getCatchParamDecl,
      getAtCatchLoc,
      getRParenLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      hasEllipsis,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCAtFinallyStmt {
    enum memnames {
      getFinallyBody,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getAtFinallyLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCAtTryStmt {
    enum memnames {
      Create,
      CreateEmpty,
      getAtTryLoc,
      getTryBody,
      getNumCatchStmts,
      getCatchStmt,
      getFinallyStmt,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCAtSynchronizedStmt {
    enum memnames {
      getAtSynchronizedLoc,
      getSynchBody,
      getSynchExpr,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCAtThrowStmt {
    enum memnames {
      getThrowExpr,
      getThrowLoc,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__ObjCAutoreleasePoolStmt {
    enum memnames {
      getSubStmt,
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getAtLoc,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPClause {
    enum memnames {
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getClauseKind,
      isImplicit,
      children,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPExecutableDirective {
    enum memnames {
      getLocStart,
      getBeginLoc,
      getLocEnd,
      getEndLoc,
      getNumClauses,
      getClause,
      hasAssociatedStmt,
      getAssociatedStmt,
      getCapturedStmt,
      getInnermostCapturedStmt,
      getDirectiveKind,
      classof,
      clauses,
    };
    static const unsigned _total_num_mems_ = clauses + 1;
  }
  namespace clang__OMPParallelDirective {
    enum memnames {
      CreateEmpty,
      hasCancel,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPLoopDirective {
    enum memnames {
      getCollapsedNumber,
      getIterationVariable,
      getLastIteration,
      getCalcLastIteration,
      getPreCond,
      getCond,
      getInit,
      getInc,
      getPreInits,
      getIsLastIterVariable,
      getLowerBoundVariable,
      getUpperBoundVariable,
      getStrideVariable,
      getEnsureUpperBound,
      getNextLowerBound,
      getNextUpperBound,
      getNumIterations,
      getPrevLowerBoundVariable,
      getPrevUpperBoundVariable,
      getDistInc,
      getPrevEnsureUpperBound,
      getCombinedLowerBoundVariable,
      getCombinedUpperBoundVariable,
      getCombinedEnsureUpperBound,
      getCombinedInit,
      getCombinedCond,
      getCombinedNextLowerBound,
      getCombinedNextUpperBound,
      getBody,
      counters,
      private_counters,
      inits,
      updates,
      finals,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPSimdDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPForDirective {
    enum memnames {
      CreateEmpty,
      hasCancel,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPForSimdDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPSectionsDirective {
    enum memnames {
      CreateEmpty,
      hasCancel,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPSectionDirective {
    enum memnames {
      Create,
      CreateEmpty,
      hasCancel,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPSingleDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPMasterDirective {
    enum memnames {
      Create,
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPCriticalDirective {
    enum memnames {
      CreateEmpty,
      getDirectiveName,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPParallelForDirective {
    enum memnames {
      CreateEmpty,
      hasCancel,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPParallelForSimdDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPParallelSectionsDirective {
    enum memnames {
      CreateEmpty,
      hasCancel,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTaskDirective {
    enum memnames {
      CreateEmpty,
      hasCancel,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTaskyieldDirective {
    enum memnames {
      Create,
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPBarrierDirective {
    enum memnames {
      Create,
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTaskwaitDirective {
    enum memnames {
      Create,
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTaskgroupDirective {
    enum memnames {
      CreateEmpty,
      getReductionRef,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPFlushDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPOrderedDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPAtomicDirective {
    enum memnames {
      CreateEmpty,
      getX,
      getUpdateExpr,
      isXLHSInRHSPart,
      isPostfixUpdate,
      getV,
      getExpr,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetDataDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetEnterDataDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetExitDataDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetParallelDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetParallelForDirective {
    enum memnames {
      CreateEmpty,
      hasCancel,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTeamsDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPCancellationPointDirective {
    enum memnames {
      Create,
      CreateEmpty,
      getCancelRegion,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPCancelDirective {
    enum memnames {
      CreateEmpty,
      getCancelRegion,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTaskLoopDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTaskLoopSimdDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPDistributeDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetUpdateDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPDistributeParallelForDirective {
    enum memnames {
      CreateEmpty,
      hasCancel,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPDistributeParallelForSimdDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPDistributeSimdDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetParallelForSimdDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetSimdDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTeamsDistributeDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTeamsDistributeSimdDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTeamsDistributeParallelForSimdDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTeamsDistributeParallelForDirective {
    enum memnames {
      CreateEmpty,
      hasCancel,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetTeamsDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetTeamsDistributeDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetTeamsDistributeParallelForDirective {
    enum memnames {
      CreateEmpty,
      hasCancel,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetTeamsDistributeParallelForSimdDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__OMPTargetTeamsDistributeSimdDirective {
    enum memnames {
      CreateEmpty,
      classof,
    };
    static const unsigned _total_num_mems_ = classof + 1;
  }
  namespace clang__StoredDeclsMap {
    enum memnames {
      empty,
      size,
      count,
      isPointerIntoBucketsArray,
      getPointerIntoBucketsArray,
      getMemorySize,
      DestroyAll,
    };
    static const unsigned _total_num_mems_ = DestroyAll + 1;
  }
  namespace clang__DependentDiagnostic {
    enum memnames {
      Create,
      getKind,
      isAccessToMember,
      getAccess,
      getAccessLoc,
      getAccessTarget,
      getAccessNamingClass,
      getAccessBaseObjectType,
      getDiagnostic,
    };
    static const unsigned _total_num_mems_ = getDiagnostic + 1;
  }
  namespace reflcontainers__VectorStr {
    enum memnames {
      _this_,
      clone,
      size,
      empty,
      clear,
      resize,
      capacity,
      reserve,
      shrink_to_fit,
      push_back,
      pop_back,
      dealloc,
      at,
      assign,
      front,
      back,
    };
    static const unsigned _total_num_mems_ = back + 1;
  }
  namespace reflcontainers__VectorInt {
    enum memnames {
      _this_,
      clone,
      size,
      empty,
      clear,
      resize,
      capacity,
      reserve,
      shrink_to_fit,
      push_back,
      pop_back,
      dealloc,
      at,
      assign,
      front,
      back,
      assign1,
      push_back1,
    };
    static const unsigned _total_num_mems_ = push_back1 + 1;
  }
  namespace reflcontainers__SetInt {
    enum memnames {
      _this_,
      clone,
      size,
      empty,
      clear,
      contains,
      insert,
      erase,
      at_ith,
      dealloc,
      contains1,
      insert1,
      erase1,
    };
    static const unsigned _total_num_mems_ = erase1 + 1;
  }
  namespace reflcontainers__SetStr {
    enum memnames {
      _this_,
      clone,
      size,
      empty,
      clear,
      contains,
      insert,
      erase,
      at_ith,
      dealloc,
    };
    static const unsigned _total_num_mems_ = dealloc + 1;
  }
  namespace reflcontainers__IntIntPair {
    enum memnames {
      first,
      second,
    };
    static const unsigned _total_num_mems_ = second + 1;
  }
  namespace reflcontainers__IntStrPair {
    enum memnames {
      first,
      second,
    };
    static const unsigned _total_num_mems_ = second + 1;
  }
  namespace reflcontainers__StrIntPair {
    enum memnames {
      first,
      second,
    };
    static const unsigned _total_num_mems_ = second + 1;
  }
  namespace reflcontainers__StrStrPair {
    enum memnames {
      first,
      second,
    };
    static const unsigned _total_num_mems_ = second + 1;
  }
  namespace reflcontainers__MapIntStr {
    enum memnames {
      _this_,
      clone,
      size,
      empty,
      clear,
      at_ith,
      at_ith_key,
      at_ith_val,
      dealloc,
      contains,
      at,
      assign,
      erase,
      erase1,
      contains1,
      at1,
      assign1,
    };
    static const unsigned _total_num_mems_ = assign1 + 1;
  }
  namespace reflcontainers__MapStrInt {
    enum memnames {
      _this_,
      clone,
      size,
      empty,
      clear,
      at_ith,
      at_ith_key,
      at_ith_val,
      dealloc,
      contains,
      at,
      assign,
      erase,
      assign1,
    };
    static const unsigned _total_num_mems_ = assign1 + 1;
  }
  namespace reflcontainers__MapStrStr {
    enum memnames {
      _this_,
      clone,
      size,
      empty,
      clear,
      at_ith,
      at_ith_key,
      at_ith_val,
      dealloc,
      contains,
      at,
      assign,
      erase,
    };
    static const unsigned _total_num_mems_ = erase + 1;
  }
  namespace reflcontainers__MapIntInt {
    enum memnames {
      _this_,
      clone,
      size,
      empty,
      clear,
      at_ith,
      at_ith_key,
      at_ith_val,
      dealloc,
      contains,
      at,
      assign,
      erase,
      erase1,
      contains1,
      at1,
      assign1,
      assign2,
      assign3,
    };
    static const unsigned _total_num_mems_ = assign3 + 1;
  }
  
} //namespace reflenums


namespace refldetail {


  namespace clang {
  }

  namespace clang {
  }

  namespace llvm {
    struct APInt {
      M_template_rtpack(Xs) struct impl;
      struct ms {
        M_template_rtpack(Xs) struct impl;
      };
      struct mu {
        M_template_rtpack(Xs) struct impl;
      };
    };
  }

  namespace llvm {
    struct APFloatBase {
      M_template_rtpack(Xs) struct impl;
      enum cmpResult : unsigned int;
      enum roundingMode : unsigned int;
      enum opStatus : unsigned int;
      enum fltCategory : unsigned int;
    };
    struct APFloat {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace llvm {
    struct APSInt {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct APValue {
      M_template_rtpack(Xs) struct impl;
      enum ValueKind : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(getMemberPointerPath,
      constexpr auto getMemberPointerPath() const ,
        (const class clang::CXXRecordDecl *),
        (reflenums::RK_clang__APValue, reflenums::clang__APValue::getMemberPointerPath, Xs...), () )
      struct LValueBase {
        M_template_rtpack(Xs) struct impl;
      };
    };
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {

    namespace diag {
      enum class Severity : int;
    }
  }

  namespace clang {
    enum OverloadsShown : unsigned int;
    enum class DiagnosticLevelMask : unsigned int;
    struct DiagnosticOptions {
      M_template_rtpack(Xs) struct impl;
      enum TextDiagnosticFormat : unsigned int;
    };
  }

  namespace clang {
    struct FileID {
      M_template_rtpack(Xs) struct impl;
    };
    struct SourceLocation {
      M_template_rtpack(Xs) struct impl;
    };
    struct SourceRange {
      M_template_rtpack(Xs) struct impl;
    };
    struct CharSourceRange {
      M_template_rtpack(Xs) struct impl;
    };
    struct PresumedLoc {
      M_template_rtpack(Xs) struct impl;
    };
    struct FullSourceLoc {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    enum AccessSpecifier : unsigned int;
    enum ExprValueKind : unsigned int;
    enum ExprObjectKind : unsigned int;
    enum TemplateSpecializationKind : unsigned int;
    enum ThreadStorageClassSpecifier : unsigned int;
    enum StorageClass : unsigned int;
    enum InClassInitStyle : unsigned int;
    enum CallingConv : unsigned int;
    enum StorageDuration : unsigned int;
    enum class NullabilityKind : uint8_t;
    enum class ParameterABI : int;
    enum ReflectionTraitKind : unsigned int;
  }

  namespace llvm {
    struct DebugEpochBase {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct FixItHint {
      M_template_rtpack(Xs) struct impl;
    };
    struct DiagnosticsEngine {
      M_template_rtpack(Xs) struct impl;
      enum Level : unsigned int;
      enum ArgumentKind : unsigned int;
    };
    struct DiagnosticBuilder {
      M_template_rtpack(Xs) struct impl;
    };
    struct DiagnosticConsumer {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {

    namespace tok {
      enum TokenKind : unsigned short;
      enum PPKeywordKind : unsigned int;
      enum ObjCKeywordKind : unsigned int;
    }
  }

  namespace clang {
    struct IdentifierInfo {
      M_template_rtpack(Xs) struct impl;
    };
    struct IdentifierInfoLookup {
      M_template_rtpack(Xs) struct impl;
    };
    struct IdentifierTable {
      M_template_rtpack(Xs) struct impl;
    };
    enum ObjCMethodFamily : unsigned int;
    enum ObjCInstanceTypeFamily : unsigned int;
    enum ObjCStringFormatFamily : unsigned int;
    struct Selector {
      M_template_rtpack(Xs) struct impl;
    };
    struct SelectorTable {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct PartialDiagnostic {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct DeclarationName {
      M_template_rtpack(Xs) struct impl;
      enum NameKind : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(getCXXIdExprArguments,
      constexpr auto getCXXIdExprArguments() const ,
        (class clang::Expr *),
        (reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getCXXIdExprArguments, Xs...), () )
    };
    struct DeclarationNameLoc {
      M_template_rtpack(Xs) struct impl;
    };
    struct DeclarationNameInfo {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace llvm {
    struct raw_ostream {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace llvm {
    struct VersionTuple {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    enum AvailabilityResult : unsigned int;
    struct Decl {
      M_template_rtpack(Xs) struct impl;
      enum Kind : unsigned int;
      enum ObjCDeclQualifier : unsigned int;
      enum class ModuleOwnershipKind : unsigned int;
      enum FriendObjectKind : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(attrs,
      constexpr auto attrs() const ,
        (class clang::Attr *const),
        (reflenums::RK_clang__Decl, reflenums::clang__Decl::attrs, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(redecls,
      constexpr auto redecls() const ,
        (class clang::Decl *const),
        (reflenums::RK_clang__Decl, reflenums::clang__Decl::redecls, Xs...), () )
    };
    struct DeclContextLookupResult {
      M_template_rtpack(Xs) struct impl;
    };
    struct DeclContext {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(decls,
      constexpr auto decls() const ,
        (class clang::Decl *const),
        (reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::decls, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(noload_decls,
      constexpr auto noload_decls() const ,
        (class clang::Decl *const),
        (reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::noload_decls, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(lookups,
      constexpr auto lookups() const ,
        (class clang::DeclContextLookupResult),
        (reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::lookups, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(ddiags,
      constexpr auto ddiags() const ,
        (class clang::DependentDiagnostic *),
        (reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::ddiags, Xs...), () )
    };
  }

  namespace clang {
    struct CharUnits {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct FileSystemOptions {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace llvm {
    struct Twine {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace llvm {

    namespace sys {

      namespace fs {
        struct UniqueID {
          M_template_rtpack(Xs) struct impl;
        };
      }
    }
  }

  namespace llvm {
    struct MemoryBuffer {
      M_template_rtpack(Xs) struct impl;
      enum BufferKind : unsigned int;
    };
    struct MemoryBufferRef {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
  }

  namespace clang {
    struct DirectoryEntry {
      M_template_rtpack(Xs) struct impl;
    };
    struct FileEntry {
      M_template_rtpack(Xs) struct impl;
    };
    struct FileManager {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct ASTFileSignature {
      M_template_rtpack(Xs) struct impl;
    };
    struct Module {
      M_template_rtpack(Xs) struct impl;
      enum ModuleKind : unsigned int;
      enum NameVisibilityKind : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(submodules,
      constexpr auto submodules() const ,
        (class clang::Module *const),
        (reflenums::RK_clang__Module, reflenums::clang__Module::submodules, Xs...), () )
      struct Header {
        M_template_rtpack(Xs) struct impl;
      };
      struct DirectoryName {
        M_template_rtpack(Xs) struct impl;
      };
    };
  }

  namespace clang {
    struct ExternalASTSource {
      M_template_rtpack(Xs) struct impl;
      struct MemoryBufferSizes {
        M_template_rtpack(Xs) struct impl;
      };
    };
  }

  namespace clang {
  }

  namespace llvm {
    struct FoldingSetBase {
      M_template_rtpack(Xs) struct impl;
      struct Node {
        M_template_rtpack(Xs) struct impl;
      };
    };
    struct FoldingSetNodeIDRef {
      M_template_rtpack(Xs) struct impl;
    };
    struct FoldingSetNodeID {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct NestedNameSpecifier {
      M_template_rtpack(Xs) struct impl;
      enum SpecifierKind : unsigned int;
    };
    struct NestedNameSpecifierLoc {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
  }

  namespace clang {
    struct UncommonTemplateNameStorage {
      M_template_rtpack(Xs) struct impl;
    };
    struct OverloadedTemplateStorage {
      M_template_rtpack(Xs) struct impl;
    };
    struct SubstTemplateTemplateParmPackStorage {
      M_template_rtpack(Xs) struct impl;
    };
    struct TemplateName {
      M_template_rtpack(Xs) struct impl;
      enum NameKind : unsigned int;
    };
    struct SubstTemplateTemplateParmStorage {
      M_template_rtpack(Xs) struct impl;
    };
    struct QualifiedTemplateName {
      M_template_rtpack(Xs) struct impl;
    };
    struct DependentTemplateName {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    enum class LangAS : unsigned int;
  }

  namespace clang {
    enum ExceptionSpecificationType : unsigned int;
    enum CanThrowResult : unsigned int;
  }

  namespace clang {
    enum Linkage : unsigned char;
    enum LanguageLinkage : unsigned int;
    enum GVALinkage : unsigned int;
  }

  namespace clang {
    enum Visibility : unsigned int;
    struct LinkageInfo {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
  }

  namespace clang {
    struct Qualifiers {
      M_template_rtpack(Xs) struct impl;
      enum GC : unsigned int;
      enum ObjCLifetime : unsigned int;
    };
    struct SplitQualType {
      M_template_rtpack(Xs) struct impl;
    };
    enum class ObjCSubstitutionContext : int;
    struct QualType {
      M_template_rtpack(Xs) struct impl;
      enum PrimitiveDefaultInitializeKind : unsigned int;
      enum PrimitiveCopyKind : unsigned int;
      enum DestructionKind : unsigned int;
    };
  }

  namespace clang {
    struct ExtQualsTypeCommonBase {
      M_template_rtpack(Xs) struct impl;
    };
    enum RefQualifierKind : unsigned int;
    enum class AutoTypeKeyword : int;
    struct Type {
      M_template_rtpack(Xs) struct impl;
      enum TypeClass : unsigned int;
      enum ScalarTypeKind : unsigned int;
    };
    struct BuiltinType {
      M_template_rtpack(Xs) struct impl;
      enum Kind : unsigned int;
    };
    struct ComplexType {
      M_template_rtpack(Xs) struct impl;
    };
    struct ParenType {
      M_template_rtpack(Xs) struct impl;
    };
    struct PointerType {
      M_template_rtpack(Xs) struct impl;
    };
    struct AdjustedType {
      M_template_rtpack(Xs) struct impl;
    };
    struct DecayedType {
      M_template_rtpack(Xs) struct impl;
    };
    struct BlockPointerType {
      M_template_rtpack(Xs) struct impl;
    };
    struct ReferenceType {
      M_template_rtpack(Xs) struct impl;
    };
    struct LValueReferenceType {
      M_template_rtpack(Xs) struct impl;
    };
    struct RValueReferenceType {
      M_template_rtpack(Xs) struct impl;
    };
    struct MemberPointerType {
      M_template_rtpack(Xs) struct impl;
    };
    struct ArrayType {
      M_template_rtpack(Xs) struct impl;
      enum ArraySizeModifier : unsigned int;
    };
    struct ConstantArrayType {
      M_template_rtpack(Xs) struct impl;
    };
    struct IncompleteArrayType {
      M_template_rtpack(Xs) struct impl;
    };
    struct VariableArrayType {
      M_template_rtpack(Xs) struct impl;
    };
    struct DependentSizedArrayType {
      M_template_rtpack(Xs) struct impl;
    };
    struct DependentAddressSpaceType {
      M_template_rtpack(Xs) struct impl;
    };
    struct DependentSizedExtVectorType {
      M_template_rtpack(Xs) struct impl;
    };
    struct VectorType {
      M_template_rtpack(Xs) struct impl;
      enum VectorKind : unsigned int;
    };
    struct DependentVectorType {
      M_template_rtpack(Xs) struct impl;
    };
    struct ExtVectorType {
      M_template_rtpack(Xs) struct impl;
    };
    struct FunctionType {
      M_template_rtpack(Xs) struct impl;
      struct ExtInfo {
        M_template_rtpack(Xs) struct impl;
      };
    };
    struct FunctionNoProtoType {
      M_template_rtpack(Xs) struct impl;
    };
    struct FunctionProtoType {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(getParamTypes,
      constexpr auto getParamTypes() const ,
        (class clang::QualType),
        (reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getParamTypes, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(param_types,
      constexpr auto param_types() const ,
        (const class clang::QualType),
        (reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::param_types, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(exceptions,
      constexpr auto exceptions() const ,
        (class clang::QualType),
        (reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::exceptions, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(getExtParameterInfos,
      constexpr auto getExtParameterInfos() const ,
        (class clang::FunctionProtoType::ExtParameterInfo),
        (reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getExtParameterInfos, Xs...), () )
      struct ExtParameterInfo {
        M_template_rtpack(Xs) struct impl;
      };
      struct ExceptionSpecInfo {
        M_template_rtpack(Xs) struct impl;
      };
      struct ExtProtoInfo {
        M_template_rtpack(Xs) struct impl;
      };
    };
    struct UnresolvedUsingType {
      M_template_rtpack(Xs) struct impl;
    };
    struct TypedefType {
      M_template_rtpack(Xs) struct impl;
    };
    struct TypeOfExprType {
      M_template_rtpack(Xs) struct impl;
    };
    struct TypeOfType {
      M_template_rtpack(Xs) struct impl;
    };
    struct DecltypeType {
      M_template_rtpack(Xs) struct impl;
    };
    struct ReflectedType {
      M_template_rtpack(Xs) struct impl;
    };
    struct UnaryTransformType {
      M_template_rtpack(Xs) struct impl;
      enum UTTKind : unsigned int;
    };
    struct TagType {
      M_template_rtpack(Xs) struct impl;
    };
    struct RecordType {
      M_template_rtpack(Xs) struct impl;
    };
    struct EnumType {
      M_template_rtpack(Xs) struct impl;
    };
    struct AttributedType {
      M_template_rtpack(Xs) struct impl;
      enum Kind : unsigned int;
    };
    struct TemplateTypeParmType {
      M_template_rtpack(Xs) struct impl;
    };
    struct SubstTemplateTypeParmType {
      M_template_rtpack(Xs) struct impl;
    };
    struct SubstTemplateTypeParmPackType {
      M_template_rtpack(Xs) struct impl;
    };
    struct DeducedType {
      M_template_rtpack(Xs) struct impl;
    };
    struct AutoType {
      M_template_rtpack(Xs) struct impl;
    };
    struct DeducedTemplateSpecializationType {
      M_template_rtpack(Xs) struct impl;
    };
    struct TemplateSpecializationType {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(template_arguments,
      constexpr auto template_arguments() const ,
        (class clang::TemplateArgument),
        (reflenums::RK_clang__TemplateSpecializationType, reflenums::clang__TemplateSpecializationType::template_arguments, Xs...), () )
    };
    struct InjectedClassNameType {
      M_template_rtpack(Xs) struct impl;
    };
    enum TagTypeKind : unsigned int;
    enum ElaboratedTypeKeyword : unsigned int;
    struct TypeWithKeyword {
      M_template_rtpack(Xs) struct impl;
    };
    struct ElaboratedType {
      M_template_rtpack(Xs) struct impl;
    };
    struct DependentNameType {
      M_template_rtpack(Xs) struct impl;
    };
    struct DependentTemplateSpecializationType {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(template_arguments,
      constexpr auto template_arguments() const ,
        (class clang::TemplateArgument),
        (reflenums::RK_clang__DependentTemplateSpecializationType, reflenums::clang__DependentTemplateSpecializationType::template_arguments, Xs...), () )
    };
    struct PackExpansionType {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCTypeParamType {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(quals,
      constexpr auto quals() const ,
        (class clang::ObjCProtocolDecl *const),
        (reflenums::RK_clang__ObjCTypeParamType, reflenums::clang__ObjCTypeParamType::quals, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(getProtocols,
      constexpr auto getProtocols() const ,
        (class clang::ObjCProtocolDecl *),
        (reflenums::RK_clang__ObjCTypeParamType, reflenums::clang__ObjCTypeParamType::getProtocols, Xs...), () )
    };
    struct ObjCObjectType {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(quals,
      constexpr auto quals() const ,
        (class clang::ObjCProtocolDecl *const),
        (reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::quals, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(getProtocols,
      constexpr auto getProtocols() const ,
        (class clang::ObjCProtocolDecl *),
        (reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::getProtocols, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(getTypeArgs,
      constexpr auto getTypeArgs() const ,
        (class clang::QualType),
        (reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::getTypeArgs, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(getTypeArgsAsWritten,
      constexpr auto getTypeArgsAsWritten() const ,
        (class clang::QualType),
        (reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::getTypeArgsAsWritten, Xs...), () )
    };
    struct ObjCInterfaceType {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCObjectPointerType {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(getTypeArgs,
      constexpr auto getTypeArgs() const ,
        (class clang::QualType),
        (reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::getTypeArgs, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(getTypeArgsAsWritten,
      constexpr auto getTypeArgsAsWritten() const ,
        (class clang::QualType),
        (reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::getTypeArgsAsWritten, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(quals,
      constexpr auto quals() const ,
        (class clang::ObjCProtocolDecl *const),
        (reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::quals, Xs...), () )
    };
    struct AtomicType {
      M_template_rtpack(Xs) struct impl;
    };
    struct PipeType {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    enum OverloadedOperatorKind : int;
  }

  namespace clang {
    enum PragmaMSCommentKind : unsigned int;
  }

  namespace clang {
    struct TypeSourceInfo {
      M_template_rtpack(Xs) struct impl;
    };
    struct TranslationUnitDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct PragmaCommentDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct PragmaDetectMismatchDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct ExternCContextDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct NamedDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct LabelDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct NamespaceDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct ValueDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct DeclaratorDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct EvaluatedStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct VarDecl {
      M_template_rtpack(Xs) struct impl;
      enum InitializationStyle : unsigned int;
      enum TLSKind : unsigned int;
      enum DefinitionKind : unsigned int;
    };
    struct ImplicitParamDecl {
      M_template_rtpack(Xs) struct impl;
      enum ImplicitParamKind : unsigned int;
    };
    struct ParmVarDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct FunctionDecl {
      M_template_rtpack(Xs) struct impl;
      enum TemplatedKind : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(parameters,
      constexpr auto parameters() const ,
        (class clang::ParmVarDecl *),
        (reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::parameters, Xs...), () )
    };
    struct FieldDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct EnumConstantDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct IndirectFieldDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(chain,
      constexpr auto chain() const ,
        (class clang::NamedDecl *),
        (reflenums::RK_clang__IndirectFieldDecl, reflenums::clang__IndirectFieldDecl::chain, Xs...), () )
    };
    struct TypeDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct TypedefNameDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct TypedefDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct TypeAliasDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct TagDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct EnumDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(enumerators,
      constexpr auto enumerators() const ,
        (class clang::EnumConstantDecl *),
        (reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::enumerators, Xs...), () )
    };
    struct RecordDecl {
      M_template_rtpack(Xs) struct impl;
      enum ArgPassingKind : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(fields,
      constexpr auto fields() const ,
        (class clang::FieldDecl *),
        (reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::fields, Xs...), () )
    };
    struct FileScopeAsmDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct BlockDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(parameters,
      constexpr auto parameters() const ,
        (class clang::ParmVarDecl *),
        (reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::parameters, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(captures,
      constexpr auto captures() const ,
        (class clang::BlockDecl::Capture),
        (reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::captures, Xs...), () )
      struct Capture {
        M_template_rtpack(Xs) struct impl;
      };
    };
    struct CapturedDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(parameters,
      constexpr auto parameters() const ,
        (class clang::ImplicitParamDecl *),
        (reflenums::RK_clang__CapturedDecl, reflenums::clang__CapturedDecl::parameters, Xs...), () )
    };
    struct ImportDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(getIdentifierLocs,
      constexpr auto getIdentifierLocs() const ,
        (class clang::SourceLocation),
        (reflenums::RK_clang__ImportDecl, reflenums::clang__ImportDecl::getIdentifierLocs, Xs...), () )
    };
    struct ExportDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct EmptyDecl {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct DeclGroup {
      M_template_rtpack(Xs) struct impl;
    };
    struct DeclGroupRef {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
  }

  namespace clang {
    enum CapturedRegionKind : unsigned int;
  }

  namespace clang {
    struct Stmt {
      M_template_rtpack(Xs) struct impl;
      enum StmtClass : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__Stmt, reflenums::clang__Stmt::children, Xs...), () )
      struct EmptyShell {
        M_template_rtpack(Xs) struct impl;
      };
    };
    struct DeclStmt {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(decls,
      constexpr auto decls() const ,
        (class clang::Decl *const),
        (reflenums::RK_clang__DeclStmt, reflenums::clang__DeclStmt::decls, Xs...), () )
    };
    struct NullStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct CompoundStmt {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(body,
      constexpr auto body() const ,
        (class clang::Stmt *const),
        (reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::body, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::children, Xs...), () )
    };
    struct SwitchCase {
      M_template_rtpack(Xs) struct impl;
    };
    struct CaseStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct DefaultStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct LabelStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct AttributedStmt {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(getAttrs,
      constexpr auto getAttrs() const ,
        (const class clang::Attr *),
        (reflenums::RK_clang__AttributedStmt, reflenums::clang__AttributedStmt::getAttrs, Xs...), () )
    };
    struct IfStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct SwitchStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct WhileStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct DoStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct ForStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct GotoStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct IndirectGotoStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct ContinueStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct BreakStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct ReturnStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct AsmStmt {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(inputs,
      constexpr auto inputs() const ,
        (const class clang::Expr *const),
        (reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::inputs, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(outputs,
      constexpr auto outputs() const ,
        (const class clang::Expr *const),
        (reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::outputs, Xs...), () )
    };
    struct GCCAsmStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct MSAsmStmt {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(getAllConstraints,
      constexpr auto getAllConstraints() const ,
        (class llvm::StringRef),
        (reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getAllConstraints, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(getClobbers,
      constexpr auto getClobbers() const ,
        (class llvm::StringRef),
        (reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getClobbers, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(getAllExprs,
      constexpr auto getAllExprs() const ,
        (class clang::Expr *),
        (reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getAllExprs, Xs...), () )
    };
    struct SEHExceptStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct SEHFinallyStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct SEHTryStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct SEHLeaveStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct CapturedStmt {
      M_template_rtpack(Xs) struct impl;
      enum VariableCaptureKind : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(captures,
      constexpr auto captures() const ,
        (const class clang::CapturedStmt::Capture),
        (reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::captures, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(capture_inits,
      constexpr auto capture_inits() const ,
        (class clang::Expr *const),
        (reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::capture_inits, Xs...), () )
      struct Capture {
        M_template_rtpack(Xs) struct impl;
      };
    };
  }

  namespace clang {
    struct TemplateArgument {
      M_template_rtpack(Xs) struct impl;
      enum ArgKind : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(pack_elements,
      constexpr auto pack_elements() const ,
        (class clang::TemplateArgument),
        (reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::pack_elements, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(getPackAsArray,
      constexpr auto getPackAsArray() const ,
        (class clang::TemplateArgument),
        (reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getPackAsArray, Xs...), () )
    };
    struct TemplateArgumentLocInfo {
      M_template_rtpack(Xs) struct impl;
    };
    struct TemplateArgumentLoc {
      M_template_rtpack(Xs) struct impl;
    };
    struct TemplateArgumentListInfo {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(arguments,
      constexpr auto arguments() const ,
        (class clang::TemplateArgumentLoc),
        (reflenums::RK_clang__TemplateArgumentListInfo, reflenums::clang__TemplateArgumentListInfo::arguments, Xs...), () )
    };
    struct ASTTemplateArgumentListInfo {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(arguments,
      constexpr auto arguments() const ,
        (class clang::TemplateArgumentLoc),
        (reflenums::RK_clang__ASTTemplateArgumentListInfo, reflenums::clang__ASTTemplateArgumentListInfo::arguments, Xs...), () )
    };
  }

  namespace clang {
    struct TypeLoc {
      M_template_rtpack(Xs) struct impl;
      enum TypeLocClass : unsigned int;
    };
    struct UnqualTypeLoc {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
    struct CommentOptions {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {

    namespace comments {
      struct CommandInfo {
        M_template_rtpack(Xs) struct impl;
      };
      struct CommandTraits {
        M_template_rtpack(Xs) struct impl;
      };
    }
  }

  namespace clang {
  }

  namespace llvm {
    struct Triple {
      M_template_rtpack(Xs) struct impl;
      enum ArchType : unsigned int;
      enum SubArchType : unsigned int;
      enum VendorType : unsigned int;
      enum OSType : unsigned int;
      enum EnvironmentType : unsigned int;
      enum ObjectFormatType : unsigned int;
    };
  }

  namespace clang {
    struct ObjCRuntime {
      M_template_rtpack(Xs) struct impl;
      enum Kind : unsigned int;
    };
  }

  namespace clang {
    struct SanitizerSet {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct LangOptionsBase {
      M_template_rtpack(Xs) struct impl;
    };
    struct LangOptions {
      M_template_rtpack(Xs) struct impl;
      enum GCMode : unsigned int;
      enum StackProtectorMode : unsigned int;
      enum SignedOverflowBehaviorTy : unsigned int;
      enum CompilingModuleKind : unsigned int;
      enum PragmaMSPointersToMembersKind : unsigned int;
      enum DefaultCallingConvention : unsigned int;
      enum AddrSpaceMapMangling : unsigned int;
      enum MSVCMajorVersion : unsigned int;
      enum class ClangABI : int;
      enum FPContractModeKind : unsigned int;
    };
    struct FPOptions {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct PrinterHelper {
      M_template_rtpack(Xs) struct impl;
    };
    struct PrintingPolicy {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {

    namespace SrcMgr {
      enum CharacteristicKind : unsigned int;
      struct ContentCache {
        M_template_rtpack(Xs) struct impl;
      };
      struct FileInfo {
        M_template_rtpack(Xs) struct impl;
      };
      struct ExpansionInfo {
        M_template_rtpack(Xs) struct impl;
      };
      struct SLocEntry {
        M_template_rtpack(Xs) struct impl;
      };
    }
    struct SourceManager {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct RawComment {
      M_template_rtpack(Xs) struct impl;
      enum CommentKind : unsigned int;
    };
  }

  namespace clang {
  }

  namespace clang {
    struct SanitizerBlacklist {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct TargetCXXABI {
      M_template_rtpack(Xs) struct impl;
      enum Kind : unsigned int;
      enum TailPaddingUseRules : unsigned int;
    };
  }

  namespace clang {
    struct OpenCLOptions {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace llvm {
    enum class EABI : int;
  }

  namespace clang {
    struct TargetOptions {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace llvm {
    struct Type {
      M_template_rtpack(Xs) struct impl;
      enum TypeID : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(subtypes,
      constexpr auto subtypes() const ,
        (class llvm::Type *),
        (reflenums::RK_llvm__Type, reflenums::llvm__Type::subtypes, Xs...), () )
    };
  }

  namespace llvm {
    struct IntegerType {
      M_template_rtpack(Xs) struct impl;
    };
    struct CompositeType {
      M_template_rtpack(Xs) struct impl;
    };
    struct StructType {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(elements,
      constexpr auto elements() const ,
        (class llvm::Type *),
        (reflenums::RK_llvm__StructType, reflenums::llvm__StructType::elements, Xs...), () )
    };
    struct PointerType {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace llvm {
    struct DataLayout {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(getNonIntegralAddressSpaces,
      constexpr auto getNonIntegralAddressSpaces() const ,
        (unsigned int),
        (reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getNonIntegralAddressSpaces, Xs...), () )
    };
    struct StructLayout {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct TargetInfo {
      M_template_rtpack(Xs) struct impl;
      enum IntType : unsigned int;
      enum RealType : unsigned int;
      enum BuiltinVaListKind : unsigned int;
      enum CallingConvMethodType : unsigned int;
      enum CallingConvCheckResult : unsigned int;
      enum CallingConvKind : unsigned int;
      enum OpenCLTypeKind : unsigned int;
      struct ConstraintInfo {
        M_template_rtpack(Xs) struct impl;
      };
    };
  }

  namespace clang {
    struct XRayFunctionFilter {
      M_template_rtpack(Xs) struct impl;
      enum class ImbueAttribute : int;
    };
  }

  namespace clang {
    struct TypeInfo {
      M_template_rtpack(Xs) struct impl;
    };
    struct ASTContext {
      M_template_rtpack(Xs) struct impl;
      enum class InlineVariableDefinitionKind : int;
    DEF_RANGE_REFLECTION_TUPLE(local_imports,
      constexpr auto local_imports() const ,
        (class clang::ImportDecl *),
        (reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::local_imports, Xs...), () )
    };
  }

  namespace clang {
  }

  namespace clang {
    struct DeclAccessPair {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct UnresolvedSetIterator {
      M_template_rtpack(Xs) struct impl;
    };
    struct UnresolvedSetImpl {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
  }

  namespace clang {
    enum CastKind : unsigned int;
    enum BinaryOperatorKind : unsigned int;
    enum UnaryOperatorKind : unsigned int;
    enum ObjCBridgeCastKind : unsigned int;
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
    enum TypeTrait : unsigned int;
    enum ArrayTypeTrait : unsigned int;
    enum UnaryExprOrTypeTrait : unsigned int;
  }

  namespace clang {
    struct Expr {
      M_template_rtpack(Xs) struct impl;
      enum LValueClassification : unsigned int;
      enum isModifiableLvalueResult : unsigned int;
      enum SideEffectsKind : unsigned int;
      enum ConstExprUsage : unsigned int;
      enum NullPointerConstantKind : unsigned int;
      enum NullPointerConstantValueDependence : unsigned int;
      struct Classification {
        M_template_rtpack(Xs) struct impl;
        enum Kinds : unsigned int;
        enum ModifiableType : unsigned int;
      };
      struct EvalStatus {
        M_template_rtpack(Xs) struct impl;
      };
      struct EvalResult {
        M_template_rtpack(Xs) struct impl;
      };
    };
    struct OpaqueValueExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__OpaqueValueExpr, reflenums::clang__OpaqueValueExpr::children, Xs...), () )
    };
    struct DeclRefExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(template_arguments,
      constexpr auto template_arguments() const ,
        (class clang::TemplateArgumentLoc),
        (reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::template_arguments, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::children, Xs...), () )
    };
    struct PredefinedExpr {
      M_template_rtpack(Xs) struct impl;
      enum IdentType : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__PredefinedExpr, reflenums::clang__PredefinedExpr::children, Xs...), () )
    };
    struct APIntStorage {
      M_template_rtpack(Xs) struct impl;
    };
    struct IntegerLiteral {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__IntegerLiteral, reflenums::clang__IntegerLiteral::children, Xs...), () )
    };
    struct FixedPointLiteral {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__FixedPointLiteral, reflenums::clang__FixedPointLiteral::children, Xs...), () )
    };
    struct CharacterLiteral {
      M_template_rtpack(Xs) struct impl;
      enum CharacterKind : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__CharacterLiteral, reflenums::clang__CharacterLiteral::children, Xs...), () )
    };
    struct FloatingLiteral {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__FloatingLiteral, reflenums::clang__FloatingLiteral::children, Xs...), () )
    };
    struct ImaginaryLiteral {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__ImaginaryLiteral, reflenums::clang__ImaginaryLiteral::children, Xs...), () )
    };
    struct StringLiteral {
      M_template_rtpack(Xs) struct impl;
      enum StringKind : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::children, Xs...), () )
    };
    struct ParenExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__ParenExpr, reflenums::clang__ParenExpr::children, Xs...), () )
    };
    struct UnaryOperator {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::children, Xs...), () )
    };
    struct OffsetOfNode {
      M_template_rtpack(Xs) struct impl;
      enum Kind : unsigned int;
    };
    struct OffsetOfExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::children, Xs...), () )
    };
    struct UnaryExprOrTypeTraitExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::children, Xs...), () )
    };
    struct ArraySubscriptExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__ArraySubscriptExpr, reflenums::clang__ArraySubscriptExpr::children, Xs...), () )
    };
    struct CallExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(arguments,
      constexpr auto arguments() const ,
        (const class clang::Expr *const),
        (reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::arguments, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::children, Xs...), () )
    };
    struct MemberExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(template_arguments,
      constexpr auto template_arguments() const ,
        (class clang::TemplateArgumentLoc),
        (reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::template_arguments, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::children, Xs...), () )
    };
    struct CompoundLiteralExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__CompoundLiteralExpr, reflenums::clang__CompoundLiteralExpr::children, Xs...), () )
    };
    struct CastExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::children, Xs...), () )
    };
    struct ImplicitCastExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ExplicitCastExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CStyleCastExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct BinaryOperator {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::children, Xs...), () )
    };
    struct CompoundAssignOperator {
      M_template_rtpack(Xs) struct impl;
    };
    struct AbstractConditionalOperator {
      M_template_rtpack(Xs) struct impl;
    };
    struct ConditionalOperator {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__ConditionalOperator, reflenums::clang__ConditionalOperator::children, Xs...), () )
    };
    struct BinaryConditionalOperator {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__BinaryConditionalOperator, reflenums::clang__BinaryConditionalOperator::children, Xs...), () )
    };
    struct AddrLabelExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__AddrLabelExpr, reflenums::clang__AddrLabelExpr::children, Xs...), () )
    };
    struct StmtExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__StmtExpr, reflenums::clang__StmtExpr::children, Xs...), () )
    };
    struct ShuffleVectorExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__ShuffleVectorExpr, reflenums::clang__ShuffleVectorExpr::children, Xs...), () )
    };
    struct ConvertVectorExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__ConvertVectorExpr, reflenums::clang__ConvertVectorExpr::children, Xs...), () )
    };
    struct ChooseExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::children, Xs...), () )
    };
    struct GNUNullExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__GNUNullExpr, reflenums::clang__GNUNullExpr::children, Xs...), () )
    };
    struct VAArgExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__VAArgExpr, reflenums::clang__VAArgExpr::children, Xs...), () )
    };
    struct InitListExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(inits,
      constexpr auto inits() const ,
        (class clang::Expr *),
        (reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::inits, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::children, Xs...), () )
    };
    struct DesignatedInitExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(designators,
      constexpr auto designators() const ,
        (class clang::DesignatedInitExpr::Designator),
        (reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::designators, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::children, Xs...), () )
      struct Designator {
        M_template_rtpack(Xs) struct impl;
      };
    };
    struct NoInitExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__NoInitExpr, reflenums::clang__NoInitExpr::children, Xs...), () )
    };
    struct DesignatedInitUpdateExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__DesignatedInitUpdateExpr, reflenums::clang__DesignatedInitUpdateExpr::children, Xs...), () )
    };
    struct ArrayInitLoopExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__ArrayInitLoopExpr, reflenums::clang__ArrayInitLoopExpr::children, Xs...), () )
    };
    struct ArrayInitIndexExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__ArrayInitIndexExpr, reflenums::clang__ArrayInitIndexExpr::children, Xs...), () )
    };
    struct ImplicitValueInitExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__ImplicitValueInitExpr, reflenums::clang__ImplicitValueInitExpr::children, Xs...), () )
    };
    struct ParenListExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__ParenListExpr, reflenums::clang__ParenListExpr::children, Xs...), () )
    };
    struct GenericSelectionExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(getAssocExprs,
      constexpr auto getAssocExprs() const ,
        (class clang::Expr *),
        (reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getAssocExprs, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(getAssocTypeSourceInfos,
      constexpr auto getAssocTypeSourceInfos() const ,
        (class clang::TypeSourceInfo *),
        (reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getAssocTypeSourceInfos, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::children, Xs...), () )
    };
    struct ExtVectorElementExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__ExtVectorElementExpr, reflenums::clang__ExtVectorElementExpr::children, Xs...), () )
    };
    struct BlockExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__BlockExpr, reflenums::clang__BlockExpr::children, Xs...), () )
    };
    struct AsTypeExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__AsTypeExpr, reflenums::clang__AsTypeExpr::children, Xs...), () )
    };
    struct PseudoObjectExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(semantics,
      constexpr auto semantics() const ,
        (const class clang::Expr *const),
        (reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::semantics, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::children, Xs...), () )
    };
    struct AtomicExpr {
      M_template_rtpack(Xs) struct impl;
      enum AtomicOp : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::children, Xs...), () )
    };
    struct TypoExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__TypoExpr, reflenums::clang__TypoExpr::children, Xs...), () )
    };
  }

  namespace clang {

    namespace attr {
      enum Kind : unsigned int;
    }
  }

  namespace clang {
    enum OpenMPDirectiveKind : unsigned int;
    enum OpenMPClauseKind : unsigned int;
  }

  namespace clang {
    struct Attr {
      M_template_rtpack(Xs) struct impl;
    };
    struct InheritableAttr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ExternalSourceSymbolAttr {
      M_template_rtpack(Xs) struct impl;
    };
    struct MSInheritanceAttr {
      M_template_rtpack(Xs) struct impl;
      enum Spelling : unsigned int;
    };
    struct MSVtorDispAttr {
      M_template_rtpack(Xs) struct impl;
      enum Mode : unsigned int;
    };
  }

  namespace clang {
    enum LambdaCaptureDefault : unsigned int;
    enum LambdaCaptureKind : unsigned int;
  }

  namespace clang {
    struct LambdaCapture {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
    struct AccessSpecDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXBaseSpecifier {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXRecordDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(bases,
      constexpr auto bases() const ,
        (const class clang::CXXBaseSpecifier),
        (reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::bases, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(vbases,
      constexpr auto vbases() const ,
        (const class clang::CXXBaseSpecifier),
        (reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::vbases, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(methods,
      constexpr auto methods() const ,
        (class clang::CXXMethodDecl *),
        (reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::methods, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(ctors,
      constexpr auto ctors() const ,
        (class clang::CXXConstructorDecl *),
        (reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::ctors, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(friends,
      constexpr auto friends() const ,
        (class clang::FriendDecl *),
        (reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::friends, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(captures,
      constexpr auto captures() const ,
        (const class clang::LambdaCapture),
        (reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::captures, Xs...), () )
    };
    struct CXXDeductionGuideDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXMethodDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXCtorInitializer {
      M_template_rtpack(Xs) struct impl;
    };
    struct InheritedConstructor {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXConstructorDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(inits,
      constexpr auto inits() const ,
        (class clang::CXXCtorInitializer *const),
        (reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::inits, Xs...), () )
    };
    struct CXXDestructorDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXConversionDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct LinkageSpecDecl {
      M_template_rtpack(Xs) struct impl;
      enum LanguageIDs : unsigned int;
    };
    struct UsingDirectiveDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct NamespaceAliasDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct UsingShadowDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct ConstructorUsingShadowDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct UsingDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(shadows,
      constexpr auto shadows() const ,
        (class clang::UsingShadowDecl *),
        (reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::shadows, Xs...), () )
    };
    struct UsingPackDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(expansions,
      constexpr auto expansions() const ,
        (class clang::NamedDecl *),
        (reflenums::RK_clang__UsingPackDecl, reflenums::clang__UsingPackDecl::expansions, Xs...), () )
    };
    struct UnresolvedUsingValueDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct UnresolvedUsingTypenameDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct StaticAssertDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct BindingDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct DecompositionDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(bindings,
      constexpr auto bindings() const ,
        (class clang::BindingDecl *),
        (reflenums::RK_clang__DecompositionDecl, reflenums::clang__DecompositionDecl::bindings, Xs...), () )
    };
    struct MSPropertyDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct ConstexprDecl {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct TemplateParameterList {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(asArray,
      constexpr auto asArray() const ,
        (const class clang::NamedDecl *),
        (reflenums::RK_clang__TemplateParameterList, reflenums::clang__TemplateParameterList::asArray, Xs...), () )
    };
    struct TemplateArgumentList {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(asArray,
      constexpr auto asArray() const ,
        (class clang::TemplateArgument),
        (reflenums::RK_clang__TemplateArgumentList, reflenums::clang__TemplateArgumentList::asArray, Xs...), () )
    };
    struct TemplateDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct FunctionTemplateSpecializationInfo {
      M_template_rtpack(Xs) struct impl;
    };
    struct MemberSpecializationInfo {
      M_template_rtpack(Xs) struct impl;
    };
    struct DependentFunctionTemplateSpecializationInfo {
      M_template_rtpack(Xs) struct impl;
    };
    struct RedeclarableTemplateDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct FunctionTemplateDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(specializations,
      constexpr auto specializations() const ,
        (class clang::FunctionDecl *),
        (reflenums::RK_clang__FunctionTemplateDecl, reflenums::clang__FunctionTemplateDecl::specializations, Xs...), () )
    };
    struct TemplateTypeParmDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct NonTypeTemplateParmDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct TemplateTemplateParmDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct BuiltinTemplateDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct ClassTemplateSpecializationDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct ClassTemplatePartialSpecializationDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct ClassTemplateDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(specializations,
      constexpr auto specializations() const ,
        (class clang::ClassTemplateSpecializationDecl *),
        (reflenums::RK_clang__ClassTemplateDecl, reflenums::clang__ClassTemplateDecl::specializations, Xs...), () )
    };
    struct FriendTemplateDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct TypeAliasTemplateDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct ClassScopeFunctionSpecializationDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct VarTemplateSpecializationDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct VarTemplatePartialSpecializationDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct VarTemplateDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(specializations,
      constexpr auto specializations() const ,
        (class clang::VarTemplateSpecializationDecl *),
        (reflenums::RK_clang__VarTemplateDecl, reflenums::clang__VarTemplateDecl::specializations, Xs...), () )
    };
  }

  namespace clang {
    struct FriendDecl {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
  }

  namespace clang {
    struct ObjCListBase {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCProtocolList {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCMethodDecl {
      M_template_rtpack(Xs) struct impl;
      enum ImplementationControl : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(parameters,
      constexpr auto parameters() const ,
        (class clang::ParmVarDecl *),
        (reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::parameters, Xs...), () )
    };
    enum class ObjCTypeParamVariance : uint8_t;
    struct ObjCTypeParamDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCTypeParamList {
      M_template_rtpack(Xs) struct impl;
    };
    enum class ObjCPropertyQueryKind : uint8_t;
    struct ObjCPropertyDecl {
      M_template_rtpack(Xs) struct impl;
      enum PropertyAttributeKind : unsigned int;
      enum SetterKind : unsigned int;
      enum PropertyControl : unsigned int;
    };
    struct ObjCContainerDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(properties,
      constexpr auto properties() const ,
        (class clang::ObjCPropertyDecl *),
        (reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::properties, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(instance_properties,
      constexpr auto instance_properties() const ,
        (class clang::ObjCPropertyDecl *),
        (reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::instance_properties, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(class_properties,
      constexpr auto class_properties() const ,
        (class clang::ObjCPropertyDecl *),
        (reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::class_properties, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(methods,
      constexpr auto methods() const ,
        (class clang::ObjCMethodDecl *),
        (reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::methods, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(instance_methods,
      constexpr auto instance_methods() const ,
        (class clang::ObjCMethodDecl *),
        (reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::instance_methods, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(class_methods,
      constexpr auto class_methods() const ,
        (class clang::ObjCMethodDecl *),
        (reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::class_methods, Xs...), () )
    };
    struct ObjCInterfaceDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(protocols,
      constexpr auto protocols() const ,
        (class clang::ObjCProtocolDecl *const),
        (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::protocols, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(protocol_locs,
      constexpr auto protocol_locs() const ,
        (const class clang::SourceLocation),
        (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::protocol_locs, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(all_referenced_protocols,
      constexpr auto all_referenced_protocols() const ,
        (class clang::ObjCProtocolDecl *const),
        (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::all_referenced_protocols, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(ivars,
      constexpr auto ivars() const ,
        (class clang::ObjCIvarDecl *),
        (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::ivars, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(visible_categories,
      constexpr auto visible_categories() const ,
        (class clang::ObjCCategoryDecl *),
        (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::visible_categories, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(known_categories,
      constexpr auto known_categories() const ,
        (class clang::ObjCCategoryDecl *),
        (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::known_categories, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(visible_extensions,
      constexpr auto visible_extensions() const ,
        (class clang::ObjCCategoryDecl *),
        (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::visible_extensions, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(known_extensions,
      constexpr auto known_extensions() const ,
        (class clang::ObjCCategoryDecl *),
        (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::known_extensions, Xs...), () )
    };
    struct ObjCIvarDecl {
      M_template_rtpack(Xs) struct impl;
      enum AccessControl : unsigned int;
    };
    struct ObjCAtDefsFieldDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCProtocolDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(protocols,
      constexpr auto protocols() const ,
        (class clang::ObjCProtocolDecl *const),
        (reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::protocols, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(protocol_locs,
      constexpr auto protocol_locs() const ,
        (const class clang::SourceLocation),
        (reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::protocol_locs, Xs...), () )
    };
    struct ObjCCategoryDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(protocols,
      constexpr auto protocols() const ,
        (class clang::ObjCProtocolDecl *const),
        (reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::protocols, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(protocol_locs,
      constexpr auto protocol_locs() const ,
        (const class clang::SourceLocation),
        (reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::protocol_locs, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(ivars,
      constexpr auto ivars() const ,
        (class clang::ObjCIvarDecl *),
        (reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::ivars, Xs...), () )
    };
    struct ObjCImplDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(property_impls,
      constexpr auto property_impls() const ,
        (class clang::ObjCPropertyImplDecl *),
        (reflenums::RK_clang__ObjCImplDecl, reflenums::clang__ObjCImplDecl::property_impls, Xs...), () )
    };
    struct ObjCCategoryImplDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCImplementationDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(inits,
      constexpr auto inits() const ,
        (class clang::CXXCtorInitializer *const),
        (reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::inits, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(ivars,
      constexpr auto ivars() const ,
        (class clang::ObjCIvarDecl *),
        (reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::ivars, Xs...), () )
    };
    struct ObjCCompatibleAliasDecl {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCPropertyImplDecl {
      M_template_rtpack(Xs) struct impl;
      enum Kind : unsigned int;
    };
  }

  namespace clang {
    struct OMPThreadPrivateDecl {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(varlists,
      constexpr auto varlists() const ,
        (const class clang::Expr *const),
        (reflenums::RK_clang__OMPThreadPrivateDecl, reflenums::clang__OMPThreadPrivateDecl::varlists, Xs...), () )
    };
    struct OMPDeclareReductionDecl {
      M_template_rtpack(Xs) struct impl;
      enum InitKind : unsigned int;
    };
    struct OMPCapturedExprDecl {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    enum ExpressionTrait : unsigned int;
  }

  namespace clang {
    struct CXXOperatorCallExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXMemberCallExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CUDAKernelCallExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXNamedCastExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXStaticCastExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXDynamicCastExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXReinterpretCastExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXConstCastExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct UserDefinedLiteral {
      M_template_rtpack(Xs) struct impl;
      enum LiteralOperatorKind : unsigned int;
    };
    struct CXXBoolLiteralExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXNullPtrLiteralExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXStdInitializerListExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXTypeidExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct MSPropertyRefExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct MSPropertySubscriptExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXUuidofExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXThisExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXThrowExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXDefaultArgExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXDefaultInitExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXTemporary {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXBindTemporaryExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXConstructExpr {
      M_template_rtpack(Xs) struct impl;
      enum ConstructionKind : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(arguments,
      constexpr auto arguments() const ,
        (const class clang::Expr *const),
        (reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::arguments, Xs...), () )
    };
    struct CXXInheritedCtorInitExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXFunctionalCastExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXTemporaryObjectExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct LambdaExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(captures,
      constexpr auto captures() const ,
        (const class clang::LambdaCapture),
        (reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::captures, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(explicit_captures,
      constexpr auto explicit_captures() const ,
        (const class clang::LambdaCapture),
        (reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::explicit_captures, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(implicit_captures,
      constexpr auto implicit_captures() const ,
        (const class clang::LambdaCapture),
        (reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::implicit_captures, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(capture_inits,
      constexpr auto capture_inits() const ,
        (class clang::Expr *const),
        (reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::capture_inits, Xs...), () )
    };
    struct CXXScalarValueInitExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXNewExpr {
      M_template_rtpack(Xs) struct impl;
      enum InitializationStyle : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(placement_arguments,
      constexpr auto placement_arguments() const ,
        (const class clang::Expr *const),
        (reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::placement_arguments, Xs...), () )
    };
    struct CXXDeleteExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXPseudoDestructorExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct TypeTraitExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(getArgs,
      constexpr auto getArgs() const ,
        (class clang::TypeSourceInfo *),
        (reflenums::RK_clang__TypeTraitExpr, reflenums::clang__TypeTraitExpr::getArgs, Xs...), () )
    };
    struct ArrayTypeTraitExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ExpressionTraitExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct OverloadExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(decls,
      constexpr auto decls() const ,
        (class clang::NamedDecl *),
        (reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::decls, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(template_arguments,
      constexpr auto template_arguments() const ,
        (class clang::TemplateArgumentLoc),
        (reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::template_arguments, Xs...), () )
      struct FindResult {
        M_template_rtpack(Xs) struct impl;
      };
    };
    struct UnresolvedLookupExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct DependentScopeDeclRefExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(template_arguments,
      constexpr auto template_arguments() const ,
        (class clang::TemplateArgumentLoc),
        (reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::template_arguments, Xs...), () )
    };
    struct ExprWithCleanups {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(getObjects,
      constexpr auto getObjects() const ,
        (class clang::BlockDecl *),
        (reflenums::RK_clang__ExprWithCleanups, reflenums::clang__ExprWithCleanups::getObjects, Xs...), () )
    };
    struct CXXUnresolvedConstructExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXDependentScopeMemberExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(template_arguments,
      constexpr auto template_arguments() const ,
        (class clang::TemplateArgumentLoc),
        (reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::template_arguments, Xs...), () )
    };
    struct UnresolvedMemberExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXNoexceptExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct PackExpansionExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct SizeOfPackExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(getPartialArguments,
      constexpr auto getPartialArguments() const ,
        (class clang::TemplateArgument),
        (reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::getPartialArguments, Xs...), () )
    };
    struct SubstNonTypeTemplateParmExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct SubstNonTypeTemplateParmPackExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct FunctionParmPackExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct MaterializeTemporaryExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXFoldExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CoroutineSuspendExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CoawaitExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct DependentCoawaitExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CoyieldExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ReflectionExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CompilerMessageExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CompilerDiagnosticExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(getArgs,
      constexpr auto getArgs() const ,
        (const class clang::Expr *),
        (reflenums::RK_clang__CompilerDiagnosticExpr, reflenums::clang__CompilerDiagnosticExpr::getArgs, Xs...), () )
    };
    struct CXXMetaparseExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ReflectionTraitExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ReflectNewExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ReflectDeleteExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXConstantExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__CXXConstantExpr, reflenums::clang__CXXConstantExpr::children, Xs...), () )
    };
    struct CXXDependentIdExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__CXXDependentIdExpr, reflenums::clang__CXXDependentIdExpr::children, Xs...), () )
    };
    struct CXXConcatenateExpr {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__CXXConcatenateExpr, reflenums::clang__CXXConcatenateExpr::children, Xs...), () )
    };
  }

  namespace clang {
    struct ObjCStringLiteral {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCBoolLiteralExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCBoxedExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCArrayLiteral {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCDictionaryElement {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct ObjCDictionaryLiteral {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCEncodeExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCSelectorExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCProtocolExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCIvarRefExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCPropertyRefExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCSubscriptRefExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCMessageExpr {
      M_template_rtpack(Xs) struct impl;
      enum ReceiverKind : unsigned int;
    DEF_RANGE_REFLECTION_TUPLE(arguments,
      constexpr auto arguments() const ,
        (const class clang::Expr *const),
        (reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::arguments, Xs...), () )
    };
    struct ObjCIsaExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCIndirectCopyRestoreExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCBridgedCastExpr {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCAvailabilityCheckExpr {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct OMPArraySectionExpr {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct CXXCatchStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXTryStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXForRangeStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXExpansionStmt {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(getInstantiatedStatements,
      constexpr auto getInstantiatedStatements() const ,
        (class clang::Stmt *),
        (reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getInstantiatedStatements, Xs...), () )
    };
    struct CXXTupleExpansionStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXPackExpansionStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct MSDependentExistsStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct CoroutineBodyStmt {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(getParamMoves,
      constexpr auto getParamMoves() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getParamMoves, Xs...), () )
      struct CtorArgs {
        M_template_rtpack(Xs) struct impl;
      };
    };
    struct CoreturnStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct CXXQueueMetaparseStmt {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct ObjCForCollectionStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCAtCatchStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCAtFinallyStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCAtTryStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCAtSynchronizedStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCAtThrowStmt {
      M_template_rtpack(Xs) struct impl;
    };
    struct ObjCAutoreleasePoolStmt {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct OMPClause {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(children,
      constexpr auto children() const ,
        (const class clang::Stmt *),
        (reflenums::RK_clang__OMPClause, reflenums::clang__OMPClause::children, Xs...), () )
    };
  }

  namespace clang {
    struct OMPExecutableDirective {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(clauses,
      constexpr auto clauses() const ,
        (class clang::OMPClause *),
        (reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::clauses, Xs...), () )
    };
    struct OMPParallelDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPLoopDirective {
      M_template_rtpack(Xs) struct impl;
    DEF_RANGE_REFLECTION_TUPLE(counters,
      constexpr auto counters() const ,
        (class clang::Expr *),
        (reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::counters, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(private_counters,
      constexpr auto private_counters() const ,
        (class clang::Expr *),
        (reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::private_counters, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(inits,
      constexpr auto inits() const ,
        (class clang::Expr *),
        (reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::inits, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(updates,
      constexpr auto updates() const ,
        (class clang::Expr *),
        (reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::updates, Xs...), () )
    DEF_RANGE_REFLECTION_TUPLE(finals,
      constexpr auto finals() const ,
        (class clang::Expr *),
        (reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::finals, Xs...), () )
    };
    struct OMPSimdDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPForDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPForSimdDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPSectionsDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPSectionDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPSingleDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPMasterDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPCriticalDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPParallelForDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPParallelForSimdDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPParallelSectionsDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTaskDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTaskyieldDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPBarrierDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTaskwaitDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTaskgroupDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPFlushDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPOrderedDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPAtomicDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetDataDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetEnterDataDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetExitDataDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetParallelDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetParallelForDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTeamsDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPCancellationPointDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPCancelDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTaskLoopDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTaskLoopSimdDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPDistributeDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetUpdateDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPDistributeParallelForDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPDistributeParallelForSimdDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPDistributeSimdDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetParallelForSimdDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetSimdDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTeamsDistributeDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTeamsDistributeSimdDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTeamsDistributeParallelForSimdDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTeamsDistributeParallelForDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetTeamsDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetTeamsDistributeDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetTeamsDistributeParallelForDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetTeamsDistributeParallelForSimdDirective {
      M_template_rtpack(Xs) struct impl;
    };
    struct OMPTargetTeamsDistributeSimdDirective {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
    struct StoredDeclsMap {
      M_template_rtpack(Xs) struct impl;
    };
  }

  namespace clang {
  }

  namespace clang {
    struct DependentDiagnostic {
      M_template_rtpack(Xs) struct impl;
      enum AccessNonce : unsigned int;
    };
  }

  namespace reflcontainers {
    struct VectorStr {
      M_template_rtpack(Xs) struct impl;
    };
    struct VectorInt {
      M_template_rtpack(Xs) struct impl;
    };
    struct SetInt {
      M_template_rtpack(Xs) struct impl;
    };
    struct SetStr {
      M_template_rtpack(Xs) struct impl;
    };
    struct IntIntPair {
      M_template_rtpack(Xs) struct impl;
    };
    struct IntStrPair {
      M_template_rtpack(Xs) struct impl;
    };
    struct StrIntPair {
      M_template_rtpack(Xs) struct impl;
    };
    struct StrStrPair {
      M_template_rtpack(Xs) struct impl;
    };
    struct MapIntStr {
      M_template_rtpack(Xs) struct impl;
    };
    struct MapStrInt {
      M_template_rtpack(Xs) struct impl;
    };
    struct MapStrStr {
      M_template_rtpack(Xs) struct impl;
    };
    struct MapIntInt {
      M_template_rtpack(Xs) struct impl;
    };
  }

#ifdef __CONSUMER_SUPPORTS_REFLECTION_AND_META__
  template<class T, int PTROFFSET, intptr_t... Xs>
  struct impl_offset;
  template<class T, int PTROFFSET, intptr_t... Xs>
  using impl_offset_t = typename impl_offset<T, PTROFFSET, Xs...>::type;

  // Pointer specialization
  template<class T, int PTROFFSET, intptr_t PTRVAL>
  struct impl_offset<T, PTROFFSET, /*IsPtr*/1, PTRVAL>
  {
    using type = typename T::template impl</*IsPtr*/1, PTRVAL + PTROFFSET>;
  };

  // Value specialization (TODO)
  template<class T, int PTROFFSET, intptr_t... OBJDATACHUNKs>
  struct impl_offset<T, PTROFFSET, /*IsPtr*/0, OBJDATACHUNKs...>
  {
    static_assert(sizeof(T) == -1,
                  "This specialization not yet implemented! "
                  "To implement, need to bitshift each OBJDATACHUNK by PTROFFSET, "
                  "but also move the shifted stuff into the end of val to its left, "
                  "i.e. ignore the boundaries between chunks. Definitely doable." );
  };
#else
  template<class T, int PTROFFSET>
  using impl_offset_t = typename T::impl;
#endif

} //namespace refldetail

  namespace clang {
  }

  namespace clang {
  }

  namespace llvm {
  M_template_rtpack(Zs) using APInt = struct refldetail::llvm::APInt::M_template impl M_targpack(Zs);
  }

  namespace llvm {
  M_template_rtpack(Zs) using APFloatBase = struct refldetail::llvm::APFloatBase::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using APFloat = struct refldetail::llvm::APFloat::M_template impl M_targpack(Zs);
  }

  namespace llvm {
  M_template_rtpack(Zs) using APSInt = struct refldetail::llvm::APSInt::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using APValue = struct refldetail::clang::APValue::M_template impl M_targpack(Zs);
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {

    namespace diag {
  using Severity = enum refldetail::clang::diag::Severity;
    }
  }

  namespace clang {
  using OverloadsShown = enum refldetail::clang::OverloadsShown;
  using DiagnosticLevelMask = enum refldetail::clang::DiagnosticLevelMask;
  M_template_rtpack(Zs) using DiagnosticOptions = struct refldetail::clang::DiagnosticOptions::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using FileID = struct refldetail::clang::FileID::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SourceLocation = struct refldetail::clang::SourceLocation::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SourceRange = struct refldetail::clang::SourceRange::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CharSourceRange = struct refldetail::clang::CharSourceRange::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using PresumedLoc = struct refldetail::clang::PresumedLoc::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FullSourceLoc = struct refldetail::clang::FullSourceLoc::M_template impl M_targpack(Zs);
  }

  namespace clang {
  using AccessSpecifier = enum refldetail::clang::AccessSpecifier;
  using ExprValueKind = enum refldetail::clang::ExprValueKind;
  using ExprObjectKind = enum refldetail::clang::ExprObjectKind;
  using TemplateSpecializationKind = enum refldetail::clang::TemplateSpecializationKind;
  using ThreadStorageClassSpecifier = enum refldetail::clang::ThreadStorageClassSpecifier;
  using StorageClass = enum refldetail::clang::StorageClass;
  using InClassInitStyle = enum refldetail::clang::InClassInitStyle;
  using CallingConv = enum refldetail::clang::CallingConv;
  using StorageDuration = enum refldetail::clang::StorageDuration;
  using NullabilityKind = enum refldetail::clang::NullabilityKind;
  using ParameterABI = enum refldetail::clang::ParameterABI;
  using ReflectionTraitKind = enum refldetail::clang::ReflectionTraitKind;
  }

  namespace llvm {
  M_template_rtpack(Zs) using DebugEpochBase = struct refldetail::llvm::DebugEpochBase::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using FixItHint = struct refldetail::clang::FixItHint::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DiagnosticsEngine = struct refldetail::clang::DiagnosticsEngine::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DiagnosticBuilder = struct refldetail::clang::DiagnosticBuilder::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DiagnosticConsumer = struct refldetail::clang::DiagnosticConsumer::M_template impl M_targpack(Zs);
  }

  namespace clang {

    namespace tok {
  using TokenKind = enum refldetail::clang::tok::TokenKind;
  using PPKeywordKind = enum refldetail::clang::tok::PPKeywordKind;
  using ObjCKeywordKind = enum refldetail::clang::tok::ObjCKeywordKind;
    }
  }

  namespace clang {
  M_template_rtpack(Zs) using IdentifierInfo = struct refldetail::clang::IdentifierInfo::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using IdentifierInfoLookup = struct refldetail::clang::IdentifierInfoLookup::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using IdentifierTable = struct refldetail::clang::IdentifierTable::M_template impl M_targpack(Zs);
  using ObjCMethodFamily = enum refldetail::clang::ObjCMethodFamily;
  using ObjCInstanceTypeFamily = enum refldetail::clang::ObjCInstanceTypeFamily;
  using ObjCStringFormatFamily = enum refldetail::clang::ObjCStringFormatFamily;
  M_template_rtpack(Zs) using Selector = struct refldetail::clang::Selector::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SelectorTable = struct refldetail::clang::SelectorTable::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using PartialDiagnostic = struct refldetail::clang::PartialDiagnostic::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using DeclarationName = struct refldetail::clang::DeclarationName::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DeclarationNameLoc = struct refldetail::clang::DeclarationNameLoc::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DeclarationNameInfo = struct refldetail::clang::DeclarationNameInfo::M_template impl M_targpack(Zs);
  }

  namespace llvm {
  M_template_rtpack(Zs) using raw_ostream = struct refldetail::llvm::raw_ostream::M_template impl M_targpack(Zs);
  }

  namespace llvm {
  M_template_rtpack(Zs) using VersionTuple = struct refldetail::llvm::VersionTuple::M_template impl M_targpack(Zs);
  }

  namespace clang {
  using AvailabilityResult = enum refldetail::clang::AvailabilityResult;
  M_template_rtpack(Zs) using Decl = struct refldetail::clang::Decl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DeclContextLookupResult = struct refldetail::clang::DeclContextLookupResult::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DeclContext = struct refldetail::clang::DeclContext::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using CharUnits = struct refldetail::clang::CharUnits::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using FileSystemOptions = struct refldetail::clang::FileSystemOptions::M_template impl M_targpack(Zs);
  }

  namespace llvm {
  M_template_rtpack(Zs) using Twine = struct refldetail::llvm::Twine::M_template impl M_targpack(Zs);
  }

  namespace llvm {

    namespace sys {

      namespace fs {
  M_template_rtpack(Zs) using UniqueID = struct refldetail::llvm::sys::fs::UniqueID::M_template impl M_targpack(Zs);
      }
    }
  }

  namespace llvm {
  M_template_rtpack(Zs) using MemoryBuffer = struct refldetail::llvm::MemoryBuffer::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MemoryBufferRef = struct refldetail::llvm::MemoryBufferRef::M_template impl M_targpack(Zs);
  }

  namespace clang {
  }

  namespace clang {
  M_template_rtpack(Zs) using DirectoryEntry = struct refldetail::clang::DirectoryEntry::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FileEntry = struct refldetail::clang::FileEntry::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FileManager = struct refldetail::clang::FileManager::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using ASTFileSignature = struct refldetail::clang::ASTFileSignature::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using Module = struct refldetail::clang::Module::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using ExternalASTSource = struct refldetail::clang::ExternalASTSource::M_template impl M_targpack(Zs);
  }

  namespace clang {
  }

  namespace llvm {
  M_template_rtpack(Zs) using FoldingSetBase = struct refldetail::llvm::FoldingSetBase::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FoldingSetNodeIDRef = struct refldetail::llvm::FoldingSetNodeIDRef::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FoldingSetNodeID = struct refldetail::llvm::FoldingSetNodeID::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using NestedNameSpecifier = struct refldetail::clang::NestedNameSpecifier::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using NestedNameSpecifierLoc = struct refldetail::clang::NestedNameSpecifierLoc::M_template impl M_targpack(Zs);
  }

  namespace clang {
  }

  namespace clang {
  M_template_rtpack(Zs) using UncommonTemplateNameStorage = struct refldetail::clang::UncommonTemplateNameStorage::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OverloadedTemplateStorage = struct refldetail::clang::OverloadedTemplateStorage::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SubstTemplateTemplateParmPackStorage = struct refldetail::clang::SubstTemplateTemplateParmPackStorage::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TemplateName = struct refldetail::clang::TemplateName::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SubstTemplateTemplateParmStorage = struct refldetail::clang::SubstTemplateTemplateParmStorage::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using QualifiedTemplateName = struct refldetail::clang::QualifiedTemplateName::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DependentTemplateName = struct refldetail::clang::DependentTemplateName::M_template impl M_targpack(Zs);
  }

  namespace clang {
  using LangAS = enum refldetail::clang::LangAS;
  }

  namespace clang {
  using ExceptionSpecificationType = enum refldetail::clang::ExceptionSpecificationType;
  using CanThrowResult = enum refldetail::clang::CanThrowResult;
  }

  namespace clang {
  using Linkage = enum refldetail::clang::Linkage;
  using LanguageLinkage = enum refldetail::clang::LanguageLinkage;
  using GVALinkage = enum refldetail::clang::GVALinkage;
  }

  namespace clang {
  using Visibility = enum refldetail::clang::Visibility;
  M_template_rtpack(Zs) using LinkageInfo = struct refldetail::clang::LinkageInfo::M_template impl M_targpack(Zs);
  }

  namespace clang {
  }

  namespace clang {
  M_template_rtpack(Zs) using Qualifiers = struct refldetail::clang::Qualifiers::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SplitQualType = struct refldetail::clang::SplitQualType::M_template impl M_targpack(Zs);
  using ObjCSubstitutionContext = enum refldetail::clang::ObjCSubstitutionContext;
  M_template_rtpack(Zs) using QualType = struct refldetail::clang::QualType::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using ExtQualsTypeCommonBase = struct refldetail::clang::ExtQualsTypeCommonBase::M_template impl M_targpack(Zs);
  using RefQualifierKind = enum refldetail::clang::RefQualifierKind;
  using AutoTypeKeyword = enum refldetail::clang::AutoTypeKeyword;
  M_template_rtpack(Zs) using Type = struct refldetail::clang::Type::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using BuiltinType = struct refldetail::clang::BuiltinType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ComplexType = struct refldetail::clang::ComplexType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ParenType = struct refldetail::clang::ParenType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using PointerType = struct refldetail::clang::PointerType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using AdjustedType = struct refldetail::clang::AdjustedType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DecayedType = struct refldetail::clang::DecayedType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using BlockPointerType = struct refldetail::clang::BlockPointerType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ReferenceType = struct refldetail::clang::ReferenceType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using LValueReferenceType = struct refldetail::clang::LValueReferenceType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using RValueReferenceType = struct refldetail::clang::RValueReferenceType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MemberPointerType = struct refldetail::clang::MemberPointerType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ArrayType = struct refldetail::clang::ArrayType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ConstantArrayType = struct refldetail::clang::ConstantArrayType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using IncompleteArrayType = struct refldetail::clang::IncompleteArrayType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using VariableArrayType = struct refldetail::clang::VariableArrayType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DependentSizedArrayType = struct refldetail::clang::DependentSizedArrayType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DependentAddressSpaceType = struct refldetail::clang::DependentAddressSpaceType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DependentSizedExtVectorType = struct refldetail::clang::DependentSizedExtVectorType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using VectorType = struct refldetail::clang::VectorType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DependentVectorType = struct refldetail::clang::DependentVectorType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ExtVectorType = struct refldetail::clang::ExtVectorType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FunctionType = struct refldetail::clang::FunctionType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FunctionNoProtoType = struct refldetail::clang::FunctionNoProtoType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FunctionProtoType = struct refldetail::clang::FunctionProtoType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UnresolvedUsingType = struct refldetail::clang::UnresolvedUsingType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TypedefType = struct refldetail::clang::TypedefType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TypeOfExprType = struct refldetail::clang::TypeOfExprType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TypeOfType = struct refldetail::clang::TypeOfType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DecltypeType = struct refldetail::clang::DecltypeType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ReflectedType = struct refldetail::clang::ReflectedType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UnaryTransformType = struct refldetail::clang::UnaryTransformType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TagType = struct refldetail::clang::TagType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using RecordType = struct refldetail::clang::RecordType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using EnumType = struct refldetail::clang::EnumType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using AttributedType = struct refldetail::clang::AttributedType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TemplateTypeParmType = struct refldetail::clang::TemplateTypeParmType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SubstTemplateTypeParmType = struct refldetail::clang::SubstTemplateTypeParmType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SubstTemplateTypeParmPackType = struct refldetail::clang::SubstTemplateTypeParmPackType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DeducedType = struct refldetail::clang::DeducedType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using AutoType = struct refldetail::clang::AutoType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DeducedTemplateSpecializationType = struct refldetail::clang::DeducedTemplateSpecializationType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TemplateSpecializationType = struct refldetail::clang::TemplateSpecializationType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using InjectedClassNameType = struct refldetail::clang::InjectedClassNameType::M_template impl M_targpack(Zs);
  using TagTypeKind = enum refldetail::clang::TagTypeKind;
  using ElaboratedTypeKeyword = enum refldetail::clang::ElaboratedTypeKeyword;
  M_template_rtpack(Zs) using TypeWithKeyword = struct refldetail::clang::TypeWithKeyword::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ElaboratedType = struct refldetail::clang::ElaboratedType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DependentNameType = struct refldetail::clang::DependentNameType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DependentTemplateSpecializationType = struct refldetail::clang::DependentTemplateSpecializationType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using PackExpansionType = struct refldetail::clang::PackExpansionType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCTypeParamType = struct refldetail::clang::ObjCTypeParamType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCObjectType = struct refldetail::clang::ObjCObjectType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCInterfaceType = struct refldetail::clang::ObjCInterfaceType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCObjectPointerType = struct refldetail::clang::ObjCObjectPointerType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using AtomicType = struct refldetail::clang::AtomicType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using PipeType = struct refldetail::clang::PipeType::M_template impl M_targpack(Zs);
  }

  namespace clang {
  using OverloadedOperatorKind = enum refldetail::clang::OverloadedOperatorKind;
  }

  namespace clang {
  using PragmaMSCommentKind = enum refldetail::clang::PragmaMSCommentKind;
  }

  namespace clang {
  M_template_rtpack(Zs) using TypeSourceInfo = struct refldetail::clang::TypeSourceInfo::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TranslationUnitDecl = struct refldetail::clang::TranslationUnitDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using PragmaCommentDecl = struct refldetail::clang::PragmaCommentDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using PragmaDetectMismatchDecl = struct refldetail::clang::PragmaDetectMismatchDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ExternCContextDecl = struct refldetail::clang::ExternCContextDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using NamedDecl = struct refldetail::clang::NamedDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using LabelDecl = struct refldetail::clang::LabelDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using NamespaceDecl = struct refldetail::clang::NamespaceDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ValueDecl = struct refldetail::clang::ValueDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DeclaratorDecl = struct refldetail::clang::DeclaratorDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using EvaluatedStmt = struct refldetail::clang::EvaluatedStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using VarDecl = struct refldetail::clang::VarDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ImplicitParamDecl = struct refldetail::clang::ImplicitParamDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ParmVarDecl = struct refldetail::clang::ParmVarDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FunctionDecl = struct refldetail::clang::FunctionDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FieldDecl = struct refldetail::clang::FieldDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using EnumConstantDecl = struct refldetail::clang::EnumConstantDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using IndirectFieldDecl = struct refldetail::clang::IndirectFieldDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TypeDecl = struct refldetail::clang::TypeDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TypedefNameDecl = struct refldetail::clang::TypedefNameDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TypedefDecl = struct refldetail::clang::TypedefDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TypeAliasDecl = struct refldetail::clang::TypeAliasDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TagDecl = struct refldetail::clang::TagDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using EnumDecl = struct refldetail::clang::EnumDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using RecordDecl = struct refldetail::clang::RecordDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FileScopeAsmDecl = struct refldetail::clang::FileScopeAsmDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using BlockDecl = struct refldetail::clang::BlockDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CapturedDecl = struct refldetail::clang::CapturedDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ImportDecl = struct refldetail::clang::ImportDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ExportDecl = struct refldetail::clang::ExportDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using EmptyDecl = struct refldetail::clang::EmptyDecl::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using DeclGroup = struct refldetail::clang::DeclGroup::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DeclGroupRef = struct refldetail::clang::DeclGroupRef::M_template impl M_targpack(Zs);
  }

  namespace clang {
  }

  namespace clang {
  using CapturedRegionKind = enum refldetail::clang::CapturedRegionKind;
  }

  namespace clang {
  M_template_rtpack(Zs) using Stmt = struct refldetail::clang::Stmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DeclStmt = struct refldetail::clang::DeclStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using NullStmt = struct refldetail::clang::NullStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CompoundStmt = struct refldetail::clang::CompoundStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SwitchCase = struct refldetail::clang::SwitchCase::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CaseStmt = struct refldetail::clang::CaseStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DefaultStmt = struct refldetail::clang::DefaultStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using LabelStmt = struct refldetail::clang::LabelStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using AttributedStmt = struct refldetail::clang::AttributedStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using IfStmt = struct refldetail::clang::IfStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SwitchStmt = struct refldetail::clang::SwitchStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using WhileStmt = struct refldetail::clang::WhileStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DoStmt = struct refldetail::clang::DoStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ForStmt = struct refldetail::clang::ForStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using GotoStmt = struct refldetail::clang::GotoStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using IndirectGotoStmt = struct refldetail::clang::IndirectGotoStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ContinueStmt = struct refldetail::clang::ContinueStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using BreakStmt = struct refldetail::clang::BreakStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ReturnStmt = struct refldetail::clang::ReturnStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using AsmStmt = struct refldetail::clang::AsmStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using GCCAsmStmt = struct refldetail::clang::GCCAsmStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MSAsmStmt = struct refldetail::clang::MSAsmStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SEHExceptStmt = struct refldetail::clang::SEHExceptStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SEHFinallyStmt = struct refldetail::clang::SEHFinallyStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SEHTryStmt = struct refldetail::clang::SEHTryStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SEHLeaveStmt = struct refldetail::clang::SEHLeaveStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CapturedStmt = struct refldetail::clang::CapturedStmt::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using TemplateArgument = struct refldetail::clang::TemplateArgument::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TemplateArgumentLocInfo = struct refldetail::clang::TemplateArgumentLocInfo::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TemplateArgumentLoc = struct refldetail::clang::TemplateArgumentLoc::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TemplateArgumentListInfo = struct refldetail::clang::TemplateArgumentListInfo::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ASTTemplateArgumentListInfo = struct refldetail::clang::ASTTemplateArgumentListInfo::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using TypeLoc = struct refldetail::clang::TypeLoc::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UnqualTypeLoc = struct refldetail::clang::UnqualTypeLoc::M_template impl M_targpack(Zs);
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
  M_template_rtpack(Zs) using CommentOptions = struct refldetail::clang::CommentOptions::M_template impl M_targpack(Zs);
  }

  namespace clang {

    namespace comments {
  M_template_rtpack(Zs) using CommandInfo = struct refldetail::clang::comments::CommandInfo::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CommandTraits = struct refldetail::clang::comments::CommandTraits::M_template impl M_targpack(Zs);
    }
  }

  namespace clang {
  }

  namespace llvm {
  M_template_rtpack(Zs) using Triple = struct refldetail::llvm::Triple::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using ObjCRuntime = struct refldetail::clang::ObjCRuntime::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using SanitizerSet = struct refldetail::clang::SanitizerSet::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using LangOptionsBase = struct refldetail::clang::LangOptionsBase::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using LangOptions = struct refldetail::clang::LangOptions::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FPOptions = struct refldetail::clang::FPOptions::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using PrinterHelper = struct refldetail::clang::PrinterHelper::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using PrintingPolicy = struct refldetail::clang::PrintingPolicy::M_template impl M_targpack(Zs);
  }

  namespace clang {

    namespace SrcMgr {
  using CharacteristicKind = enum refldetail::clang::SrcMgr::CharacteristicKind;
  M_template_rtpack(Zs) using ContentCache = struct refldetail::clang::SrcMgr::ContentCache::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FileInfo = struct refldetail::clang::SrcMgr::FileInfo::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ExpansionInfo = struct refldetail::clang::SrcMgr::ExpansionInfo::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SLocEntry = struct refldetail::clang::SrcMgr::SLocEntry::M_template impl M_targpack(Zs);
    }
  M_template_rtpack(Zs) using SourceManager = struct refldetail::clang::SourceManager::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using RawComment = struct refldetail::clang::RawComment::M_template impl M_targpack(Zs);
  }

  namespace clang {
  }

  namespace clang {
  M_template_rtpack(Zs) using SanitizerBlacklist = struct refldetail::clang::SanitizerBlacklist::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using TargetCXXABI = struct refldetail::clang::TargetCXXABI::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using OpenCLOptions = struct refldetail::clang::OpenCLOptions::M_template impl M_targpack(Zs);
  }

  namespace llvm {
  using EABI = enum refldetail::llvm::EABI;
  }

  namespace clang {
  M_template_rtpack(Zs) using TargetOptions = struct refldetail::clang::TargetOptions::M_template impl M_targpack(Zs);
  }

  namespace llvm {
  M_template_rtpack(Zs) using Type = struct refldetail::llvm::Type::M_template impl M_targpack(Zs);
  }

  namespace llvm {
  M_template_rtpack(Zs) using IntegerType = struct refldetail::llvm::IntegerType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CompositeType = struct refldetail::llvm::CompositeType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using StructType = struct refldetail::llvm::StructType::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using PointerType = struct refldetail::llvm::PointerType::M_template impl M_targpack(Zs);
  }

  namespace llvm {
  M_template_rtpack(Zs) using DataLayout = struct refldetail::llvm::DataLayout::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using StructLayout = struct refldetail::llvm::StructLayout::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using TargetInfo = struct refldetail::clang::TargetInfo::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using XRayFunctionFilter = struct refldetail::clang::XRayFunctionFilter::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using TypeInfo = struct refldetail::clang::TypeInfo::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ASTContext = struct refldetail::clang::ASTContext::M_template impl M_targpack(Zs);
  }

  namespace clang {
  }

  namespace clang {
  M_template_rtpack(Zs) using DeclAccessPair = struct refldetail::clang::DeclAccessPair::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using UnresolvedSetIterator = struct refldetail::clang::UnresolvedSetIterator::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UnresolvedSetImpl = struct refldetail::clang::UnresolvedSetImpl::M_template impl M_targpack(Zs);
  }

  namespace clang {
  }

  namespace clang {
  using CastKind = enum refldetail::clang::CastKind;
  using BinaryOperatorKind = enum refldetail::clang::BinaryOperatorKind;
  using UnaryOperatorKind = enum refldetail::clang::UnaryOperatorKind;
  using ObjCBridgeCastKind = enum refldetail::clang::ObjCBridgeCastKind;
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
  using TypeTrait = enum refldetail::clang::TypeTrait;
  using ArrayTypeTrait = enum refldetail::clang::ArrayTypeTrait;
  using UnaryExprOrTypeTrait = enum refldetail::clang::UnaryExprOrTypeTrait;
  }

  namespace clang {
  M_template_rtpack(Zs) using Expr = struct refldetail::clang::Expr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OpaqueValueExpr = struct refldetail::clang::OpaqueValueExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DeclRefExpr = struct refldetail::clang::DeclRefExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using PredefinedExpr = struct refldetail::clang::PredefinedExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using APIntStorage = struct refldetail::clang::APIntStorage::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using IntegerLiteral = struct refldetail::clang::IntegerLiteral::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FixedPointLiteral = struct refldetail::clang::FixedPointLiteral::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CharacterLiteral = struct refldetail::clang::CharacterLiteral::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FloatingLiteral = struct refldetail::clang::FloatingLiteral::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ImaginaryLiteral = struct refldetail::clang::ImaginaryLiteral::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using StringLiteral = struct refldetail::clang::StringLiteral::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ParenExpr = struct refldetail::clang::ParenExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UnaryOperator = struct refldetail::clang::UnaryOperator::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OffsetOfNode = struct refldetail::clang::OffsetOfNode::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OffsetOfExpr = struct refldetail::clang::OffsetOfExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UnaryExprOrTypeTraitExpr = struct refldetail::clang::UnaryExprOrTypeTraitExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ArraySubscriptExpr = struct refldetail::clang::ArraySubscriptExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CallExpr = struct refldetail::clang::CallExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MemberExpr = struct refldetail::clang::MemberExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CompoundLiteralExpr = struct refldetail::clang::CompoundLiteralExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CastExpr = struct refldetail::clang::CastExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ImplicitCastExpr = struct refldetail::clang::ImplicitCastExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ExplicitCastExpr = struct refldetail::clang::ExplicitCastExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CStyleCastExpr = struct refldetail::clang::CStyleCastExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using BinaryOperator = struct refldetail::clang::BinaryOperator::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CompoundAssignOperator = struct refldetail::clang::CompoundAssignOperator::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using AbstractConditionalOperator = struct refldetail::clang::AbstractConditionalOperator::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ConditionalOperator = struct refldetail::clang::ConditionalOperator::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using BinaryConditionalOperator = struct refldetail::clang::BinaryConditionalOperator::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using AddrLabelExpr = struct refldetail::clang::AddrLabelExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using StmtExpr = struct refldetail::clang::StmtExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ShuffleVectorExpr = struct refldetail::clang::ShuffleVectorExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ConvertVectorExpr = struct refldetail::clang::ConvertVectorExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ChooseExpr = struct refldetail::clang::ChooseExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using GNUNullExpr = struct refldetail::clang::GNUNullExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using VAArgExpr = struct refldetail::clang::VAArgExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using InitListExpr = struct refldetail::clang::InitListExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DesignatedInitExpr = struct refldetail::clang::DesignatedInitExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using NoInitExpr = struct refldetail::clang::NoInitExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DesignatedInitUpdateExpr = struct refldetail::clang::DesignatedInitUpdateExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ArrayInitLoopExpr = struct refldetail::clang::ArrayInitLoopExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ArrayInitIndexExpr = struct refldetail::clang::ArrayInitIndexExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ImplicitValueInitExpr = struct refldetail::clang::ImplicitValueInitExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ParenListExpr = struct refldetail::clang::ParenListExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using GenericSelectionExpr = struct refldetail::clang::GenericSelectionExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ExtVectorElementExpr = struct refldetail::clang::ExtVectorElementExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using BlockExpr = struct refldetail::clang::BlockExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using AsTypeExpr = struct refldetail::clang::AsTypeExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using PseudoObjectExpr = struct refldetail::clang::PseudoObjectExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using AtomicExpr = struct refldetail::clang::AtomicExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TypoExpr = struct refldetail::clang::TypoExpr::M_template impl M_targpack(Zs);
  }

  namespace clang {

    namespace attr {
  using Kind = enum refldetail::clang::attr::Kind;
    }
  }

  namespace clang {
  using OpenMPDirectiveKind = enum refldetail::clang::OpenMPDirectiveKind;
  using OpenMPClauseKind = enum refldetail::clang::OpenMPClauseKind;
  }

  namespace clang {
  M_template_rtpack(Zs) using Attr = struct refldetail::clang::Attr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using InheritableAttr = struct refldetail::clang::InheritableAttr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ExternalSourceSymbolAttr = struct refldetail::clang::ExternalSourceSymbolAttr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MSInheritanceAttr = struct refldetail::clang::MSInheritanceAttr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MSVtorDispAttr = struct refldetail::clang::MSVtorDispAttr::M_template impl M_targpack(Zs);
  }

  namespace clang {
  using LambdaCaptureDefault = enum refldetail::clang::LambdaCaptureDefault;
  using LambdaCaptureKind = enum refldetail::clang::LambdaCaptureKind;
  }

  namespace clang {
  M_template_rtpack(Zs) using LambdaCapture = struct refldetail::clang::LambdaCapture::M_template impl M_targpack(Zs);
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
  }

  namespace clang {
  M_template_rtpack(Zs) using AccessSpecDecl = struct refldetail::clang::AccessSpecDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXBaseSpecifier = struct refldetail::clang::CXXBaseSpecifier::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXRecordDecl = struct refldetail::clang::CXXRecordDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXDeductionGuideDecl = struct refldetail::clang::CXXDeductionGuideDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXMethodDecl = struct refldetail::clang::CXXMethodDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXCtorInitializer = struct refldetail::clang::CXXCtorInitializer::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using InheritedConstructor = struct refldetail::clang::InheritedConstructor::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXConstructorDecl = struct refldetail::clang::CXXConstructorDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXDestructorDecl = struct refldetail::clang::CXXDestructorDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXConversionDecl = struct refldetail::clang::CXXConversionDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using LinkageSpecDecl = struct refldetail::clang::LinkageSpecDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UsingDirectiveDecl = struct refldetail::clang::UsingDirectiveDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using NamespaceAliasDecl = struct refldetail::clang::NamespaceAliasDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UsingShadowDecl = struct refldetail::clang::UsingShadowDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ConstructorUsingShadowDecl = struct refldetail::clang::ConstructorUsingShadowDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UsingDecl = struct refldetail::clang::UsingDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UsingPackDecl = struct refldetail::clang::UsingPackDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UnresolvedUsingValueDecl = struct refldetail::clang::UnresolvedUsingValueDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UnresolvedUsingTypenameDecl = struct refldetail::clang::UnresolvedUsingTypenameDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using StaticAssertDecl = struct refldetail::clang::StaticAssertDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using BindingDecl = struct refldetail::clang::BindingDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DecompositionDecl = struct refldetail::clang::DecompositionDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MSPropertyDecl = struct refldetail::clang::MSPropertyDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ConstexprDecl = struct refldetail::clang::ConstexprDecl::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using TemplateParameterList = struct refldetail::clang::TemplateParameterList::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TemplateArgumentList = struct refldetail::clang::TemplateArgumentList::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TemplateDecl = struct refldetail::clang::TemplateDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FunctionTemplateSpecializationInfo = struct refldetail::clang::FunctionTemplateSpecializationInfo::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MemberSpecializationInfo = struct refldetail::clang::MemberSpecializationInfo::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DependentFunctionTemplateSpecializationInfo = struct refldetail::clang::DependentFunctionTemplateSpecializationInfo::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using RedeclarableTemplateDecl = struct refldetail::clang::RedeclarableTemplateDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FunctionTemplateDecl = struct refldetail::clang::FunctionTemplateDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TemplateTypeParmDecl = struct refldetail::clang::TemplateTypeParmDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using NonTypeTemplateParmDecl = struct refldetail::clang::NonTypeTemplateParmDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TemplateTemplateParmDecl = struct refldetail::clang::TemplateTemplateParmDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using BuiltinTemplateDecl = struct refldetail::clang::BuiltinTemplateDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ClassTemplateSpecializationDecl = struct refldetail::clang::ClassTemplateSpecializationDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ClassTemplatePartialSpecializationDecl = struct refldetail::clang::ClassTemplatePartialSpecializationDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ClassTemplateDecl = struct refldetail::clang::ClassTemplateDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FriendTemplateDecl = struct refldetail::clang::FriendTemplateDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TypeAliasTemplateDecl = struct refldetail::clang::TypeAliasTemplateDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ClassScopeFunctionSpecializationDecl = struct refldetail::clang::ClassScopeFunctionSpecializationDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using VarTemplateSpecializationDecl = struct refldetail::clang::VarTemplateSpecializationDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using VarTemplatePartialSpecializationDecl = struct refldetail::clang::VarTemplatePartialSpecializationDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using VarTemplateDecl = struct refldetail::clang::VarTemplateDecl::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using FriendDecl = struct refldetail::clang::FriendDecl::M_template impl M_targpack(Zs);
  }

  namespace clang {
  }

  namespace clang {
  M_template_rtpack(Zs) using ObjCListBase = struct refldetail::clang::ObjCListBase::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCProtocolList = struct refldetail::clang::ObjCProtocolList::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCMethodDecl = struct refldetail::clang::ObjCMethodDecl::M_template impl M_targpack(Zs);
  using ObjCTypeParamVariance = enum refldetail::clang::ObjCTypeParamVariance;
  M_template_rtpack(Zs) using ObjCTypeParamDecl = struct refldetail::clang::ObjCTypeParamDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCTypeParamList = struct refldetail::clang::ObjCTypeParamList::M_template impl M_targpack(Zs);
  using ObjCPropertyQueryKind = enum refldetail::clang::ObjCPropertyQueryKind;
  M_template_rtpack(Zs) using ObjCPropertyDecl = struct refldetail::clang::ObjCPropertyDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCContainerDecl = struct refldetail::clang::ObjCContainerDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCInterfaceDecl = struct refldetail::clang::ObjCInterfaceDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCIvarDecl = struct refldetail::clang::ObjCIvarDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCAtDefsFieldDecl = struct refldetail::clang::ObjCAtDefsFieldDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCProtocolDecl = struct refldetail::clang::ObjCProtocolDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCCategoryDecl = struct refldetail::clang::ObjCCategoryDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCImplDecl = struct refldetail::clang::ObjCImplDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCCategoryImplDecl = struct refldetail::clang::ObjCCategoryImplDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCImplementationDecl = struct refldetail::clang::ObjCImplementationDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCCompatibleAliasDecl = struct refldetail::clang::ObjCCompatibleAliasDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCPropertyImplDecl = struct refldetail::clang::ObjCPropertyImplDecl::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using OMPThreadPrivateDecl = struct refldetail::clang::OMPThreadPrivateDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPDeclareReductionDecl = struct refldetail::clang::OMPDeclareReductionDecl::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPCapturedExprDecl = struct refldetail::clang::OMPCapturedExprDecl::M_template impl M_targpack(Zs);
  }

  namespace clang {
  using ExpressionTrait = enum refldetail::clang::ExpressionTrait;
  }

  namespace clang {
  M_template_rtpack(Zs) using CXXOperatorCallExpr = struct refldetail::clang::CXXOperatorCallExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXMemberCallExpr = struct refldetail::clang::CXXMemberCallExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CUDAKernelCallExpr = struct refldetail::clang::CUDAKernelCallExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXNamedCastExpr = struct refldetail::clang::CXXNamedCastExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXStaticCastExpr = struct refldetail::clang::CXXStaticCastExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXDynamicCastExpr = struct refldetail::clang::CXXDynamicCastExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXReinterpretCastExpr = struct refldetail::clang::CXXReinterpretCastExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXConstCastExpr = struct refldetail::clang::CXXConstCastExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UserDefinedLiteral = struct refldetail::clang::UserDefinedLiteral::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXBoolLiteralExpr = struct refldetail::clang::CXXBoolLiteralExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXNullPtrLiteralExpr = struct refldetail::clang::CXXNullPtrLiteralExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXStdInitializerListExpr = struct refldetail::clang::CXXStdInitializerListExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXTypeidExpr = struct refldetail::clang::CXXTypeidExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MSPropertyRefExpr = struct refldetail::clang::MSPropertyRefExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MSPropertySubscriptExpr = struct refldetail::clang::MSPropertySubscriptExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXUuidofExpr = struct refldetail::clang::CXXUuidofExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXThisExpr = struct refldetail::clang::CXXThisExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXThrowExpr = struct refldetail::clang::CXXThrowExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXDefaultArgExpr = struct refldetail::clang::CXXDefaultArgExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXDefaultInitExpr = struct refldetail::clang::CXXDefaultInitExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXTemporary = struct refldetail::clang::CXXTemporary::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXBindTemporaryExpr = struct refldetail::clang::CXXBindTemporaryExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXConstructExpr = struct refldetail::clang::CXXConstructExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXInheritedCtorInitExpr = struct refldetail::clang::CXXInheritedCtorInitExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXFunctionalCastExpr = struct refldetail::clang::CXXFunctionalCastExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXTemporaryObjectExpr = struct refldetail::clang::CXXTemporaryObjectExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using LambdaExpr = struct refldetail::clang::LambdaExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXScalarValueInitExpr = struct refldetail::clang::CXXScalarValueInitExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXNewExpr = struct refldetail::clang::CXXNewExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXDeleteExpr = struct refldetail::clang::CXXDeleteExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXPseudoDestructorExpr = struct refldetail::clang::CXXPseudoDestructorExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using TypeTraitExpr = struct refldetail::clang::TypeTraitExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ArrayTypeTraitExpr = struct refldetail::clang::ArrayTypeTraitExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ExpressionTraitExpr = struct refldetail::clang::ExpressionTraitExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OverloadExpr = struct refldetail::clang::OverloadExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UnresolvedLookupExpr = struct refldetail::clang::UnresolvedLookupExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DependentScopeDeclRefExpr = struct refldetail::clang::DependentScopeDeclRefExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ExprWithCleanups = struct refldetail::clang::ExprWithCleanups::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXUnresolvedConstructExpr = struct refldetail::clang::CXXUnresolvedConstructExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXDependentScopeMemberExpr = struct refldetail::clang::CXXDependentScopeMemberExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using UnresolvedMemberExpr = struct refldetail::clang::UnresolvedMemberExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXNoexceptExpr = struct refldetail::clang::CXXNoexceptExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using PackExpansionExpr = struct refldetail::clang::PackExpansionExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SizeOfPackExpr = struct refldetail::clang::SizeOfPackExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SubstNonTypeTemplateParmExpr = struct refldetail::clang::SubstNonTypeTemplateParmExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SubstNonTypeTemplateParmPackExpr = struct refldetail::clang::SubstNonTypeTemplateParmPackExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using FunctionParmPackExpr = struct refldetail::clang::FunctionParmPackExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MaterializeTemporaryExpr = struct refldetail::clang::MaterializeTemporaryExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXFoldExpr = struct refldetail::clang::CXXFoldExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CoroutineSuspendExpr = struct refldetail::clang::CoroutineSuspendExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CoawaitExpr = struct refldetail::clang::CoawaitExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DependentCoawaitExpr = struct refldetail::clang::DependentCoawaitExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CoyieldExpr = struct refldetail::clang::CoyieldExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ReflectionExpr = struct refldetail::clang::ReflectionExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CompilerMessageExpr = struct refldetail::clang::CompilerMessageExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CompilerDiagnosticExpr = struct refldetail::clang::CompilerDiagnosticExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXMetaparseExpr = struct refldetail::clang::CXXMetaparseExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ReflectionTraitExpr = struct refldetail::clang::ReflectionTraitExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ReflectNewExpr = struct refldetail::clang::ReflectNewExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ReflectDeleteExpr = struct refldetail::clang::ReflectDeleteExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXConstantExpr = struct refldetail::clang::CXXConstantExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXDependentIdExpr = struct refldetail::clang::CXXDependentIdExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXConcatenateExpr = struct refldetail::clang::CXXConcatenateExpr::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using ObjCStringLiteral = struct refldetail::clang::ObjCStringLiteral::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCBoolLiteralExpr = struct refldetail::clang::ObjCBoolLiteralExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCBoxedExpr = struct refldetail::clang::ObjCBoxedExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCArrayLiteral = struct refldetail::clang::ObjCArrayLiteral::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCDictionaryElement = struct refldetail::clang::ObjCDictionaryElement::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using ObjCDictionaryLiteral = struct refldetail::clang::ObjCDictionaryLiteral::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCEncodeExpr = struct refldetail::clang::ObjCEncodeExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCSelectorExpr = struct refldetail::clang::ObjCSelectorExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCProtocolExpr = struct refldetail::clang::ObjCProtocolExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCIvarRefExpr = struct refldetail::clang::ObjCIvarRefExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCPropertyRefExpr = struct refldetail::clang::ObjCPropertyRefExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCSubscriptRefExpr = struct refldetail::clang::ObjCSubscriptRefExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCMessageExpr = struct refldetail::clang::ObjCMessageExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCIsaExpr = struct refldetail::clang::ObjCIsaExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCIndirectCopyRestoreExpr = struct refldetail::clang::ObjCIndirectCopyRestoreExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCBridgedCastExpr = struct refldetail::clang::ObjCBridgedCastExpr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCAvailabilityCheckExpr = struct refldetail::clang::ObjCAvailabilityCheckExpr::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using OMPArraySectionExpr = struct refldetail::clang::OMPArraySectionExpr::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using CXXCatchStmt = struct refldetail::clang::CXXCatchStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXTryStmt = struct refldetail::clang::CXXTryStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXForRangeStmt = struct refldetail::clang::CXXForRangeStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXExpansionStmt = struct refldetail::clang::CXXExpansionStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXTupleExpansionStmt = struct refldetail::clang::CXXTupleExpansionStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXPackExpansionStmt = struct refldetail::clang::CXXPackExpansionStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MSDependentExistsStmt = struct refldetail::clang::MSDependentExistsStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CoroutineBodyStmt = struct refldetail::clang::CoroutineBodyStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CoreturnStmt = struct refldetail::clang::CoreturnStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using CXXQueueMetaparseStmt = struct refldetail::clang::CXXQueueMetaparseStmt::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using ObjCForCollectionStmt = struct refldetail::clang::ObjCForCollectionStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCAtCatchStmt = struct refldetail::clang::ObjCAtCatchStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCAtFinallyStmt = struct refldetail::clang::ObjCAtFinallyStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCAtTryStmt = struct refldetail::clang::ObjCAtTryStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCAtSynchronizedStmt = struct refldetail::clang::ObjCAtSynchronizedStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCAtThrowStmt = struct refldetail::clang::ObjCAtThrowStmt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ObjCAutoreleasePoolStmt = struct refldetail::clang::ObjCAutoreleasePoolStmt::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using OMPClause = struct refldetail::clang::OMPClause::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using OMPExecutableDirective = struct refldetail::clang::OMPExecutableDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPParallelDirective = struct refldetail::clang::OMPParallelDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPLoopDirective = struct refldetail::clang::OMPLoopDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPSimdDirective = struct refldetail::clang::OMPSimdDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPForDirective = struct refldetail::clang::OMPForDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPForSimdDirective = struct refldetail::clang::OMPForSimdDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPSectionsDirective = struct refldetail::clang::OMPSectionsDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPSectionDirective = struct refldetail::clang::OMPSectionDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPSingleDirective = struct refldetail::clang::OMPSingleDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPMasterDirective = struct refldetail::clang::OMPMasterDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPCriticalDirective = struct refldetail::clang::OMPCriticalDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPParallelForDirective = struct refldetail::clang::OMPParallelForDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPParallelForSimdDirective = struct refldetail::clang::OMPParallelForSimdDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPParallelSectionsDirective = struct refldetail::clang::OMPParallelSectionsDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTaskDirective = struct refldetail::clang::OMPTaskDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTaskyieldDirective = struct refldetail::clang::OMPTaskyieldDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPBarrierDirective = struct refldetail::clang::OMPBarrierDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTaskwaitDirective = struct refldetail::clang::OMPTaskwaitDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTaskgroupDirective = struct refldetail::clang::OMPTaskgroupDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPFlushDirective = struct refldetail::clang::OMPFlushDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPOrderedDirective = struct refldetail::clang::OMPOrderedDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPAtomicDirective = struct refldetail::clang::OMPAtomicDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetDirective = struct refldetail::clang::OMPTargetDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetDataDirective = struct refldetail::clang::OMPTargetDataDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetEnterDataDirective = struct refldetail::clang::OMPTargetEnterDataDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetExitDataDirective = struct refldetail::clang::OMPTargetExitDataDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetParallelDirective = struct refldetail::clang::OMPTargetParallelDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetParallelForDirective = struct refldetail::clang::OMPTargetParallelForDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTeamsDirective = struct refldetail::clang::OMPTeamsDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPCancellationPointDirective = struct refldetail::clang::OMPCancellationPointDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPCancelDirective = struct refldetail::clang::OMPCancelDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTaskLoopDirective = struct refldetail::clang::OMPTaskLoopDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTaskLoopSimdDirective = struct refldetail::clang::OMPTaskLoopSimdDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPDistributeDirective = struct refldetail::clang::OMPDistributeDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetUpdateDirective = struct refldetail::clang::OMPTargetUpdateDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPDistributeParallelForDirective = struct refldetail::clang::OMPDistributeParallelForDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPDistributeParallelForSimdDirective = struct refldetail::clang::OMPDistributeParallelForSimdDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPDistributeSimdDirective = struct refldetail::clang::OMPDistributeSimdDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetParallelForSimdDirective = struct refldetail::clang::OMPTargetParallelForSimdDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetSimdDirective = struct refldetail::clang::OMPTargetSimdDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTeamsDistributeDirective = struct refldetail::clang::OMPTeamsDistributeDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTeamsDistributeSimdDirective = struct refldetail::clang::OMPTeamsDistributeSimdDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTeamsDistributeParallelForSimdDirective = struct refldetail::clang::OMPTeamsDistributeParallelForSimdDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTeamsDistributeParallelForDirective = struct refldetail::clang::OMPTeamsDistributeParallelForDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetTeamsDirective = struct refldetail::clang::OMPTargetTeamsDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetTeamsDistributeDirective = struct refldetail::clang::OMPTargetTeamsDistributeDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetTeamsDistributeParallelForDirective = struct refldetail::clang::OMPTargetTeamsDistributeParallelForDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetTeamsDistributeParallelForSimdDirective = struct refldetail::clang::OMPTargetTeamsDistributeParallelForSimdDirective::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using OMPTargetTeamsDistributeSimdDirective = struct refldetail::clang::OMPTargetTeamsDistributeSimdDirective::M_template impl M_targpack(Zs);
  }

  namespace clang {
  M_template_rtpack(Zs) using StoredDeclsMap = struct refldetail::clang::StoredDeclsMap::M_template impl M_targpack(Zs);
  }

  namespace clang {
  }

  namespace clang {
  M_template_rtpack(Zs) using DependentDiagnostic = struct refldetail::clang::DependentDiagnostic::M_template impl M_targpack(Zs);
  }

  namespace reflcontainers {
  M_template_rtpack(Zs) using VectorStr = struct refldetail::reflcontainers::VectorStr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using VectorInt = struct refldetail::reflcontainers::VectorInt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SetInt = struct refldetail::reflcontainers::SetInt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using SetStr = struct refldetail::reflcontainers::SetStr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using IntIntPair = struct refldetail::reflcontainers::IntIntPair::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using IntStrPair = struct refldetail::reflcontainers::IntStrPair::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using StrIntPair = struct refldetail::reflcontainers::StrIntPair::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using StrStrPair = struct refldetail::reflcontainers::StrStrPair::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MapIntStr = struct refldetail::reflcontainers::MapIntStr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MapStrInt = struct refldetail::reflcontainers::MapStrInt::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MapStrStr = struct refldetail::reflcontainers::MapStrStr::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using MapIntInt = struct refldetail::reflcontainers::MapIntInt::M_template impl M_targpack(Zs);
  }
namespace refldetail {


/// Class for arbitrary precision integers.
///
/// APInt is a functional replacement for common case unsigned integer type like
/// "unsigned", "unsigned long" or "uint64_t", but also allows non-byte-width
/// integer sizes and large integer value types such as 3-bits, 15-bits, or more
/// than 64-bits of precision. APInt provides a variety of arithmetic operators
/// and methods to manipulate integer values of any bit-width. It supports both
/// the typical integer arithmetic and comparison operations as well as bitwise
/// manipulation.
///
/// The class has several invariants worth noting:
///   * All bit, byte, and word positions are zero-based.
///   * Once the bit width is set, it doesn't change except by the Truncate,
///     SignExtend, or ZeroExtend operations.
///   * All binary operators must be on APInt instances of the same bit width.
///     Attempting to use these operators on instances with different bit
///     widths will yield an assertion.
///   * The value is stored canonically as an unsigned value. For operations
///     where it makes a difference, there are both signed and unsigned variants
///     of the operation. For example, sdiv and udiv. However, because the bit
///     widths must be the same, operations such as Mul and Add produce the same
///     results regardless of whether the values are interpreted as signed or
///     not.
///   * In general, the class tries to follow the style of computation that LLVM
///     uses in its IR. This simplifies its use for LLVM.
///
M_template_rtpack(Xs)
struct llvm::APInt::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__APInt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::APInt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  static const unsigned long long WORD_MAX = 18446744073709551615u;
  /// Returns whether this instance allocated memory.
  constexpr bool needsCleanup() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::needsCleanup, Xs...); }) , (;) )
  /// Used to insert APInt objects, or objects that contain APInt objects, into
  ///  FoldingSets.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) id) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::Profile, Xs..., Y0s...); }) , (;) )
  /// Determine sign of this APInt.
  ///
  /// This tests the high bit of this APInt to determine if it is set.
  ///
  /// \returns true if this APInt is negative, false otherwise
  constexpr bool isNegative() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isNegative, Xs...); }) , (;) )
  /// Determine if this APInt Value is non-negative (>= 0)
  ///
  /// This tests the high bit of the APInt to determine if it is unset.
  constexpr bool isNonNegative() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isNonNegative, Xs...); }) , (;) )
  /// Determine if sign bit of this APInt is set.
  ///
  /// This tests the high bit of this APInt to determine if it is set.
  ///
  /// \returns true if this APInt has its sign bit set, false otherwise.
  constexpr bool isSignBitSet() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isSignBitSet, Xs...); }) , (;) )
  /// Determine if sign bit of this APInt is clear.
  ///
  /// This tests the high bit of this APInt to determine if it is clear.
  ///
  /// \returns true if this APInt has its sign bit clear, false otherwise.
  constexpr bool isSignBitClear() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isSignBitClear, Xs...); }) , (;) )
  /// Determine if this APInt Value is positive.
  ///
  /// This tests if the value of this APInt is positive (> 0). Note
  /// that 0 is not a positive value.
  ///
  /// \returns true if this APInt is positive.
  constexpr bool isStrictlyPositive() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isStrictlyPositive, Xs...); }) , (;) )
  /// Determine if all bits are set
  ///
  /// This checks to see if the value has all bits of the APInt are set or not.
  constexpr bool isAllOnesValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isAllOnesValue, Xs...); }) , (;) )
  /// Determine if all bits are clear
  ///
  /// This checks to see if the value has all bits of the APInt are clear or
  /// not.
  constexpr bool isNullValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isNullValue, Xs...); }) , (;) )
  /// Determine if this is a value of 1.
  ///
  /// This checks to see if the value of this APInt is one.
  constexpr bool isOneValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isOneValue, Xs...); }) , (;) )
  /// Determine if this is the largest unsigned value.
  ///
  /// This checks to see if the value of this APInt is the maximum unsigned
  /// value for the APInt's bit width.
  constexpr bool isMaxValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isMaxValue, Xs...); }) , (;) )
  /// Determine if this is the largest signed value.
  ///
  /// This checks to see if the value of this APInt is the maximum signed
  /// value for the APInt's bit width.
  constexpr bool isMaxSignedValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isMaxSignedValue, Xs...); }) , (;) )
  /// Determine if this is the smallest unsigned value.
  ///
  /// This checks to see if the value of this APInt is the minimum unsigned
  /// value for the APInt's bit width.
  constexpr bool isMinValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isMinValue, Xs...); }) , (;) )
  /// Determine if this is the smallest signed value.
  ///
  /// This checks to see if the value of this APInt is the minimum signed
  /// value for the APInt's bit width.
  constexpr bool isMinSignedValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isMinSignedValue, Xs...); }) , (;) )
  /// Check if this APInt has an N-bits unsigned integer value.
  constexpr bool isIntN(unsigned int N) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isIntN, Xs..., N); }) , (;) )
  /// Check if this APInt has an N-bits signed integer value.
  constexpr bool isSignedIntN(unsigned int N) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isSignedIntN, Xs..., N); }) , (;) )
  /// Check if this APInt's value is a power of two greater than zero.
  ///
  /// \returns true if the argument APInt value is a power of two > 0.
  constexpr bool isPowerOf2() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isPowerOf2, Xs...); }) , (;) )
  /// Check if the APInt's value is returned by getSignMask.
  ///
  /// \returns true if this is the value returned by getSignMask.
  constexpr bool isSignMask() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isSignMask, Xs...); }) , (;) )
  /// Convert APInt to a boolean value.
  ///
  /// This converts the APInt to a boolean value as a test against zero.
  constexpr bool getBoolValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::getBoolValue, Xs...); }) , (;) )
  /// If this value is smaller than the specified limit, return it, otherwise
  /// return the limit value.  This causes the value to saturate to the limit.
  constexpr unsigned long long getLimitedValue(unsigned long long Limit = 18446744073709551615ULL) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::getLimitedValue, Xs..., Limit); }) , (;) )
  /// Check if the APInt consists of a repeated bit pattern.
  ///
  /// e.g. 0x01010101 satisfies isSplat(8).
  /// \param SplatSizeInBits The size of the pattern in bits. Must divide bit
  /// width without remainder.
  constexpr bool isSplat(unsigned int SplatSizeInBits) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isSplat, Xs..., SplatSizeInBits); }) , (;) )
  /// \returns true if this APInt value is a sequence of \param numBits ones
  /// starting at the least significant bit with the remainder zero.
  constexpr bool isMask(unsigned int numBits) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isMask, Xs..., numBits); }) , (;) )
  /// \returns true if this APInt is a non-empty sequence of ones starting at
  /// the least significant bit with the remainder zero.
  /// Ex. isMask(0x0000FFFFU) == true.
  constexpr bool isMask() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isMask1, Xs...); }) , (;) )
  /// Return true if this APInt value contains a sequence of ones with
  /// the remainder zero.
  constexpr bool isShiftedMask() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isShiftedMask, Xs...); }) , (;) )
  /// Determine if two APInts have the same value, after zero-extending
  /// one of them (if needed!) to ensure that the bit-widths match.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr bool isSameValue(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) I1, IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::APInt &)) I2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isSameValue, Xs..., Y0s..., Y1s...); }) , (;) )
  /// This function returns a pointer to the internal storage of the APInt.
  /// This is useful for writing out the APInt in binary form without any
  /// conversions.
  constexpr const unsigned long long * getRawData() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::getRawData, Xs...); }) , (;) )
  /// Logical negation operator.
  ///
  /// Performs logical negation operation on this APInt.
  ///
  /// \returns true if *this is zero, false otherwise.
  constexpr bool operator!() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::operator_not, Xs...); }) , (;) )
  constexpr unsigned long long urem(unsigned long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::urem, Xs..., RHS); }) , (;) )
  constexpr long long srem(long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::srem, Xs..., RHS); }) , (;) )
  /// Dual division/remainder interface.
  ///
  /// Sometimes it is convenient to divide two APInt values and obtain both the
  /// quotient and remainder. This function does both operations in the same
  /// computation making it a little more efficient. The pair of input arguments
  /// may overlap with the pair of output arguments. It is safe to call
  /// udivrem(X, Y, X, Y), for example.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr void udivrem(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) LHS, IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::APInt &)) RHS, IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y2s...>), (typename meta::llvm::APInt &)) Quotient, IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y3s...>), (typename meta::llvm::APInt &)) Remainder) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::udivrem, Xs..., Y0s..., Y1s..., Y2s..., Y3s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr void sdivrem(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) LHS, IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::APInt &)) RHS, IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y2s...>), (typename meta::llvm::APInt &)) Quotient, IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y3s...>), (typename meta::llvm::APInt &)) Remainder) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::sdivrem, Xs..., Y0s..., Y1s..., Y2s..., Y3s...); }) , (;) )
  /// Array-indexing support.
  ///
  /// \returns the bit value at bitPosition
  constexpr bool operator[](unsigned int bitPosition) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::operator_sub, Xs..., bitPosition); }) , (;) )
  /// Equality operator.
  ///
  /// Compares this APInt with RHS for the validity of the equality
  /// relationship.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  /// Equality operator.
  ///
  /// Compares this APInt with a uint64_t for the validity of the equality
  /// relationship.
  ///
  /// \returns true if *this == Val
  constexpr bool operator==(unsigned long long Val) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::operator_eq_eq1, Xs..., Val); }) , (;) )
  /// Equality comparison.
  ///
  /// Compares this APInt with RHS for the validity of the equality
  /// relationship.
  ///
  /// \returns true if *this == Val
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool eq(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::eq, Xs..., Y0s...); }) , (;) )
  /// Inequality operator.
  ///
  /// Compares this APInt with RHS for the validity of the inequality
  /// relationship.
  ///
  /// \returns true if *this != Val
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::operator_not_eq, Xs..., Y0s...); }) , (;) )
  /// Inequality operator.
  ///
  /// Compares this APInt with a uint64_t for the validity of the inequality
  /// relationship.
  ///
  /// \returns true if *this != Val
  constexpr bool operator!=(unsigned long long Val) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::operator_not_eq1, Xs..., Val); }) , (;) )
  /// Inequality comparison
  ///
  /// Compares this APInt with RHS for the validity of the inequality
  /// relationship.
  ///
  /// \returns true if *this != Val
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool ne(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::ne, Xs..., Y0s...); }) , (;) )
  /// Unsigned less than comparison
  ///
  /// Regards both *this and RHS as unsigned quantities and compares them for
  /// the validity of the less-than relationship.
  ///
  /// \returns true if *this < RHS when both are considered unsigned.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool ult(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::ult, Xs..., Y0s...); }) , (;) )
  /// Unsigned less than comparison
  ///
  /// Regards both *this as an unsigned quantity and compares it with RHS for
  /// the validity of the less-than relationship.
  ///
  /// \returns true if *this < RHS when considered unsigned.
  constexpr bool ult(unsigned long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::ult1, Xs..., RHS); }) , (;) )
  /// Signed less than comparison
  ///
  /// Regards both *this and RHS as signed quantities and compares them for
  /// validity of the less-than relationship.
  ///
  /// \returns true if *this < RHS when both are considered signed.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool slt(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::slt, Xs..., Y0s...); }) , (;) )
  /// Signed less than comparison
  ///
  /// Regards both *this as a signed quantity and compares it with RHS for
  /// the validity of the less-than relationship.
  ///
  /// \returns true if *this < RHS when considered signed.
  constexpr bool slt(long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::slt1, Xs..., RHS); }) , (;) )
  /// Unsigned less or equal comparison
  ///
  /// Regards both *this and RHS as unsigned quantities and compares them for
  /// validity of the less-or-equal relationship.
  ///
  /// \returns true if *this <= RHS when both are considered unsigned.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool ule(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::ule, Xs..., Y0s...); }) , (;) )
  /// Unsigned less or equal comparison
  ///
  /// Regards both *this as an unsigned quantity and compares it with RHS for
  /// the validity of the less-or-equal relationship.
  ///
  /// \returns true if *this <= RHS when considered unsigned.
  constexpr bool ule(unsigned long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::ule1, Xs..., RHS); }) , (;) )
  /// Signed less or equal comparison
  ///
  /// Regards both *this and RHS as signed quantities and compares them for
  /// validity of the less-or-equal relationship.
  ///
  /// \returns true if *this <= RHS when both are considered signed.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool sle(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::sle, Xs..., Y0s...); }) , (;) )
  /// Signed less or equal comparison
  ///
  /// Regards both *this as a signed quantity and compares it with RHS for the
  /// validity of the less-or-equal relationship.
  ///
  /// \returns true if *this <= RHS when considered signed.
  constexpr bool sle(unsigned long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::sle1, Xs..., RHS); }) , (;) )
  /// Unsigned greather than comparison
  ///
  /// Regards both *this and RHS as unsigned quantities and compares them for
  /// the validity of the greater-than relationship.
  ///
  /// \returns true if *this > RHS when both are considered unsigned.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool ugt(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::ugt, Xs..., Y0s...); }) , (;) )
  /// Unsigned greater than comparison
  ///
  /// Regards both *this as an unsigned quantity and compares it with RHS for
  /// the validity of the greater-than relationship.
  ///
  /// \returns true if *this > RHS when considered unsigned.
  constexpr bool ugt(unsigned long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::ugt1, Xs..., RHS); }) , (;) )
  /// Signed greather than comparison
  ///
  /// Regards both *this and RHS as signed quantities and compares them for the
  /// validity of the greater-than relationship.
  ///
  /// \returns true if *this > RHS when both are considered signed.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool sgt(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::sgt, Xs..., Y0s...); }) , (;) )
  /// Signed greater than comparison
  ///
  /// Regards both *this as a signed quantity and compares it with RHS for
  /// the validity of the greater-than relationship.
  ///
  /// \returns true if *this > RHS when considered signed.
  constexpr bool sgt(long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::sgt1, Xs..., RHS); }) , (;) )
  /// Unsigned greater or equal comparison
  ///
  /// Regards both *this and RHS as unsigned quantities and compares them for
  /// validity of the greater-or-equal relationship.
  ///
  /// \returns true if *this >= RHS when both are considered unsigned.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool uge(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::uge, Xs..., Y0s...); }) , (;) )
  /// Unsigned greater or equal comparison
  ///
  /// Regards both *this as an unsigned quantity and compares it with RHS for
  /// the validity of the greater-or-equal relationship.
  ///
  /// \returns true if *this >= RHS when considered unsigned.
  constexpr bool uge(unsigned long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::uge1, Xs..., RHS); }) , (;) )
  /// Signed greater or equal comparison
  ///
  /// Regards both *this and RHS as signed quantities and compares them for
  /// validity of the greater-or-equal relationship.
  ///
  /// \returns true if *this >= RHS when both are considered signed.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool sge(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::sge, Xs..., Y0s...); }) , (;) )
  /// Signed greater or equal comparison
  ///
  /// Regards both *this as a signed quantity and compares it with RHS for
  /// the validity of the greater-or-equal relationship.
  ///
  /// \returns true if *this >= RHS when considered signed.
  constexpr bool sge(long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::sge1, Xs..., RHS); }) , (;) )
  /// This operation tests if there are any pairs of corresponding bits
  /// between this APInt and RHS that are both set.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool intersects(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::intersects, Xs..., Y0s...); }) , (;) )
  /// This operation checks that all bits set in this APInt are also set in RHS.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isSubsetOf(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::isSubsetOf, Xs..., Y0s...); }) , (;) )
  /// Return the number of bits in the APInt.
  constexpr unsigned int getBitWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::getBitWidth, Xs...); }) , (;) )
  /// Get the number of words.
  ///
  /// Here one word's bitwidth equals to that of uint64_t.
  ///
  /// \returns the number of words to hold the integer value of this APInt.
  constexpr unsigned int getNumWords() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::getNumWords, Xs...); }) , (;) )
  /// Get the number of words.
  ///
  /// *NOTE* Here one word's bitwidth equals to that of uint64_t.
  ///
  /// \returns the number of words to hold the integer value with a given bit
  /// width.
  static constexpr unsigned int getNumWords(unsigned int BitWidth) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::getNumWords1, Xs..., BitWidth); }) , (;) )
  /// Compute the number of active bits in the value
  ///
  /// This function returns the number of active bits which is defined as the
  /// bit width minus the number of leading zeros. This is used in several
  /// computations to see how "wide" the value is.
  constexpr unsigned int getActiveBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::getActiveBits, Xs...); }) , (;) )
  /// Compute the number of active words in the value of this APInt.
  ///
  /// This is used in conjunction with getActiveData to extract the raw value of
  /// the APInt.
  constexpr unsigned int getActiveWords() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::getActiveWords, Xs...); }) , (;) )
  /// Get the minimum bit size for this signed APInt
  ///
  /// Computes the minimum bit width for this APInt while considering it to be a
  /// signed (and probably negative) value. If the value is not negative, this
  /// function returns the same value as getActiveBits()+1. Otherwise, it
  /// returns the smallest bit width that will retain the negative value. For
  /// example, -1 can be written as 0b1 or 0xFFFFFFFFFF. 0b1 is shorter and so
  /// for -1, this function will always return 1.
  constexpr unsigned int getMinSignedBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::getMinSignedBits, Xs...); }) , (;) )
  /// Get zero extended value
  ///
  /// This method attempts to return the value of this APInt as a zero extended
  /// uint64_t. The bitwidth must be <= 64 or the value must fit within a
  /// uint64_t. Otherwise an assertion will result.
  constexpr unsigned long long getZExtValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::getZExtValue, Xs...); }) , (;) )
  /// Get sign extended value
  ///
  /// This method attempts to return the value of this APInt as a sign extended
  /// int64_t. The bit width must be <= 64 or the value must fit within an
  /// int64_t. Otherwise an assertion will result.
  constexpr long long getSExtValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::getSExtValue, Xs...); }) , (;) )
  /// Get bits required for string value.
  ///
  /// This method determines how many bits are required to hold the APInt
  /// equivalent of the string given by \p str.
  static constexpr unsigned int getBitsNeeded(const char * str, unsigned char radix) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::getBitsNeeded, Xs..., str, radix); }) , (;) )
  /// The APInt version of the countLeadingZeros functions in
  ///   MathExtras.h.
  ///
  /// It counts the number of zeros from the most significant bit to the first
  /// one bit.
  ///
  /// \returns BitWidth if the value is zero, otherwise returns the number of
  ///   zeros from the most significant bit to the first one bits.
  constexpr unsigned int countLeadingZeros() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::countLeadingZeros, Xs...); }) , (;) )
  /// Count the number of leading one bits.
  ///
  /// This function is an APInt version of the countLeadingOnes
  /// functions in MathExtras.h. It counts the number of ones from the most
  /// significant bit to the first zero bit.
  ///
  /// \returns 0 if the high order bit is not set, otherwise returns the number
  /// of 1 bits from the most significant to the least
  constexpr unsigned int countLeadingOnes() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::countLeadingOnes, Xs...); }) , (;) )
  /// Computes the number of leading bits of this APInt that are equal to its
  /// sign bit.
  constexpr unsigned int getNumSignBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::getNumSignBits, Xs...); }) , (;) )
  /// Count the number of trailing zero bits.
  ///
  /// This function is an APInt version of the countTrailingZeros
  /// functions in MathExtras.h. It counts the number of zeros from the least
  /// significant bit to the first set bit.
  ///
  /// \returns BitWidth if the value is zero, otherwise returns the number of
  /// zeros from the least significant bit to the first one bit.
  constexpr unsigned int countTrailingZeros() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::countTrailingZeros, Xs...); }) , (;) )
  /// Count the number of trailing one bits.
  ///
  /// This function is an APInt version of the countTrailingOnes
  /// functions in MathExtras.h. It counts the number of ones from the least
  /// significant bit to the first zero bit.
  ///
  /// \returns BitWidth if the value is all ones, otherwise returns the number
  /// of ones from the least significant bit to the first zero bit.
  constexpr unsigned int countTrailingOnes() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::countTrailingOnes, Xs...); }) , (;) )
  /// Count the number of bits set.
  ///
  /// This function is an APInt version of the countPopulation functions
  /// in MathExtras.h. It counts the number of 1 bits in the APInt value.
  ///
  /// \returns 0 if the value is zero, otherwise returns the number of set bits.
  constexpr unsigned int countPopulation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::countPopulation, Xs...); }) , (;) )
  /// @}
  /// \name Conversion Functions
  /// @{
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void print(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, bool isSigned) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::print, Xs..., Y0s..., isSigned); }) , (;) )
  /// Return the APInt as a std::string.
  ///
  /// Note that this is an inefficient method.  It is better to pass in a
  /// SmallVector/SmallString to the methods above to avoid thrashing the heap
  /// for the string.
  constexpr const char * toString(unsigned int Radix, bool Signed) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::toString, Xs..., Radix, Signed); }) , (;) )
  /// Converts this APInt to a double value.
  constexpr double roundToDouble(bool isSigned) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::roundToDouble, Xs..., isSigned); }) , (;) )
  /// Converts this unsigned APInt to a double value.
  constexpr double roundToDouble() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::roundToDouble1, Xs...); }) , (;) )
  /// Converts this signed APInt to a double value.
  constexpr double signedRoundToDouble() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::signedRoundToDouble, Xs...); }) , (;) )
  /// Converts APInt bits to a double
  ///
  /// The conversion does not do a translation from integer to double, it just
  /// re-interprets the bits as a double. Note that it is valid to do this on
  /// any bit width. Exactly 64 bits will be translated.
  constexpr double bitsToDouble() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::bitsToDouble, Xs...); }) , (;) )
  /// Converts APInt bits to a double
  ///
  /// The conversion does not do a translation from integer to float, it just
  /// re-interprets the bits as a float. Note that it is valid to do this on
  /// any bit width. Exactly 32 bits will be translated.
  constexpr float bitsToFloat() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::bitsToFloat, Xs...); }) , (;) )
  /// \returns the floor log base 2 of this APInt.
  constexpr unsigned int logBase2() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::logBase2, Xs...); }) , (;) )
  /// \returns the ceil log base 2 of this APInt.
  constexpr unsigned int ceilLogBase2() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::ceilLogBase2, Xs...); }) , (;) )
  /// \returns the nearest log base 2 of this APInt. Ties round up.
  ///
  /// NOTE: When we have a BitWidth of 1, we define:
  ///
  ///   log2(0) = UINT32_MAX
  ///   log2(1) = 0
  ///
  /// to get around any mathematical concerns resulting from
  /// referencing 2 in a space where 2 does no exist.
  constexpr unsigned int nearestLogBase2() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::nearestLogBase2, Xs...); }) , (;) )
  /// \returns the log base 2 of this APInt if its an exact power of two, -1
  /// otherwise
  constexpr int exactLogBase2() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::exactLogBase2, Xs...); }) , (;) )
  M_template_rtpack(Zs) using ms = struct refldetail::llvm::APInt::ms::M_template impl M_targpack(Zs);
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APInt::ms) )
  magic() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::magic, Xs...); }) , (;) )
  M_template_rtpack(Zs) using mu = struct refldetail::llvm::APInt::mu::M_template impl M_targpack(Zs);
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APInt::mu) )
  magicu(unsigned int LeadingZeros = 0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::magicu, Xs..., LeadingZeros); }) , (;) )
  /// Sets the least significant part of a bignum to the input value, and zeroes
  /// out higher parts.
  static constexpr void tcSet(unsigned long long * p0, unsigned long long p1, unsigned int p2) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcSet, Xs..., p0, p1, p2); }) , (;) )
  /// Assign one bignum to another.
  static constexpr void tcAssign(unsigned long long * p0, const unsigned long long * p1, unsigned int p2) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcAssign, Xs..., p0, p1, p2); }) , (;) )
  /// Returns true if a bignum is zero, false otherwise.
  static constexpr bool tcIsZero(const unsigned long long * p0, unsigned int p1) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcIsZero, Xs..., p0, p1); }) , (;) )
  /// Extract the given bit of a bignum; returns 0 or 1.  Zero-based.
  static constexpr int tcExtractBit(const unsigned long long * p0, unsigned int bit) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcExtractBit, Xs..., p0, bit); }) , (;) )
  /// Copy the bit vector of width srcBITS from SRC, starting at bit srcLSB, to
  /// DST, of dstCOUNT parts, such that the bit srcLSB becomes the least
  /// significant bit of DST.  All high bits above srcBITS in DST are
  /// zero-filled.
  static constexpr void tcExtract(unsigned long long * p0, unsigned int dstCount, const unsigned long long * p2, unsigned int srcBits, unsigned int srcLSB) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcExtract, Xs..., p0, dstCount, p2, srcBits, srcLSB); }) , (;) )
  /// Set the given bit of a bignum.  Zero-based.
  static constexpr void tcSetBit(unsigned long long * p0, unsigned int bit) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcSetBit, Xs..., p0, bit); }) , (;) )
  /// Clear the given bit of a bignum.  Zero-based.
  static constexpr void tcClearBit(unsigned long long * p0, unsigned int bit) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcClearBit, Xs..., p0, bit); }) , (;) )
  /// Returns the bit number of the least or most significant set bit of a
  /// number.  If the input number has no bits set -1U is returned.
  static constexpr unsigned int tcLSB(const unsigned long long * p0, unsigned int n) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcLSB, Xs..., p0, n); }) , (;) )
  static constexpr unsigned int tcMSB(const unsigned long long * parts, unsigned int n) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcMSB, Xs..., parts, n); }) , (;) )
  /// Negate a bignum in-place.
  static constexpr void tcNegate(unsigned long long * p0, unsigned int p1) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcNegate, Xs..., p0, p1); }) , (;) )
  /// DST += RHS + CARRY where CARRY is zero or one.  Returns the carry flag.
  static constexpr unsigned long long tcAdd(unsigned long long * p0, const unsigned long long * p1, unsigned long long carry, unsigned int p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcAdd, Xs..., p0, p1, carry, p3); }) , (;) )
  /// DST += RHS.  Returns the carry flag.
  static constexpr unsigned long long tcAddPart(unsigned long long * p0, unsigned long long p1, unsigned int p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcAddPart, Xs..., p0, p1, p2); }) , (;) )
  /// DST -= RHS + CARRY where CARRY is zero or one. Returns the carry flag.
  static constexpr unsigned long long tcSubtract(unsigned long long * p0, const unsigned long long * p1, unsigned long long carry, unsigned int p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcSubtract, Xs..., p0, p1, carry, p3); }) , (;) )
  /// DST -= RHS.  Returns the carry flag.
  static constexpr unsigned long long tcSubtractPart(unsigned long long * p0, unsigned long long p1, unsigned int p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcSubtractPart, Xs..., p0, p1, p2); }) , (;) )
  /// DST += SRC * MULTIPLIER + PART   if add is true
  /// DST  = SRC * MULTIPLIER + PART   if add is false
  ///
  /// Requires 0 <= DSTPARTS <= SRCPARTS + 1.  If DST overlaps SRC they must
  /// start at the same point, i.e. DST == SRC.
  ///
  /// If DSTPARTS == SRC_PARTS + 1 no overflow occurs and zero is returned.
  /// Otherwise DST is filled with the least significant DSTPARTS parts of the
  /// result, and if all of the omitted higher parts were zero return zero,
  /// otherwise overflow occurred and return one.
  static constexpr int tcMultiplyPart(unsigned long long * dst, const unsigned long long * src, unsigned long long multiplier, unsigned long long carry, unsigned int srcParts, unsigned int dstParts, bool add) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcMultiplyPart, Xs..., dst, src, multiplier, carry, srcParts, dstParts, add); }) , (;) )
  /// DST = LHS * RHS, where DST has the same width as the operands and is
  /// filled with the least significant parts of the result.  Returns one if
  /// overflow occurred, otherwise zero.  DST must be disjoint from both
  /// operands.
  static constexpr int tcMultiply(unsigned long long * p0, const unsigned long long * p1, const unsigned long long * p2, unsigned int p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcMultiply, Xs..., p0, p1, p2, p3); }) , (;) )
  /// DST = LHS * RHS, where DST has width the sum of the widths of the
  /// operands. No overflow occurs. DST must be disjoint from both operands.
  static constexpr void tcFullMultiply(unsigned long long * p0, const unsigned long long * p1, const unsigned long long * p2, unsigned int p3, unsigned int p4) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcFullMultiply, Xs..., p0, p1, p2, p3, p4); }) , (;) )
  /// If RHS is zero LHS and REMAINDER are left unchanged, return one.
  /// Otherwise set LHS to LHS / RHS with the fractional part discarded, set
  /// REMAINDER to the remainder, return zero.  i.e.
  ///
  ///  OLD_LHS = RHS * LHS + REMAINDER
  ///
  /// SCRATCH is a bignum of the same size as the operands and result for use by
  /// the routine; its contents need not be initialized and are destroyed.  LHS,
  /// REMAINDER and SCRATCH must be distinct.
  static constexpr int tcDivide(unsigned long long * lhs, const unsigned long long * rhs, unsigned long long * remainder, unsigned long long * scratch, unsigned int parts) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcDivide, Xs..., lhs, rhs, remainder, scratch, parts); }) , (;) )
  /// Shift a bignum left Count bits. Shifted in bits are zero. There are no
  /// restrictions on Count.
  static constexpr void tcShiftLeft(unsigned long long * p0, unsigned int Words, unsigned int Count) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcShiftLeft, Xs..., p0, Words, Count); }) , (;) )
  /// Shift a bignum right Count bits.  Shifted in bits are zero.  There are no
  /// restrictions on Count.
  static constexpr void tcShiftRight(unsigned long long * p0, unsigned int Words, unsigned int Count) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcShiftRight, Xs..., p0, Words, Count); }) , (;) )
  /// The obvious AND, OR and XOR and complement operations.
  static constexpr void tcAnd(unsigned long long * p0, const unsigned long long * p1, unsigned int p2) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcAnd, Xs..., p0, p1, p2); }) , (;) )
  static constexpr void tcOr(unsigned long long * p0, const unsigned long long * p1, unsigned int p2) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcOr, Xs..., p0, p1, p2); }) , (;) )
  static constexpr void tcXor(unsigned long long * p0, const unsigned long long * p1, unsigned int p2) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcXor, Xs..., p0, p1, p2); }) , (;) )
  static constexpr void tcComplement(unsigned long long * p0, unsigned int p1) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcComplement, Xs..., p0, p1); }) , (;) )
  /// Comparison (unsigned) of two bignums.
  static constexpr int tcCompare(const unsigned long long * p0, const unsigned long long * p1, unsigned int p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcCompare, Xs..., p0, p1, p2); }) , (;) )
  /// Increment a bignum in-place.  Return the carry flag.
  static constexpr unsigned long long tcIncrement(unsigned long long * dst, unsigned int parts) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcIncrement, Xs..., dst, parts); }) , (;) )
  /// Decrement a bignum in-place.  Return the borrow flag.
  static constexpr unsigned long long tcDecrement(unsigned long long * dst, unsigned int parts) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcDecrement, Xs..., dst, parts); }) , (;) )
  /// Set the least significant BITS and clear the rest.
  static constexpr void tcSetLeastSignificantBits(unsigned long long * p0, unsigned int p1, unsigned int bits) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::tcSetLeastSignificantBits, Xs..., p0, p1, bits); }) , (;) )
  /// debug method
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APInt, reflenums::llvm__APInt::dump, Xs...); }) , (;) )
};

/// Magic data for optimising signed division by a constant.
M_template_rtpack(Xs)
struct llvm::APInt::ms::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__APInt__ms;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::APInt::ms::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  ///< shift amount
  unsigned int s
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_llvm__APInt__ms, reflenums::llvm__APInt__ms::s, Xs...);), (;) )
};

/// Magic data for optimising unsigned division by a constant.
M_template_rtpack(Xs)
struct llvm::APInt::mu::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__APInt__mu;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::APInt::mu::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  ///< add indicator
  bool a
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_llvm__APInt__mu, reflenums::llvm__APInt__mu::a, Xs...);), (;) )
  ///< shift amount
  unsigned int s
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_llvm__APInt__mu, reflenums::llvm__APInt__mu::s, Xs...);), (;) )
};

/// IEEE-754R 5.11: Floating Point Comparison Relations.
enum llvm::APFloatBase::cmpResult : unsigned int {
  cmpLessThan,
  cmpEqual,
  cmpGreaterThan,
  cmpUnordered,
};

/// IEEE-754R 4.3: Rounding-direction attributes.
enum llvm::APFloatBase::roundingMode : unsigned int {
  rmNearestTiesToEven,
  rmTowardPositive,
  rmTowardNegative,
  rmTowardZero,
  rmNearestTiesToAway,
};

/// IEEE-754R 7: Default exception handling.
///
/// opUnderflow or opOverflow are always returned or-ed with opInexact.
enum llvm::APFloatBase::opStatus : unsigned int {
  opOK = 0,
  opInvalidOp = 1,
  opDivByZero = 2,
  opOverflow = 4,
  opUnderflow = 8,
  opInexact = 16,
};

/// Category of internally-represented number.
enum llvm::APFloatBase::fltCategory : unsigned int {
  fcInfinity,
  fcNaN,
  fcNormal,
  fcZero,
};

/// A self-contained host- and target-independent arbitrary-precision
/// floating-point software implementation.
///
/// APFloat uses bignum integer arithmetic as provided by static functions in
/// the APInt class.  The library will work with bignum integers whose parts are
/// any unsigned type at least 16 bits wide, but 64 bits is recommended.
///
/// Written for clarity rather than speed, in particular with a view to use in
/// the front-end of a cross compiler so that target arithmetic can be correctly
/// performed on the host.  Performance should nonetheless be reasonable,
/// particularly for its intended use.  It may be useful as a base
/// implementation for a run-time library during development of a faster
/// target-specific one.
///
/// All 5 rounding modes in the IEEE-754R draft are handled correctly for all
/// implemented operations.  Currently implemented operations are add, subtract,
/// multiply, divide, fused-multiply-add, conversion-to-float,
/// conversion-to-integer and conversion-from-integer.  New rounding modes
/// (e.g. away from zero) can be added with three or four lines of code.
///
/// Four formats are built-in: IEEE single precision, double precision,
/// quadruple precision, and x87 80-bit extended double (when operating with
/// full extended precision).  Adding a new format that obeys IEEE semantics
/// only requires adding two lines of code: a declaration and definition of the
/// format.
///
/// All operations return the status of that operation as an exception bit-mask,
/// so multiple operations can be done consecutively with their results or-ed
/// together.  The returned status can be useful for compiler diagnostics; e.g.,
/// inexact, underflow and overflow can be easily diagnosed on constant folding,
/// and compiler optimizers can determine what exceptions would be raised by
/// folding operations and optimize, or perhaps not optimize, accordingly.
///
/// At present, underflow tininess is detected after rounding; it should be
/// straight forward to add support for the before-rounding case too.
///
/// The library reads hexadecimal floating point numbers as per C99, and
/// correctly rounds if necessary according to the specified rounding mode.
/// Syntax is required to have been validated by the caller.  It also converts
/// floating point numbers to hexadecimal text as per the C99 %a and %A
/// conversions.  The output precision (or alternatively the natural minimal
/// precision) can be specified; if the requested precision is less than the
/// natural precision the output is correctly rounded for the specified rounding
/// mode.
///
/// It also reads decimal floating point numbers and correctly rounds according
/// to the specified rounding mode.
///
/// Conversion to decimal text is not currently implemented.
///
/// Non-zero finite numbers are represented internally as a sign bit, a 16-bit
/// signed exponent, and the significand as an array of integer parts.  After
/// normalization of a number of precision P the exponent is within the range of
/// the format, and if the number is not denormal the P-th bit of the
/// significand is set as an explicit integer bit.  For denormals the most
/// significant bit is shifted right so that the exponent is maintained at the
/// format's minimum, so that the smallest denormal has just the least
/// significant bit of the significand set.  The sign of zeroes and infinities
/// is significant; the exponent and significand of such numbers is not stored,
/// but has a known implicit (deterministic) value: 0 for the significands, 0
/// for zero exponent, all 1 bits for infinity exponent.  For NaNs the sign and
/// significand are deterministic, although not really meaningful, and preserved
/// in non-conversion operations.  The exponent is implicitly all 1 bits.
///
/// APFloat does not provide any exception handling beyond default exception
/// handling. We represent Signaling NaNs via IEEE-754R 2008 6.2.1 should clause
/// by encoding Signaling NaNs with the first bit of its trailing significand as
/// 0.
///
/// TODO
/// ====
///
/// Some features that may or may not be worth adding:
///
/// Binary to decimal conversion (hard).
///
/// Optional ability to detect underflow tininess before rounding.
///
/// New formats: x87 in single and double precision mode (IEEE apart from
/// extended exponent range) (hard).
///
/// New operations: sqrt, IEEE remainder, C90 fmod, nexttoward.
///
M_template_rtpack(Xs)
struct llvm::APFloatBase::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__APFloatBase;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::APFloatBase::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  static const unsigned int integerPartWidth = 64u;
  using cmpResult = enum refldetail::llvm::APFloatBase::cmpResult;
  using roundingMode = enum refldetail::llvm::APFloatBase::roundingMode;
  using opStatus = enum refldetail::llvm::APFloatBase::opStatus;
  using fltCategory = enum refldetail::llvm::APFloatBase::fltCategory;
};

M_template_rtpack(Xs)
struct llvm::APFloat::impl : impl_offset_t<llvm::APFloatBase, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__APFloat;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::APFloat::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool needsCleanup() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::needsCleanup, Xs...); }) , (;) )
  /// Used to insert APFloat objects, or objects that contain APFloat objects,
  /// into FoldingSets.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) NID) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::Profile, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum llvm::APFloatBase::opStatus convertToInteger(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::APSInt &)) Result, enum llvm::APFloatBase::roundingMode RM, bool * IsExact) const IFMETA_ELSE( ({    return (enum llvm::APFloatBase::opStatus)__reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::convertToInteger, Xs..., Y0s..., RM, IsExact); }) , (;) )
  constexpr double convertToDouble() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::convertToDouble, Xs...); }) , (;) )
  constexpr float convertToFloat() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::convertToFloat, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum llvm::APFloatBase::cmpResult compare(IFMETA_ELSE((const llvm::APFloat::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APFloat &)) RHS) const IFMETA_ELSE( ({    return (enum llvm::APFloatBase::cmpResult)__reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::compare, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool bitwiseIsEqual(IFMETA_ELSE((const llvm::APFloat::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APFloat &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::bitwiseIsEqual, Xs..., Y0s...); }) , (;) )
  /// We don't rely on operator== working on double values, as
  /// it returns true for things that are clearly not equal, like -0.0 and 0.0.
  /// As such, this method can be used to do an exact bit-for-bit comparison of
  /// two floating point values.
  ///
  /// We leave the version with the double argument here because it's just so
  /// convenient to write "2.0" and the like.  Without this function we'd
  /// have to duplicate its logic everywhere it's called.
  constexpr bool isExactlyValue(double V) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isExactlyValue, Xs..., V); }) , (;) )
  constexpr unsigned int convertToHexString(char * DST, unsigned int HexDigits, bool UpperCase, enum llvm::APFloatBase::roundingMode RM) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::convertToHexString, Xs..., DST, HexDigits, UpperCase, RM); }) , (;) )
  constexpr bool isZero() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isZero, Xs...); }) , (;) )
  constexpr bool isInfinity() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isInfinity, Xs...); }) , (;) )
  constexpr bool isNaN() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isNaN, Xs...); }) , (;) )
  constexpr bool isNegative() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isNegative, Xs...); }) , (;) )
  constexpr bool isDenormal() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isDenormal, Xs...); }) , (;) )
  constexpr bool isSignaling() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isSignaling, Xs...); }) , (;) )
  constexpr bool isNormal() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isNormal, Xs...); }) , (;) )
  constexpr bool isFinite() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isFinite, Xs...); }) , (;) )
  constexpr enum llvm::APFloatBase::fltCategory getCategory() const IFMETA_ELSE( ({    return (enum llvm::APFloatBase::fltCategory)__reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::getCategory, Xs...); }) , (;) )
  constexpr bool isNonZero() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isNonZero, Xs...); }) , (;) )
  constexpr bool isFiniteNonZero() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isFiniteNonZero, Xs...); }) , (;) )
  constexpr bool isPosZero() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isPosZero, Xs...); }) , (;) )
  constexpr bool isNegZero() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isNegZero, Xs...); }) , (;) )
  constexpr bool isSmallest() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isSmallest, Xs...); }) , (;) )
  constexpr bool isLargest() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isLargest, Xs...); }) , (;) )
  constexpr bool isInteger() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::isInteger, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void print(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) p0) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::print, Xs..., Y0s...); }) , (;) )
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::dump, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool getExactInverse(IFMETA_ELSE((const llvm::APFloat::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::APFloat *)) inv) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APFloat, reflenums::llvm__APFloat::getExactInverse, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool getExactInverse(ptrwrp<Y0> p0) const {
      return getExactInverse(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct llvm::APSInt::impl : impl_offset_t<llvm::APInt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__APSInt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::APSInt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isSigned() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::isSigned, Xs...); }) , (;) )
  constexpr bool isUnsigned() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::isUnsigned, Xs...); }) , (;) )
  /// toString - Converts an APInt to a std::string.  This is an inefficient
  /// method; you should prefer passing in a SmallString instead.
  constexpr const char * toString(unsigned int Radix) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::toString, Xs..., Radix); }) , (;) )
  /// Get the correctly-extended \c int64_t value.
  constexpr long long getExtValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::getExtValue, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  trunc(unsigned int width) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::trunc, Xs..., width); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  extend(unsigned int width) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::extend, Xs..., width); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  extOrTrunc(unsigned int width) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::extOrTrunc, Xs..., width); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  operator%(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_mod, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  operator/(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_div, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  operator>>(unsigned int Amt) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_gr_gr, Xs..., Amt); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_less, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator>(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_gr, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<=(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_less_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator>=(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_gr_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_not_eq, Xs..., Y0s...); }) , (;) )
  constexpr bool operator==(long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_eq_eq1, Xs..., RHS); }) , (;) )
  constexpr bool operator!=(long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_not_eq1, Xs..., RHS); }) , (;) )
  constexpr bool operator<=(long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_less_eq1, Xs..., RHS); }) , (;) )
  constexpr bool operator>=(long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_gr_eq1, Xs..., RHS); }) , (;) )
  constexpr bool operator<(long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_less1, Xs..., RHS); }) , (;) )
  constexpr bool operator>(long long RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_gr1, Xs..., RHS); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  operator<<(unsigned int Bits) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_less_less, Xs..., Bits); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  operator-() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_minus, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  operator&(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_and, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  operator|(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_or, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  operator^(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_exp, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  operator*(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_star, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  operator+(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_plus, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  operator-(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_minus1, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  operator~() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::operator_tilde, Xs...); }) , (;) )
  /// getMaxValue - Return the APSInt representing the maximum integer value
  ///  with the given bit width and signedness.
  static constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  getMaxValue(unsigned int numBits, bool Unsigned) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::getMaxValue, Xs..., numBits, Unsigned); }) , (;) )
  /// getMinValue - Return the APSInt representing the minimum integer value
  ///  with the given bit width and signedness.
  static constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  getMinValue(unsigned int numBits, bool Unsigned) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::getMinValue, Xs..., numBits, Unsigned); }) , (;) )
  /// Determine if two APSInts have the same value, zero- or
  /// sign-extending as needed.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr bool isSameValue(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) I1, IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::APSInt &)) I2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::isSameValue, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Compare underlying values of two numbers.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr int compareValues(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APSInt &)) I1, IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::APSInt &)) I2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::compareValues, Xs..., Y0s..., Y1s...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  get(long long X) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::get, Xs..., X); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  getUnsigned(unsigned long long X) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::getUnsigned, Xs..., X); }) , (;) )
  /// Profile - Used to insert APSInt objects, or objects that contain APSInt
  ///  objects, into FoldingSets.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__APSInt, reflenums::llvm__APSInt::Profile, Xs..., Y0s...); }) , (;) )
};

enum clang::APValue::ValueKind : unsigned int {
  Uninitialized,
  Int,
  Float,
  ComplexInt,
  ComplexFloat,
  LValue,
  Vector,
  Array,
  Struct,
  Union,
  MemberPointer,
  AddrLabelDiff,
};

/// APValue - This class implements a discriminated union of [uninitialized]
/// [APSInt] [APFloat], [Complex APSInt] [Complex APFloat], [Expr + Offset],
/// [Vector: N * APValue], [Array: N * APValue]
M_template_rtpack(Xs)
struct clang::APValue::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__APValue;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::APValue::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using ValueKind = enum refldetail::clang::APValue::ValueKind;
  M_template_rtpack(Zs) using LValueBase = struct refldetail::clang::APValue::LValueBase::M_template impl M_targpack(Zs);
  static const unsigned long DataSize = 64u;
  /// Returns whether the object performed allocations.
  ///
  /// If APValues are constructed via placement new, \c needsCleanup()
  /// indicates whether the destructor must be called in order to correctly
  /// free all allocated memory.
  constexpr bool needsCleanup() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::needsCleanup, Xs...); }) , (;) )
  constexpr enum clang::APValue::ValueKind getKind() const IFMETA_ELSE( ({    return (enum clang::APValue::ValueKind)__reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getKind, Xs...); }) , (;) )
  constexpr bool isUninit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isUninit, Xs...); }) , (;) )
  constexpr bool isInt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isInt, Xs...); }) , (;) )
  constexpr bool isFloat() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isFloat, Xs...); }) , (;) )
  constexpr bool isComplexInt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isComplexInt, Xs...); }) , (;) )
  constexpr bool isComplexFloat() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isComplexFloat, Xs...); }) , (;) )
  constexpr bool isLValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isLValue, Xs...); }) , (;) )
  constexpr bool isVector() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isVector, Xs...); }) , (;) )
  constexpr bool isArray() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isArray, Xs...); }) , (;) )
  constexpr bool isStruct() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isStruct, Xs...); }) , (;) )
  constexpr bool isUnion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isUnion, Xs...); }) , (;) )
  constexpr bool isMemberPointer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isMemberPointer, Xs...); }) , (;) )
  constexpr bool isAddrLabelDiff() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isAddrLabelDiff, Xs...); }) , (;) )
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::dump, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void dump(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::dump1, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr void printPretty(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (typename meta::clang::ASTContext &)) Ctx, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) Ty) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::printPretty, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr const char * getAsString(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getAsString, Xs..., Y0s..., Y1s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::APSInt &) )
  getInt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getInt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::APFloat &) )
  getFloat() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getFloat, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::APSInt &) )
  getComplexIntReal() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getComplexIntReal, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::APSInt &) )
  getComplexIntImag() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getComplexIntImag, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::APFloat &) )
  getComplexFloatReal() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getComplexFloatReal, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::APFloat &) )
  getComplexFloatImag() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getComplexFloatImag, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::APValue::LValueBase) )
  getLValueBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getLValueBase, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CharUnits &) )
  getLValueOffset() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getLValueOffset, Xs...); }) , (;) )
  constexpr bool isLValueOnePastTheEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isLValueOnePastTheEnd, Xs...); }) , (;) )
  constexpr bool hasLValuePath() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::hasLValuePath, Xs...); }) , (;) )
  constexpr unsigned int getLValueCallIndex() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getLValueCallIndex, Xs...); }) , (;) )
  constexpr unsigned int getLValueVersion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getLValueVersion, Xs...); }) , (;) )
  constexpr bool isNullPointer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isNullPointer, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::APValue &) )
  getVectorElt(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getVectorElt, Xs..., I); }) , (;) )
  constexpr unsigned int getVectorLength() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getVectorLength, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::APValue &) )
  getArrayInitializedElt(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getArrayInitializedElt, Xs..., I); }) , (;) )
  constexpr bool hasArrayFiller() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::hasArrayFiller, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::APValue &) )
  getArrayFiller() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getArrayFiller, Xs...); }) , (;) )
  constexpr unsigned int getArrayInitializedElts() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getArrayInitializedElts, Xs...); }) , (;) )
  constexpr unsigned int getArraySize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getArraySize, Xs...); }) , (;) )
  constexpr unsigned int getStructNumBases() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getStructNumBases, Xs...); }) , (;) )
  constexpr unsigned int getStructNumFields() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getStructNumFields, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::APValue &) )
  getStructBase(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getStructBase, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::APValue &) )
  getStructField(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getStructField, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FieldDecl *) )
  getUnionField() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getUnionField, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::APValue &) )
  getUnionValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getUnionValue, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ValueDecl *) )
  getMemberPointerDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getMemberPointerDecl, Xs...); }) , (;) )
  constexpr bool isMemberPointerToDerivedMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::isMemberPointerToDerivedMember, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::APValue, getMemberPointerPath,
      constexpr auto getMemberPointerPath() const ,
      (const typename meta::clang::CXXRecordDecl *),
      (reflenums::RK_clang__APValue, reflenums::clang__APValue::getMemberPointerPath, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::AddrLabelExpr *) )
  getAddrLabelDiffLHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getAddrLabelDiffLHS, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::AddrLabelExpr *) )
  getAddrLabelDiffRHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue, reflenums::clang__APValue::getAddrLabelDiffRHS, Xs...); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::APValue::LValueBase::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__APValue__LValueBase;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::APValue::LValueBase::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr void * getOpaqueValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue__LValueBase, reflenums::clang__APValue__LValueBase::getOpaqueValue, Xs...); }) , (;) )
  constexpr bool isNull() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue__LValueBase, reflenums::clang__APValue__LValueBase::isNull, Xs...); }) , (;) )
  constexpr explicit operator bool() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue__LValueBase, reflenums::clang__APValue__LValueBase::operator_bool, Xs...); }) , (;) )
  constexpr unsigned int getCallIndex() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue__LValueBase, reflenums::clang__APValue__LValueBase::getCallIndex, Xs...); }) , (;) )
  constexpr unsigned int getVersion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue__LValueBase, reflenums::clang__APValue__LValueBase::getVersion, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const clang::APValue::LValueBase::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::APValue::LValueBase &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__APValue__LValueBase, reflenums::clang__APValue__LValueBase::operator_eq_eq, Xs..., Y0s...); }) , (;) )
};

/// Enum values that allow the client to map NOTEs, WARNINGs, and EXTENSIONs
  /// to either Ignore (nothing), Remark (emit a remark), Warning
  /// (emit a warning) or Error (emit as an error).  It allows clients to
  /// map ERRORs to Error or Fatal (stop emitting diagnostics after this one).
enum class clang::diag::Severity : int {
  ///< Do not present this diagnostic, ignore it.
  Ignored = 1,
  ///< Present this diagnostic as a remark.
  Remark = 2,
  ///< Present this diagnostic as a warning.
  Warning = 3,
  ///< Present this diagnostic as an error.
  Error = 4,
  ///< Present this diagnostic as a fatal error.
  Fatal = 5,
};

/// Specifies which overload candidates to display when overload
/// resolution fails.
enum clang::OverloadsShown : unsigned int {
  /// Show all overloads.
  Ovl_All,
  /// Show just the "best" overload candidates.
  Ovl_Best,
};

/// A bitmask representing the diagnostic levels used by
/// VerifyDiagnosticConsumer.
enum class clang::DiagnosticLevelMask : unsigned int {
  None = 0,
  Note = 1,
  Remark = 2,
  Warning = 4,
  Error = 8,
  All = 15,
};

enum clang::DiagnosticOptions::TextDiagnosticFormat : unsigned int {
  Clang,
  MSVC,
  Vi,
};

/// Options for controlling the compiler diagnostics engine.
M_template_rtpack(Xs)
struct clang::DiagnosticOptions::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DiagnosticOptions;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DiagnosticOptions::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr void Retain() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::Retain, Xs...); }) , (;) )
  constexpr void Release() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::Release, Xs...); }) , (;) )
  using TextDiagnosticFormat = enum refldetail::clang::DiagnosticOptions::TextDiagnosticFormat;
  bool IgnoreWarnings
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::IgnoreWarnings, Xs...);), (;) )
  /// -w
  bool NoRewriteMacros
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::NoRewriteMacros, Xs...);), (;) )
  /// -Wno-rewrite-macros
  bool Pedantic
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::Pedantic, Xs...);), (;) )
  /// -pedantic
  bool PedanticErrors
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::PedanticErrors, Xs...);), (;) )
  /// -pedantic-errors
  bool ShowColumn
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ShowColumn, Xs...);), (;) )
  /// Show column number on diagnostics.
  bool ShowLocation
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ShowLocation, Xs...);), (;) )
  /// Show source location information.
  bool AbsolutePath
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::AbsolutePath, Xs...);), (;) )
  /// Use absolute paths.
  bool ShowCarets
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ShowCarets, Xs...);), (;) )
  /// Show carets in diagnostics.
  bool ShowFixits
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ShowFixits, Xs...);), (;) )
  /// Show fixit information.
  bool ShowSourceRanges
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ShowSourceRanges, Xs...);), (;) )
  /// Show source ranges in numeric form.
  bool ShowParseableFixits
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ShowParseableFixits, Xs...);), (;) )
  /// Show machine parseable fix-its.
  bool ShowPresumedLoc
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ShowPresumedLoc, Xs...);), (;) )
  /// Show presumed location for diagnostics.
  bool ShowOptionNames
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ShowOptionNames, Xs...);), (;) )
  /// Show the option name for mappable
                                /// diagnostics.
  bool ShowNoteIncludeStack
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ShowNoteIncludeStack, Xs...);), (;) )
  /// Show include stacks for notes.
  unsigned int ShowCategories
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ShowCategories, Xs...);), (;) )
  /// Format for diagnostics:
  bool ShowColors
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ShowColors, Xs...);), (;) )
  /// Overload candidates to show.
  bool VerifyDiagnostics
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::VerifyDiagnostics, Xs...);), (;) )
  /// Ignore unexpected diagnostics of
                                        /// the specified levels when using
                                        /// -verify.
  bool ElideType
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ElideType, Xs...);), (;) )
  /// Elide identical types in template diffing
  bool ShowTemplateTree
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ShowTemplateTree, Xs...);), (;) )
  /// Print a template tree when diffing
  bool CLFallbackMode
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::CLFallbackMode, Xs...);), (;) )
  /// Format for clang-cl fallback mode
  unsigned int ErrorLimit
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ErrorLimit, Xs...);), (;) )
  /// Limit # errors emitted.
/// Limit depth of macro expansion backtrace.
  unsigned int MacroBacktraceLimit
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::MacroBacktraceLimit, Xs...);), (;) )
  /// Limit depth of instantiation backtrace.
  unsigned int TemplateBacktraceLimit
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::TemplateBacktraceLimit, Xs...);), (;) )
  /// Limit depth of constexpr backtrace.
  unsigned int ConstexprBacktraceLimit
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::ConstexprBacktraceLimit, Xs...);), (;) )
  /// Limit number of times to perform spell checking.
  unsigned int SpellCheckingLimit
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::SpellCheckingLimit, Xs...);), (;) )
  /// Limit number of lines shown in a snippet.
  unsigned int SnippetLineLimit
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::SnippetLineLimit, Xs...);), (;) )
  unsigned int TabStop
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::TabStop, Xs...);), (;) )
  /// The distance between tab stops.
/// Column limit for formatting message diagnostics, or 0 if unused.
  unsigned int MessageLength
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::MessageLength, Xs...);), (;) )
  /// -w
                                /// -Wno-rewrite-macros
                                /// -pedantic
                                /// -pedantic-errors
                                /// Show column number on diagnostics.
                                /// Show source location information.
                                /// Use absolute paths.
                                /// Show carets in diagnostics.
                                /// Show fixit information.
                                /// Show source ranges in numeric form.
                                   /// Show machine parseable fix-its.
                                /// Show presumed location for diagnostics.
                                /// Show the option name for mappable
                                /// diagnostics.
                                    /// Show include stacks for notes.
                                    /// Show categories: 0 -> none, 1 -> Number,
                                    /// 2 -> Full Name.
  constexpr enum clang::DiagnosticOptions::TextDiagnosticFormat getFormat() const IFMETA_ELSE( ({    return (enum clang::DiagnosticOptions::TextDiagnosticFormat)__reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::getFormat, Xs...); }) , (;) )
  /// Show diagnostics with ANSI color sequences.
  constexpr enum clang::OverloadsShown getShowOverloads() const IFMETA_ELSE( ({    return (enum clang::OverloadsShown)__reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::getShowOverloads, Xs...); }) , (;) )
  /// Check that diagnostics match the expected
                                 /// diagnostics, indicated by markers in the
                                 /// input source file.
  constexpr enum clang::DiagnosticLevelMask getVerifyIgnoreUnexpected() const IFMETA_ELSE( ({    return (enum clang::DiagnosticLevelMask)__reflect_prop(reflenums::RK_clang__DiagnosticOptions, reflenums::clang__DiagnosticOptions::getVerifyIgnoreUnexpected, Xs...); }) , (;) )
};

/// An opaque identifier used by SourceManager which refers to a
/// source file (MemoryBuffer) along with its \#include path and \#line data.
///
M_template_rtpack(Xs)
struct clang::FileID::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FileID;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FileID::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isValid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileID, reflenums::clang__FileID::isValid, Xs...); }) , (;) )
  constexpr bool isInvalid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileID, reflenums::clang__FileID::isInvalid, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::FileID &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileID, reflenums::clang__FileID::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::FileID &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileID, reflenums::clang__FileID::operator_less, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<=(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::FileID &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileID, reflenums::clang__FileID::operator_less_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::FileID &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileID, reflenums::clang__FileID::operator_not_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator>(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::FileID &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileID, reflenums::clang__FileID::operator_gr, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator>=(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::FileID &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileID, reflenums::clang__FileID::operator_gr_eq, Xs..., Y0s...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FileID) )
  getSentinel() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileID, reflenums::clang__FileID::getSentinel, Xs...); }) , (;) )
  constexpr unsigned int getHashValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileID, reflenums::clang__FileID::getHashValue, Xs...); }) , (;) )
};

/// Encodes a location in the source. The SourceManager can decode this
/// to get at the full include stack, line and column information.
///
/// Technically, a source location is simply an offset into the manager's view
/// of the input source, which is all input buffers (including macro
/// expansions) concatenated in an effectively arbitrary order. The manager
/// actually maintains two blocks of input buffers. One, starting at offset
/// 0 and growing upwards, contains all buffers from this module. The other,
/// starting at the highest possible offset and growing downwards, contains
/// buffers of loaded modules.
///
/// In addition, one bit of SourceLocation is used for quick access to the
/// information whether the location is in a file or a macro expansion.
///
/// It is important that this type remains small. It is currently 32 bits wide.
M_template_rtpack(Xs)
struct clang::SourceLocation::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SourceLocation;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SourceLocation::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isFileID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceLocation, reflenums::clang__SourceLocation::isFileID, Xs...); }) , (;) )
  constexpr bool isMacroID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceLocation, reflenums::clang__SourceLocation::isMacroID, Xs...); }) , (;) )
  /// Return true if this is a valid SourceLocation object.
  ///
  /// Invalid SourceLocations are often used when events have no corresponding
  /// location in the source (e.g. a diagnostic is required for a command line
  /// option).
  constexpr bool isValid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceLocation, reflenums::clang__SourceLocation::isValid, Xs...); }) , (;) )
  constexpr bool isInvalid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceLocation, reflenums::clang__SourceLocation::isInvalid, Xs...); }) , (;) )
  /// Return a source location with the specified offset from this
  /// SourceLocation.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocWithOffset(int Offset) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceLocation, reflenums::clang__SourceLocation::getLocWithOffset, Xs..., Offset); }) , (;) )
  /// When a SourceLocation itself cannot be used, this returns
  /// an (opaque) 32-bit integer encoding for it.
  ///
  /// This should only be passed to SourceLocation::getFromRawEncoding, it
  /// should not be inspected directly.
  constexpr unsigned int getRawEncoding() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceLocation, reflenums::clang__SourceLocation::getRawEncoding, Xs...); }) , (;) )
  /// Turn a raw encoding of a SourceLocation object into
  /// a real SourceLocation.
  ///
  /// \see getRawEncoding.
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getFromRawEncoding(unsigned int Encoding) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceLocation, reflenums::clang__SourceLocation::getFromRawEncoding, Xs..., Encoding); }) , (;) )
  /// When a SourceLocation itself cannot be used, this returns
  /// an (opaque) pointer encoding for it.
  ///
  /// This should only be passed to SourceLocation::getFromPtrEncoding, it
  /// should not be inspected directly.
  constexpr void * getPtrEncoding() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceLocation, reflenums::clang__SourceLocation::getPtrEncoding, Xs...); }) , (;) )
  /// Turn a pointer encoding of a SourceLocation object back
  /// into a real SourceLocation.
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getFromPtrEncoding(const void * Encoding) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceLocation, reflenums::clang__SourceLocation::getFromPtrEncoding, Xs..., Encoding); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr bool isPairOfFileLocations(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Start, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) End) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceLocation, reflenums::clang__SourceLocation::isPairOfFileLocations, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void print(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::SourceManager::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::SourceManager &)) SM) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__SourceLocation, reflenums::clang__SourceLocation::print, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * printToString(IFMETA_ELSE((const clang::SourceManager::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::SourceManager &)) SM) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceLocation, reflenums::clang__SourceLocation::printToString, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void dump(IFMETA_ELSE((const clang::SourceManager::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::SourceManager &)) SM) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__SourceLocation, reflenums::clang__SourceLocation::dump, Xs..., Y0s...); }) , (;) )
};

/// A trivial tuple used to represent a source range.
M_template_rtpack(Xs)
struct clang::SourceRange::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SourceRange;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SourceRange::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBegin() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceRange, reflenums::clang__SourceRange::getBegin, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceRange, reflenums::clang__SourceRange::getEnd, Xs...); }) , (;) )
  constexpr bool isValid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceRange, reflenums::clang__SourceRange::isValid, Xs...); }) , (;) )
  constexpr bool isInvalid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceRange, reflenums::clang__SourceRange::isInvalid, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::SourceRange &)) X) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceRange, reflenums::clang__SourceRange::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::SourceRange &)) X) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceRange, reflenums::clang__SourceRange::operator_not_eq, Xs..., Y0s...); }) , (;) )
};

/// Represents a character-granular source range.
///
/// The underlying SourceRange can either specify the starting/ending character
/// of the range, or it can specify the start of the range and the start of the
/// last token of the range (a "token range").  In the token range case, the
/// size of the last token must be measured to determine the actual end of the
/// range.
M_template_rtpack(Xs)
struct clang::CharSourceRange::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CharSourceRange;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CharSourceRange::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharSourceRange) )
  getTokenRange(IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceRange)) R) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharSourceRange, reflenums::clang__CharSourceRange::getTokenRange, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharSourceRange) )
  getCharRange(IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceRange)) R) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharSourceRange, reflenums::clang__CharSourceRange::getCharRange, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharSourceRange) )
  getTokenRange(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) B, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) E) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharSourceRange, reflenums::clang__CharSourceRange::getTokenRange1, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharSourceRange) )
  getCharRange(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) B, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) E) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharSourceRange, reflenums::clang__CharSourceRange::getCharRange1, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Return true if the end of this range specifies the start of
  /// the last token.  Return false if the end of this range specifies the last
  /// character in the range.
  constexpr bool isTokenRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharSourceRange, reflenums::clang__CharSourceRange::isTokenRange, Xs...); }) , (;) )
  constexpr bool isCharRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharSourceRange, reflenums::clang__CharSourceRange::isCharRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBegin() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharSourceRange, reflenums::clang__CharSourceRange::getBegin, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharSourceRange, reflenums::clang__CharSourceRange::getEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getAsRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharSourceRange, reflenums::clang__CharSourceRange::getAsRange, Xs...); }) , (;) )
  constexpr bool isValid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharSourceRange, reflenums::clang__CharSourceRange::isValid, Xs...); }) , (;) )
  constexpr bool isInvalid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharSourceRange, reflenums::clang__CharSourceRange::isInvalid, Xs...); }) , (;) )
};

/// Represents an unpacked "presumed" location which can be presented
/// to the user.
///
/// A 'presumed' location can be modified by \#line and GNU line marker
/// directives and is always the expansion point of a normal location.
///
/// You can get a PresumedLoc from a SourceLocation with SourceManager.
M_template_rtpack(Xs)
struct clang::PresumedLoc::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__PresumedLoc;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::PresumedLoc::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Return true if this object is invalid or uninitialized.
  ///
  /// This occurs when created with invalid source locations or when walking
  /// off the top of a \#include stack.
  constexpr bool isInvalid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PresumedLoc, reflenums::clang__PresumedLoc::isInvalid, Xs...); }) , (;) )
  constexpr bool isValid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PresumedLoc, reflenums::clang__PresumedLoc::isValid, Xs...); }) , (;) )
  /// Return the presumed filename of this location.
  ///
  /// This can be affected by \#line etc.
  constexpr const char * getFilename() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PresumedLoc, reflenums::clang__PresumedLoc::getFilename, Xs...); }) , (;) )
  /// Return the presumed line number of this location.
  ///
  /// This can be affected by \#line etc.
  constexpr unsigned int getLine() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PresumedLoc, reflenums::clang__PresumedLoc::getLine, Xs...); }) , (;) )
  /// Return the presumed column number of this location.
  ///
  /// This cannot be affected by \#line, but is packaged here for convenience.
  constexpr unsigned int getColumn() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PresumedLoc, reflenums::clang__PresumedLoc::getColumn, Xs...); }) , (;) )
  /// Return the presumed include location of this location.
  ///
  /// This can be affected by GNU linemarker directives.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getIncludeLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PresumedLoc, reflenums::clang__PresumedLoc::getIncludeLoc, Xs...); }) , (;) )
};

/// A SourceLocation and its associated SourceManager.
///
/// This is useful for argument passing to functions that expect both objects.
M_template_rtpack(Xs)
struct clang::FullSourceLoc::impl : impl_offset_t<clang::SourceLocation, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FullSourceLoc;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FullSourceLoc::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool hasManager() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::hasManager, Xs...); }) , (;) )
  /// \pre This FullSourceLoc has an associated SourceManager.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::SourceManager &) )
  getManager() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getManager, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FileID) )
  getFileID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getFileID, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FullSourceLoc) )
  getExpansionLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getExpansionLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FullSourceLoc) )
  getSpellingLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getSpellingLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FullSourceLoc) )
  getFileLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getFileLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::PresumedLoc) )
  getPresumedLoc(bool UseLineDirectives = true) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getPresumedLoc, Xs..., UseLineDirectives); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isMacroArgExpansion(IFMETA_ELSE((const clang::FullSourceLoc::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::FullSourceLoc *)) StartLoc = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::isMacroArgExpansion, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isMacroArgExpansion(ptrwrp<Y0> p0 = {}) const {
      return isMacroArgExpansion(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FullSourceLoc) )
  getImmediateMacroCallerLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getImmediateMacroCallerLoc, Xs...); }) , (;) )
  constexpr unsigned int getFileOffset() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getFileOffset, Xs...); }) , (;) )
  constexpr unsigned int getExpansionLineNumber(bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getExpansionLineNumber, Xs..., Invalid); }) , (;) )
  constexpr unsigned int getExpansionColumnNumber(bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getExpansionColumnNumber, Xs..., Invalid); }) , (;) )
  constexpr unsigned int getSpellingLineNumber(bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getSpellingLineNumber, Xs..., Invalid); }) , (;) )
  constexpr unsigned int getSpellingColumnNumber(bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getSpellingColumnNumber, Xs..., Invalid); }) , (;) )
  constexpr const char * getCharacterData(bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getCharacterData, Xs..., Invalid); }) , (;) )
  constexpr unsigned int getLineNumber(bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getLineNumber, Xs..., Invalid); }) , (;) )
  constexpr unsigned int getColumnNumber(bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getColumnNumber, Xs..., Invalid); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FileEntry *) )
  getFileEntry() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getFileEntry, Xs...); }) , (;) )
  /// Return a StringRef to the source buffer data for the
  /// specified FileID.
  constexpr const char * getBufferData(bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::getBufferData, Xs..., Invalid); }) , (;) )
  constexpr bool isInSystemHeader() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::isInSystemHeader, Xs...); }) , (;) )
  /// Determines the order of 2 source locations in the translation unit.
  ///
  /// \returns true if this source location comes before 'Loc', false otherwise.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isBeforeInTranslationUnitThan(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::isBeforeInTranslationUnitThan, Xs..., Y0s...); }) , (;) )
  /// Determines the order of 2 source locations in the translation unit.
  ///
  /// \returns true if this source location comes before 'Loc', false otherwise.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isBeforeInTranslationUnitThan(IFMETA_ELSE((const clang::FullSourceLoc::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FullSourceLoc)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::isBeforeInTranslationUnitThan1, Xs..., Y0s...); }) , (;) )
  /// Prints information about this FullSourceLoc to stderr.
  ///
  /// This is useful for debugging.
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::dump, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator==(IFMETA_ELSE((const clang::FullSourceLoc::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::FullSourceLoc &)) LHS, IFMETA_ELSE((const clang::FullSourceLoc::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::FullSourceLoc &)) RHS) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::operator_eq_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator!=(IFMETA_ELSE((const clang::FullSourceLoc::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::FullSourceLoc &)) LHS, IFMETA_ELSE((const clang::FullSourceLoc::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::FullSourceLoc &)) RHS) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FullSourceLoc, reflenums::clang__FullSourceLoc::operator_not_eq, Xs..., Y0s..., Y1s...); }) , (;) )
};

/// A C++ access specifier (public, private, protected), plus the
/// special value "none" which means different things in different contexts.
enum clang::AccessSpecifier : unsigned int {
  AS_public,
  AS_protected,
  AS_private,
  AS_none,
};

/// The categorization of expression values, currently following the
/// C++11 scheme.
enum clang::ExprValueKind : unsigned int {
  /// An r-value expression (a pr-value in the C++11 taxonomy)
  /// produces a temporary value.
  VK_RValue,
  /// An l-value expression is a reference to an object with
  /// independent storage.
  VK_LValue,
  /// An x-value expression is a reference to an object with
  /// independent storage but which can be "moved", i.e.
  /// efficiently cannibalized for its resources.
  VK_XValue,
};

/// A further classification of the kind of object referenced by an
/// l-value or x-value.
enum clang::ExprObjectKind : unsigned int {
  /// An ordinary object is located at an address in memory.
  OK_Ordinary,
  /// A bitfield object is a bitfield on a C or C++ record.
  OK_BitField,
  /// A vector component is an element or range of elements on a vector.
  OK_VectorComponent,
  /// An Objective-C property is a logical field of an Objective-C
  /// object which is read and written via Objective-C method calls.
  OK_ObjCProperty,
  /// An Objective-C array/dictionary subscripting which reads an
  /// object or writes at the subscripted array/dictionary element via
  /// Objective-C method calls.
  OK_ObjCSubscript,
};

/// Describes the kind of template specialization that a
/// particular template specialization declaration represents.
enum clang::TemplateSpecializationKind : unsigned int {
  /// This template specialization was formed from a template-id but
  /// has not yet been declared, defined, or instantiated.
  TSK_Undeclared = 0,
  /// This template specialization was implicitly instantiated from a
  /// template. (C++ [temp.inst]).
  TSK_ImplicitInstantiation,
  /// This template specialization was declared or defined by an
  /// explicit specialization (C++ [temp.expl.spec]) or partial
  /// specialization (C++ [temp.class.spec]).
  TSK_ExplicitSpecialization,
  /// This template specialization was instantiated from a template
  /// due to an explicit instantiation declaration request
  /// (C++11 [temp.explicit]).
  TSK_ExplicitInstantiationDeclaration,
  /// This template specialization was instantiated from a template
  /// due to an explicit instantiation definition request
  /// (C++ [temp.explicit]).
  TSK_ExplicitInstantiationDefinition,
};

/// Thread storage-class-specifier.
enum clang::ThreadStorageClassSpecifier : unsigned int {
  TSCS_unspecified,
  /// GNU __thread.
  TSCS___thread,
  /// C++11 thread_local. Implies 'static' at block scope, but not at
  /// class scope.
  TSCS_thread_local,
  /// C11 _Thread_local. Must be combined with either 'static' or 'extern'
  /// if used at block scope.
  TSCS__Thread_local,
};

/// Storage classes.
enum clang::StorageClass : unsigned int {
  SC_None,
  SC_Extern,
  SC_Static,
  SC_PrivateExtern,
  SC_Auto,
  SC_Register,
};

/// In-class initialization styles for non-static data members.
enum clang::InClassInitStyle : unsigned int {
  ///< No in-class initializer.
  ICIS_NoInit,
  ///< Copy initialization.
  ICIS_CopyInit,
  ///< Direct list-initialization.
  ICIS_ListInit,
};

/// CallingConv - Specifies the calling convention that a function uses.
enum clang::CallingConv : unsigned int {
  CC_C,
  CC_X86StdCall,
  CC_X86FastCall,
  CC_X86ThisCall,
  CC_X86VectorCall,
  CC_X86Pascal,
  CC_Win64,
  CC_X86_64SysV,
  CC_X86RegCall,
  CC_AAPCS,
  CC_AAPCS_VFP,
  CC_IntelOclBicc,
  CC_SpirFunction,
  CC_OpenCLKernel,
  CC_Swift,
  CC_PreserveMost,
  CC_PreserveAll,
};

/// The storage duration for an object (per C++ [basic.stc]).
enum clang::StorageDuration : unsigned int {
  ///< Full-expression storage duration (for temporaries).
  SD_FullExpression,
  ///< Automatic storage duration (most local variables).
  SD_Automatic,
  ///< Thread storage duration.
  SD_Thread,
  ///< Static storage duration.
  SD_Static,
  ///< Dynamic storage duration.
  SD_Dynamic,
};

/// Describes the nullability of a particular type.
enum class clang::NullabilityKind : uint8_t {
  /// Values of this type can never be null.
  NonNull = 0,
  /// Values of this type can be null.
  Nullable,
  /// Whether values of this type can be null is (explicitly)
  /// unspecified. This captures a (fairly rare) case where we
  /// can't conclude anything about the nullability of the type even
  /// though it has been considered.
  Unspecified,
};

/// Kinds of parameter ABI.
enum class clang::ParameterABI : int {
  /// This parameter uses ordinary ABI rules for its type.
  Ordinary,
  /// This parameter (which must have pointer type) is a Swift
  /// indirect result parameter.
  SwiftIndirectResult,
  /// This parameter (which must have pointer-to-pointer type) uses
  /// the special Swift error-result ABI treatment.  There can be at
  /// most one parameter on a given function that uses this treatment.
  SwiftErrorResult,
  /// This parameter (which must have pointer type) uses the special
  /// Swift context-pointer ABI treatment.  There can be at
  /// most one parameter on a given function that uses this treatment.
  SwiftContext,
};

enum clang::ReflectionTraitKind : unsigned int {
  RTK_prop,
  ///__reflect_prop
  RTK_range_nth,
  ///__reflect_range_nth
  RTK_range_size,
  ///__reflect_range_size
  RTK_cast,
};

/// A base class for data structure classes wishing to make iterators
/// ("handles") pointing into themselves fail-fast.  When building without
/// asserts, this class is empty and does nothing.
///
/// DebugEpochBase does not by itself track handles pointing into itself.  The
/// expectation is that routines touching the handles will poll on
/// isHandleInSync at appropriate points to assert that the handle they're using
/// is still valid.
///
M_template_rtpack(Xs)
struct llvm::DebugEpochBase::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__DebugEpochBase;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::DebugEpochBase::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
};

/// Annotates a diagnostic with some code that should be
/// inserted, removed, or replaced to fix the problem.
///
/// This kind of hint should be used when we are certain that the
/// introduction, removal, or modification of a particular (small!)
/// amount of code will correct a compilation error. The compiler
/// should also provide full recovery from such errors, such that
/// suppressing the diagnostic output can still result in successful
/// compilation.
M_template_rtpack(Xs)
struct clang::FixItHint::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FixItHint;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FixItHint::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Code that should be replaced to correct the error. Empty for an
  /// insertion hint.
  M_REFLTYPED_FIELD(RemoveRange, (typename meta::clang::CharSourceRange), __reflect_prop(reflenums::RK_clang__FixItHint, reflenums::clang__FixItHint::RemoveRange, Xs...))
  /// Code in the specific range that should be inserted in the insertion
  /// location.
  M_REFLTYPED_FIELD(InsertFromRange, (typename meta::clang::CharSourceRange), __reflect_prop(reflenums::RK_clang__FixItHint, reflenums::clang__FixItHint::InsertFromRange, Xs...))
  bool BeforePreviousInsertions
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__FixItHint, reflenums::clang__FixItHint::BeforePreviousInsertions, Xs...);), (;) )
  constexpr bool isNull() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FixItHint, reflenums::clang__FixItHint::isNull, Xs...); }) , (;) )
  /// Create a code modification hint that inserts the given
  /// code from \p FromRange at a specific location.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FixItHint) )
  CreateInsertionFromRange(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) InsertionLoc, IFMETA_ELSE((const clang::CharSourceRange::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::CharSourceRange)) FromRange, bool BeforePreviousInsertions = false) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FixItHint, reflenums::clang__FixItHint::CreateInsertionFromRange, Xs..., Y0s..., Y1s..., BeforePreviousInsertions); }) , (;) )
  /// Create a code modification hint that removes the given
  /// source range.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FixItHint) )
  CreateRemoval(IFMETA_ELSE((const clang::CharSourceRange::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::CharSourceRange)) RemoveRange) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FixItHint, reflenums::clang__FixItHint::CreateRemoval, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FixItHint) )
  CreateRemoval(IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceRange)) RemoveRange) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FixItHint, reflenums::clang__FixItHint::CreateRemoval1, Xs..., Y0s...); }) , (;) )
};

/// The level of the diagnostic, after it has been through mapping.
enum clang::DiagnosticsEngine::Level : unsigned int {
  Ignored = 0,
  Note = 1,
  Remark = 2,
  Warning = 3,
  Error = 4,
  Fatal = 5,
};

enum clang::DiagnosticsEngine::ArgumentKind : unsigned int {
  /// std::string
  ak_std_string,
  /// const char *
  ak_c_string,
  /// int
  ak_sint,
  /// unsigned
  ak_uint,
  /// enum TokenKind : unsigned
  ak_tokenkind,
  /// IdentifierInfo
  ak_identifierinfo,
  /// QualType
  ak_qualtype,
  /// DeclarationName
  ak_declarationname,
  /// NamedDecl *
  ak_nameddecl,
  /// NestedNameSpecifier *
  ak_nestednamespec,
  /// DeclContext *
  ak_declcontext,
  /// pair<QualType, QualType>
  ak_qualtype_pair,
  /// Attr *
  ak_attr,
};

/// Concrete class used by the front-end to report problems and issues.
///
/// This massages the diagnostics (e.g. handling things like "report warnings
/// as errors" and passes them off to the DiagnosticConsumer for reporting to
/// the user. DiagnosticsEngine is tied to one translation unit and one
/// SourceManager.
M_template_rtpack(Xs)
struct clang::DiagnosticsEngine::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DiagnosticsEngine;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DiagnosticsEngine::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr void Retain() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::Retain, Xs...); }) , (;) )
  constexpr void Release() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::Release, Xs...); }) , (;) )
  using Level = enum refldetail::clang::DiagnosticsEngine::Level;
  using ArgumentKind = enum refldetail::clang::DiagnosticsEngine::ArgumentKind;
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::dump, Xs...); }) , (;) )
  constexpr void dump(const char * DiagName) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::dump1, Xs..., DiagName); }) , (;) )
  /// Retrieve the diagnostic options.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DiagnosticOptions &) )
  getDiagnosticOptions() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getDiagnosticOptions, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DiagnosticConsumer *) )
  getClient() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getClient, Xs...); }) , (;) )
  /// Determine whether this \c DiagnosticsEngine object own its client.
  constexpr bool ownsClient() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::ownsClient, Xs...); }) , (;) )
  constexpr bool hasSourceManager() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::hasSourceManager, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceManager &) )
  getSourceManager() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getSourceManager, Xs...); }) , (;) )
  /// Retrieve the maximum number of template instantiation
  /// notes to emit along with a given diagnostic.
  constexpr unsigned int getTemplateBacktraceLimit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getTemplateBacktraceLimit, Xs...); }) , (;) )
  /// Retrieve the maximum number of constexpr evaluation
  /// notes to emit along with a given diagnostic.
  constexpr unsigned int getConstexprBacktraceLimit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getConstexprBacktraceLimit, Xs...); }) , (;) )
  constexpr bool getIgnoreAllWarnings() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getIgnoreAllWarnings, Xs...); }) , (;) )
  constexpr bool getEnableAllWarnings() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getEnableAllWarnings, Xs...); }) , (;) )
  constexpr bool getWarningsAsErrors() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getWarningsAsErrors, Xs...); }) , (;) )
  constexpr bool getErrorsAsFatal() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getErrorsAsFatal, Xs...); }) , (;) )
  constexpr bool getSuppressSystemWarnings() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getSuppressSystemWarnings, Xs...); }) , (;) )
  constexpr bool getSuppressAllDiagnostics() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getSuppressAllDiagnostics, Xs...); }) , (;) )
  constexpr enum clang::OverloadsShown getShowOverloads() const IFMETA_ELSE( ({    return (enum clang::OverloadsShown)__reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getShowOverloads, Xs...); }) , (;) )
  /// Determine whether the previous diagnostic was ignored. This can
  /// be used by clients that want to determine whether notes attached to a
  /// diagnostic will be suppressed.
  constexpr bool isLastDiagnosticIgnored() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::isLastDiagnosticIgnored, Xs...); }) , (;) )
  constexpr enum clang::diag::Severity getExtensionHandlingBehavior() const IFMETA_ELSE( ({    return (enum clang::diag::Severity)__reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getExtensionHandlingBehavior, Xs...); }) , (;) )
  constexpr bool hasErrorOccurred() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::hasErrorOccurred, Xs...); }) , (;) )
  /// Errors that actually prevent compilation, not those that are
  /// upgraded from a warning by -Werror.
  constexpr bool hasUncompilableErrorOccurred() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::hasUncompilableErrorOccurred, Xs...); }) , (;) )
  constexpr bool hasFatalErrorOccurred() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::hasFatalErrorOccurred, Xs...); }) , (;) )
  /// Determine whether any kind of unrecoverable error has occurred.
  constexpr bool hasUnrecoverableErrorOccurred() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::hasUnrecoverableErrorOccurred, Xs...); }) , (;) )
  constexpr unsigned int getNumWarnings() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getNumWarnings, Xs...); }) , (;) )
  /// Determine whether the diagnostic is known to be ignored.
  ///
  /// This can be used to opportunistically avoid expensive checks when it's
  /// known for certain that the diagnostic has been suppressed at the
  /// specified location \p Loc.
  ///
  /// \param Loc The source location we are interested in finding out the
  /// diagnostic state. Can be null in order to query the latest state.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isIgnored(unsigned int DiagID, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::isIgnored, Xs..., DiagID, Y0s...); }) , (;) )
  /// Based on the way the client configured the DiagnosticsEngine
  /// object, classify the specified diagnostic ID into a Level, consumable by
  /// the DiagnosticConsumer.
  ///
  /// To preserve invariant assumptions, this function should not be used to
  /// influence parse or semantic analysis actions. Instead consider using
  /// \c isIgnored().
  ///
  /// \param Loc The source location we are interested in finding out the
  /// diagnostic state. Can be null in order to query the latest state.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum clang::DiagnosticsEngine::Level getDiagnosticLevel(unsigned int DiagID, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return (enum clang::DiagnosticsEngine::Level)__reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getDiagnosticLevel, Xs..., DiagID, Y0s...); }) , (;) )
  /// Determine whethere there is already a diagnostic in flight.
  constexpr bool isDiagnosticInFlight() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::isDiagnosticInFlight, Xs...); }) , (;) )
  /// Return the value associated with this diagnostic flag.
  constexpr const char * getFlagValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticsEngine, reflenums::clang__DiagnosticsEngine::getFlagValue, Xs...); }) , (;) )
};

/// A little helper class used to produce diagnostics.
///
/// This is constructed by the DiagnosticsEngine::Report method, and
/// allows insertion of extra information (arguments and source ranges) into
/// the currently "in flight" diagnostic.  When the temporary for the builder
/// is destroyed, the diagnostic is issued.
///
/// Note that many of these will be created as temporary objects (many call
/// sites), so we want them to be small and we never want their address taken.
/// This ensures that compilers with somewhat reasonable optimizers will promote
/// the common fields to registers, eliminating increments of the NumArgs field,
/// for example.
M_template_rtpack(Xs)
struct clang::DiagnosticBuilder::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DiagnosticBuilder;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DiagnosticBuilder::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Forces the diagnostic to be emitted.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DiagnosticBuilder &) )
  setForceEmit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticBuilder, reflenums::clang__DiagnosticBuilder::setForceEmit, Xs...); }) , (;) )
  /// Conversion of DiagnosticBuilder to bool always returns \c true.
  ///
  /// This allows is to be used in boolean error contexts (where \c true is
  /// used to indicate that an error has occurred), like:
  /// \code
  /// return Diag(...);
  /// \endcode
  constexpr operator bool() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticBuilder, reflenums::clang__DiagnosticBuilder::operator_bool, Xs...); }) , (;) )
  constexpr void AddString(const char * S) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DiagnosticBuilder, reflenums::clang__DiagnosticBuilder::AddString, Xs..., S); }) , (;) )
  constexpr void AddTaggedVal(intptr_t V, enum clang::DiagnosticsEngine::ArgumentKind Kind) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DiagnosticBuilder, reflenums::clang__DiagnosticBuilder::AddTaggedVal, Xs..., V, Kind); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void AddSourceRange(IFMETA_ELSE((const clang::CharSourceRange::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::CharSourceRange &)) R) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DiagnosticBuilder, reflenums::clang__DiagnosticBuilder::AddSourceRange, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void AddFixItHint(IFMETA_ELSE((const clang::FixItHint::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::FixItHint &)) Hint) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DiagnosticBuilder, reflenums::clang__DiagnosticBuilder::AddFixItHint, Xs..., Y0s...); }) , (;) )
  constexpr void addFlagValue(const char * V) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DiagnosticBuilder, reflenums::clang__DiagnosticBuilder::addFlagValue, Xs..., V); }) , (;) )
};

/// Abstract interface, implemented by clients of the front-end, which
/// formats and prints fully processed diagnostics.
M_template_rtpack(Xs)
struct clang::DiagnosticConsumer::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DiagnosticConsumer;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DiagnosticConsumer::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr unsigned int getNumErrors() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticConsumer, reflenums::clang__DiagnosticConsumer::getNumErrors, Xs...); }) , (;) )
  constexpr unsigned int getNumWarnings() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticConsumer, reflenums::clang__DiagnosticConsumer::getNumWarnings, Xs...); }) , (;) )
  /// Indicates whether the diagnostics handled by this
  /// DiagnosticConsumer should be included in the number of diagnostics
  /// reported by DiagnosticsEngine.
  ///
  /// The default implementation returns true.
  constexpr bool IncludeInDiagnosticCounts() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DiagnosticConsumer, reflenums::clang__DiagnosticConsumer::IncludeInDiagnosticCounts, Xs...); }) , (;) )
};

/// Provides a simple uniform namespace for tokens from all C languages.
enum clang::tok::TokenKind : unsigned short {
  unknown,
  eof,
  eod,
  code_completion,
  comment,
  identifier,
  raw_identifier,
  numeric_constant,
  char_constant,
  wide_char_constant,
  utf8_char_constant,
  utf16_char_constant,
  utf32_char_constant,
  string_literal,
  wide_string_literal,
  angle_string_literal,
  utf8_string_literal,
  utf16_string_literal,
  utf32_string_literal,
  l_square,
  r_square,
  l_paren,
  r_paren,
  l_brace,
  r_brace,
  period,
  ellipsis,
  amp,
  ampamp,
  ampequal,
  star,
  starequal,
  plus,
  plusplus,
  plusequal,
  minus,
  arrow,
  minusminus,
  minusequal,
  tilde,
  exclaim,
  exclaimequal,
  slash,
  slashequal,
  percent,
  percentequal,
  less,
  lessless,
  lessequal,
  lesslessequal,
  spaceship,
  greater,
  greatergreater,
  greaterequal,
  greatergreaterequal,
  caret,
  caretequal,
  pipe,
  pipepipe,
  pipeequal,
  question,
  colon,
  semi,
  equal,
  equalequal,
  comma,
  hash,
  hashhash,
  hashat,
  periodstar,
  arrowstar,
  coloncolon,
  dollar,
  at,
  lesslessless,
  greatergreatergreater,
  caretcaret,
  kw_auto,
  kw_break,
  kw_case,
  kw_char,
  kw_const,
  kw_continue,
  kw_default,
  kw_do,
  kw_double,
  kw_else,
  kw_enum,
  kw_extern,
  kw_float,
  kw_for,
  kw_goto,
  kw_if,
  kw_inline,
  kw_int,
  kw_long,
  kw_register,
  kw_restrict,
  kw_return,
  kw_short,
  kw_signed,
  kw_sizeof,
  kw_static,
  kw_struct,
  kw_switch,
  kw_typedef,
  kw_union,
  kw_unsigned,
  kw_void,
  kw_volatile,
  kw_while,
  kw__Alignas,
  kw__Alignof,
  kw__Atomic,
  kw__Bool,
  kw__Complex,
  kw__Generic,
  kw__Imaginary,
  kw__Noreturn,
  kw__Static_assert,
  kw__Thread_local,
  kw___func__,
  kw___objc_yes,
  kw___objc_no,
  kw_asm,
  kw_bool,
  kw_catch,
  kw_class,
  kw_const_cast,
  kw_delete,
  kw_dynamic_cast,
  kw_explicit,
  kw_export,
  kw_false,
  kw_friend,
  kw_mutable,
  kw_namespace,
  kw_new,
  kw_operator,
  kw_private,
  kw_protected,
  kw_public,
  kw_reinterpret_cast,
  kw_static_cast,
  kw_template,
  kw_this,
  kw_throw,
  kw_true,
  kw_try,
  kw_typename,
  kw_typeid,
  kw_using,
  kw_virtual,
  kw_wchar_t,
  kw_alignas,
  kw_alignof,
  kw_char16_t,
  kw_char32_t,
  kw_constexpr,
  kw_decltype,
  kw_noexcept,
  kw_nullptr,
  kw_static_assert,
  kw_thread_local,
  kw_concept,
  kw_requires,
  kw_co_await,
  kw_co_return,
  kw_co_yield,
  kw_module,
  kw_import,
  kw_char8_t,
  kw__Float16,
  kw__Accum,
  kw__Fract,
  kw__Sat,
  kw_reflexpr,
  kw_idexpr,
  ////END
  kw__Decimal32,
  ////END
  kw__Decimal64,
  ////END
  kw__Decimal128,
  ////END
  kw___null,
  ////END
  kw___alignof,
  ////END
  kw___attribute,
  ////END
  kw___builtin_choose_expr,
  ////END
  kw___builtin_offsetof,
  ////END
  kw___builtin_types_compatible_p,
  ////END
  kw___builtin_va_arg,
  ////END
  kw___extension__,
  ////END
  kw___float128,
  ////END
  kw___imag,
  ////END
  kw___int128,
  ////END
  kw___label__,
  ////END
  kw___real,
  ////END
  kw___thread,
  ////END
  kw___FUNCTION__,
  ////END
  kw___PRETTY_FUNCTION__,
  ////END
  kw___auto_type,
  ////END
  kw_typeof,
  ////END
  kw___FUNCDNAME__,
  ////END
  kw___FUNCSIG__,
  ////END
  kw_L__FUNCTION__,
  ////END
  kw_L__FUNCSIG__,
  ////END
  kw___is_interface_class,
  ////END
  kw___is_sealed,
  ////END
  kw___is_destructible,
  ////END
  kw___is_trivially_destructible,
  ////END
  kw___is_nothrow_destructible,
  ////END
  kw___is_nothrow_assignable,
  ////END
  kw___is_constructible,
  ////END
  kw___is_nothrow_constructible,
  ////END
  kw___is_assignable,
  ////END
  kw___has_nothrow_assign,
  ////END
  kw___has_nothrow_move_assign,
  ////END
  kw___has_nothrow_copy,
  ////END
  kw___has_nothrow_constructor,
  ////END
  kw___has_trivial_assign,
  ////END
  kw___has_trivial_move_assign,
  ////END
  kw___has_trivial_copy,
  ////END
  kw___has_trivial_constructor,
  ////END
  kw___has_trivial_move_constructor,
  ////END
  kw___has_trivial_destructor,
  ////END
  kw___has_virtual_destructor,
  ////END
  kw___is_abstract,
  ////END
  kw___is_aggregate,
  ////END
  kw___is_base_of,
  ////END
  kw___is_class,
  ////END
  kw___is_convertible_to,
  ////END
  kw___is_empty,
  ////END
  kw___is_enum,
  ////END
  kw___is_final,
  ////END
  kw___is_literal,
  ////END
  kw___is_pod,
  ////END
  kw___is_polymorphic,
  ////END
  kw___is_trivial,
  ////END
  kw___is_union,
  ////END
  kw___has_unique_object_representations,
  ////END
  kw___is_trivially_constructible,
  ////END
  kw___is_trivially_copyable,
  ////END
  kw___is_trivially_assignable,
  ////END
  kw___reference_binds_to_temporary,
  ////END
  kw___underlying_type,
  ////END
  kw___is_lvalue_expr,
  ////END
  kw___is_rvalue_expr,
  ////END
  kw___is_arithmetic,
  ////END
  kw___is_floating_point,
  ////END
  kw___is_integral,
  ////END
  kw___is_complete_type,
  ////END
  kw___is_void,
  ////END
  kw___is_array,
  ////END
  kw___is_function,
  ////END
  kw___is_reference,
  ////END
  kw___is_lvalue_reference,
  ////END
  kw___is_rvalue_reference,
  ////END
  kw___is_fundamental,
  ////END
  kw___is_object,
  ////END
  kw___is_scalar,
  ////END
  kw___is_compound,
  ////END
  kw___is_pointer,
  ////END
  kw___is_member_object_pointer,
  ////END
  kw___is_member_function_pointer,
  ////END
  kw___is_member_pointer,
  ////END
  kw___is_const,
  ////END
  kw___is_volatile,
  ////END
  kw___is_standard_layout,
  ////END
  kw___is_signed,
  ////END
  kw___is_unsigned,
  ////END
  kw___is_same,
  ////END
  kw___is_convertible,
  ////END
  kw___array_rank,
  ////END
  kw___array_extent,
  ////END
  kw___queue_metaparse,
  ////END
  kw___metaparse_expr,
  ////END
  kw___reflect_prop,
  ////END
  kw___reflect_range_nth,
  ////END
  kw___reflect_range_size,
  ////END
  kw___reflect_cast,
  ////END
  kw___reflect_new,
  ////END
  kw___reflect_delete,
  //// Placeholders for future syntax
  kw___concatenate,
  //// Placeholders for future syntax
  kw___compiler_debug,
  //// Placeholders for future syntax
  kw___compiler_diag,
  //// Placeholders for future syntax
  kw___private_extern__,
  //// Placeholders for future syntax
  kw___module_private__,
  //// Placeholders for future syntax
  kw___declspec,
  //// Placeholders for future syntax
  kw___cdecl,
  //// Placeholders for future syntax
  kw___stdcall,
  //// Placeholders for future syntax
  kw___fastcall,
  //// Placeholders for future syntax
  kw___thiscall,
  //// Placeholders for future syntax
  kw___regcall,
  //// Placeholders for future syntax
  kw___vectorcall,
  //// Placeholders for future syntax
  kw___forceinline,
  //// Placeholders for future syntax
  kw___unaligned,
  //// Placeholders for future syntax
  kw___super,
  //// Placeholders for future syntax
  kw___global,
  //// Placeholders for future syntax
  kw___local,
  //// Placeholders for future syntax
  kw___constant,
  //// Placeholders for future syntax
  kw___private,
  //// Placeholders for future syntax
  kw___generic,
  //// Placeholders for future syntax
  kw___kernel,
  //// Placeholders for future syntax
  kw___read_only,
  //// Placeholders for future syntax
  kw___write_only,
  //// Placeholders for future syntax
  kw___read_write,
  //// Placeholders for future syntax
  kw___builtin_astype,
  //// Placeholders for future syntax
  kw_vec_step,
  //// Placeholders for future syntax
  kw_image1d_t,
  //// Placeholders for future syntax
  kw_image1d_array_t,
  //// Placeholders for future syntax
  kw_image1d_buffer_t,
  //// Placeholders for future syntax
  kw_image2d_t,
  //// Placeholders for future syntax
  kw_image2d_array_t,
  //// Placeholders for future syntax
  kw_image2d_depth_t,
  //// Placeholders for future syntax
  kw_image2d_array_depth_t,
  //// Placeholders for future syntax
  kw_image2d_msaa_t,
  //// Placeholders for future syntax
  kw_image2d_array_msaa_t,
  //// Placeholders for future syntax
  kw_image2d_msaa_depth_t,
  //// Placeholders for future syntax
  kw_image2d_array_msaa_depth_t,
  //// Placeholders for future syntax
  kw_image3d_t,
  //// Placeholders for future syntax
  kw___builtin_omp_required_simd_align,
  //// Placeholders for future syntax
  kw_pipe,
  //// Placeholders for future syntax
  kw___pascal,
  //// Placeholders for future syntax
  kw___vector,
  //// Placeholders for future syntax
  kw___pixel,
  //// Placeholders for future syntax
  kw___bool,
  //// Placeholders for future syntax
  kw_half,
  //// Placeholders for future syntax
  kw___bridge,
  //// Placeholders for future syntax
  kw___bridge_transfer,
  //// Placeholders for future syntax
  kw___bridge_retained,
  //// Placeholders for future syntax
  kw___bridge_retain,
  //// Placeholders for future syntax
  kw___covariant,
  //// Placeholders for future syntax
  kw___contravariant,
  //// Placeholders for future syntax
  kw___kindof,
  //// Placeholders for future syntax
  kw__Nonnull,
  //// Placeholders for future syntax
  kw__Nullable,
  //// Placeholders for future syntax
  kw__Null_unspecified,
  //// Placeholders for future syntax
  kw___ptr64,
  //// Placeholders for future syntax
  kw___ptr32,
  //// Placeholders for future syntax
  kw___sptr,
  //// Placeholders for future syntax
  kw___uptr,
  //// Placeholders for future syntax
  kw___w64,
  //// Placeholders for future syntax
  kw___uuidof,
  //// Placeholders for future syntax
  kw___try,
  //// Placeholders for future syntax
  kw___finally,
  //// Placeholders for future syntax
  kw___leave,
  //// Placeholders for future syntax
  kw___int64,
  //// Placeholders for future syntax
  kw___if_exists,
  //// Placeholders for future syntax
  kw___if_not_exists,
  //// Placeholders for future syntax
  kw___single_inheritance,
  //// Placeholders for future syntax
  kw___multiple_inheritance,
  //// Placeholders for future syntax
  kw___virtual_inheritance,
  //// Placeholders for future syntax
  kw___interface,
  //// Placeholders for future syntax
  kw___builtin_convertvector,
  //// Placeholders for future syntax
  kw___builtin_available,
  //// Placeholders for future syntax
  kw___unknown_anytype,
  annot_cxxscope,
  annot_typename,
  annot_template_id,
  annot_primary_expr,
  annot_decltype,
  ////END
  annot_refltype,
  annot_pragma_unused,
  annot_pragma_vis,
  annot_pragma_pack,
  annot_pragma_parser_crash,
  annot_pragma_captured,
  annot_pragma_dump,
  annot_pragma_msstruct,
  annot_pragma_align,
  annot_pragma_weak,
  annot_pragma_weakalias,
  annot_pragma_redefine_extname,
  annot_pragma_fp_contract,
  annot_pragma_ms_pointers_to_members,
  annot_pragma_ms_vtordisp,
  annot_pragma_ms_pragma,
  annot_pragma_opencl_extension,
  annot_pragma_openmp,
  annot_pragma_openmp_end,
  annot_pragma_loop_hint,
  annot_pragma_fp,
  annot_pragma_attribute,
  annot_module_include,
  annot_module_begin,
  annot_module_end,
  NUM_TOKENS,
};

/// Provides a namespace for preprocessor keywords which start with a
/// '#' at the beginning of the line.
enum clang::tok::PPKeywordKind : unsigned int {
  pp_not_keyword,
  pp_if,
  pp_ifdef,
  pp_ifndef,
  pp_elif,
  pp_else,
  pp_endif,
  pp_defined,
  pp_include,
  pp___include_macros,
  pp_define,
  pp_undef,
  pp_line,
  pp_error,
  pp_pragma,
  pp_import,
  pp_include_next,
  pp_warning,
  pp_ident,
  pp_sccs,
  pp_assert,
  pp_unassert,
  pp___public_macro,
  pp___private_macro,
  NUM_PP_KEYWORDS,
};

/// Provides a namespace for Objective-C keywords which start with
/// an '@'.
enum clang::tok::ObjCKeywordKind : unsigned int {
  objc_not_keyword,
  objc_class,
  objc_compatibility_alias,
  objc_defs,
  objc_encode,
  objc_end,
  objc_implementation,
  objc_interface,
  objc_private,
  objc_protected,
  objc_protocol,
  objc_public,
  objc_selector,
  objc_throw,
  objc_try,
  objc_catch,
  objc_finally,
  objc_synchronized,
  objc_autoreleasepool,
  objc_property,
  objc_package,
  objc_required,
  objc_optional,
  objc_synthesize,
  objc_dynamic,
  objc_import,
  objc_available,
  NUM_OBJC_KEYWORDS,
};

/// One of these records is kept for each identifier that
/// is lexed.  This contains information about whether the token was \#define'd,
/// is a language keyword, or if it is a front-end token of some sort (e.g. a
/// variable or function name).  The preprocessor keeps this information in a
/// set, and all tok::identifier tokens have a pointer to one of these.
M_template_rtpack(Xs)
struct clang::IdentifierInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__IdentifierInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::IdentifierInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Return true if this is the identifier for the specified StringRef.
  constexpr bool isStr(const char * Str) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::isStr, Xs..., Str); }) , (;) )
  /// Return the beginning of the actual null-terminated string for this
  /// identifier.
  constexpr const char * getNameStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::getNameStart, Xs...); }) , (;) )
  /// Efficiently return the length of this identifier info.
  constexpr unsigned int getLength() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::getLength, Xs...); }) , (;) )
  /// Return the actual identifier string.
  constexpr const char * getName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::getName, Xs...); }) , (;) )
  /// Return true if this identifier is \#defined to some other value.
  /// \note The current definition may be in a module and not currently visible.
  constexpr bool hasMacroDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::hasMacroDefinition, Xs...); }) , (;) )
  /// Returns true if this identifier was \#defined to some value at any
  /// moment. In this case there should be an entry for the identifier in the
  /// macro history table in Preprocessor.
  constexpr bool hadMacroDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::hadMacroDefinition, Xs...); }) , (;) )
  /// If this is a source-language token (e.g. 'for'), this API
  /// can be used to cause the lexer to map identifiers to source-language
  /// tokens.
  constexpr enum clang::tok::TokenKind getTokenID() const IFMETA_ELSE( ({    return (enum clang::tok::TokenKind)__reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::getTokenID, Xs...); }) , (;) )
  /// True if revertTokenIDToIdentifier() was called.
  constexpr bool hasRevertedTokenIDToIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::hasRevertedTokenIDToIdentifier, Xs...); }) , (;) )
  /// Return the preprocessor keyword ID for this identifier.
  ///
  /// For example, "define" will return tok::pp_define.
  constexpr enum clang::tok::PPKeywordKind getPPKeywordID() const IFMETA_ELSE( ({    return (enum clang::tok::PPKeywordKind)__reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::getPPKeywordID, Xs...); }) , (;) )
  /// Return the Objective-C keyword ID for the this identifier.
  ///
  /// For example, 'class' will return tok::objc_class if ObjC is enabled.
  constexpr enum clang::tok::ObjCKeywordKind getObjCKeywordID() const IFMETA_ELSE( ({    return (enum clang::tok::ObjCKeywordKind)__reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::getObjCKeywordID, Xs...); }) , (;) )
  /// True if setNotBuiltin() was called.
  constexpr bool hasRevertedBuiltin() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::hasRevertedBuiltin, Xs...); }) , (;) )
  /// Return a value indicating whether this is a builtin function.
  ///
  /// 0 is not-built-in. 1+ are specific builtin functions.
  constexpr unsigned int getBuiltinID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::getBuiltinID, Xs...); }) , (;) )
  constexpr unsigned int getObjCOrBuiltinID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::getObjCOrBuiltinID, Xs...); }) , (;) )
  /// get/setExtension - Initialize information about whether or not this
  /// language token is an extension.  This controls extension warnings, and is
  /// only valid if a custom token ID is set.
  constexpr bool isExtensionToken() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::isExtensionToken, Xs...); }) , (;) )
  /// is/setIsFutureCompatKeyword - Initialize information about whether or not
  /// this language token is a keyword in a newer or proposed Standard. This
  /// controls compatibility warnings, and is only true when not parsing the
  /// corresponding Standard. Once a compatibility problem has been diagnosed
  /// with this keyword, the flag will be cleared.
  constexpr bool isFutureCompatKeyword() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::isFutureCompatKeyword, Xs...); }) , (;) )
  /// Return true if this token has been poisoned.
  constexpr bool isPoisoned() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::isPoisoned, Xs...); }) , (;) )
  constexpr bool isCPlusPlusOperatorKeyword() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::isCPlusPlusOperatorKeyword, Xs...); }) , (;) )
  /// Return true if this token is a keyword in the specified language.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isKeyword(IFMETA_ELSE((const clang::LangOptions::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::LangOptions &)) LangOpts) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::isKeyword, Xs..., Y0s...); }) , (;) )
  /// Return true if this token is a C++ keyword in the specified
  /// language.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isCPlusPlusKeyword(IFMETA_ELSE((const clang::LangOptions::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::LangOptions &)) LangOpts) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::isCPlusPlusKeyword, Xs..., Y0s...); }) , (;) )
  /// Return true if the Preprocessor::HandleIdentifier must be called
  /// on a token of this identifier.
  ///
  /// If this returns false, we know that HandleIdentifier will not affect
  /// the token.
  constexpr bool isHandleIdentifierCase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::isHandleIdentifierCase, Xs...); }) , (;) )
  /// Return true if the identifier in its current state was loaded
  /// from an AST file.
  constexpr bool isFromAST() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::isFromAST, Xs...); }) , (;) )
  /// Determine whether this identifier has changed since it was loaded
  /// from an AST file.
  constexpr bool hasChangedSinceDeserialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::hasChangedSinceDeserialization, Xs...); }) , (;) )
  /// Determine whether the frontend token information for this
  /// identifier has changed since it was loaded from an AST file.
  constexpr bool hasFETokenInfoChangedSinceDeserialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::hasFETokenInfoChangedSinceDeserialization, Xs...); }) , (;) )
  /// Determine whether the information for this identifier is out of
  /// date with respect to the external source.
  constexpr bool isOutOfDate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::isOutOfDate, Xs...); }) , (;) )
  /// Determine whether this is the contextual keyword \c import.
  constexpr bool isModulesImport() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::isModulesImport, Xs...); }) , (;) )
  /// Return true if this identifier is an editor placeholder.
  ///
  /// Editor placeholders are produced by the code-completion engine and are
  /// represented as characters between '<#' and '#>' in the source code. An
  /// example of auto-completed call with a placeholder parameter is shown
  /// below:
  /// \code
  ///   function(<#int x#>);
  /// \endcode
  constexpr bool isEditorPlaceholder() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::isEditorPlaceholder, Xs...); }) , (;) )
  /// Provide less than operator for lexicographical sorting.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<(IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::IdentifierInfo &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierInfo, reflenums::clang__IdentifierInfo::operator_less, Xs..., Y0s...); }) , (;) )
};

/// Provides lookups to, and iteration over, IdentiferInfo objects.
M_template_rtpack(Xs)
struct clang::IdentifierInfoLookup::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__IdentifierInfoLookup;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::IdentifierInfoLookup::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
};

/// Implements an efficient mapping from strings to IdentifierInfo nodes.
///
/// This has no other purpose, but this is an extremely performance-critical
/// piece of the code, as each occurrence of every identifier goes through
/// here when lexed.
M_template_rtpack(Xs)
struct clang::IdentifierTable::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__IdentifierTable;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::IdentifierTable::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the external identifier lookup object, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfoLookup *) )
  getExternalIdentifierLookup() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierTable, reflenums::clang__IdentifierTable::getExternalIdentifierLookup, Xs...); }) , (;) )
  constexpr unsigned int size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IdentifierTable, reflenums::clang__IdentifierTable::size, Xs...); }) , (;) )
  /// Print some statistics to stderr that indicate how well the
  /// hashing is doing.
  constexpr void PrintStats() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__IdentifierTable, reflenums::clang__IdentifierTable::PrintStats, Xs...); }) , (;) )
};

/// A family of Objective-C methods.
///
/// These families have no inherent meaning in the language, but are
/// nonetheless central enough in the existing implementations to
/// merit direct AST support.  While, in theory, arbitrary methods can
/// be considered to form families, we focus here on the methods
/// involving allocation and retain-count management, as these are the
/// most "core" and the most likely to be useful to diverse clients
/// without extra information.
///
/// Both selectors and actual method declarations may be classified
/// into families.  Method families may impose additional restrictions
/// beyond their selector name; for example, a method called '_init'
/// that returns void is not considered to be in the 'init' family
/// (but would be if it returned 'id').  It is also possible to
/// explicitly change or remove a method's family.  Therefore the
/// method's family should be considered the single source of truth.
enum clang::ObjCMethodFamily : unsigned int {
  /// No particular method family.
  OMF_None,
  /// No particular method family.
  OMF_alloc,
  /// No particular method family.
  OMF_copy,
  /// No particular method family.
  OMF_init,
  /// No particular method family.
  OMF_mutableCopy,
  /// No particular method family.
  OMF_new,
  /// No particular method family.
  OMF_autorelease,
  /// No particular method family.
  OMF_dealloc,
  /// No particular method family.
  OMF_finalize,
  /// No particular method family.
  OMF_release,
  /// No particular method family.
  OMF_retain,
  /// No particular method family.
  OMF_retainCount,
  /// No particular method family.
  OMF_self,
  /// No particular method family.
  OMF_initialize,
  /// No particular method family.
  OMF_performSelector,
};

/// A family of Objective-C methods.
///
/// These are family of methods whose result type is initially 'id', but
/// but are candidate for the result type to be changed to 'instancetype'.
enum clang::ObjCInstanceTypeFamily : unsigned int {
  OIT_None,
  OIT_Array,
  OIT_Dictionary,
  OIT_Singleton,
  OIT_Init,
  OIT_ReturnsSelf,
};

enum clang::ObjCStringFormatFamily : unsigned int {
  SFF_None,
  SFF_NSString,
  SFF_CFString,
};

/// Smart pointer class that efficiently represents Objective-C method
/// names.
///
/// This class will either point to an IdentifierInfo or a
/// MultiKeywordSelector (which is private). This enables us to optimize
/// selectors that take no arguments and selectors that take 1 argument, which
/// accounts for 78% of all selectors in Cocoa.h.
M_template_rtpack(Xs)
struct clang::Selector::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Selector;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Selector::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// operator==/!= - Indicate whether the specified selectors are identical.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::operator_not_eq, Xs..., Y0s...); }) , (;) )
  constexpr void * getAsOpaquePtr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::getAsOpaquePtr, Xs...); }) , (;) )
  /// Determine whether this is the empty selector.
  constexpr bool isNull() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::isNull, Xs...); }) , (;) )
  constexpr bool isKeywordSelector() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::isKeywordSelector, Xs...); }) , (;) )
  constexpr bool isUnarySelector() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::isUnarySelector, Xs...); }) , (;) )
  constexpr unsigned int getNumArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::getNumArgs, Xs...); }) , (;) )
  /// Retrieve the identifier at a given position in the selector.
  ///
  /// Note that the identifier pointer returned may be NULL. Clients that only
  /// care about the text of the identifier string, and not the specific,
  /// uniqued identifier pointer, should use \c getNameForSlot(), which returns
  /// an empty string when the identifier pointer would be NULL.
  ///
  /// \param argIndex The index for which we want to retrieve the identifier.
  /// This index shall be less than \c getNumArgs() unless this is a keyword
  /// selector, in which case 0 is the only permissible value.
  ///
  /// \returns the uniqued identifier for this slot, or NULL if this slot has
  /// no corresponding identifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getIdentifierInfoForSlot(unsigned int argIndex) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::getIdentifierInfoForSlot, Xs..., argIndex); }) , (;) )
  /// Retrieve the name at a given position in the selector.
  ///
  /// \param argIndex The index for which we want to retrieve the name.
  /// This index shall be less than \c getNumArgs() unless this is a keyword
  /// selector, in which case 0 is the only permissible value.
  ///
  /// \returns the name for this slot, which may be the empty string if no
  /// name was supplied.
  constexpr const char * getNameForSlot(unsigned int argIndex) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::getNameForSlot, Xs..., argIndex); }) , (;) )
  /// Derive the full selector name (e.g. "foo:bar:") and return
  /// it as an std::string.
  constexpr const char * getAsString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::getAsString, Xs...); }) , (;) )
  /// Prints the full selector name (e.g. "foo:bar:").
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void print(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::print, Xs..., Y0s...); }) , (;) )
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::dump, Xs...); }) , (;) )
  /// Derive the conventional family of this method.
  constexpr enum clang::ObjCMethodFamily getMethodFamily() const IFMETA_ELSE( ({    return (enum clang::ObjCMethodFamily)__reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::getMethodFamily, Xs...); }) , (;) )
  constexpr enum clang::ObjCStringFormatFamily getStringFormatFamily() const IFMETA_ELSE( ({    return (enum clang::ObjCStringFormatFamily)__reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::getStringFormatFamily, Xs...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::Selector) )
  getEmptyMarker() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::getEmptyMarker, Xs...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::Selector) )
  getTombstoneMarker() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::getTombstoneMarker, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr enum clang::ObjCInstanceTypeFamily getInstTypeMethodFamily(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) sel) IFMETA_ELSE( ({    return (enum clang::ObjCInstanceTypeFamily)__reflect_prop(reflenums::RK_clang__Selector, reflenums::clang__Selector::getInstTypeMethodFamily, Xs..., Y0s...); }) , (;) )
};

/// This table allows us to fully hide how we implement
/// multi-keyword caching.
M_template_rtpack(Xs)
struct clang::SelectorTable::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SelectorTable;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SelectorTable::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Return the total amount of memory allocated for managing selectors.
  constexpr unsigned long getTotalMemory() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SelectorTable, reflenums::clang__SelectorTable::getTotalMemory, Xs...); }) , (;) )
  /// Return the default setter selector for the given identifier.
  ///
  /// This is "set" + \p Name where the initial character of \p Name
  /// has been capitalized.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::Selector) )
  constructSetterSelector(IFMETA_ELSE((const clang::IdentifierTable::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::IdentifierTable &)) Idents, IFMETA_ELSE((const clang::SelectorTable::template impl</*ptrorref=*/1, Y1s...>), (typename meta::clang::SelectorTable &)) SelTable, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y2s...> *), (const typename meta::clang::IdentifierInfo *)) Name) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SelectorTable, reflenums::clang__SelectorTable::constructSetterSelector, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::Selector) )
  constructSetterSelector(Y0 p0, Y1 p1, ptrwrp<Y2> p2) {
      return constructSetterSelector(p0, p1, p2.get());
  }), () )
  /// Return the property name for the given setter selector.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr const char * getPropertyNameFromSetterSelector(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SelectorTable, reflenums::clang__SelectorTable::getPropertyNameFromSetterSelector, Xs..., Y0s...); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::PartialDiagnostic::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__PartialDiagnostic;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::PartialDiagnostic::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr unsigned int getDiagID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PartialDiagnostic, reflenums::clang__PartialDiagnostic::getDiagID, Xs...); }) , (;) )
  constexpr void AddTaggedVal(intptr_t V, enum clang::DiagnosticsEngine::ArgumentKind Kind) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__PartialDiagnostic, reflenums::clang__PartialDiagnostic::AddTaggedVal, Xs..., V, Kind); }) , (;) )
  constexpr void AddString(const char * V) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__PartialDiagnostic, reflenums::clang__PartialDiagnostic::AddString, Xs..., V); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void Emit(IFMETA_ELSE((const clang::DiagnosticBuilder::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::DiagnosticBuilder &)) DB) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__PartialDiagnostic, reflenums::clang__PartialDiagnostic::Emit, Xs..., Y0s...); }) , (;) )
  constexpr bool hasStorage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PartialDiagnostic, reflenums::clang__PartialDiagnostic::hasStorage, Xs...); }) , (;) )
  constexpr unsigned int getNumArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PartialDiagnostic, reflenums::clang__PartialDiagnostic::getNumArgs, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  friend constexpr IFMETA_ELSE( (auto), (const typename meta::clang::PartialDiagnostic &) )
  operator<<(IFMETA_ELSE((const clang::PartialDiagnostic::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::PartialDiagnostic &)) PD, unsigned int I) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PartialDiagnostic, reflenums::clang__PartialDiagnostic::operator_less_less, Xs..., Y0s..., I); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  friend constexpr IFMETA_ELSE( (auto), (const typename meta::clang::PartialDiagnostic &) )
  operator<<(IFMETA_ELSE((const clang::PartialDiagnostic::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::PartialDiagnostic &)) PD, int I) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PartialDiagnostic, reflenums::clang__PartialDiagnostic::operator_less_less1, Xs..., Y0s..., I); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr IFMETA_ELSE( (auto), (const typename meta::clang::PartialDiagnostic &) )
  operator<<(IFMETA_ELSE((const clang::PartialDiagnostic::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::PartialDiagnostic &)) PD, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::IdentifierInfo *)) II) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PartialDiagnostic, reflenums::clang__PartialDiagnostic::operator_less_less2, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  friend constexpr IFMETA_ELSE( (auto), (const typename meta::clang::PartialDiagnostic &) )
  operator<<(Y0 p0, ptrwrp<Y1> p1) {
      return operator<<(p0, p1.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr IFMETA_ELSE( (auto), (const typename meta::clang::PartialDiagnostic &) )
  operator<<(IFMETA_ELSE((const clang::PartialDiagnostic::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::PartialDiagnostic &)) PD, IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceRange)) R) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PartialDiagnostic, reflenums::clang__PartialDiagnostic::operator_less_less3, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr IFMETA_ELSE( (auto), (const typename meta::clang::PartialDiagnostic &) )
  operator<<(IFMETA_ELSE((const clang::PartialDiagnostic::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::PartialDiagnostic &)) PD, IFMETA_ELSE((const clang::CharSourceRange::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::CharSourceRange &)) R) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PartialDiagnostic, reflenums::clang__PartialDiagnostic::operator_less_less4, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr IFMETA_ELSE( (auto), (const typename meta::clang::PartialDiagnostic &) )
  operator<<(IFMETA_ELSE((const clang::PartialDiagnostic::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::PartialDiagnostic &)) PD, IFMETA_ELSE((const clang::FixItHint::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::FixItHint &)) Hint) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PartialDiagnostic, reflenums::clang__PartialDiagnostic::operator_less_less5, Xs..., Y0s..., Y1s...); }) , (;) )
};

/// NameKind - The kind of name this object contains.
enum clang::DeclarationName::NameKind : unsigned int {
  Identifier,
  ObjCZeroArgSelector,
  ObjCOneArgSelector,
  ObjCMultiArgSelector,
  CXXConstructorName,
  CXXDestructorName,
  CXXConversionFunctionName,
  CXXDeductionGuideName,
  CXXOperatorName,
  CXXLiteralOperatorName,
  CXXIdExprName,
  CXXUsingDirective,
};

/// DeclarationName - The name of a declaration. In the common case,
/// this just stores an IdentifierInfo pointer to a normal
/// name. However, it also provides encodings for Objective-C
/// selectors (optimizing zero- and one-argument selectors, which make
/// up 78% percent of all selectors in Cocoa.h) and special C++ names
/// for constructors, destructors, and conversion functions.
M_template_rtpack(Xs)
struct clang::DeclarationName::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DeclarationName;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DeclarationName::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using NameKind = enum refldetail::clang::DeclarationName::NameKind;
  static const unsigned int NumNameKinds = 12u;
  /// getUsingDirectiveName - Return name for all using-directives.
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationName) )
  getUsingDirectiveName() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getUsingDirectiveName, Xs...); }) , (;) )
  constexpr explicit operator bool() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::operator_bool, Xs...); }) , (;) )
  /// Evaluates true when this declaration name is empty.
  constexpr bool isEmpty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::isEmpty, Xs...); }) , (;) )
  /// Predicate functions for querying what type of name this is.
  constexpr bool isIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::isIdentifier, Xs...); }) , (;) )
  constexpr bool isObjCZeroArgSelector() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::isObjCZeroArgSelector, Xs...); }) , (;) )
  constexpr bool isObjCOneArgSelector() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::isObjCOneArgSelector, Xs...); }) , (;) )
  /// getNameKind - Determine what kind of name this is.
  constexpr enum clang::DeclarationName::NameKind getNameKind() const IFMETA_ELSE( ({    return (enum clang::DeclarationName::NameKind)__reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getNameKind, Xs...); }) , (;) )
  /// Determines whether the name itself is dependent, e.g., because it
  /// involves a C++ type that is itself dependent.
  ///
  /// Note that this does not capture all of the notions of "dependent name",
  /// because an identifier can be a dependent name if it is used as the
  /// callee in a call expression with dependent arguments.
  constexpr bool isDependentName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::isDependentName, Xs...); }) , (;) )
  /// getNameAsString - Retrieve the human-readable string for this name.
  constexpr const char * getAsString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getAsString, Xs...); }) , (;) )
  /// getAsIdentifierInfo - Retrieve the IdentifierInfo * stored in
  /// this declaration name, or NULL if this declaration name isn't a
  /// simple identifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getAsIdentifierInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getAsIdentifierInfo, Xs...); }) , (;) )
  /// getAsOpaqueInteger - Get the representation of this declaration
  /// name as an opaque integer.
  constexpr unsigned long getAsOpaqueInteger() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getAsOpaqueInteger, Xs...); }) , (;) )
  /// getAsOpaquePtr - Get the representation of this declaration name as
  /// an opaque pointer.
  constexpr void * getAsOpaquePtr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getAsOpaquePtr, Xs...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationName) )
  getFromOpaquePtr(void * P) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getFromOpaquePtr, Xs..., P); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationName) )
  getFromOpaqueInteger(unsigned long P) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getFromOpaqueInteger, Xs..., P); }) , (;) )
  /// getCXXNameType - If this name is one of the C++ names (of a
  /// constructor, destructor, or conversion function), return the
  /// type associated with that name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getCXXNameType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getCXXNameType, Xs...); }) , (;) )
  /// If this name is the name of a C++ deduction guide, return the
  /// template associated with that name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateDecl *) )
  getCXXDeductionGuideTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getCXXDeductionGuideTemplate, Xs...); }) , (;) )
  /// getCXXOverloadedOperator - If this name is the name of an
  /// overloadable operator in C++ (e.g., @c operator+), retrieve the
  /// kind of overloaded operator.
  constexpr enum clang::OverloadedOperatorKind getCXXOverloadedOperator() const IFMETA_ELSE( ({    return (enum clang::OverloadedOperatorKind)__reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getCXXOverloadedOperator, Xs...); }) , (;) )
  /// getCXXLiteralIdentifier - If this name is the name of a literal
  /// operator, retrieve the identifier associated with it.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getCXXLiteralIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getCXXLiteralIdentifier, Xs...); }) , (;) )
  /// getCXXIdExprArguments - If this is an idexpr name, retrieve the list
  /// of arguments.
  RANGE_REFLECTION(clang::DeclarationName, getCXXIdExprArguments,
      constexpr auto getCXXIdExprArguments() const ,
      (typename meta::clang::Expr *),
      (reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getCXXIdExprArguments, Xs...), () )
  /// getObjCSelector - Get the Objective-C selector stored in this
  /// declaration name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Selector) )
  getObjCSelector() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getObjCSelector, Xs...); }) , (;) )
  /// operator== - Determine whether the specified names are identical..
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator==(IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::DeclarationName)) LHS, IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::DeclarationName)) RHS) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::operator_eq_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  /// operator!= - Determine whether the specified names are different.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator!=(IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::DeclarationName)) LHS, IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::DeclarationName)) RHS) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::operator_not_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationName) )
  getEmptyMarker() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getEmptyMarker, Xs...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationName) )
  getTombstoneMarker() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::getTombstoneMarker, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr int compare(IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::DeclarationName)) LHS, IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::DeclarationName)) RHS) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::compare, Xs..., Y0s..., Y1s...); }) , (;) )
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DeclarationName, reflenums::clang__DeclarationName::dump, Xs...); }) , (;) )
};

/// DeclarationNameLoc - Additional source/type location info
/// for a declaration name. Needs a DeclarationName in order
/// to be interpreted correctly.
M_template_rtpack(Xs)
struct clang::DeclarationNameLoc::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DeclarationNameLoc;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DeclarationNameLoc::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
};

/// DeclarationNameInfo - A collector data type for bundling together
/// a DeclarationName and the correspnding source/type location info.
M_template_rtpack(Xs)
struct clang::DeclarationNameInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DeclarationNameInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DeclarationNameInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// getName - Returns the embedded declaration name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationName) )
  getName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::getName, Xs...); }) , (;) )
  /// getLoc - Returns the main location of the declaration name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::getLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclarationNameLoc &) )
  getInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::getInfo, Xs...); }) , (;) )
  /// getNamedTypeInfo - Returns the source type info associated to
  /// the name. Assumes it is a constructor, destructor or conversion.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getNamedTypeInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::getNamedTypeInfo, Xs...); }) , (;) )
  /// getCXXOperatorNameRange - Gets the range of the operator name
  /// (without the operator keyword). Assumes it is a (non-literal) operator.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getCXXOperatorNameRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::getCXXOperatorNameRange, Xs...); }) , (;) )
  /// getCXXLiteralOperatorNameLoc - Returns the location of the literal
  /// operator name (not the operator keyword).
  /// Assumes it is a literal operator.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getCXXLiteralOperatorNameLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::getCXXLiteralOperatorNameLoc, Xs...); }) , (;) )
  /// The source range of the idexpr operator.
  /// Reuses the structure of operator names.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getCXXIdExprNameRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::getCXXIdExprNameRange, Xs...); }) , (;) )
  /// Determine whether this name involves a template parameter.
  constexpr bool isInstantiationDependent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::isInstantiationDependent, Xs...); }) , (;) )
  /// Determine whether this name contains an unexpanded
  /// parameter pack.
  constexpr bool containsUnexpandedParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::containsUnexpandedParameterPack, Xs...); }) , (;) )
  /// getAsString - Retrieve the human-readable string for this name.
  constexpr const char * getAsString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::getAsString, Xs...); }) , (;) )
  /// printName - Print the human-readable name to a stream.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void printName(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::printName, Xs..., Y0s...); }) , (;) )
  /// getBeginLoc - Retrieve the location of the first token.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::getBeginLoc, Xs...); }) , (;) )
  /// getSourceRange - The range of the declaration name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclarationNameInfo, reflenums::clang__DeclarationNameInfo::getEndLoc, Xs...); }) , (;) )
};

/// This class implements an extremely fast bulk output stream that can *only*
/// output to a stream.  It does not support seeking, reopening, rewinding, line
/// buffered disciplines etc. It is a simple buffer that outputs
/// a chunk at a time.
M_template_rtpack(Xs)
struct llvm::raw_ostream::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__raw_ostream;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::raw_ostream::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// tell - Return the current offset with the file.
  constexpr unsigned long long tell() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__raw_ostream, reflenums::llvm__raw_ostream::tell, Xs...); }) , (;) )
  constexpr unsigned long GetBufferSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__raw_ostream, reflenums::llvm__raw_ostream::GetBufferSize, Xs...); }) , (;) )
  constexpr unsigned long GetNumBytesInBuffer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__raw_ostream, reflenums::llvm__raw_ostream::GetNumBytesInBuffer, Xs...); }) , (;) )
  /// This function determines if this stream is connected to a "tty" or
  /// "console" window. That is, the output would be displayed to the user
  /// rather than being put on a pipe or stored in a file.
  constexpr bool is_displayed() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__raw_ostream, reflenums::llvm__raw_ostream::is_displayed, Xs...); }) , (;) )
  /// This function determines if this stream is displayed and supports colors.
  constexpr bool has_colors() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__raw_ostream, reflenums::llvm__raw_ostream::has_colors, Xs...); }) , (;) )
};

/// Represents a version number in the form major[.minor[.subminor[.build]]].
M_template_rtpack(Xs)
struct llvm::VersionTuple::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__VersionTuple;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::VersionTuple::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Determine whether this version information is empty
  /// (e.g., all version components are zero).
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__VersionTuple, reflenums::llvm__VersionTuple::empty, Xs...); }) , (;) )
  /// Retrieve the major version number.
  constexpr unsigned int getMajor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__VersionTuple, reflenums::llvm__VersionTuple::getMajor, Xs...); }) , (;) )
  /// Determine if two version numbers are equivalent. If not
  /// provided, minor and subminor version numbers are considered to be zero.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator==(IFMETA_ELSE((const llvm::VersionTuple::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::VersionTuple &)) X, IFMETA_ELSE((const llvm::VersionTuple::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::VersionTuple &)) Y) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__VersionTuple, reflenums::llvm__VersionTuple::operator_eq_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Determine if two version numbers are not equivalent.
  ///
  /// If not provided, minor and subminor version numbers are considered to be
  /// zero.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator!=(IFMETA_ELSE((const llvm::VersionTuple::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::VersionTuple &)) X, IFMETA_ELSE((const llvm::VersionTuple::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::VersionTuple &)) Y) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__VersionTuple, reflenums::llvm__VersionTuple::operator_not_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Determine whether one version number precedes another.
  ///
  /// If not provided, minor and subminor version numbers are considered to be
  /// zero.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator<(IFMETA_ELSE((const llvm::VersionTuple::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::VersionTuple &)) X, IFMETA_ELSE((const llvm::VersionTuple::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::VersionTuple &)) Y) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__VersionTuple, reflenums::llvm__VersionTuple::operator_less, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Determine whether one version number follows another.
  ///
  /// If not provided, minor and subminor version numbers are considered to be
  /// zero.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator>(IFMETA_ELSE((const llvm::VersionTuple::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::VersionTuple &)) X, IFMETA_ELSE((const llvm::VersionTuple::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::VersionTuple &)) Y) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__VersionTuple, reflenums::llvm__VersionTuple::operator_gr, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Determine whether one version number precedes or is
  /// equivalent to another.
  ///
  /// If not provided, minor and subminor version numbers are considered to be
  /// zero.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator<=(IFMETA_ELSE((const llvm::VersionTuple::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::VersionTuple &)) X, IFMETA_ELSE((const llvm::VersionTuple::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::VersionTuple &)) Y) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__VersionTuple, reflenums::llvm__VersionTuple::operator_less_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Determine whether one version number follows or is
  /// equivalent to another.
  ///
  /// If not provided, minor and subminor version numbers are considered to be
  /// zero.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator>=(IFMETA_ELSE((const llvm::VersionTuple::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::VersionTuple &)) X, IFMETA_ELSE((const llvm::VersionTuple::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::VersionTuple &)) Y) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__VersionTuple, reflenums::llvm__VersionTuple::operator_gr_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Retrieve a string representation of the version number.
  constexpr const char * getAsString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__VersionTuple, reflenums::llvm__VersionTuple::getAsString, Xs...); }) , (;) )
};

/// Captures the result of checking the availability of a
/// declaration.
enum clang::AvailabilityResult : unsigned int {
  AR_Available = 0,
  AR_NotYetIntroduced,
  AR_Deprecated,
  AR_Unavailable,
};

/// Lists the kind of concrete classes of Decl.
enum clang::Decl::Kind : unsigned int {
  AccessSpec,
  Block,
  Captured,
  ClassScopeFunctionSpecialization,
  Constexpr,
  Empty,
  Export,
  ExternCContext,
  FileScopeAsm,
  Friend,
  FriendTemplate,
  Import,
  LinkageSpec,
  Label,
  Namespace,
  NamespaceAlias,
  ObjCCompatibleAlias,
  ObjCCategory,
  ObjCCategoryImpl,
  ObjCImplementation,
  firstObjCImpl = 18,
  lastObjCImpl = 19,
  ObjCInterface,
  ObjCProtocol,
  firstObjCContainer = 17,
  lastObjCContainer = 21,
  ObjCMethod,
  ObjCProperty,
  BuiltinTemplate,
  ClassTemplate,
  FunctionTemplate,
  TypeAliasTemplate,
  VarTemplate,
  firstRedeclarableTemplate = 25,
  lastRedeclarableTemplate = 28,
  TemplateTemplateParm,
  firstTemplate = 24,
  lastTemplate = 29,
  Enum,
  Record,
  CXXRecord,
  ClassTemplateSpecialization,
  ClassTemplatePartialSpecialization,
  firstClassTemplateSpecialization = 33,
  lastClassTemplateSpecialization = 34,
  firstCXXRecord = 32,
  lastCXXRecord = 34,
  firstRecord = 31,
  lastRecord = 34,
  firstTag = 30,
  lastTag = 34,
  TemplateTypeParm,
  ObjCTypeParam,
  TypeAlias,
  Typedef,
  firstTypedefName = 36,
  lastTypedefName = 38,
  UnresolvedUsingTypename,
  firstType = 30,
  lastType = 39,
  Using,
  UsingDirective,
  UsingPack,
  UsingShadow,
  ConstructorUsingShadow,
  firstUsingShadow = 43,
  lastUsingShadow = 44,
  Binding,
  Field,
  ObjCAtDefsField,
  ObjCIvar,
  firstField = 46,
  lastField = 48,
  Function,
  CXXDeductionGuide,
  CXXMethod,
  CXXConstructor,
  CXXConversion,
  CXXDestructor,
  firstCXXMethod = 51,
  lastCXXMethod = 54,
  firstFunction = 49,
  lastFunction = 54,
  MSProperty,
  NonTypeTemplateParm,
  Var,
  Decomposition,
  ImplicitParam,
  OMPCapturedExpr,
  ParmVar,
  VarTemplateSpecialization,
  VarTemplatePartialSpecialization,
  firstVarTemplateSpecialization = 62,
  lastVarTemplateSpecialization = 63,
  firstVar = 57,
  lastVar = 63,
  firstDeclarator = 46,
  lastDeclarator = 63,
  EnumConstant,
  IndirectField,
  OMPDeclareReduction,
  UnresolvedUsingValue,
  firstValue = 45,
  lastValue = 67,
  firstNamed = 13,
  lastNamed = 67,
  OMPThreadPrivate,
  ObjCPropertyImpl,
  PragmaComment,
  PragmaDetectMismatch,
  StaticAssert,
  TranslationUnit,
  firstDecl = 0,
  lastDecl = 73,
};

/// ObjCDeclQualifier - 'Qualifiers' written next to the return and
/// parameter types in method declarations.  Other than remembering
/// them and mangling them into the method's signature string, these
/// are ignored by the compiler; they are consumed by certain
/// remote-messaging frameworks.
///
/// in, inout, and out are mutually exclusive and apply only to
/// method parameters.  bycopy and byref are mutually exclusive and
/// apply only to method parameters (?).  oneway applies only to
/// results.  All of these expect their corresponding parameter to
/// have a particular type.  None of this is currently enforced by
/// clang.
///
/// This should be kept in sync with ObjCDeclSpec::ObjCDeclQualifier.
enum clang::Decl::ObjCDeclQualifier : unsigned int {
  OBJC_TQ_None = 0,
  OBJC_TQ_In = 1,
  OBJC_TQ_Inout = 2,
  OBJC_TQ_Out = 4,
  OBJC_TQ_Bycopy = 8,
  OBJC_TQ_Byref = 16,
  OBJC_TQ_Oneway = 32,
  /// The nullability qualifier is set when the nullability of the
  /// result or parameter was expressed via a context-sensitive
  /// keyword.
  OBJC_TQ_CSNullability = 64,
};

/// The kind of ownership a declaration has, for visibility purposes.
/// This enumeration is designed such that higher values represent higher
/// levels of name hiding.
enum class clang::Decl::ModuleOwnershipKind : unsigned int {
  /// This declaration is not owned by a module.
  Unowned,
  /// This declaration has an owning module, but is globally visible
  /// (typically because its owning module is visible and we know that
  /// modules cannot later become hidden in this compilation).
  /// After serialization and deserialization, this will be converted
  /// to VisibleWhenImported.
  Visible,
  /// This declaration has an owning module, and is visible when that
  /// module is imported.
  VisibleWhenImported,
  /// This declaration has an owning module, but is only visible to
  /// lookups that occur within that module.
  ModulePrivate,
};

enum clang::Decl::FriendObjectKind : unsigned int {
  ///< Not a friend object.
  FOK_None,
  ///< A friend of a previously-declared entity.
  FOK_Declared,
  ///< A friend of a previously-undeclared entity.
  FOK_Undeclared,
};

/// Decl - This represents one declaration (or definition), e.g. a variable,
/// typedef, function, struct, etc.
///
/// Note: There are objects tacked on before the *beginning* of Decl
/// (and its subclasses) in its Decl::operator new(). Proper alignment
/// of all subclasses (not requiring more than the alignment of Decl) is
/// asserted in DeclBase.cpp.
M_template_rtpack(Xs)
struct clang::Decl::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Decl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Decl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using Kind = enum refldetail::clang::Decl::Kind;
  using ObjCDeclQualifier = enum refldetail::clang::Decl::ObjCDeclQualifier;
  using ModuleOwnershipKind = enum refldetail::clang::Decl::ModuleOwnershipKind;
  /// Source range that this declaration covers.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getLocation, Xs...); }) , (;) )
  constexpr enum clang::Decl::Kind getKind() const IFMETA_ELSE( ({    return (enum clang::Decl::Kind)__reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getKind, Xs...); }) , (;) )
  constexpr const char * getDeclKindName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getDeclKindName, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Decl *) )
  getNextDeclInContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getNextDeclInContext, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclContext *) )
  getDeclContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getDeclContext, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Decl *) )
  getNonClosureContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getNonClosureContext, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TranslationUnitDecl *) )
  getTranslationUnitDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getTranslationUnitDecl, Xs...); }) , (;) )
  constexpr bool isInAnonymousNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isInAnonymousNamespace, Xs...); }) , (;) )
  constexpr bool isInStdNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isInStdNamespace, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ASTContext &) )
  getASTContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getASTContext, Xs...); }) , (;) )
  constexpr enum clang::AccessSpecifier getAccess() const IFMETA_ELSE( ({    return (enum clang::AccessSpecifier)__reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getAccess, Xs...); }) , (;) )
  /// Retrieve the access specifier for this declaration, even though
  /// it may not yet have been properly set.
  constexpr enum clang::AccessSpecifier getAccessUnsafe() const IFMETA_ELSE( ({    return (enum clang::AccessSpecifier)__reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getAccessUnsafe, Xs...); }) , (;) )
  constexpr bool hasAttrs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::hasAttrs, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::Decl, attrs,
      constexpr auto attrs() const ,
      (typename meta::clang::Attr *const),
      (reflenums::RK_clang__Decl, reflenums::clang__Decl::attrs, Xs...), () )
  /// getMaxAlignment - return the maximum alignment specified by attributes
  /// on this decl, 0 if there are none.
  constexpr unsigned int getMaxAlignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getMaxAlignment, Xs...); }) , (;) )
  constexpr bool isInvalidDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isInvalidDecl, Xs...); }) , (;) )
  /// isImplicit - Indicates whether the declaration was implicitly
  /// generated by the implementation. If false, this declaration
  /// was written explicitly in the source code.
  constexpr bool isImplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isImplicit, Xs...); }) , (;) )
  /// Whether *any* (re-)declaration of the entity was used, meaning that
  /// a definition is required.
  ///
  /// \param CheckUsedAttr When true, also consider the "used" attribute
  /// (in addition to the "used" bit set by \c setUsed()) when determining
  /// whether the function is used.
  constexpr bool isUsed(bool CheckUsedAttr = true) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isUsed, Xs..., CheckUsedAttr); }) , (;) )
  /// Whether any declaration of this entity was referenced.
  constexpr bool isReferenced() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isReferenced, Xs...); }) , (;) )
  /// Whether this declaration was referenced. This should not be relied
  /// upon for anything other than debugging.
  constexpr bool isThisDeclarationReferenced() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isThisDeclarationReferenced, Xs...); }) , (;) )
  ////END
  constexpr bool instantiationsWillNeedParsing() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::instantiationsWillNeedParsing, Xs...); }) , (;) )
  /// Whether this declaration is a top-level declaration (function,
  /// global variable, etc.) that is lexically inside an objc container
  /// definition.
  constexpr bool isTopLevelDeclInObjCContainer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isTopLevelDeclInObjCContainer, Xs...); }) , (;) )
  /// Looks on this and related declarations for an applicable
  /// external source symbol attribute.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ExternalSourceSymbolAttr *) )
  getExternalSourceSymbolAttr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getExternalSourceSymbolAttr, Xs...); }) , (;) )
  /// Whether this declaration was marked as being private to the
  /// module in which it was defined.
  constexpr bool isModulePrivate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isModulePrivate, Xs...); }) , (;) )
  /// Whether this declaration is exported (by virtue of being lexically
  /// within an ExportDecl or by being a NamespaceDecl).
  constexpr bool isExported() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isExported, Xs...); }) , (;) )
  /// Return true if this declaration has an attribute which acts as
  /// definition of the entity, such as 'alias' or 'ifunc'.
  constexpr bool hasDefiningAttr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::hasDefiningAttr, Xs...); }) , (;) )
  /// Return this declaration's defining attribute if it has one.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Attr *) )
  getDefiningAttr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getDefiningAttr, Xs...); }) , (;) )
  /// Retrieve the version of the target platform in which this
  /// declaration was introduced.
  ///
  /// \returns An empty version tuple if this declaration has no 'introduced'
  /// availability attributes, or the version tuple that's specified in the
  /// attribute otherwise.
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::VersionTuple) )
  getVersionIntroduced() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getVersionIntroduced, Xs...); }) , (;) )
  /// Determine whether this is a weak-imported symbol.
  ///
  /// Weak-imported symbols are typically marked with the
  /// 'weak_import' attribute, but may also be marked with an
  /// 'availability' attribute where we're targing a platform prior to
  /// the introduction of this feature.
  constexpr bool isWeakImported() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isWeakImported, Xs...); }) , (;) )
  /// Determine whether this declaration came from an AST file (such as
  /// a precompiled header or module) rather than having been parsed.
  constexpr bool isFromASTFile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isFromASTFile, Xs...); }) , (;) )
  /// Retrieve the global declaration ID associated with this
  /// declaration, which specifies where this Decl was loaded from.
  constexpr unsigned int getGlobalID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getGlobalID, Xs...); }) , (;) )
  /// Retrieve the global ID of the module that owns this particular
  /// declaration.
  constexpr unsigned int getOwningModuleID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getOwningModuleID, Xs...); }) , (;) )
  /// Get the imported owning module, if this decl is from an imported
  /// (non-local) module.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Module *) )
  getImportedOwningModule() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getImportedOwningModule, Xs...); }) , (;) )
  /// Get the local owning module, if known. Returns nullptr if owner is
  /// not yet known or declaration is not from a module.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Module *) )
  getLocalOwningModule() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getLocalOwningModule, Xs...); }) , (;) )
  /// Is this declaration owned by some module?
  constexpr bool hasOwningModule() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::hasOwningModule, Xs...); }) , (;) )
  /// Get the module that owns this declaration (for visibility purposes).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Module *) )
  getOwningModule() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getOwningModule, Xs...); }) , (;) )
  /// Get the module that owns this declaration for linkage purposes.
  /// There only ever is such a module under the C++ Modules TS.
  ///
  /// \param IgnoreLinkage Ignore the linkage of the entity; assume that
  /// all declarations in a global module fragment are unowned.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Module *) )
  getOwningModuleForLinkage(bool IgnoreLinkage = false) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getOwningModuleForLinkage, Xs..., IgnoreLinkage); }) , (;) )
  /// Determine whether this declaration might be hidden from name
  /// lookup. Note that the declaration might be visible even if this returns
  /// \c false, if the owning module is visible within the query context.
  constexpr bool isHidden() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isHidden, Xs...); }) , (;) )
  /// Get the kind of module ownership for this declaration.
  constexpr enum clang::Decl::ModuleOwnershipKind getModuleOwnershipKind() const IFMETA_ELSE( ({    return (enum clang::Decl::ModuleOwnershipKind)__reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getModuleOwnershipKind, Xs...); }) , (;) )
  constexpr unsigned int getIdentifierNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getIdentifierNamespace, Xs...); }) , (;) )
  constexpr bool isInIdentifierNamespace(unsigned int NS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isInIdentifierNamespace, Xs..., NS); }) , (;) )
  static constexpr unsigned int getIdentifierNamespaceForKind(enum clang::Decl::Kind DK) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getIdentifierNamespaceForKind, Xs..., DK); }) , (;) )
  constexpr bool hasTagIdentifierNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::hasTagIdentifierNamespace, Xs...); }) , (;) )
  static constexpr bool isTagIdentifierNamespace(unsigned int NS) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isTagIdentifierNamespace, Xs..., NS); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclContext *) )
  getLexicalDeclContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getLexicalDeclContext, Xs...); }) , (;) )
  /// Determine whether this declaration is declared out of line (outside its
  /// semantic context).
  constexpr bool isOutOfLine() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isOutOfLine, Xs...); }) , (;) )
  /// Determine whether this declaration is a templated entity (whether it is
  constexpr bool isTemplated() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isTemplated, Xs...); }) , (;) )
  /// isDefinedOutsideFunctionOrMethod - This predicate returns true if this
  /// scoped decl is defined outside the current function or method.  This is
  /// roughly global variables and functions, but also handles enums (which
  /// could be defined inside or outside a function etc).
  constexpr bool isDefinedOutsideFunctionOrMethod() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isDefinedOutsideFunctionOrMethod, Xs...); }) , (;) )
  /// Returns true if this declaration lexically is inside a function.
  /// It recognizes non-defining declarations as well as members of local
  /// classes:
  /// \code
  ///     void foo() { void bar(); }
  ///     void foo2() { class ABC { void bar(); }; }
  /// \endcode
  constexpr bool isLexicallyWithinFunctionOrMethod() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isLexicallyWithinFunctionOrMethod, Xs...); }) , (;) )
  /// If this decl is defined inside a function/method/block it returns
  /// the corresponding DeclContext, otherwise it returns null.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclContext *) )
  getParentFunctionOrMethod() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getParentFunctionOrMethod, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Decl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getCanonicalDecl, Xs...); }) , (;) )
  /// Whether this particular Decl is a canonical one.
  constexpr bool isCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isCanonicalDecl, Xs...); }) , (;) )
  /// Returns an iterator range for all the redeclarations of the same
  /// decl. It will iterate at least once (when this decl is the only one).
  RANGE_REFLECTION(clang::Decl, redecls,
      constexpr auto redecls() const ,
      (typename meta::clang::Decl *const),
      (reflenums::RK_clang__Decl, reflenums::clang__Decl::redecls, Xs...), () )
  /// Retrieve the most recent declaration that declares the same entity
  /// as this declaration, or NULL if there is no previous declaration.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Decl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getPreviousDecl, Xs...); }) , (;) )
  /// True if this is the first declaration in its redeclaration chain.
  constexpr bool isFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isFirstDecl, Xs...); }) , (;) )
  /// Retrieve the most recent declaration that declares the same entity
  /// as this declaration (which may be this declaration).
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Decl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getMostRecentDecl, Xs...); }) , (;) )
  /// getBody - If this Decl represents a declaration for a body of code,
  ///  such as a function or method definition, this method returns the
  ///  top-level Stmt* of that body.  Otherwise this method returns null.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getBody, Xs...); }) , (;) )
  /// Returns true if this \c Decl represents a declaration for a body of
  /// code, such as a function or method definition.
  /// Note that \c hasBody can also return true if any redeclaration of this
  /// \c Decl represents a declaration for a body of code.
  constexpr bool hasBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::hasBody, Xs...); }) , (;) )
  /// getBodyRBrace - Gets the right brace of the body, if a body exists.
  /// This works whether the body is a CompoundStmt or a CXXTryStmt.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBodyRBrace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getBodyRBrace, Xs...); }) , (;) )
  static constexpr void add(enum clang::Decl::Kind k) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::add, Xs..., k); }) , (;) )
  static constexpr void EnableStatistics() IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::EnableStatistics, Xs...); }) , (;) )
  static constexpr void PrintStats() IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::PrintStats, Xs...); }) , (;) )
  /// isTemplateParameter - Determines whether this declaration is a
  /// template parameter.
  constexpr bool isTemplateParameter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isTemplateParameter, Xs...); }) , (;) )
  /// isTemplateParameter - Determines whether this declaration is a
  /// template parameter pack.
  constexpr bool isTemplateParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isTemplateParameterPack, Xs...); }) , (;) )
  /// Whether this declaration is a parameter pack.
  constexpr bool isParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isParameterPack, Xs...); }) , (;) )
  /// returns true if this declaration is a template
  constexpr bool isTemplateDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isTemplateDecl, Xs...); }) , (;) )
  /// Whether this declaration is a function or function template.
  constexpr bool isFunctionOrFunctionTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::isFunctionOrFunctionTemplate, Xs...); }) , (;) )
  /// If this is a declaration that describes some template, this
  /// method returns that template declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateDecl *) )
  getDescribedTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getDescribedTemplate, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionDecl *) )
  getAsFunction() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getAsFunction, Xs...); }) , (;) )
  using FriendObjectKind = enum refldetail::clang::Decl::FriendObjectKind;
  /// Determines whether this declaration is the object of a
  /// friend declaration and, if so, what kind.
  ///
  /// There is currently no direct way to find the associated FriendDecl.
  constexpr enum clang::Decl::FriendObjectKind getFriendObjectKind() const IFMETA_ELSE( ({    return (enum clang::Decl::FriendObjectKind)__reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getFriendObjectKind, Xs...); }) , (;) )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::classofKind, Xs..., K); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void print(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) Out, unsigned int Indentation = 0, bool PrintInstantiation = false) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::print, Xs..., Y0s..., Indentation, PrintInstantiation); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void print(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) Out, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy, unsigned int Indentation = 0, bool PrintInstantiation = false) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::print1, Xs..., Y0s..., Y1s..., Indentation, PrintInstantiation); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr void printGroup(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> * *), (typename meta::clang::Decl **)) Begin, unsigned int NumDecls, IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y1s...>), (typename meta::llvm::raw_ostream &)) Out, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y2s...>), (const typename meta::clang::PrintingPolicy &)) Policy, unsigned int Indentation = 0) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::printGroup, Xs..., Y0s..., NumDecls, Y1s..., Y2s..., Indentation); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr void printGroup(ptrwrp<Y0> p0, unsigned int p1, Y1 p2, Y2 p3, unsigned int p4 = 0) {
      return printGroup(p0.get(), p1, p2, p3, p4);
  }), () )
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::dump, Xs...); }) , (;) )
  constexpr void dumpColor() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::dumpColor, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void dump(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) Out, bool Deserialize = false) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::dump1, Xs..., Y0s..., Deserialize); }) , (;) )
  /// Looks through the Decl's underlying type to extract a FunctionType
  /// when possible. Will return null if the type underlying the Decl does not
  /// have a FunctionType.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionType *) )
  getFunctionType(bool BlocksToo = true) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Decl, reflenums::clang__Decl::getFunctionType, Xs..., BlocksToo); }) , (;) )
};

/// The results of name lookup within a DeclContext. This is either a
/// single result (with no stable storage) or a collection of results (with
/// stable storage provided by the lookup table).
M_template_rtpack(Xs)
struct clang::DeclContextLookupResult::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DeclContextLookupResult;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DeclContextLookupResult::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContextLookupResult, reflenums::clang__DeclContextLookupResult::empty, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *const *) )
  data() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContextLookupResult, reflenums::clang__DeclContextLookupResult::data, Xs...); }) , (;) )
  constexpr unsigned long size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContextLookupResult, reflenums::clang__DeclContextLookupResult::size, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *const &) )
  front() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContextLookupResult, reflenums::clang__DeclContextLookupResult::front, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *const &) )
  back() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContextLookupResult, reflenums::clang__DeclContextLookupResult::back, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *const &) )
  operator[](unsigned long N) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContextLookupResult, reflenums::clang__DeclContextLookupResult::operator_sub, Xs..., N); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclContextLookupResult) )
  slice(unsigned long N) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContextLookupResult, reflenums::clang__DeclContextLookupResult::slice, Xs..., N); }) , (;) )
  RANGECLASS_SIZE_AND_GET(clang__DeclContextLookupResult, typename meta::clang::NamedDecl *const);
};

/// DeclContext - This is used only as base class of specific decl types that
/// can act as declaration contexts. These decls are (only the top classes
/// that directly derive from DeclContext are mentioned, not their subclasses):
///
///   TranslationUnitDecl
///   NamespaceDecl
///   FunctionDecl
///   TagDecl
///   ObjCMethodDecl
///   ObjCContainerDecl
///   LinkageSpecDecl
///   ExportDecl
///   BlockDecl
///   OMPDeclareReductionDecl
M_template_rtpack(Xs)
struct clang::DeclContext::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DeclContext;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DeclContext::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr enum clang::Decl::Kind getDeclKind() const IFMETA_ELSE( ({    return (enum clang::Decl::Kind)__reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::getDeclKind, Xs...); }) , (;) )
  constexpr const char * getDeclKindName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::getDeclKindName, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclContext *) )
  getParent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::getParent, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclContext *) )
  getLexicalParent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::getLexicalParent, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclContext *) )
  getLookupParent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::getLookupParent, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ASTContext &) )
  getParentASTContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::getParentASTContext, Xs...); }) , (;) )
  constexpr bool isClosure() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isClosure, Xs...); }) , (;) )
  constexpr bool isObjCContainer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isObjCContainer, Xs...); }) , (;) )
  constexpr bool isFunctionOrMethod() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isFunctionOrMethod, Xs...); }) , (;) )
  /// Test whether the context supports looking up names.
  constexpr bool isLookupContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isLookupContext, Xs...); }) , (;) )
  constexpr bool isFileContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isFileContext, Xs...); }) , (;) )
  constexpr bool isTranslationUnit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isTranslationUnit, Xs...); }) , (;) )
  constexpr bool isRecord() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isRecord, Xs...); }) , (;) )
  constexpr bool isNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isNamespace, Xs...); }) , (;) )
  constexpr bool isStdNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isStdNamespace, Xs...); }) , (;) )
  constexpr bool isInlineNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isInlineNamespace, Xs...); }) , (;) )
  /// Determines whether this context is dependent on a
  /// template parameter.
  constexpr bool isDependentContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isDependentContext, Xs...); }) , (;) )
  /// isTransparentContext - Determines whether this context is a
  /// "transparent" context, meaning that the members declared in this
  /// context are semantically declared in the nearest enclosing
  /// non-transparent (opaque) context but are lexically declared in
  /// this context. For example, consider the enumerators of an
  /// enumeration type:
  /// @code
  /// enum E {
  ///   Val1
  /// };
  /// @endcode
  /// Here, E is a transparent context, so its enumerator (Val1) will
  /// appear (semantically) that it is in the same context of E.
  /// Examples of transparent contexts include: enumerations (except for
  /// C++0x scoped enums), and C++ linkage specifications.
  constexpr bool isTransparentContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isTransparentContext, Xs...); }) , (;) )
  /// Determines whether this context or some of its ancestors is a
  /// linkage specification context that specifies C linkage.
  constexpr bool isExternCContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isExternCContext, Xs...); }) , (;) )
  /// Retrieve the nearest enclosing C linkage specification context.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::LinkageSpecDecl *) )
  getExternCContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::getExternCContext, Xs...); }) , (;) )
  /// Determines whether this context or some of its ancestors is a
  /// linkage specification context that specifies C++ linkage.
  constexpr bool isExternCXXContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isExternCXXContext, Xs...); }) , (;) )
  /// Determine whether this declaration context is equivalent
  /// to the declaration context DC.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool Equals(IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::DeclContext *)) DC) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::Equals, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool Equals(ptrwrp<Y0> p0) const {
      return Equals(p0.get());
  }), () )
  /// Determine whether this declaration context encloses the
  /// declaration context DC.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool Encloses(IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::DeclContext *)) DC) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::Encloses, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool Encloses(ptrwrp<Y0> p0) const {
      return Encloses(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Decl *) )
  getNonClosureAncestor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::getNonClosureAncestor, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclContext *) )
  getPrimaryContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::getPrimaryContext, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclContext *) )
  getRedeclContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::getRedeclContext, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclContext *) )
  getEnclosingNamespaceContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::getEnclosingNamespaceContext, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::RecordDecl *) )
  getOuterLexicalRecordContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::getOuterLexicalRecordContext, Xs...); }) , (;) )
  /// Test if this context is part of the enclosing namespace set of
  /// the context NS, as defined in C++0x [namespace.def]p9. If either context
  /// isn't a namespace, this is equivalent to Equals().
  ///
  /// The enclosing namespace set of a namespace is the namespace and, if it is
  /// inline, its enclosing namespace, recursively.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool InEnclosingNamespaceSetOf(IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::DeclContext *)) NS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::InEnclosingNamespaceSetOf, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool InEnclosingNamespaceSetOf(ptrwrp<Y0> p0) const {
      return InEnclosingNamespaceSetOf(p0.get());
  }), () )
  /// decls_begin/decls_end - Iterate over the declarations stored in
  /// this context.
  RANGE_REFLECTION(clang::DeclContext, decls,
      constexpr auto decls() const ,
      (typename meta::clang::Decl *const),
      (reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::decls, Xs...), () )
  constexpr bool decls_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::decls_empty, Xs...); }) , (;) )
  /// noload_decls_begin/end - Iterate over the declarations stored in this
  /// context that are currently loaded; don't attempt to retrieve anything
  /// from an external source.
  RANGE_REFLECTION(clang::DeclContext, noload_decls,
      constexpr auto noload_decls() const ,
      (typename meta::clang::Decl *const),
      (reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::noload_decls, Xs...), () )
  /// Checks whether a declaration is in this context.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool containsDecl(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::Decl *)) D) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::containsDecl, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool containsDecl(ptrwrp<Y0> p0) const {
      return containsDecl(p0.get());
  }), () )
  /// Checks whether a declaration is in this context.
  /// This also loads the Decls from the external source before the check.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool containsDeclAndLoad(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::Decl *)) D) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::containsDeclAndLoad, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool containsDeclAndLoad(ptrwrp<Y0> p0) const {
      return containsDeclAndLoad(p0.get());
  }), () )
  /// lookup - Find the declarations (if any) with the given Name in
  /// this context. Returns a range of iterators that contains all of
  /// the declarations with this name, with object, function, member,
  /// and enumerator names preceding any tag name. Note that this
  /// routine will not look into parent contexts.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclContextLookupResult) )
  lookup(IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::DeclarationName)) Name) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::lookup, Xs..., Y0s...); }) , (;) )
  RANGE_REFLECTION(clang::DeclContext, lookups,
      constexpr auto lookups() const ,
      (typename meta::clang::DeclContextLookupResult),
      (reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::lookups, Xs...), () )
  RANGE_REFLECTION(clang::DeclContext, ddiags,
      constexpr auto ddiags() const ,
      (typename meta::clang::DependentDiagnostic *),
      (reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::ddiags, Xs...), () )
  /// Retrieve the internal representation of the lookup structure.
  /// This may omit some names if we are lazily building the structure.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::StoredDeclsMap *) )
  getLookupPtr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::getLookupPtr, Xs...); }) , (;) )
  /// Whether this DeclContext has external storage containing
  /// additional declarations that are lexically in this context.
  constexpr bool hasExternalLexicalStorage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::hasExternalLexicalStorage, Xs...); }) , (;) )
  /// Whether this DeclContext has external storage containing
  /// additional declarations that are visible in this context.
  constexpr bool hasExternalVisibleStorage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::hasExternalVisibleStorage, Xs...); }) , (;) )
  /// Determine whether the given declaration is stored in the list of
  /// declarations lexically within this context.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isDeclInLexicalTraversal(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::isDeclInLexicalTraversal, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isDeclInLexicalTraversal(ptrwrp<Y0> p0) const {
      return isDeclInLexicalTraversal(p0.get());
  }), () )
  constexpr bool shouldUseQualifiedLookup() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::shouldUseQualifiedLookup, Xs...); }) , (;) )
  ////END
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::DeclContext *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::classof1, Xs..., Y0s...); }) , (;) )
  constexpr void dumpDeclContext() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::dumpDeclContext, Xs...); }) , (;) )
  constexpr void dumpLookups() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::dumpLookups, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void dumpLookups(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, bool DumpDecls = false, bool Deserialize = false) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DeclContext, reflenums::clang__DeclContext::dumpLookups1, Xs..., Y0s..., DumpDecls, Deserialize); }) , (;) )
};

/// CharUnits - This is an opaque type for sizes expressed in character units.
  /// Instances of this type represent a quantity as a multiple of the size
  /// of the standard C type, char, on the target architecture. As an opaque
  /// type, CharUnits protects you from accidentally combining operations on
  /// quantities in bit units and character units.
  ///
  /// In both C and C++, an object of type 'char', 'signed char', or 'unsigned
  /// char' occupies exactly one byte, so 'character unit' and 'byte' refer to
  /// the same quantity of storage. However, we use the term 'character unit'
  /// rather than 'byte' to avoid an implication that a character unit is
  /// exactly 8 bits.
  ///
  /// For portability, never assume that a target character is 8 bits wide. Use
  /// CharUnit values wherever you calculate sizes, offsets, or alignments
  /// in character units.
M_template_rtpack(Xs)
struct clang::CharUnits::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CharUnits;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CharUnits::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Zero - Construct a CharUnits quantity of zero.
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  Zero() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::Zero, Xs...); }) , (;) )
  /// One - Construct a CharUnits quantity of one.
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  One() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::One, Xs...); }) , (;) )
  /// fromQuantity - Construct a CharUnits quantity from a raw integer type.
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  fromQuantity(long long Quantity) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::fromQuantity, Xs..., Quantity); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::CharUnits &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::CharUnits &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_not_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::CharUnits &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_less, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<=(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::CharUnits &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_less_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator>(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::CharUnits &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_gr, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator>=(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::CharUnits &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_gr_eq, Xs..., Y0s...); }) , (;) )
  /// isZero - Test whether the quantity equals zero.
  constexpr bool isZero() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::isZero, Xs...); }) , (;) )
  /// isOne - Test whether the quantity equals one.
  constexpr bool isOne() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::isOne, Xs...); }) , (;) )
  /// isPositive - Test whether the quantity is greater than zero.
  constexpr bool isPositive() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::isPositive, Xs...); }) , (;) )
  /// isNegative - Test whether the quantity is less than zero.
  constexpr bool isNegative() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::isNegative, Xs...); }) , (;) )
  /// isPowerOfTwo - Test whether the quantity is a power of two.
      /// Zero is not a power of two.
  constexpr bool isPowerOfTwo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::isPowerOfTwo, Xs...); }) , (;) )
  /// Test whether this is a multiple of the other value.
      ///
      /// Among other things, this promises that
      /// self.alignTo(N) will just return self.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isMultipleOf(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::CharUnits)) N) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::isMultipleOf, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  operator*(long long N) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_star, Xs..., N); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  operator/(long long N) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_div, Xs..., N); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr long long operator/(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::CharUnits &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_div1, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  operator%(long long N) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_mod, Xs..., N); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr long long operator%(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::CharUnits &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_mod1, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  operator+(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::CharUnits &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_plus, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  operator-(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::CharUnits &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_minus, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  operator-() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::operator_minus1, Xs...); }) , (;) )
  /// getQuantity - Get the raw integer representation of this quantity.
  constexpr long long getQuantity() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::getQuantity, Xs...); }) , (;) )
  /// alignTo - Returns the next integer (mod 2**64) that is
      /// greater than or equal to this quantity and is a multiple of \p Align.
      /// Align must be non-zero.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  alignTo(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::CharUnits &)) Align) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::alignTo, Xs..., Y0s...); }) , (;) )
  /// Given that this is a non-zero alignment value, what is the
      /// alignment at the given offset?
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  alignmentAtOffset(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::CharUnits)) offset) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::alignmentAtOffset, Xs..., Y0s...); }) , (;) )
  /// Given that this is the alignment of the first element of an
      /// array, return the minimum alignment of any element in the array.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  alignmentOfArrayElement(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::CharUnits)) elementSize) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharUnits, reflenums::clang__CharUnits::alignmentOfArrayElement, Xs..., Y0s...); }) , (;) )
};

/// Keeps track of options that affect how file operations are performed.
M_template_rtpack(Xs)
struct clang::FileSystemOptions::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FileSystemOptions;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FileSystemOptions::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
};

/// Twine - A lightweight data structure for efficiently representing the
  /// concatenation of temporary values as strings.
  ///
  /// A Twine is a kind of rope, it represents a concatenated string using a
  /// binary-tree, where the string is the preorder of the nodes. Since the
  /// Twine can be efficiently rendered into a buffer when its result is used,
  /// it avoids the cost of generating temporary values for intermediate string
  /// results -- particularly in cases when the Twine result is never
  /// required. By explicitly tracking the type of leaf nodes, we can also avoid
  /// the creation of temporary strings for conversions operations (such as
  /// appending an integer to a string).
  ///
  /// A Twine is not intended for use directly and should not be stored, its
  /// implementation relies on the ability to store pointers to temporary stack
  /// objects which may be deallocated at the end of a statement. Twines should
  /// only be used accepted as const references in arguments, when an API wishes
  /// to accept possibly-concatenated strings.
  ///
  /// Twines support a special 'null' value, which always concatenates to form
  /// itself, and renders as an empty string. This can be returned from APIs to
  /// effectively nullify any concatenations performed on the result.
  ///
  /// \b Implementation
  ///
  /// Given the nature of a Twine, it is not possible for the Twine's
  /// concatenation method to construct interior nodes; the result must be
  /// represented inside the returned value. For this reason a Twine object
  /// actually holds two values, the left- and right-hand sides of a
  /// concatenation. We also have nullary Twine objects, which are effectively
  /// sentinel values that represent empty strings.
  ///
  /// Thus, a Twine can effectively have zero, one, or two children. The \see
  /// isNullary(), \see isUnary(), and \see isBinary() predicates exist for
  /// testing the number of children.
  ///
  /// We maintain a number of invariants on Twine objects (FIXME: Why):
  ///  - Nullary twines are always represented with their Kind on the left-hand
  ///    side, and the Empty kind on the right-hand side.
  ///  - Unary twines are always represented with the value on the left-hand
  ///    side, and the Empty kind on the right-hand side.
  ///  - If a Twine has another Twine as a child, that child should always be
  ///    binary (otherwise it could have been folded into the parent).
  ///
  /// These invariants are check by \see isValid().
  ///
  /// \b Efficiency Considerations
  ///
  /// The Twine is designed to yield efficient and small code for common
  /// situations. For this reason, the concat() method is inlined so that
  /// concatenations of leaf nodes can be optimized into stores directly into a
  /// single stack allocated object.
  ///
  /// In practice, not all compilers can be trusted to optimize concat() fully,
  /// so we provide two additional methods (and accompanying operator+
  /// overloads) to guarantee that particularly important cases (cstring plus
  /// StringRef) codegen as desired.
M_template_rtpack(Xs)
struct llvm::Twine::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__Twine;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::Twine::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Check if this twine is trivially empty; a false return value does not
    /// necessarily mean the twine is empty.
  constexpr bool isTriviallyEmpty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Twine, reflenums::llvm__Twine::isTriviallyEmpty, Xs...); }) , (;) )
  /// Return true if this twine can be dynamically accessed as a single
    /// StringRef value with getSingleStringRef().
  constexpr bool isSingleStringRef() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Twine, reflenums::llvm__Twine::isSingleStringRef, Xs...); }) , (;) )
  /// Return the twine contents as a std::string.
  constexpr const char * str() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Twine, reflenums::llvm__Twine::str, Xs...); }) , (;) )
  /// This returns the twine as a single StringRef.  This method is only valid
    /// if isSingleStringRef() is true.
  constexpr const char * getSingleStringRef() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Twine, reflenums::llvm__Twine::getSingleStringRef, Xs...); }) , (;) )
  /// Write the concatenated string represented by this twine to the
    /// stream \p OS.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void print(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__Twine, reflenums::llvm__Twine::print, Xs..., Y0s...); }) , (;) )
  /// Dump the concatenated string represented by this twine to stderr.
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__Twine, reflenums::llvm__Twine::dump, Xs...); }) , (;) )
  /// Write the representation of this twine to the stream \p OS.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void printRepr(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__Twine, reflenums::llvm__Twine::printRepr, Xs..., Y0s...); }) , (;) )
  /// Dump the representation of this twine to stderr.
  constexpr void dumpRepr() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__Twine, reflenums::llvm__Twine::dumpRepr, Xs...); }) , (;) )
};

M_template_rtpack(Xs)
struct llvm::sys::fs::UniqueID::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__sys__fs__UniqueID;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::sys::fs::UniqueID::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const llvm::sys::fs::UniqueID::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::sys::fs::UniqueID &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__sys__fs__UniqueID, reflenums::llvm__sys__fs__UniqueID::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const llvm::sys::fs::UniqueID::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::sys::fs::UniqueID &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__sys__fs__UniqueID, reflenums::llvm__sys__fs__UniqueID::operator_not_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<(IFMETA_ELSE((const llvm::sys::fs::UniqueID::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::sys::fs::UniqueID &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__sys__fs__UniqueID, reflenums::llvm__sys__fs__UniqueID::operator_less, Xs..., Y0s...); }) , (;) )
  constexpr unsigned long long getDevice() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__sys__fs__UniqueID, reflenums::llvm__sys__fs__UniqueID::getDevice, Xs...); }) , (;) )
  constexpr unsigned long long getFile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__sys__fs__UniqueID, reflenums::llvm__sys__fs__UniqueID::getFile, Xs...); }) , (;) )
};

/// The kind of memory backing used to support the MemoryBuffer.
enum llvm::MemoryBuffer::BufferKind : unsigned int {
  MemoryBuffer_Malloc,
  MemoryBuffer_MMap,
};

/// This interface provides simple read-only access to a block of memory, and
/// provides simple methods for reading files and standard input into a memory
/// buffer.  In addition to basic access to the characters in the file, this
/// interface guarantees you can read one character past the end of the file,
/// and that this character will read as '\0'.
///
/// The '\0' guarantee is needed to support an optimization -- it's intended to
/// be more efficient for clients which are reading all the data to stop
/// reading when they encounter a '\0' than to continually check the file
/// position to see if it has reached the end of the file.
M_template_rtpack(Xs)
struct llvm::MemoryBuffer::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__MemoryBuffer;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::MemoryBuffer::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr const char * getBufferStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__MemoryBuffer, reflenums::llvm__MemoryBuffer::getBufferStart, Xs...); }) , (;) )
  constexpr const char * getBufferEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__MemoryBuffer, reflenums::llvm__MemoryBuffer::getBufferEnd, Xs...); }) , (;) )
  constexpr unsigned long getBufferSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__MemoryBuffer, reflenums::llvm__MemoryBuffer::getBufferSize, Xs...); }) , (;) )
  constexpr const char * getBuffer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__MemoryBuffer, reflenums::llvm__MemoryBuffer::getBuffer, Xs...); }) , (;) )
  /// Return an identifier for this buffer, typically the filename it was read
  /// from.
  constexpr const char * getBufferIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__MemoryBuffer, reflenums::llvm__MemoryBuffer::getBufferIdentifier, Xs...); }) , (;) )
  using BufferKind = enum refldetail::llvm::MemoryBuffer::BufferKind;
  /// Return information on the memory mechanism used to support the
  /// MemoryBuffer.
  constexpr enum llvm::MemoryBuffer::BufferKind getBufferKind() const IFMETA_ELSE( ({    return (enum llvm::MemoryBuffer::BufferKind)__reflect_prop(reflenums::RK_llvm__MemoryBuffer, reflenums::llvm__MemoryBuffer::getBufferKind, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::MemoryBufferRef) )
  getMemBufferRef() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__MemoryBuffer, reflenums::llvm__MemoryBuffer::getMemBufferRef, Xs...); }) , (;) )
};

M_template_rtpack(Xs)
struct llvm::MemoryBufferRef::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__MemoryBufferRef;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::MemoryBufferRef::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr const char * getBuffer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__MemoryBufferRef, reflenums::llvm__MemoryBufferRef::getBuffer, Xs...); }) , (;) )
  constexpr const char * getBufferIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__MemoryBufferRef, reflenums::llvm__MemoryBufferRef::getBufferIdentifier, Xs...); }) , (;) )
  constexpr const char * getBufferStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__MemoryBufferRef, reflenums::llvm__MemoryBufferRef::getBufferStart, Xs...); }) , (;) )
  constexpr const char * getBufferEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__MemoryBufferRef, reflenums::llvm__MemoryBufferRef::getBufferEnd, Xs...); }) , (;) )
  constexpr unsigned long getBufferSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__MemoryBufferRef, reflenums::llvm__MemoryBufferRef::getBufferSize, Xs...); }) , (;) )
};

/// Cached information about one directory (either on disk or in
/// the virtual file system).
M_template_rtpack(Xs)
struct clang::DirectoryEntry::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DirectoryEntry;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DirectoryEntry::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr const char * getName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DirectoryEntry, reflenums::clang__DirectoryEntry::getName, Xs...); }) , (;) )
};

/// Cached information about one file (either on disk
/// or in the virtual file system).
///
/// If the 'File' member is valid, then this FileEntry has an open file
/// descriptor for the file.
M_template_rtpack(Xs)
struct clang::FileEntry::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FileEntry;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FileEntry::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr const char * getName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileEntry, reflenums::clang__FileEntry::getName, Xs...); }) , (;) )
  constexpr const char * tryGetRealPathName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileEntry, reflenums::clang__FileEntry::tryGetRealPathName, Xs...); }) , (;) )
  constexpr bool isValid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileEntry, reflenums::clang__FileEntry::isValid, Xs...); }) , (;) )
  constexpr long long getSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileEntry, reflenums::clang__FileEntry::getSize, Xs...); }) , (;) )
  constexpr unsigned int getUID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileEntry, reflenums::clang__FileEntry::getUID, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::sys::fs::UniqueID &) )
  getUniqueID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileEntry, reflenums::clang__FileEntry::getUniqueID, Xs...); }) , (;) )
  constexpr bool isInPCH() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileEntry, reflenums::clang__FileEntry::isInPCH, Xs...); }) , (;) )
  constexpr long getModificationTime() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileEntry, reflenums::clang__FileEntry::getModificationTime, Xs...); }) , (;) )
  /// Return the directory the file lives in.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DirectoryEntry *) )
  getDir() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileEntry, reflenums::clang__FileEntry::getDir, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<(IFMETA_ELSE((const clang::FileEntry::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::FileEntry &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileEntry, reflenums::clang__FileEntry::operator_less, Xs..., Y0s...); }) , (;) )
  /// Check whether the file is a named pipe (and thus can't be opened by
  /// the native FileManager methods).
  constexpr bool isNamedPipe() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileEntry, reflenums::clang__FileEntry::isNamedPipe, Xs...); }) , (;) )
  constexpr void closeFile() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__FileEntry, reflenums::clang__FileEntry::closeFile, Xs...); }) , (;) )
};

/// Implements support for file system lookup, file system caching,
/// and directory search management.
///
/// This also handles more advanced properties, such as uniquing files based
/// on "inode", so that a file with two names (e.g. symlinked) will be treated
/// as a single file.
///
M_template_rtpack(Xs)
struct clang::FileManager::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FileManager;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FileManager::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr void Retain() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__FileManager, reflenums::clang__FileManager::Retain, Xs...); }) , (;) )
  constexpr void Release() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__FileManager, reflenums::clang__FileManager::Release, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FileSystemOptions &) )
  getFileSystemOpts() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileManager, reflenums::clang__FileManager::getFileSystemOpts, Xs...); }) , (;) )
  /// Modifies the size and modification time of a previously created
  /// FileEntry. Use with caution.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr void modifyFileEntry(IFMETA_ELSE((const clang::FileEntry::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::FileEntry *)) File, long long Size, long ModificationTime) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__FileManager, reflenums::clang__FileManager::modifyFileEntry, Xs..., Y0s..., Size, ModificationTime); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr void modifyFileEntry(ptrwrp<Y0> p0, long long p1, long p2) {
      return modifyFileEntry(p0.get(), p1, p2);
  }), () )
  constexpr void PrintStats() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__FileManager, reflenums::clang__FileManager::PrintStats, Xs...); }) , (;) )
};

/// The signature of a module, which is a hash of the AST content.
M_template_rtpack(Xs)
struct clang::ASTFileSignature::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ASTFileSignature;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ASTFileSignature::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr const unsigned int * cbegin() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTFileSignature, reflenums::clang__ASTFileSignature::cbegin, Xs...); }) , (;) )
  constexpr const unsigned int * cend() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTFileSignature, reflenums::clang__ASTFileSignature::cend, Xs...); }) , (;) )
  constexpr unsigned long size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTFileSignature, reflenums::clang__ASTFileSignature::size, Xs...); }) , (;) )
  constexpr unsigned long max_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTFileSignature, reflenums::clang__ASTFileSignature::max_size, Xs...); }) , (;) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTFileSignature, reflenums::clang__ASTFileSignature::empty, Xs...); }) , (;) )
  constexpr const unsigned int & operator[](unsigned long __n) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTFileSignature, reflenums::clang__ASTFileSignature::operator_sub, Xs..., __n); }) , (;) )
  constexpr const unsigned int & at(unsigned long __n) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTFileSignature, reflenums::clang__ASTFileSignature::at, Xs..., __n); }) , (;) )
  constexpr const unsigned int & front() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTFileSignature, reflenums::clang__ASTFileSignature::front, Xs...); }) , (;) )
  constexpr const unsigned int & back() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTFileSignature, reflenums::clang__ASTFileSignature::back, Xs...); }) , (;) )
  constexpr const unsigned int * data() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTFileSignature, reflenums::clang__ASTFileSignature::data, Xs...); }) , (;) )
  constexpr explicit operator bool() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTFileSignature, reflenums::clang__ASTFileSignature::operator_bool, Xs...); }) , (;) )
  RANGECLASS_SIZE_AND_GET(clang__ASTFileSignature, const unsigned int);
};

enum clang::Module::ModuleKind : unsigned int {
  /// This is a module that was defined by a module map and built out
  /// of header files.
  ModuleMapModule,
  /// This is a C++ Modules TS module interface unit.
  ModuleInterfaceUnit,
  /// This is a fragment of the global module within some C++ Modules
  /// TS module.
  GlobalModuleFragment,
};

/// Describes the visibility of the various names within a
/// particular module.
enum clang::Module::NameVisibilityKind : unsigned int {
  /// All of the names in this module are hidden.
  Hidden,
  /// All of the names in this module are visible.
  AllVisible,
};

/// Describes a module or submodule.
M_template_rtpack(Xs)
struct clang::Module::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Module;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Module::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// The location of the module definition.
  M_REFLTYPED_FIELD(DefinitionLoc, (typename meta::clang::SourceLocation), __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::DefinitionLoc, Xs...))
  using ModuleKind = enum refldetail::clang::Module::ModuleKind;
  /// The kind of this module.
  enum clang::Module::ModuleKind Kind
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::Kind, Xs...);), (;) )
  /// The parent of this module. This will be NULL for the top-level
  /// module.
  M_REFLTYPED_FIELD(Parent, (typename meta::clang::Module *), __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::Parent, Xs...))
  /// The build directory of this module. This is the directory in
  /// which the module is notionally built, and relative to which its headers
  /// are found.
  M_REFLTYPED_FIELD(Directory, (const typename meta::clang::DirectoryEntry *), __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::Directory, Xs...))
  /// The module signature.
  M_REFLTYPED_FIELD(Signature, (typename meta::clang::ASTFileSignature), __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::Signature, Xs...))
  static const int NumHeaderKinds = 5u;
  M_template_rtpack(Zs) using Header = struct refldetail::clang::Module::Header::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using DirectoryName = struct refldetail::clang::Module::DirectoryName::M_template impl M_targpack(Zs);
  /// A module with the same name that shadows this module.
  M_REFLTYPED_FIELD(ShadowingModule, (typename meta::clang::Module *), __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::ShadowingModule, Xs...))
  /// Whether this module is missing a feature from \c Requirements.
  bool IsMissingRequirement
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::IsMissingRequirement, Xs...);), (;) )
  /// Whether we tried and failed to load a module file for this module.
  bool HasIncompatibleModuleFile
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::HasIncompatibleModuleFile, Xs...);), (;) )
  /// Whether this module is available in the current translation unit.
  ///
  /// If the module is missing headers or does not meet all requirements then
  /// this bit will be 0.
  bool IsAvailable
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::IsAvailable, Xs...);), (;) )
  /// Whether this module was loaded from a module file.
  bool IsFromModuleFile
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::IsFromModuleFile, Xs...);), (;) )
  /// Whether this is a framework module.
  bool IsFramework
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::IsFramework, Xs...);), (;) )
  /// Whether this is an explicit submodule.
  bool IsExplicit
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::IsExplicit, Xs...);), (;) )
  /// Whether this is a "system" module (which assumes that all
  /// headers in it are system headers).
  bool IsSystem
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::IsSystem, Xs...);), (;) )
  /// Whether this is an 'extern "C"' module (which implicitly puts all
  /// headers in it within an 'extern "C"' block, and allows the module to be
  /// imported within such a block).
  bool IsExternC
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::IsExternC, Xs...);), (;) )
  /// Whether this is an inferred submodule (module * { ... }).
  bool IsInferred
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::IsInferred, Xs...);), (;) )
  /// Whether we should infer submodules for this module based on
  /// the headers.
  ///
  /// Submodules can only be inferred for modules with an umbrella header.
  bool InferSubmodules
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::InferSubmodules, Xs...);), (;) )
  /// Whether, when inferring submodules, the inferred submodules
  /// should be explicit.
  bool InferExplicitSubmodules
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::InferExplicitSubmodules, Xs...);), (;) )
  /// Whether, when inferring submodules, the inferr submodules should
  /// export all modules they import (e.g., the equivalent of "export *").
  bool InferExportWildcard
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::InferExportWildcard, Xs...);), (;) )
  /// Whether the set of configuration macros is exhaustive.
  ///
  /// When the set of configuration macros is exhaustive, meaning
  /// that no identifier not in this list should affect how the module is
  /// built.
  bool ConfigMacrosExhaustive
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::ConfigMacrosExhaustive, Xs...);), (;) )
  /// Whether files in this module can only include non-modular headers
  /// and headers from used modules.
  bool NoUndeclaredIncludes
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::NoUndeclaredIncludes, Xs...);), (;) )
  /// Whether this module came from a "private" module map, found next
  /// to a regular (public) module map.
  bool ModuleMapIsPrivate
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::ModuleMapIsPrivate, Xs...);), (;) )
  using NameVisibilityKind = enum refldetail::clang::Module::NameVisibilityKind;
  /// The visibility of names within this particular module.
  enum clang::Module::NameVisibilityKind NameVisibility
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::NameVisibility, Xs...);), (;) )
  /// The location of the inferred submodule.
  M_REFLTYPED_FIELD(InferredSubmoduleLoc, (typename meta::clang::SourceLocation), __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::InferredSubmoduleLoc, Xs...))
  /// Autolinking uses the framework name for linking purposes
  /// when this is false and the export_as name otherwise.
  bool UseExportAsModuleLinkName
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::UseExportAsModuleLinkName, Xs...);), (;) )
  /// Determine whether this module is available for use within the
  /// current translation unit.
  constexpr bool isAvailable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::isAvailable, Xs...); }) , (;) )
  /// Determine whether this module is a submodule.
  constexpr bool isSubModule() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::isSubModule, Xs...); }) , (;) )
  /// Determine whether this module is a submodule of the given other
  /// module.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isSubModuleOf(IFMETA_ELSE((const clang::Module::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Module *)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::isSubModuleOf, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isSubModuleOf(ptrwrp<Y0> p0) const {
      return isSubModuleOf(p0.get());
  }), () )
  /// Determine whether this module is a part of a framework,
  /// either because it is a framework module or because it is a submodule
  /// of a framework module.
  constexpr bool isPartOfFramework() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::isPartOfFramework, Xs...); }) , (;) )
  /// Determine whether this module is a subframework of another
  /// framework.
  constexpr bool isSubFramework() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::isSubFramework, Xs...); }) , (;) )
  /// Retrieve the full name of this module, including the path from
  /// its top-level module.
  /// \param AllowStringLiterals If \c true, components that might not be
  ///        lexically valid as identifiers will be emitted as string literals.
  constexpr const char * getFullModuleName(bool AllowStringLiterals = false) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::getFullModuleName, Xs..., AllowStringLiterals); }) , (;) )
  /// Retrieve the top-level module for this (sub)module, which may
  /// be this module.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Module *) )
  getTopLevelModule() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::getTopLevelModule, Xs...); }) , (;) )
  /// Retrieve the name of the top-level module.
  constexpr const char * getTopLevelModuleName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::getTopLevelModuleName, Xs...); }) , (;) )
  /// The serialized AST file for this module, if one was created.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FileEntry *) )
  getASTFile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::getASTFile, Xs...); }) , (;) )
  /// Retrieve the directory for which this module serves as the
  /// umbrella.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Module::DirectoryName) )
  getUmbrellaDir() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::getUmbrellaDir, Xs...); }) , (;) )
  /// Retrieve the header that serves as the umbrella header for this
  /// module.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Module::Header) )
  getUmbrellaHeader() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::getUmbrellaHeader, Xs...); }) , (;) )
  /// Determine whether this module has an umbrella directory that is
  /// not based on an umbrella header.
  constexpr bool hasUmbrellaDir() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::hasUmbrellaDir, Xs...); }) , (;) )
  /// Determine whether this module has declared its intention to
  /// directly use another module.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool directlyUses(IFMETA_ELSE((const clang::Module::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Module *)) Requested) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::directlyUses, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool directlyUses(ptrwrp<Y0> p0) const {
      return directlyUses(p0.get());
  }), () )
  /// Determine whether the specified module would be visible to
  /// a lookup at the end of this module.
  ///
  /// FIXME: This may return incorrect results for (submodules of) the
  /// module currently being built, if it's queried before we see all
  /// of its imports.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isModuleVisible(IFMETA_ELSE((const clang::Module::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Module *)) M) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::isModuleVisible, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isModuleVisible(ptrwrp<Y0> p0) const {
      return isModuleVisible(p0.get());
  }), () )
  constexpr unsigned int getVisibilityID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::getVisibilityID, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::Module, submodules,
      constexpr auto submodules() const ,
      (typename meta::clang::Module *const),
      (reflenums::RK_clang__Module, reflenums::clang__Module::submodules, Xs...), () )
  static constexpr const char * getModuleInputBufferName() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::getModuleInputBufferName, Xs...); }) , (;) )
  /// Print the module map for this module to the given stream.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void print(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, unsigned int Indent = 0) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::print, Xs..., Y0s..., Indent); }) , (;) )
  /// Dump the contents of this module to the given output stream.
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Module, reflenums::clang__Module::dump, Xs...); }) , (;) )
};

/// Information about a header directive as found in the module map
  /// file.
M_template_rtpack(Xs)
struct clang::Module::Header::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Module__Header;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Module::Header::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_REFLTYPED_FIELD(Entry, (const typename meta::clang::FileEntry *), __reflect_prop(reflenums::RK_clang__Module__Header, reflenums::clang__Module__Header::Entry, Xs...))
};

/// Information about a directory name as found in the module map
  /// file.
M_template_rtpack(Xs)
struct clang::Module::DirectoryName::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Module__DirectoryName;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Module::DirectoryName::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_REFLTYPED_FIELD(Entry, (const typename meta::clang::DirectoryEntry *), __reflect_prop(reflenums::RK_clang__Module__DirectoryName, reflenums::clang__Module__DirectoryName::Entry, Xs...))
};

/// Abstract interface for external sources of AST nodes.
///
/// External AST sources provide AST nodes constructed from some
/// external source, such as a precompiled header. External AST
/// sources can resolve types and declarations from abstract IDs into
/// actual type and declaration nodes, and read parts of declaration
/// contexts.
M_template_rtpack(Xs)
struct clang::ExternalASTSource::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ExternalASTSource;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ExternalASTSource::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr void Retain() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ExternalASTSource, reflenums::clang__ExternalASTSource::Retain, Xs...); }) , (;) )
  constexpr void Release() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ExternalASTSource, reflenums::clang__ExternalASTSource::Release, Xs...); }) , (;) )
  /// Get the current generation of this AST source. This number
  /// is incremented each time the AST source lazily extends an existing
  /// entity.
  constexpr unsigned int getGeneration() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExternalASTSource, reflenums::clang__ExternalASTSource::getGeneration, Xs...); }) , (;) )
  M_template_rtpack(Zs) using MemoryBufferSizes = struct refldetail::clang::ExternalASTSource::MemoryBufferSizes::M_template impl M_targpack(Zs);
  /// Return the amount of memory used by memory buffers, breaking down
  /// by heap-backed versus mmap'ed memory.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ExternalASTSource::MemoryBufferSizes) )
  getMemoryBufferSizes() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExternalASTSource, reflenums::clang__ExternalASTSource::getMemoryBufferSizes, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void getMemoryBufferSizes(IFMETA_ELSE((const clang::ExternalASTSource::MemoryBufferSizes::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ExternalASTSource::MemoryBufferSizes &)) sizes) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ExternalASTSource, reflenums::clang__ExternalASTSource::getMemoryBufferSizes1, Xs..., Y0s...); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::ExternalASTSource::MemoryBufferSizes::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ExternalASTSource__MemoryBufferSizes;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ExternalASTSource::MemoryBufferSizes::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  unsigned long malloc_bytes
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__ExternalASTSource__MemoryBufferSizes, reflenums::clang__ExternalASTSource__MemoryBufferSizes::malloc_bytes, Xs...);), (;) )
  unsigned long mmap_bytes
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__ExternalASTSource__MemoryBufferSizes, reflenums::clang__ExternalASTSource__MemoryBufferSizes::mmap_bytes, Xs...);), (;) )
};

/// FoldingSetBase - Implements the folding set functionality.  The main
/// structure is an array of buckets.  Each bucket is indexed by the hash of
/// the nodes it contains.  The bucket itself points to the nodes contained
/// in the bucket via a singly linked list.  The last node in the list points
/// back to the bucket to facilitate node removal.
///
M_template_rtpack(Xs)
struct llvm::FoldingSetBase::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__FoldingSetBase;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::FoldingSetBase::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template_rtpack(Zs) using Node = struct refldetail::llvm::FoldingSetBase::Node::M_template impl M_targpack(Zs);
  /// size - Returns the number of nodes in the folding set.
  constexpr unsigned int size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetBase, reflenums::llvm__FoldingSetBase::size, Xs...); }) , (;) )
  /// empty - Returns true if there are no nodes in the folding set.
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetBase, reflenums::llvm__FoldingSetBase::empty, Xs...); }) , (;) )
};

/// Node - This class is used to maintain the singly linked bucket list in
  /// a folding set.
M_template_rtpack(Xs)
struct llvm::FoldingSetBase::Node::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__FoldingSetBase__Node;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::FoldingSetBase::Node::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr void * getNextInBucket() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetBase__Node, reflenums::llvm__FoldingSetBase__Node::getNextInBucket, Xs...); }) , (;) )
};

/// FoldingSetNodeIDRef - This class describes a reference to an interned
/// FoldingSetNodeID, which can be a useful to store node id data rather
/// than using plain FoldingSetNodeIDs, since the 32-element SmallVector
/// is often much larger than necessary, and the possibility of heap
/// allocation means it requires a non-trivial destructor call.
M_template_rtpack(Xs)
struct llvm::FoldingSetNodeIDRef::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__FoldingSetNodeIDRef;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::FoldingSetNodeIDRef::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeIDRef,
  /// used to lookup the node in the FoldingSetBase.
  constexpr unsigned int ComputeHash() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetNodeIDRef, reflenums::llvm__FoldingSetNodeIDRef::ComputeHash, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const llvm::FoldingSetNodeIDRef::template impl</*ptrorref=*/0, Y0s...>), (typename meta::llvm::FoldingSetNodeIDRef)) p0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetNodeIDRef, reflenums::llvm__FoldingSetNodeIDRef::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const llvm::FoldingSetNodeIDRef::template impl</*ptrorref=*/0, Y0s...>), (typename meta::llvm::FoldingSetNodeIDRef)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetNodeIDRef, reflenums::llvm__FoldingSetNodeIDRef::operator_not_eq, Xs..., Y0s...); }) , (;) )
  /// Used to compare the "ordering" of two nodes as defined by the
  /// profiled bits and their ordering defined by memcmp().
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<(IFMETA_ELSE((const llvm::FoldingSetNodeIDRef::template impl</*ptrorref=*/0, Y0s...>), (typename meta::llvm::FoldingSetNodeIDRef)) p0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetNodeIDRef, reflenums::llvm__FoldingSetNodeIDRef::operator_less, Xs..., Y0s...); }) , (;) )
  constexpr const unsigned int * getData() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetNodeIDRef, reflenums::llvm__FoldingSetNodeIDRef::getData, Xs...); }) , (;) )
  constexpr unsigned long getSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetNodeIDRef, reflenums::llvm__FoldingSetNodeIDRef::getSize, Xs...); }) , (;) )
};

/// FoldingSetNodeID - This class is used to gather all the unique data bits of
/// a node.  When all the bits are gathered this class is used to produce a
/// hash value for the node.
M_template_rtpack(Xs)
struct llvm::FoldingSetNodeID::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__FoldingSetNodeID;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::FoldingSetNodeID::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// ComputeHash - Compute a strong hash value for this FoldingSetNodeID, used
  /// to lookup the node in the FoldingSetBase.
  constexpr unsigned int ComputeHash() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetNodeID, reflenums::llvm__FoldingSetNodeID::ComputeHash, Xs...); }) , (;) )
  /// operator== - Used to compare two nodes to each other.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::FoldingSetNodeID &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetNodeID, reflenums::llvm__FoldingSetNodeID::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const llvm::FoldingSetNodeIDRef::template impl</*ptrorref=*/0, Y0s...>), (const typename meta::llvm::FoldingSetNodeIDRef)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetNodeID, reflenums::llvm__FoldingSetNodeID::operator_eq_eq1, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::FoldingSetNodeID &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetNodeID, reflenums::llvm__FoldingSetNodeID::operator_not_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const llvm::FoldingSetNodeIDRef::template impl</*ptrorref=*/0, Y0s...>), (const typename meta::llvm::FoldingSetNodeIDRef)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetNodeID, reflenums::llvm__FoldingSetNodeID::operator_not_eq1, Xs..., Y0s...); }) , (;) )
  /// Used to compare the "ordering" of two nodes as defined by the
  /// profiled bits and their ordering defined by memcmp().
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::FoldingSetNodeID &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetNodeID, reflenums::llvm__FoldingSetNodeID::operator_less, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<(IFMETA_ELSE((const llvm::FoldingSetNodeIDRef::template impl</*ptrorref=*/0, Y0s...>), (const typename meta::llvm::FoldingSetNodeIDRef)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__FoldingSetNodeID, reflenums::llvm__FoldingSetNodeID::operator_less1, Xs..., Y0s...); }) , (;) )
};

/// The kind of specifier that completes this nested name
/// specifier.
enum clang::NestedNameSpecifier::SpecifierKind : unsigned int {
  /// An identifier, stored as an IdentifierInfo*.
  Identifier,
  /// A namespace, stored as a NamespaceDecl*.
  Namespace,
  /// A namespace alias, stored as a NamespaceAliasDecl*.
  NamespaceAlias,
  /// A type, stored as a Type*.
  TypeSpec,
  /// A type that was preceded by the 'template' keyword,
  /// stored as a Type*.
  TypeSpecWithTemplate,
  /// The global specifier '::'. There is no stored value.
  Global,
  /// Microsoft's '__super' specifier, stored as a CXXRecordDecl* of
  /// the class it appeared in.
  Super,
};

/// Represents a C++ nested name specifier, such as
/// "\::std::vector<int>::".
///
/// C++ nested name specifiers are the prefixes to qualified
/// names. For example, "foo::" in "foo::x" is a nested name
/// specifier. Nested name specifiers are made up of a sequence of
/// specifiers, each of which can be a namespace, type, identifier
/// (for dependent names), decltype specifier, or the global specifier ('::').
/// The last two specifiers can only appear at the start of a
/// nested-namespace-specifier.
M_template_rtpack(Xs)
struct clang::NestedNameSpecifier::impl : impl_offset_t<llvm::FoldingSetBase::Node, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__NestedNameSpecifier;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::NestedNameSpecifier::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using SpecifierKind = enum refldetail::clang::NestedNameSpecifier::SpecifierKind;
  /// Builds a specifier combining a prefix and an identifier.
  ///
  /// The prefix must be dependent, since nested name specifiers
  /// referencing an identifier are only permitted when the identifier
  /// cannot be resolved.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::NestedNameSpecifier *)) Prefix, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::IdentifierInfo *)) II) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::Create, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  Create(Y0 p0, ptrwrp<Y1> p1, ptrwrp<Y2> p2) {
      return Create(p0, p1.get(), p2.get());
  }), () )
  /// Builds a nested name specifier that names a namespace.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::NestedNameSpecifier *)) Prefix, IFMETA_ELSE((const clang::NamespaceDecl::template impl</*ptrorref=*/1, Y2s...> *), (const typename meta::clang::NamespaceDecl *)) NS) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::Create1, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  /// Builds a nested name specifier that names a namespace alias.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::NestedNameSpecifier *)) Prefix, IFMETA_ELSE((const clang::NamespaceAliasDecl::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::NamespaceAliasDecl *)) Alias) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::Create2, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  /// Builds a nested name specifier that names a type.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::NestedNameSpecifier *)) Prefix, bool Template, IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y2s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::Create3, Xs..., Y0s..., Y1s..., Template, Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  Create(Y0 p0, ptrwrp<Y1> p1, bool p2, ptrwrp<Y2> p3) {
      return Create(p0, p1.get(), p2, p3.get());
  }), () )
  /// Builds a specifier that consists of just an identifier.
  ///
  /// The nested-name-specifier is assumed to be dependent, but has no
  /// prefix because the prefix is implied by something outside of the
  /// nested name specifier, e.g., in "x->Base::f", the "x" has a dependent
  /// type.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::IdentifierInfo *)) II) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::Create4, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  Create(Y0 p0, ptrwrp<Y1> p1) {
      return Create(p0, p1.get());
  }), () )
  /// Returns the nested name specifier representing the global
  /// scope.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  GlobalSpecifier(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::GlobalSpecifier, Xs..., Y0s...); }) , (;) )
  /// Returns the nested name specifier representing the __super scope
  /// for the given CXXRecordDecl.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  SuperSpecifier(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::CXXRecordDecl *)) RD) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::SuperSpecifier, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  SuperSpecifier(Y0 p0, ptrwrp<Y1> p1) {
      return SuperSpecifier(p0, p1.get());
  }), () )
  /// Return the prefix of this nested name specifier.
  ///
  /// The prefix contains all of the parts of the nested name
  /// specifier that preced this current specifier. For example, for a
  /// nested name specifier that represents "foo::bar::", the current
  /// specifier will contain "bar::" and the prefix will contain
  /// "foo::".
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getPrefix() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::getPrefix, Xs...); }) , (;) )
  /// Determine what kind of nested name specifier is stored.
  constexpr enum clang::NestedNameSpecifier::SpecifierKind getKind() const IFMETA_ELSE( ({    return (enum clang::NestedNameSpecifier::SpecifierKind)__reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::getKind, Xs...); }) , (;) )
  /// Retrieve the identifier stored in this nested name
  /// specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getAsIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::getAsIdentifier, Xs...); }) , (;) )
  /// Retrieve the namespace stored in this nested name
  /// specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamespaceDecl *) )
  getAsNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::getAsNamespace, Xs...); }) , (;) )
  /// Retrieve the namespace alias stored in this nested name
  /// specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamespaceAliasDecl *) )
  getAsNamespaceAlias() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::getAsNamespaceAlias, Xs...); }) , (;) )
  /// Retrieve the record declaration stored in this nested name
  /// specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getAsRecordDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::getAsRecordDecl, Xs...); }) , (;) )
  /// Retrieve the type stored in this nested name specifier.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getAsType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::getAsType, Xs...); }) , (;) )
  /// Whether this nested name specifier refers to a dependent
  /// type or not.
  constexpr bool isDependent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::isDependent, Xs...); }) , (;) )
  /// Whether this nested name specifier involves a template
  /// parameter.
  constexpr bool isInstantiationDependent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::isInstantiationDependent, Xs...); }) , (;) )
  /// Whether this nested-name-specifier contains an unexpanded
  /// parameter pack (for C++11 variadic templates).
  constexpr bool containsUnexpandedParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::containsUnexpandedParameterPack, Xs...); }) , (;) )
  /// Print this nested name specifier to the given output
  /// stream.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void print(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::print, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::Profile, Xs..., Y0s...); }) , (;) )
  /// Dump the nested name specifier to standard output to aid
  /// in debugging.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void dump(IFMETA_ELSE((const clang::LangOptions::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::LangOptions &)) LO) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::dump, Xs..., Y0s...); }) , (;) )
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__NestedNameSpecifier, reflenums::clang__NestedNameSpecifier::dump1, Xs...); }) , (;) )
};

/// A C++ nested-name-specifier augmented with source location
/// information.
M_template_rtpack(Xs)
struct clang::NestedNameSpecifierLoc::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__NestedNameSpecifierLoc;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::NestedNameSpecifierLoc::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Evaluates true when this nested-name-specifier location is
  /// non-empty.
  constexpr explicit operator bool() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::operator_bool, Xs...); }) , (;) )
  /// Evaluates true when this nested-name-specifier location is
  /// empty.
  constexpr bool hasQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::hasQualifier, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier to which this instance
  /// refers.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getNestedNameSpecifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::getNestedNameSpecifier, Xs...); }) , (;) )
  /// Retrieve the opaque pointer that refers to source-location data.
  constexpr void * getOpaqueData() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::getOpaqueData, Xs...); }) , (;) )
  /// Retrieve the source range covering the entirety of this
  /// nested-name-specifier.
  ///
  /// For example, if this instance refers to a nested-name-specifier
  /// \c \::std::vector<int>::, the returned source range would cover
  /// from the initial '::' to the last '::'.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::getSourceRange, Xs...); }) , (;) )
  /// Retrieve the source range covering just the last part of
  /// this nested-name-specifier, not including the prefix.
  ///
  /// For example, if this instance refers to a nested-name-specifier
  /// \c \::std::vector<int>::, the returned source range would cover
  /// from "vector" to the last '::'.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getLocalSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::getLocalSourceRange, Xs...); }) , (;) )
  /// Retrieve the location of the beginning of this
  /// nested-name-specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::getBeginLoc, Xs...); }) , (;) )
  /// Retrieve the location of the end of this
  /// nested-name-specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::getEndLoc, Xs...); }) , (;) )
  /// Retrieve the location of the beginning of this
  /// component of the nested-name-specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocalBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::getLocalBeginLoc, Xs...); }) , (;) )
  /// Retrieve the location of the end of this component of the
  /// nested-name-specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocalEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::getLocalEndLoc, Xs...); }) , (;) )
  /// Return the prefix of this nested-name-specifier.
  ///
  /// For example, if this instance refers to a nested-name-specifier
  /// \c \::std::vector<int>::, the prefix is \c \::std::. Note that the
  /// returned prefix may be empty, if this is the first component of
  /// the nested-name-specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getPrefix() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::getPrefix, Xs...); }) , (;) )
  /// For a nested-name-specifier that refers to a type,
  /// retrieve the type with source-location information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeLoc) )
  getTypeLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::getTypeLoc, Xs...); }) , (;) )
  /// Determines the data length for the entire
  /// nested-name-specifier.
  constexpr unsigned int getDataLength() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::getDataLength, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator==(IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::NestedNameSpecifierLoc)) X, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::NestedNameSpecifierLoc)) Y) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::operator_eq_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator!=(IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::NestedNameSpecifierLoc)) X, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::NestedNameSpecifierLoc)) Y) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NestedNameSpecifierLoc, reflenums::clang__NestedNameSpecifierLoc::operator_not_eq, Xs..., Y0s..., Y1s...); }) , (;) )
};

/// Implementation class used to describe either a set of overloaded
/// template names or an already-substituted template template parameter pack.
M_template_rtpack(Xs)
struct clang::UncommonTemplateNameStorage::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UncommonTemplateNameStorage;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UncommonTemplateNameStorage::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr unsigned int size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UncommonTemplateNameStorage, reflenums::clang__UncommonTemplateNameStorage::size, Xs...); }) , (;) )
};

/// A structure for storing the information associated with an
/// overloaded template name.
M_template_rtpack(Xs)
struct clang::OverloadedTemplateStorage::impl : impl_offset_t<clang::UncommonTemplateNameStorage, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OverloadedTemplateStorage;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OverloadedTemplateStorage::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  RANGECLASS_SIZE_AND_GET(clang__OverloadedTemplateStorage, typename meta::clang::NamedDecl *const);
};

/// A structure for storing an already-substituted template template
/// parameter pack.
///
/// This kind of template names occurs when the parameter pack has been
/// provided with a template template argument pack in a context where its
/// enclosing pack expansion could not be fully expanded.
M_template_rtpack(Xs)
struct clang::SubstTemplateTemplateParmPackStorage::impl : impl_offset_t<clang::UncommonTemplateNameStorage, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 8 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SubstTemplateTemplateParmPackStorage;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SubstTemplateTemplateParmPackStorage::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the template template parameter pack being substituted.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateTemplateParmDecl *) )
  getParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTemplateParmPackStorage, reflenums::clang__SubstTemplateTemplateParmPackStorage::getParameterPack, Xs...); }) , (;) )
  /// Retrieve the template template argument pack with which this
  /// parameter was substituted.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateArgument) )
  getArgumentPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTemplateParmPackStorage, reflenums::clang__SubstTemplateTemplateParmPackStorage::getArgumentPack, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::TemplateTemplateParmDecl::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::TemplateTemplateParmDecl *)) Parameter, IFMETA_ELSE((const clang::TemplateArgument::template impl</*ptrorref=*/1, Y3s...>), (const typename meta::clang::TemplateArgument &)) ArgPack) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__SubstTemplateTemplateParmPackStorage, reflenums::clang__SubstTemplateTemplateParmPackStorage::Profile, Xs..., Y0s..., Y1s..., Y2s..., Y3s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr void Profile(Y0 p0, Y1 p1, ptrwrp<Y2> p2, Y3 p3) {
      return Profile(p0, p1, p2.get(), p3);
  }), () )
};

enum clang::TemplateName::NameKind : unsigned int {
  /// A single template declaration.
  Template,
  /// A set of overloaded template declarations.
  OverloadedTemplate,
  /// A qualified template name, where the qualification is kept
  /// to describe the source code as written.
  QualifiedTemplate,
  /// A dependent template name that has not been resolved to a
  /// template (or set of templates).
  DependentTemplate,
  /// A template template parameter that has been substituted
  /// for some other template name.
  SubstTemplateTemplateParm,
  /// A template template parameter pack that has been substituted for
  /// a template template argument pack, but has not yet been expanded into
  /// individual arguments.
  SubstTemplateTemplateParmPack,
};

/// Represents a C++ template name within the type system.
///
/// A C++ template name refers to a template within the C++ type
/// system. In most cases, a template name is simply a reference to a
/// class template, e.g.
///
/// \code
/// template<typename T> class X { };
///
/// X<int> xi;
/// \endcode
///
/// Here, the 'X' in \c X<int> is a template name that refers to the
/// declaration of the class template X, above. Template names can
/// also refer to function templates, C++0x template aliases, etc.
///
/// Some template names are dependent. For example, consider:
///
/// \code
/// template<typename MetaFun, typename T1, typename T2> struct apply2 {
///   typedef typename MetaFun::template apply<T1, T2>::type type;
/// };
/// \endcode
///
/// Here, "apply" is treated as a template name within the typename
/// specifier in the typedef. "apply" is a nested template, and can
/// only be understood in the context of
M_template_rtpack(Xs)
struct clang::TemplateName::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TemplateName;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TemplateName::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using NameKind = enum refldetail::clang::TemplateName::NameKind;
  /// Determine whether this template name is NULL.
  constexpr bool isNull() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::isNull, Xs...); }) , (;) )
  constexpr enum clang::TemplateName::NameKind getKind() const IFMETA_ELSE( ({    return (enum clang::TemplateName::NameKind)__reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::getKind, Xs...); }) , (;) )
  /// Retrieve the underlying template declaration that
  /// this template name refers to, if known.
  ///
  /// \returns The template declaration that this template name refers
  /// to, if any. If the template name does not refer to a specific
  /// declaration because it is a dependent name, or if it refers to a
  /// set of function templates, returns NULL.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateDecl *) )
  getAsTemplateDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::getAsTemplateDecl, Xs...); }) , (;) )
  ///
  /// \returns The set of overloaded function templates that this template
  /// name refers to, if known. If the template name does not refer to a
  /// specific set of function templates because it is a dependent name or
  /// refers to a single template, returns NULL.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::OverloadedTemplateStorage *) )
  getAsOverloadedTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::getAsOverloadedTemplate, Xs...); }) , (;) )
  /// Retrieve the substituted template template parameter, if
  /// known.
  ///
  /// \returns The storage for the substituted template template parameter,
  /// if known. Otherwise, returns NULL.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SubstTemplateTemplateParmStorage *) )
  getAsSubstTemplateTemplateParm() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::getAsSubstTemplateTemplateParm, Xs...); }) , (;) )
  /// Retrieve the substituted template template parameter pack, if
  /// known.
  ///
  /// \returns The storage for the substituted template template parameter pack,
  /// if known. Otherwise, returns NULL.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SubstTemplateTemplateParmPackStorage *) )
  getAsSubstTemplateTemplateParmPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::getAsSubstTemplateTemplateParmPack, Xs...); }) , (;) )
  /// Retrieve the underlying qualified template name
  /// structure, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualifiedTemplateName *) )
  getAsQualifiedTemplateName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::getAsQualifiedTemplateName, Xs...); }) , (;) )
  /// Retrieve the underlying dependent template name
  /// structure, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DependentTemplateName *) )
  getAsDependentTemplateName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::getAsDependentTemplateName, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getUnderlying() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::getUnderlying, Xs...); }) , (;) )
  /// Get the template name to substitute when this template name is used as a
  /// template template argument. This refers to the most recent declaration of
  /// the template, including any default template arguments.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getNameToSubstitute() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::getNameToSubstitute, Xs...); }) , (;) )
  /// Determines whether this is a dependent template name.
  constexpr bool isDependent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::isDependent, Xs...); }) , (;) )
  /// Determines whether this is a template name that somehow
  /// depends on a template parameter.
  constexpr bool isInstantiationDependent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::isInstantiationDependent, Xs...); }) , (;) )
  /// Determines whether this template name contains an
  /// unexpanded parameter pack (for C++0x variadic templates).
  constexpr bool containsUnexpandedParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::containsUnexpandedParameterPack, Xs...); }) , (;) )
  /// Print the template name.
  ///
  /// \param OS the output stream to which the template name will be
  /// printed.
  ///
  /// \param SuppressNNS if true, don't print the
  /// nested-name-specifier that precedes the template name (if it has
  /// one).
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void print(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy, bool SuppressNNS = false) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::print, Xs..., Y0s..., Y1s..., SuppressNNS); }) , (;) )
  /// Debugging aid that dumps the template name.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void dump(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::dump, Xs..., Y0s...); }) , (;) )
  /// Debugging aid that dumps the template name to standard
  /// error.
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::dump1, Xs...); }) , (;) )
  /// Retrieve the template name as a void pointer.
  constexpr void * getAsVoidPointer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::getAsVoidPointer, Xs...); }) , (;) )
  /// Build a template name from a void pointer.
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getFromVoidPointer(void * Ptr) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateName, reflenums::clang__TemplateName::getFromVoidPointer, Xs..., Ptr); }) , (;) )
};

/// A structure for storing the information associated with a
/// substituted template template parameter.
M_template_rtpack(Xs)
struct clang::SubstTemplateTemplateParmStorage::impl : impl_offset_t<clang::UncommonTemplateNameStorage, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 8 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SubstTemplateTemplateParmStorage;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SubstTemplateTemplateParmStorage::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateTemplateParmDecl *) )
  getParameter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTemplateParmStorage, reflenums::clang__SubstTemplateTemplateParmStorage::getParameter, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getReplacement() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTemplateParmStorage, reflenums::clang__SubstTemplateTemplateParmStorage::getReplacement, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::TemplateTemplateParmDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::TemplateTemplateParmDecl *)) parameter, IFMETA_ELSE((const clang::TemplateName::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::TemplateName)) replacement) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__SubstTemplateTemplateParmStorage, reflenums::clang__SubstTemplateTemplateParmStorage::Profile, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr void Profile(Y0 p0, ptrwrp<Y1> p1, Y2 p2) {
      return Profile(p0, p1.get(), p2);
  }), () )
};

/// Represents a template name that was expressed as a
/// qualified name.
///
/// This kind of template name refers to a template name that was
/// preceded by a nested name specifier, e.g., \c std::vector. Here,
/// the nested name specifier is "std::" and the template name is the
/// declaration for "vector". The QualifiedTemplateName class is only
/// used to provide "sugar" for template names that were expressed
/// with a qualified name, and has no semantic meaning. In this
/// manner, it is to TemplateName what ElaboratedType is to Type,
/// providing extra syntactic sugar for downstream clients.
M_template_rtpack(Xs)
struct clang::QualifiedTemplateName::impl : impl_offset_t<llvm::FoldingSetBase::Node, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__QualifiedTemplateName;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::QualifiedTemplateName::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Return the nested name specifier that qualifies this name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualifiedTemplateName, reflenums::clang__QualifiedTemplateName::getQualifier, Xs...); }) , (;) )
  /// Whether the template name was prefixed by the "template"
  /// keyword.
  constexpr bool hasTemplateKeyword() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualifiedTemplateName, reflenums::clang__QualifiedTemplateName::hasTemplateKeyword, Xs...); }) , (;) )
  /// The template declaration that this qualified name refers
  /// to.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualifiedTemplateName, reflenums::clang__QualifiedTemplateName::getDecl, Xs...); }) , (;) )
  /// The template declaration to which this qualified name
  /// refers.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateDecl *) )
  getTemplateDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualifiedTemplateName, reflenums::clang__QualifiedTemplateName::getTemplateDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::NestedNameSpecifier *)) NNS, bool TemplateKeyword, IFMETA_ELSE((const clang::TemplateDecl::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::TemplateDecl *)) Template) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__QualifiedTemplateName, reflenums::clang__QualifiedTemplateName::Profile, Xs..., Y0s..., Y1s..., TemplateKeyword, Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr void Profile(Y0 p0, ptrwrp<Y1> p1, bool p2, ptrwrp<Y2> p3) {
      return Profile(p0, p1.get(), p2, p3.get());
  }), () )
};

/// Represents a dependent template name that cannot be
/// resolved prior to template instantiation.
///
/// This kind of template name refers to a dependent template name,
/// including its nested name specifier (if any). For example,
/// DependentTemplateName can refer to "MetaFun::template apply",
/// where "MetaFun::" is the nested name specifier and "apply" is the
/// template name referenced. The "template" keyword is implied.
M_template_rtpack(Xs)
struct clang::DependentTemplateName::impl : impl_offset_t<llvm::FoldingSetBase::Node, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DependentTemplateName;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DependentTemplateName::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Return the nested name specifier that qualifies this name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentTemplateName, reflenums::clang__DependentTemplateName::getQualifier, Xs...); }) , (;) )
  /// Determine whether this template name refers to an identifier.
  constexpr bool isIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentTemplateName, reflenums::clang__DependentTemplateName::isIdentifier, Xs...); }) , (;) )
  /// Returns the identifier to which this template name refers.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::IdentifierInfo *) )
  getIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentTemplateName, reflenums::clang__DependentTemplateName::getIdentifier, Xs...); }) , (;) )
  /// Determine whether this template name refers to an overloaded
  /// operator.
  constexpr bool isOverloadedOperator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentTemplateName, reflenums::clang__DependentTemplateName::isOverloadedOperator, Xs...); }) , (;) )
  /// Return the overloaded operator to which this template name refers.
  constexpr enum clang::OverloadedOperatorKind getOperator() const IFMETA_ELSE( ({    return (enum clang::OverloadedOperatorKind)__reflect_prop(reflenums::RK_clang__DependentTemplateName, reflenums::clang__DependentTemplateName::getOperator, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::NestedNameSpecifier *)) NNS, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y2s...> *), (const typename meta::clang::IdentifierInfo *)) Identifier) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DependentTemplateName, reflenums::clang__DependentTemplateName::Profile, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr void Profile(Y0 p0, ptrwrp<Y1> p1, ptrwrp<Y2> p2) {
      return Profile(p0, p1.get(), p2.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::NestedNameSpecifier *)) NNS, enum clang::OverloadedOperatorKind Operator) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DependentTemplateName, reflenums::clang__DependentTemplateName::Profile1, Xs..., Y0s..., Y1s..., Operator); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  static constexpr void Profile(Y0 p0, ptrwrp<Y1> p1, enum clang::OverloadedOperatorKind p2) {
      return Profile(p0, p1.get(), p2);
  }), () )
};

/// Defines the address space values used by the address space qualifier
/// of QualType.
///
enum class clang::LangAS : unsigned int {
  Default = 0,
  opencl_global,
  opencl_local,
  opencl_constant,
  opencl_private,
  opencl_generic,
  cuda_device,
  cuda_constant,
  cuda_shared,
  FirstTargetAddressSpace,
};

/// The various types of exception specifications that exist in C++11.
enum clang::ExceptionSpecificationType : unsigned int {
  ///< no exception specification
  EST_None,
  ///< throw()
  EST_DynamicNone,
  ///< throw(T1, T2)
  EST_Dynamic,
  ///< Microsoft throw(...) extension
  EST_MSAny,
  ///< noexcept
  EST_BasicNoexcept,
  ///< noexcept(expression), value-dependent
  EST_DependentNoexcept,
  ///< noexcept(expression), evals to 'false'
  EST_NoexceptFalse,
  ///< noexcept(expression), evals to 'true'
  EST_NoexceptTrue,
  ///< not evaluated yet, for special member function
  EST_Unevaluated,
  ///< not instantiated yet
  EST_Uninstantiated,
  ///< not parsed yet
  EST_Unparsed,
};

/// Possible results from evaluation of a noexcept expression.
enum clang::CanThrowResult : unsigned int {
  CT_Cannot,
  CT_Dependent,
  CT_Can,
};

/// Describes the different kinds of linkage
/// (C++ [basic.link], C99 6.2.2) that an entity may have.
enum clang::Linkage : unsigned char {
  /// No linkage, which means that the entity is unique and
  /// can only be referred to from within its scope.
  NoLinkage = 0,
  /// Internal linkage, which indicates that the entity can
  /// be referred to from within the translation unit (but not other
  /// translation units).
  InternalLinkage,
  /// External linkage within a unique namespace.
  ///
  /// From the language perspective, these entities have external
  /// linkage. However, since they reside in an anonymous namespace,
  /// their names are unique to this translation unit, which is
  /// equivalent to having internal linkage from the code-generation
  /// point of view.
  UniqueExternalLinkage,
  /// No linkage according to the standard, but is visible from other
  /// translation units because of types defined in a inline function.
  VisibleNoLinkage,
  /// Internal linkage according to the Modules TS, but can be referred
  /// to from other translation units indirectly through inline functions and
  /// templates in the module interface.
  ModuleInternalLinkage,
  /// Module linkage, which indicates that the entity can be referred
  /// to from other translation units within the same module, and indirectly
  /// from arbitrary other translation units through inline functions and
  /// templates in the module interface.
  ModuleLinkage,
  /// External linkage, which indicates that the entity can
  /// be referred to from other translation units.
  ExternalLinkage,
};

/// Describes the different kinds of language linkage
/// (C++ [dcl.link]) that an entity may have.
enum clang::LanguageLinkage : unsigned int {
  CLanguageLinkage,
  CXXLanguageLinkage,
  NoLanguageLinkage,
};

/// A more specific kind of linkage than enum Linkage.
///
/// This is relevant to CodeGen and AST file reading.
enum clang::GVALinkage : unsigned int {
  GVA_Internal,
  GVA_AvailableExternally,
  GVA_DiscardableODR,
  GVA_StrongExternal,
  GVA_StrongODR,
};

/// Describes the different kinds of visibility that a declaration
/// may have.
///
/// Visibility determines how a declaration interacts with the dynamic
/// linker.  It may also affect whether the symbol can be found by runtime
/// symbol lookup APIs.
///
/// Visibility is not described in any language standard and
/// (nonetheless) sometimes has odd behavior.  Not all platforms
/// support all visibility kinds.
enum clang::Visibility : unsigned int {
  /// Objects with "hidden" visibility are not seen by the dynamic
  /// linker.
  HiddenVisibility,
  /// Objects with "protected" visibility are seen by the dynamic
  /// linker but always dynamically resolve to an object within this
  /// shared object.
  ProtectedVisibility,
  /// Objects with "default" visibility are seen by the dynamic linker
  /// and act like normal objects.
  DefaultVisibility,
};

M_template_rtpack(Xs)
struct clang::LinkageInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__LinkageInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::LinkageInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LinkageInfo) )
  external() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageInfo, reflenums::clang__LinkageInfo::external, Xs...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LinkageInfo) )
  internal() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageInfo, reflenums::clang__LinkageInfo::internal, Xs...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LinkageInfo) )
  uniqueExternal() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageInfo, reflenums::clang__LinkageInfo::uniqueExternal, Xs...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LinkageInfo) )
  none() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageInfo, reflenums::clang__LinkageInfo::none, Xs...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LinkageInfo) )
  visible_none() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageInfo, reflenums::clang__LinkageInfo::visible_none, Xs...); }) , (;) )
  constexpr enum clang::Linkage getLinkage() const IFMETA_ELSE( ({    return (enum clang::Linkage)__reflect_prop(reflenums::RK_clang__LinkageInfo, reflenums::clang__LinkageInfo::getLinkage, Xs...); }) , (;) )
  constexpr enum clang::Visibility getVisibility() const IFMETA_ELSE( ({    return (enum clang::Visibility)__reflect_prop(reflenums::RK_clang__LinkageInfo, reflenums::clang__LinkageInfo::getVisibility, Xs...); }) , (;) )
  constexpr bool isVisibilityExplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageInfo, reflenums::clang__LinkageInfo::isVisibilityExplicit, Xs...); }) , (;) )
};

enum clang::Qualifiers::GC : unsigned int {
  GCNone = 0,
  Weak,
  Strong,
};

enum clang::Qualifiers::ObjCLifetime : unsigned int {
  /// There is no lifetime qualification on this type.
  OCL_None,
  /// This object can be modified without requiring retains or
  /// releases.
  OCL_ExplicitNone,
  /// Assigning into this object requires the old value to be
  /// released and the new value to be retained.  The timing of the
  /// release of the old value is inexact: it may be moved to
  /// immediately after the last known point where the value is
  /// live.
  OCL_Strong,
  /// Reading or writing from this object requires a barrier call.
  OCL_Weak,
  /// Assigning into this object requires a lifetime extension.
  OCL_Autoreleasing,
};

/// The collection of all-type qualifiers we support.
/// Clang supports five independent qualifiers:
/// * C99: const, volatile, and restrict
/// * MS: __unaligned
/// * Embedded C (TR18037): address spaces
/// * Objective C: the GC attributes (none, weak, or strong)
M_template_rtpack(Xs)
struct clang::Qualifiers::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Qualifiers;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Qualifiers::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using GC = enum refldetail::clang::Qualifiers::GC;
  using ObjCLifetime = enum refldetail::clang::Qualifiers::ObjCLifetime;
  /// Returns the common set of qualifiers while removing them from
  /// the given sets.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::Qualifiers) )
  removeCommonQualifiers(IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::Qualifiers &)) L, IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/1, Y1s...>), (typename meta::clang::Qualifiers &)) R) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::removeCommonQualifiers, Xs..., Y0s..., Y1s...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::Qualifiers) )
  fromFastMask(unsigned int Mask) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::fromFastMask, Xs..., Mask); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::Qualifiers) )
  fromCVRMask(unsigned int CVR) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::fromCVRMask, Xs..., CVR); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::Qualifiers) )
  fromCVRUMask(unsigned int CVRU) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::fromCVRUMask, Xs..., CVRU); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::Qualifiers) )
  fromOpaqueValue(unsigned int opaque) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::fromOpaqueValue, Xs..., opaque); }) , (;) )
  constexpr unsigned int getAsOpaqueValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::getAsOpaqueValue, Xs...); }) , (;) )
  constexpr bool hasConst() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasConst, Xs...); }) , (;) )
  constexpr bool hasVolatile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasVolatile, Xs...); }) , (;) )
  constexpr bool hasRestrict() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasRestrict, Xs...); }) , (;) )
  constexpr bool hasCVRQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasCVRQualifiers, Xs...); }) , (;) )
  constexpr unsigned int getCVRQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::getCVRQualifiers, Xs...); }) , (;) )
  constexpr bool hasUnaligned() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasUnaligned, Xs...); }) , (;) )
  constexpr bool hasObjCGCAttr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasObjCGCAttr, Xs...); }) , (;) )
  constexpr enum clang::Qualifiers::GC getObjCGCAttr() const IFMETA_ELSE( ({    return (enum clang::Qualifiers::GC)__reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::getObjCGCAttr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Qualifiers) )
  withoutObjCGCAttr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::withoutObjCGCAttr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Qualifiers) )
  withoutObjCLifetime() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::withoutObjCLifetime, Xs...); }) , (;) )
  constexpr bool hasObjCLifetime() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasObjCLifetime, Xs...); }) , (;) )
  constexpr enum clang::Qualifiers::ObjCLifetime getObjCLifetime() const IFMETA_ELSE( ({    return (enum clang::Qualifiers::ObjCLifetime)__reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::getObjCLifetime, Xs...); }) , (;) )
  /// True if the lifetime is neither None or ExplicitNone.
  constexpr bool hasNonTrivialObjCLifetime() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasNonTrivialObjCLifetime, Xs...); }) , (;) )
  /// True if the lifetime is either strong or weak.
  constexpr bool hasStrongOrWeakObjCLifetime() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasStrongOrWeakObjCLifetime, Xs...); }) , (;) )
  constexpr bool hasAddressSpace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasAddressSpace, Xs...); }) , (;) )
  constexpr enum clang::LangAS getAddressSpace() const IFMETA_ELSE( ({    return (enum clang::LangAS)__reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::getAddressSpace, Xs...); }) , (;) )
  constexpr bool hasTargetSpecificAddressSpace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasTargetSpecificAddressSpace, Xs...); }) , (;) )
  /// Get the address space attribute value to be printed by diagnostics.
  constexpr unsigned int getAddressSpaceAttributePrintValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::getAddressSpaceAttributePrintValue, Xs...); }) , (;) )
  constexpr bool hasFastQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasFastQualifiers, Xs...); }) , (;) )
  constexpr unsigned int getFastQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::getFastQualifiers, Xs...); }) , (;) )
  /// Return true if the set contains any qualifiers which require an ExtQuals
  /// node to be allocated.
  constexpr bool hasNonFastQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasNonFastQualifiers, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Qualifiers) )
  getNonFastQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::getNonFastQualifiers, Xs...); }) , (;) )
  /// Return true if the set contains any qualifiers.
  constexpr bool hasQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::hasQualifiers, Xs...); }) , (;) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::empty, Xs...); }) , (;) )
  /// Returns true if this address space is a superset of the other one.
  /// OpenCL v2.0 defines conversion rules (OpenCLC v2.0 s6.5.5) and notion of
  /// overlapping address spaces.
  /// CL1.1 or CL1.2:
  ///   every address space is a superset of itself.
  /// CL2.0 adds:
  ///   __generic is a superset of any address space except for __constant.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isAddressSpaceSupersetOf(IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Qualifiers)) other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::isAddressSpaceSupersetOf, Xs..., Y0s...); }) , (;) )
  /// Determines if these qualifiers compatibly include another set.
  /// Generally this answers the question of whether an object with the other
  /// qualifiers can be safely used as an object with these qualifiers.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool compatiblyIncludes(IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Qualifiers)) other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::compatiblyIncludes, Xs..., Y0s...); }) , (;) )
  /// Determines if these qualifiers compatibly include another set of
  /// qualifiers from the narrow perspective of Objective-C ARC lifetime.
  ///
  /// One set of Objective-C lifetime qualifiers compatibly includes the other
  /// if the lifetime qualifiers match, or if both are non-__weak and the
  /// including set also contains the 'const' qualifier, or both are non-__weak
  /// and one is None (which can only happen in non-ARC modes).
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool compatiblyIncludesObjCLifetime(IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Qualifiers)) other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::compatiblyIncludesObjCLifetime, Xs..., Y0s...); }) , (;) )
  /// Determine whether this set of qualifiers is a strict superset of
  /// another set of qualifiers, not considering qualifier compatibility.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isStrictSupersetOf(IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Qualifiers)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::isStrictSupersetOf, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Qualifiers)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Qualifiers)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::operator_not_eq, Xs..., Y0s...); }) , (;) )
  constexpr explicit operator bool() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::operator_bool, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr IFMETA_ELSE( (auto), (typename meta::clang::Qualifiers) )
  operator+(IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Qualifiers)) L, IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Qualifiers)) R) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::operator_plus, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Compute the difference between two qualifier sets.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr IFMETA_ELSE( (auto), (typename meta::clang::Qualifiers) )
  operator-(IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Qualifiers)) L, IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Qualifiers)) R) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::operator_minus, Xs..., Y0s..., Y1s...); }) , (;) )
  constexpr const char * getAsString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::getAsString, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * getAsString(IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::PrintingPolicy &)) Policy) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::getAsString1, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isEmptyWhenPrinted(IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::PrintingPolicy &)) Policy) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::isEmptyWhenPrinted, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void print(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy, bool appendSpaceIfNonEmpty = false) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::print, Xs..., Y0s..., Y1s..., appendSpaceIfNonEmpty); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Qualifiers, reflenums::clang__Qualifiers::Profile, Xs..., Y0s...); }) , (;) )
  static const unsigned int UMask = 8u;
  static const unsigned int UShift = 3u;
  static const unsigned int GCAttrMask = 48u;
  static const unsigned int GCAttrShift = 4u;
  static const unsigned int LifetimeMask = 448u;
  static const unsigned int LifetimeShift = 6u;
  static const unsigned int AddressSpaceMask = 4294966784u;
  static const unsigned int AddressSpaceShift = 9u;
};

/// A std::pair-like structure for storing a qualified type split
/// into its local qualifiers and its locally-unqualified type.
M_template_rtpack(Xs)
struct clang::SplitQualType::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SplitQualType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SplitQualType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// The locally-unqualified type.
  M_REFLTYPED_FIELD(Ty, (const typename meta::clang::Type *), __reflect_prop(reflenums::RK_clang__SplitQualType, reflenums::clang__SplitQualType::Ty, Xs...))
  /// The local qualifiers.
  M_REFLTYPED_FIELD(Quals, (typename meta::clang::Qualifiers), __reflect_prop(reflenums::RK_clang__SplitQualType, reflenums::clang__SplitQualType::Quals, Xs...))
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SplitQualType) )
  getSingleStepDesugaredType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SplitQualType, reflenums::clang__SplitQualType::getSingleStepDesugaredType, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator==(IFMETA_ELSE((const clang::SplitQualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SplitQualType)) a, IFMETA_ELSE((const clang::SplitQualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SplitQualType)) b) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SplitQualType, reflenums::clang__SplitQualType::operator_eq_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator!=(IFMETA_ELSE((const clang::SplitQualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SplitQualType)) a, IFMETA_ELSE((const clang::SplitQualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SplitQualType)) b) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SplitQualType, reflenums::clang__SplitQualType::operator_not_eq, Xs..., Y0s..., Y1s...); }) , (;) )
};

/// The kind of type we are substituting Objective-C type arguments into.
///
/// The kind of substitution affects the replacement of type parameters when
/// no concrete type information is provided, e.g., when dealing with an
/// unspecialized type.
enum class clang::ObjCSubstitutionContext : int {
  /// An ordinary type.
  Ordinary,
  /// The result type of a method or function.
  Result,
  /// The parameter type of a method or function.
  Parameter,
  /// The type of a property.
  Property,
  /// The superclass of a type.
  Superclass,
};

enum clang::QualType::PrimitiveDefaultInitializeKind : unsigned int {
  /// The type does not fall into any of the following categories. Note that
  /// this case is zero-valued so that values of this enum can be used as a
  /// boolean condition for non-triviality.
  PDIK_Trivial,
  /// The type is an Objective-C retainable pointer type that is qualified
  /// with the ARC __strong qualifier.
  PDIK_ARCStrong,
  /// The type is an Objective-C retainable pointer type that is qualified
  /// with the ARC __weak qualifier.
  PDIK_ARCWeak,
  /// The type is a struct containing a field whose type is not PCK_Trivial.
  PDIK_Struct,
};

enum clang::QualType::PrimitiveCopyKind : unsigned int {
  /// The type does not fall into any of the following categories. Note that
  /// this case is zero-valued so that values of this enum can be used as a
  /// boolean condition for non-triviality.
  PCK_Trivial,
  /// The type would be trivial except that it is volatile-qualified. Types
  /// that fall into one of the other non-trivial cases may additionally be
  /// volatile-qualified.
  PCK_VolatileTrivial,
  /// The type is an Objective-C retainable pointer type that is qualified
  /// with the ARC __strong qualifier.
  PCK_ARCStrong,
  /// The type is an Objective-C retainable pointer type that is qualified
  /// with the ARC __weak qualifier.
  PCK_ARCWeak,
  /// The type is a struct containing a field whose type is neither
  /// PCK_Trivial nor PCK_VolatileTrivial.
  /// Note that a C++ struct type does not necessarily match this; C++ copying
  /// semantics are too complex to express here, in part because they depend
  /// on the exact constructor or assignment operator that is chosen by
  /// overload resolution to do the copy.
  PCK_Struct,
};

enum clang::QualType::DestructionKind : unsigned int {
  DK_none,
  DK_cxx_destructor,
  DK_objc_strong_lifetime,
  DK_objc_weak_lifetime,
  DK_nontrivial_c_struct,
};

/// A (possibly-)qualified type.
///
/// For efficiency, we don't store CV-qualified types as nodes on their
/// own: instead each reference to a type stores the qualifiers.  This
/// greatly reduces the number of nodes we need to allocate for types (for
/// example we only need one for 'int', 'const int', 'volatile int',
/// 'const volatile int', etc).
///
/// As an added efficiency bonus, instead of making this a pair, we
/// just store the two bits we care about in the low bits of the
/// pointer.  To handle the packing/unpacking, we make QualType be a
/// simple wrapper class that acts like a smart pointer.  A third bit
/// indicates whether there are extended qualifiers present, in which
/// case the pointer points to a special structure.
M_template_rtpack(Xs)
struct clang::QualType::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__QualType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::QualType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr unsigned int getLocalFastQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getLocalFastQualifiers, Xs...); }) , (;) )
  /// Retrieves a pointer to the underlying (unqualified) type.
  ///
  /// This function requires that the type not be NULL. If the type might be
  /// NULL, use the (slightly less efficient) \c getTypePtrOrNull().
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getTypePtr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getTypePtr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getTypePtrOrNull() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getTypePtrOrNull, Xs...); }) , (;) )
  /// Retrieves a pointer to the name of the base type.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::IdentifierInfo *) )
  getBaseTypeIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getBaseTypeIdentifier, Xs...); }) , (;) )
  /// Divides a QualType into its unqualified type and a set of local
  /// qualifiers.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SplitQualType) )
  split() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::split, Xs...); }) , (;) )
  constexpr void * getAsOpaquePtr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getAsOpaquePtr, Xs...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getFromOpaquePtr(const void * Ptr) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getFromOpaquePtr, Xs..., Ptr); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type &) )
  operator*() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::operator_star, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  operator->() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::operator_arrow, Xs...); }) , (;) )
  constexpr bool isCanonical() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isCanonical, Xs...); }) , (;) )
  constexpr bool isCanonicalAsParam() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isCanonicalAsParam, Xs...); }) , (;) )
  /// Return true if this QualType doesn't point to a type yet.
  constexpr bool isNull() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isNull, Xs...); }) , (;) )
  /// Determine whether this particular QualType instance has the
  /// "const" qualifier set, without looking through typedefs that may have
  /// added "const" at a different level.
  constexpr bool isLocalConstQualified() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isLocalConstQualified, Xs...); }) , (;) )
  /// Determine whether this type is const-qualified.
  constexpr bool isConstQualified() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isConstQualified, Xs...); }) , (;) )
  /// Determine whether this particular QualType instance has the
  /// "restrict" qualifier set, without looking through typedefs that may have
  /// added "restrict" at a different level.
  constexpr bool isLocalRestrictQualified() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isLocalRestrictQualified, Xs...); }) , (;) )
  /// Determine whether this type is restrict-qualified.
  constexpr bool isRestrictQualified() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isRestrictQualified, Xs...); }) , (;) )
  /// Determine whether this particular QualType instance has the
  /// "volatile" qualifier set, without looking through typedefs that may have
  /// added "volatile" at a different level.
  constexpr bool isLocalVolatileQualified() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isLocalVolatileQualified, Xs...); }) , (;) )
  /// Determine whether this type is volatile-qualified.
  constexpr bool isVolatileQualified() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isVolatileQualified, Xs...); }) , (;) )
  /// Determine whether this particular QualType instance has any
  /// qualifiers, without looking through any typedefs that might add
  /// qualifiers at a different level.
  constexpr bool hasLocalQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::hasLocalQualifiers, Xs...); }) , (;) )
  /// Determine whether this type has any qualifiers.
  constexpr bool hasQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::hasQualifiers, Xs...); }) , (;) )
  /// Determine whether this particular QualType instance has any
  /// "non-fast" qualifiers, e.g., those that are stored in an ExtQualType
  /// instance.
  constexpr bool hasLocalNonFastQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::hasLocalNonFastQualifiers, Xs...); }) , (;) )
  /// Retrieve the set of qualifiers local to this particular QualType
  /// instance, not including any qualifiers acquired through typedefs or
  /// other sugar.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Qualifiers) )
  getLocalQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getLocalQualifiers, Xs...); }) , (;) )
  /// Retrieve the set of qualifiers applied to this type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Qualifiers) )
  getQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getQualifiers, Xs...); }) , (;) )
  /// Retrieve the set of CVR (const-volatile-restrict) qualifiers
  /// local to this particular QualType instance, not including any qualifiers
  /// acquired through typedefs or other sugar.
  constexpr unsigned int getLocalCVRQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getLocalCVRQualifiers, Xs...); }) , (;) )
  /// Retrieve the set of CVR (const-volatile-restrict) qualifiers
  /// applied to this type.
  constexpr unsigned int getCVRQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getCVRQualifiers, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isConstant(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isConstant, Xs..., Y0s...); }) , (;) )
  /// Determine whether this is a Plain Old Data (POD) type (C++ 3.9p10).
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isPODType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isPODType, Xs..., Y0s...); }) , (;) )
  /// Return true if this is a POD type according to the rules of the C++98
  /// standard, regardless of the current compilation's language.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isCXX98PODType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isCXX98PODType, Xs..., Y0s...); }) , (;) )
  /// Return true if this is a POD type according to the more relaxed rules
  /// of the C++11 standard, regardless of the current compilation's language.
  /// (C++0x [basic.types]p9). Note that, unlike
  /// CXXRecordDecl::isCXX11StandardLayout, this takes DRs into account.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isCXX11PODType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isCXX11PODType, Xs..., Y0s...); }) , (;) )
  /// Return true if this is a trivial type per (C++0x [basic.types]p9)
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isTrivialType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isTrivialType, Xs..., Y0s...); }) , (;) )
  /// Return true if this is a trivially copyable type (C++0x [basic.types]p9)
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isTriviallyCopyableType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isTriviallyCopyableType, Xs..., Y0s...); }) , (;) )
  /// Returns true if it is a class and it might be dynamic.
  constexpr bool mayBeDynamicClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::mayBeDynamicClass, Xs...); }) , (;) )
  /// Returns true if it is not a class or if the class might not be dynamic.
  constexpr bool mayBeNotDynamicClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::mayBeNotDynamicClass, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  withConst() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::withConst, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  withVolatile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::withVolatile, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  withRestrict() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::withRestrict, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  withCVRQualifiers(unsigned int CVR) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::withCVRQualifiers, Xs..., CVR); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  withFastQualifiers(unsigned int TQs) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::withFastQualifiers, Xs..., TQs); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  withExactLocalFastQualifiers(unsigned int TQs) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::withExactLocalFastQualifiers, Xs..., TQs); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  withoutLocalFastQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::withoutLocalFastQualifiers, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getCanonicalType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getCanonicalType, Xs...); }) , (;) )
  /// Return this type with all of the instance-specific qualifiers
  /// removed, but without removing any qualifiers that may have been applied
  /// through typedefs.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getLocalUnqualifiedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getLocalUnqualifiedType, Xs...); }) , (;) )
  /// Retrieve the unqualified variant of the given type,
  /// removing as little sugar as possible.
  ///
  /// This routine looks through various kinds of sugar to find the
  /// least-desugared type that is unqualified. For example, given:
  ///
  /// \code
  /// typedef int Integer;
  /// typedef const Integer CInteger;
  /// typedef CInteger DifferenceType;
  /// \endcode
  ///
  /// Executing \c getUnqualifiedType() on the type \c DifferenceType will
  /// desugar until we hit the type \c Integer, which has no qualifiers on it.
  ///
  /// The resulting type might still be qualified if it's sugar for an array
  /// type.  To strip qualifiers even from within a sugared array type, use
  /// ASTContext::getUnqualifiedArrayType.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getUnqualifiedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getUnqualifiedType, Xs...); }) , (;) )
  /// Retrieve the unqualified variant of the given type, removing as little
  /// sugar as possible.
  ///
  /// Like getUnqualifiedType(), but also returns the set of
  /// qualifiers that were built up.
  ///
  /// The resulting type might still be qualified if it's sugar for an array
  /// type.  To strip qualifiers even from within a sugared array type, use
  /// ASTContext::getUnqualifiedArrayType.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SplitQualType) )
  getSplitUnqualifiedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getSplitUnqualifiedType, Xs...); }) , (;) )
  /// Determine whether this type is more qualified than the other
  /// given type, requiring exact equality for non-CVR qualifiers.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isMoreQualifiedThan(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isMoreQualifiedThan, Xs..., Y0s...); }) , (;) )
  /// Determine whether this type is at least as qualified as the other
  /// given type, requiring exact equality for non-CVR qualifiers.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isAtLeastAsQualifiedAs(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isAtLeastAsQualifiedAs, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getNonReferenceType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getNonReferenceType, Xs...); }) , (;) )
  /// Determine the type of a (typically non-lvalue) expression with the
  /// specified result type.
  ///
  /// This routine should be used for expressions for which the return type is
  /// explicitly specified (e.g., in a cast or call) and isn't necessarily
  /// an lvalue. It removes a top-level reference (since there are no
  /// expressions of reference type) and deletes top-level cvr-qualifiers
  /// from non-class types (in C++) or all types (in C).
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getNonLValueExprType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getNonLValueExprType, Xs..., Y0s...); }) , (;) )
  /// Return the specified type with any "sugar" removed from
  /// the type.  This takes off typedefs, typeof's etc.  If the outer level of
  /// the type is already concrete, it returns it unmodified.  This is similar
  /// to getting the canonical type, but it doesn't remove *all* typedefs.  For
  /// example, it returns "T*" as "T*", (not as "int*"), because the pointer is
  /// concrete.
  ///
  /// Qualifiers are left in place.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDesugaredType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getDesugaredType, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SplitQualType) )
  getSplitDesugaredType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getSplitDesugaredType, Xs...); }) , (;) )
  /// Return the specified type with one level of "sugar" removed from
  /// the type.
  ///
  /// This routine takes off the first typedef, typeof, etc. If the outer level
  /// of the type is already concrete, it returns it unmodified.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getSingleStepDesugaredType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getSingleStepDesugaredType, Xs..., Y0s...); }) , (;) )
  /// Returns the specified type after dropping any
  /// outer-level parentheses.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  IgnoreParens() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::IgnoreParens, Xs...); }) , (;) )
  /// Indicate whether the specified types and qualifiers are identical.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator==(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::QualType &)) LHS, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::QualType &)) RHS) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::operator_eq_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator!=(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::QualType &)) LHS, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::QualType &)) RHS) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::operator_not_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr const char * getAsString(IFMETA_ELSE((const clang::SplitQualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SplitQualType)) split, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getAsString, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr const char * getAsString(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) ty, IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Qualifiers)) qs, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y2s...>), (const typename meta::clang::PrintingPolicy &)) Policy) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getAsString1, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr const char * getAsString(ptrwrp<Y0> p0, Y1 p1, Y2 p2) {
      return getAsString(p0.get(), p1, p2);
  }), () )
  constexpr const char * getAsString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getAsString2, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * getAsString(IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::PrintingPolicy &)) Policy) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getAsString3, Xs..., Y0s...); }) , (;) )
  constexpr const char * getAsString_NoPrependScope() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getAsString_NoPrependScope, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr void print(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy, IFMETA_ELSE((const llvm::Twine::template impl</*ptrorref=*/1, Y2s...>), (const typename meta::llvm::Twine &)) PlaceHolder = {}, unsigned int Indentation = 0) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::print, Xs..., Y0s..., Y1s..., Y2s..., Indentation); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr void print(IFMETA_ELSE((const clang::SplitQualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SplitQualType)) split, IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y1s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y2s...>), (const typename meta::clang::PrintingPolicy &)) policy, IFMETA_ELSE((const llvm::Twine::template impl</*ptrorref=*/1, Y3s...>), (const typename meta::llvm::Twine &)) PlaceHolder, unsigned int Indentation = 0) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::print1, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Indentation); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr void print(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) ty, IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Qualifiers)) qs, IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y2s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y3s...>), (const typename meta::clang::PrintingPolicy &)) policy, IFMETA_ELSE((const llvm::Twine::template impl</*ptrorref=*/1, Y4s...>), (const typename meta::llvm::Twine &)) PlaceHolder, unsigned int Indentation = 0, bool MayAppendScope = true) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::print2, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Indentation, MayAppendScope); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr void print(ptrwrp<Y0> p0, Y1 p1, Y2 p2, Y3 p3, Y4 p4, unsigned int p5 = 0, bool p6 = true) {
      return print(p0.get(), p1, p2, p3, p4, p5, p6);
  }), () )
  constexpr void dump(const char * s) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::dump, Xs..., s); }) , (;) )
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::dump1, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void dump(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::dump2, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::Profile, Xs..., Y0s...); }) , (;) )
  /// Return the address space of this type.
  constexpr enum clang::LangAS getAddressSpace() const IFMETA_ELSE( ({    return (enum clang::LangAS)__reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getAddressSpace, Xs...); }) , (;) )
  /// Returns gc attribute of this type.
  constexpr enum clang::Qualifiers::GC getObjCGCAttr() const IFMETA_ELSE( ({    return (enum clang::Qualifiers::GC)__reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getObjCGCAttr, Xs...); }) , (;) )
  /// true when Type is objc's weak.
  constexpr bool isObjCGCWeak() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isObjCGCWeak, Xs...); }) , (;) )
  /// true when Type is objc's strong.
  constexpr bool isObjCGCStrong() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isObjCGCStrong, Xs...); }) , (;) )
  /// Returns lifetime attribute of this type.
  constexpr enum clang::Qualifiers::ObjCLifetime getObjCLifetime() const IFMETA_ELSE( ({    return (enum clang::Qualifiers::ObjCLifetime)__reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getObjCLifetime, Xs...); }) , (;) )
  constexpr bool hasNonTrivialObjCLifetime() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::hasNonTrivialObjCLifetime, Xs...); }) , (;) )
  constexpr bool hasStrongOrWeakObjCLifetime() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::hasStrongOrWeakObjCLifetime, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isNonWeakInMRRWithObjCWeak(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isNonWeakInMRRWithObjCWeak, Xs..., Y0s...); }) , (;) )
  using PrimitiveDefaultInitializeKind = enum refldetail::clang::QualType::PrimitiveDefaultInitializeKind;
  /// Check if this is a non-trivial type that would cause a C struct
  /// transitively containing this type to be non-trivial to default initialize
  /// and return the kind.
  constexpr enum clang::QualType::PrimitiveDefaultInitializeKind isNonTrivialToPrimitiveDefaultInitialize() const IFMETA_ELSE( ({    return (enum clang::QualType::PrimitiveDefaultInitializeKind)__reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isNonTrivialToPrimitiveDefaultInitialize, Xs...); }) , (;) )
  using PrimitiveCopyKind = enum refldetail::clang::QualType::PrimitiveCopyKind;
  /// Check if this is a non-trivial type that would cause a C struct
  /// transitively containing this type to be non-trivial to copy and return the
  /// kind.
  constexpr enum clang::QualType::PrimitiveCopyKind isNonTrivialToPrimitiveCopy() const IFMETA_ELSE( ({    return (enum clang::QualType::PrimitiveCopyKind)__reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isNonTrivialToPrimitiveCopy, Xs...); }) , (;) )
  /// Check if this is a non-trivial type that would cause a C struct
  /// transitively containing this type to be non-trivial to destructively
  /// move and return the kind. Destructive move in this context is a C++-style
  /// move in which the source object is placed in a valid but unspecified state
  /// after it is moved, as opposed to a truly destructive move in which the
  /// source object is placed in an uninitialized state.
  constexpr enum clang::QualType::PrimitiveCopyKind isNonTrivialToPrimitiveDestructiveMove() const IFMETA_ELSE( ({    return (enum clang::QualType::PrimitiveCopyKind)__reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isNonTrivialToPrimitiveDestructiveMove, Xs...); }) , (;) )
  using DestructionKind = enum refldetail::clang::QualType::DestructionKind;
  /// Returns a nonzero value if objects of this type require
  /// non-trivial work to clean up after.  Non-zero because it's
  /// conceivable that qualifiers (objc_gc(weak)?) could make
  /// something require destruction.
  constexpr enum clang::QualType::DestructionKind isDestructedType() const IFMETA_ELSE( ({    return (enum clang::QualType::DestructionKind)__reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isDestructedType, Xs...); }) , (;) )
  /// Determine whether expressions of the given type are forbidden
  /// from being lvalues in C.
  ///
  /// The expression types that are forbidden to be lvalues are:
  ///   - 'void', but not qualified void
  ///   - function types
  ///
  /// The exact rule here is C99 6.3.2.1:
  ///   An lvalue is an expression with an object type or an incomplete
  ///   type other than void.
  constexpr bool isCForbiddenLValueType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::isCForbiddenLValueType, Xs...); }) , (;) )
  /// Substitute type arguments from an object type for the Objective-C type
  /// parameters used in the subject type.
  ///
  /// This operation combines the computation of type arguments for
  /// substitution (\c Type::getObjCSubstitutions) with the actual process of
  /// substitution (\c QualType::substObjCTypeArgs) for the convenience of
  /// callers that need to perform a single substitution in isolation.
  ///
  /// \param objectType The type of the object whose member type we're
  /// substituting into. For example, this might be the receiver of a message
  /// or the base of a property access.
  ///
  /// \param dc The declaration context from which the subject type was
  /// retrieved, which indicates (for example) which type parameters should
  /// be substituted.
  ///
  /// \param context The context in which the subject type was written.
  ///
  /// \returns the subject type after replacing all of the Objective-C type
  /// parameters with their corresponding arguments.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  substObjCMemberType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) objectType, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::DeclContext *)) dc, enum clang::ObjCSubstitutionContext context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::substObjCMemberType, Xs..., Y0s..., Y1s..., context); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  substObjCMemberType(Y0 p0, ptrwrp<Y1> p1, enum clang::ObjCSubstitutionContext p2) const {
      return substObjCMemberType(p0, p1.get(), p2);
  }), () )
  /// Strip Objective-C "__kindof" types from the given type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  stripObjCKindOfType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::stripObjCKindOfType, Xs..., Y0s...); }) , (;) )
  /// Remove all qualifiers including _Atomic.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAtomicUnqualifiedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__QualType, reflenums::clang__QualType::getAtomicUnqualifiedType, Xs...); }) , (;) )
};

/// Base class that is common to both the \c ExtQuals and \c Type
/// classes, which allows \c QualType to access the common fields between the
/// two.
M_template_rtpack(Xs)
struct clang::ExtQualsTypeCommonBase::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ExtQualsTypeCommonBase;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ExtQualsTypeCommonBase::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
};

/// The kind of C++11 ref-qualifier associated with a function type.
/// This determines whether a member function's "this" object can be an
/// lvalue, rvalue, or neither.
enum clang::RefQualifierKind : unsigned int {
  /// No ref-qualifier was provided.
  RQ_None = 0,
  /// An lvalue ref-qualifier was provided (\c &).
  RQ_LValue,
  /// An rvalue ref-qualifier was provided (\c &&).
  RQ_RValue,
};

/// Which keyword(s) were used to create an AutoType.
enum class clang::AutoTypeKeyword : int {
  /// auto
  Auto,
  /// decltype(auto)
  DecltypeAuto,
  /// __auto_type (GNU extension)
  GNUAutoType,
};

enum clang::Type::TypeClass : unsigned int {
  Builtin,
  Complex,
  Pointer,
  BlockPointer,
  LValueReference,
  RValueReference,
  MemberPointer,
  ConstantArray,
  IncompleteArray,
  VariableArray,
  DependentSizedArray,
  DependentSizedExtVector,
  DependentAddressSpace,
  Vector,
  DependentVector,
  ExtVector,
  FunctionProto,
  FunctionNoProto,
  UnresolvedUsing,
  Paren,
  Typedef,
  Adjusted,
  Decayed,
  TypeOfExpr,
  TypeOf,
  Decltype,
  Reflected,
  UnaryTransform,
  Record,
  Enum,
  Elaborated,
  Attributed,
  TemplateTypeParm,
  SubstTemplateTypeParm,
  SubstTemplateTypeParmPack,
  TemplateSpecialization,
  Auto,
  DeducedTemplateSpecialization,
  InjectedClassName,
  ////END
  DependentName,
  ////END
  DependentTemplateSpecialization,
  ////END
  PackExpansion,
  ////END
  ObjCTypeParam,
  ////END
  ObjCObject,
  ////END
  ObjCInterface,
  ////END
  ObjCObjectPointer,
  ////END
  Pipe,
  ////END
  Atomic,
  ////END
  TypeLast = 47,
  ////END
  TagFirst = 28,
  ////END
  TagLast = 29,
};

enum clang::Type::ScalarTypeKind : unsigned int {
  STK_CPointer,
  STK_BlockPointer,
  STK_ObjCObjectPointer,
  STK_MemberPointer,
  STK_Bool,
  STK_Integral,
  STK_Floating,
  STK_IntegralComplex,
  STK_FloatingComplex,
};

/// The base class of the type hierarchy.
///
/// A central concept with types is that each type always has a canonical
/// type.  A canonical type is the type with any typedef names stripped out
/// of it or the types it references.  For example, consider:
///
///  typedef int  foo;
///  typedef foo* bar;
///    'int *'    'foo *'    'bar'
///
/// There will be a Type object created for 'int'.  Since int is canonical, its
/// CanonicalType pointer points to itself.  There is also a Type for 'foo' (a
/// TypedefType).  Its CanonicalType pointer points to the 'int' Type.  Next
/// there is a PointerType that represents 'int*', which, like 'int', is
/// canonical.  Finally, there is a PointerType type for 'foo*' whose canonical
/// type is 'int*', and there is a TypedefType for 'bar', whose canonical type
/// is also 'int*'.
///
/// Non-canonical types are useful for emitting diagnostics, without losing
/// information about typedefs being used.  Canonical types are useful for type
/// comparisons (they allow by-pointer equality tests) and useful for reasoning
/// about whether something has a particular form (e.g. is a function type),
/// because they implicitly, recursively, strip all typedefs out of a type.
///
/// Types, once created, are immutable.
///
M_template_rtpack(Xs)
struct clang::Type::impl : impl_offset_t<clang::ExtQualsTypeCommonBase, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Type;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Type::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using TypeClass = enum refldetail::clang::Type::TypeClass;
  constexpr enum clang::Type::TypeClass getTypeClass() const IFMETA_ELSE( ({    return (enum clang::Type::TypeClass)__reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getTypeClass, Xs...); }) , (;) )
  /// Whether this type comes from an AST file.
  constexpr bool isFromAST() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isFromAST, Xs...); }) , (;) )
  /// Whether this type is or contains an unexpanded parameter
  /// pack, used to support C++0x variadic templates.
  ///
  /// A type that contains a parameter pack shall be expanded by the
  /// ellipsis operator at some point. For example, the typedef in the
  /// following example contains an unexpanded parameter pack 'T':
  ///
  /// \code
  /// template<typename ...T>
  /// struct X {
  ///   typedef T* pointer_types; // ill-formed; T is a parameter pack.
  /// };
  /// \endcode
  ///
  /// Note that this routine does not specify which
  constexpr bool containsUnexpandedParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::containsUnexpandedParameterPack, Xs...); }) , (;) )
  /// Determines if this type would be canonical if it had no further
  /// qualification.
  constexpr bool isCanonicalUnqualified() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isCanonicalUnqualified, Xs...); }) , (;) )
  /// Pull a single level of sugar off of this locally-unqualified type.
  /// Users should generally prefer SplitQualType::getSingleStepDesugaredType()
  /// or QualType::getSingleStepDesugaredType(const ASTContext&).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getLocallyUnqualifiedSingleStepDesugaredType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getLocallyUnqualifiedSingleStepDesugaredType, Xs...); }) , (;) )
  /// Return true if this is an incomplete type.
  /// A type that can describe objects, but which lacks information needed to
  /// determine its size (e.g. void, or a fwd declared struct). Clients of this
  /// routine will need to determine if the size is actually required.
  ///
  /// Def If non-null, and the type refers to some kind of declaration
  /// that can be completed (such as a C struct, C++ class, or Objective-C
  /// class), will be set to the declaration.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isIncompleteType(IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y0s...> * *), (typename meta::clang::NamedDecl **)) Def = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isIncompleteType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isIncompleteType(ptrwrp<Y0> p0 = {}) const {
      return isIncompleteType(p0.get());
  }), () )
  /// Return true if this is an incomplete or object
  /// type, in other words, not a function type.
  constexpr bool isIncompleteOrObjectType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isIncompleteOrObjectType, Xs...); }) , (;) )
  /// Determine whether this type is an object type.
  constexpr bool isObjectType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjectType, Xs...); }) , (;) )
  /// Return true if this is a literal type
  /// (C++11 [basic.types]p10)
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isLiteralType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isLiteralType, Xs..., Y0s...); }) , (;) )
  /// Test if this type is a standard-layout type.
  /// (C++0x [basic.type]p9)
  constexpr bool isStandardLayoutType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isStandardLayoutType, Xs...); }) , (;) )
  /// Returns true if the type is a builtin type.
  constexpr bool isBuiltinType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isBuiltinType, Xs...); }) , (;) )
  /// Test for a particular builtin type.
  constexpr bool isSpecificBuiltinType(unsigned int K) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isSpecificBuiltinType, Xs..., K); }) , (;) )
  /// Test for a type which does not represent an actual type-system type but
  /// is instead used as a placeholder for various convenient purposes within
  /// Clang.  All such types are BuiltinTypes.
  constexpr bool isPlaceholderType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isPlaceholderType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::BuiltinType *) )
  getAsPlaceholderType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getAsPlaceholderType, Xs...); }) , (;) )
  /// Test for a specific placeholder type.
  constexpr bool isSpecificPlaceholderType(unsigned int K) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isSpecificPlaceholderType, Xs..., K); }) , (;) )
  /// Test for a placeholder type other than Overload; see
  /// BuiltinType::isNonOverloadPlaceholderType.
  constexpr bool isNonOverloadPlaceholderType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isNonOverloadPlaceholderType, Xs...); }) , (;) )
  /// isIntegerType() does *not* include complex integers (a GCC extension).
  /// isComplexIntegerType() can be used to test for complex integers.
  constexpr bool isIntegerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isIntegerType, Xs...); }) , (;) )
  constexpr bool isEnumeralType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isEnumeralType, Xs...); }) , (;) )
  /// Determine whether this type is a scoped enumeration type.
  constexpr bool isScopedEnumeralType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isScopedEnumeralType, Xs...); }) , (;) )
  constexpr bool isBooleanType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isBooleanType, Xs...); }) , (;) )
  constexpr bool isCharType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isCharType, Xs...); }) , (;) )
  constexpr bool isWideCharType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isWideCharType, Xs...); }) , (;) )
  constexpr bool isChar8Type() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isChar8Type, Xs...); }) , (;) )
  constexpr bool isChar16Type() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isChar16Type, Xs...); }) , (;) )
  constexpr bool isChar32Type() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isChar32Type, Xs...); }) , (;) )
  constexpr bool isAnyCharacterType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isAnyCharacterType, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isIntegralType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isIntegralType, Xs..., Y0s...); }) , (;) )
  /// Determine whether this type is an integral or enumeration type.
  constexpr bool isIntegralOrEnumerationType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isIntegralOrEnumerationType, Xs...); }) , (;) )
  /// Determine whether this type is an integral or unscoped enumeration type.
  constexpr bool isIntegralOrUnscopedEnumerationType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isIntegralOrUnscopedEnumerationType, Xs...); }) , (;) )
  /// Floating point categories.
  constexpr bool isRealFloatingType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isRealFloatingType, Xs...); }) , (;) )
  /// isComplexType() does *not* include complex integers (a GCC extension).
  /// isComplexIntegerType() can be used to test for complex integers.
  constexpr bool isComplexType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isComplexType, Xs...); }) , (;) )
  constexpr bool isAnyComplexType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isAnyComplexType, Xs...); }) , (;) )
  constexpr bool isFloatingType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isFloatingType, Xs...); }) , (;) )
  constexpr bool isHalfType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isHalfType, Xs...); }) , (;) )
  constexpr bool isFloat16Type() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isFloat16Type, Xs...); }) , (;) )
  constexpr bool isFloat128Type() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isFloat128Type, Xs...); }) , (;) )
  constexpr bool isRealType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isRealType, Xs...); }) , (;) )
  constexpr bool isArithmeticType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isArithmeticType, Xs...); }) , (;) )
  constexpr bool isVoidType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isVoidType, Xs...); }) , (;) )
  constexpr bool isScalarType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isScalarType, Xs...); }) , (;) )
  constexpr bool isAggregateType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isAggregateType, Xs...); }) , (;) )
  constexpr bool isFundamentalType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isFundamentalType, Xs...); }) , (;) )
  constexpr bool isCompoundType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isCompoundType, Xs...); }) , (;) )
  constexpr bool isFunctionType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isFunctionType, Xs...); }) , (;) )
  constexpr bool isFunctionNoProtoType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isFunctionNoProtoType, Xs...); }) , (;) )
  constexpr bool isFunctionProtoType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isFunctionProtoType, Xs...); }) , (;) )
  constexpr bool isPointerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isPointerType, Xs...); }) , (;) )
  constexpr bool isAnyPointerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isAnyPointerType, Xs...); }) , (;) )
  constexpr bool isBlockPointerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isBlockPointerType, Xs...); }) , (;) )
  constexpr bool isVoidPointerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isVoidPointerType, Xs...); }) , (;) )
  constexpr bool isReferenceType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isReferenceType, Xs...); }) , (;) )
  constexpr bool isLValueReferenceType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isLValueReferenceType, Xs...); }) , (;) )
  constexpr bool isRValueReferenceType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isRValueReferenceType, Xs...); }) , (;) )
  constexpr bool isFunctionPointerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isFunctionPointerType, Xs...); }) , (;) )
  constexpr bool isMemberPointerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isMemberPointerType, Xs...); }) , (;) )
  constexpr bool isMemberFunctionPointerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isMemberFunctionPointerType, Xs...); }) , (;) )
  constexpr bool isMemberDataPointerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isMemberDataPointerType, Xs...); }) , (;) )
  constexpr bool isArrayType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isArrayType, Xs...); }) , (;) )
  constexpr bool isConstantArrayType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isConstantArrayType, Xs...); }) , (;) )
  constexpr bool isIncompleteArrayType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isIncompleteArrayType, Xs...); }) , (;) )
  constexpr bool isVariableArrayType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isVariableArrayType, Xs...); }) , (;) )
  constexpr bool isDependentSizedArrayType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isDependentSizedArrayType, Xs...); }) , (;) )
  constexpr bool isRecordType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isRecordType, Xs...); }) , (;) )
  constexpr bool isClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isClassType, Xs...); }) , (;) )
  constexpr bool isStructureType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isStructureType, Xs...); }) , (;) )
  constexpr bool isObjCBoxableRecordType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCBoxableRecordType, Xs...); }) , (;) )
  constexpr bool isInterfaceType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isInterfaceType, Xs...); }) , (;) )
  constexpr bool isStructureOrClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isStructureOrClassType, Xs...); }) , (;) )
  constexpr bool isUnionType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isUnionType, Xs...); }) , (;) )
  constexpr bool isReflectedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isReflectedType, Xs...); }) , (;) )
  constexpr bool isComplexIntegerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isComplexIntegerType, Xs...); }) , (;) )
  constexpr bool isVectorType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isVectorType, Xs...); }) , (;) )
  constexpr bool isExtVectorType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isExtVectorType, Xs...); }) , (;) )
  constexpr bool isDependentAddressSpaceType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isDependentAddressSpaceType, Xs...); }) , (;) )
  constexpr bool isObjCObjectPointerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCObjectPointerType, Xs...); }) , (;) )
  constexpr bool isObjCRetainableType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCRetainableType, Xs...); }) , (;) )
  constexpr bool isObjCLifetimeType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCLifetimeType, Xs...); }) , (;) )
  constexpr bool isObjCIndirectLifetimeType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCIndirectLifetimeType, Xs...); }) , (;) )
  constexpr bool isObjCNSObjectType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCNSObjectType, Xs...); }) , (;) )
  constexpr bool isObjCIndependentClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCIndependentClassType, Xs...); }) , (;) )
  constexpr bool isObjCObjectType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCObjectType, Xs...); }) , (;) )
  constexpr bool isObjCQualifiedInterfaceType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCQualifiedInterfaceType, Xs...); }) , (;) )
  constexpr bool isObjCQualifiedIdType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCQualifiedIdType, Xs...); }) , (;) )
  constexpr bool isObjCQualifiedClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCQualifiedClassType, Xs...); }) , (;) )
  constexpr bool isObjCObjectOrInterfaceType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCObjectOrInterfaceType, Xs...); }) , (;) )
  constexpr bool isObjCIdType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCIdType, Xs...); }) , (;) )
  constexpr bool isObjCInertUnsafeUnretainedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCInertUnsafeUnretainedType, Xs...); }) , (;) )
  /// Whether the type is Objective-C 'id' or a __kindof type of an
  /// object type, e.g., __kindof NSView * or __kindof id
  /// <NSCopying>.
  ///
  /// \param bound Will be set to the bound on non-id subtype types,
  /// which will be (possibly specialized) Objective-C class type, or
  /// null for 'id.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isObjCIdOrObjectKindOfType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) ctx, IFMETA_ELSE((const clang::ObjCObjectType::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ObjCObjectType *&)) bound) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCIdOrObjectKindOfType, Xs..., Y0s..., Y1s...); }) , (;) )
  constexpr bool isObjCClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCClassType, Xs...); }) , (;) )
  /// Whether the type is Objective-C 'Class' or a __kindof type of an
  /// Class type, e.g., __kindof Class <NSCopying>.
  ///
  /// Unlike \c isObjCIdOrObjectKindOfType, there is no relevant bound
  /// here because Objective-C's type system cannot express "a class
  /// object for a subclass of NSFoo".
  constexpr bool isObjCClassOrClassKindOfType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCClassOrClassKindOfType, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isBlockCompatibleObjCPointerType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isBlockCompatibleObjCPointerType, Xs..., Y0s...); }) , (;) )
  constexpr bool isObjCSelType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCSelType, Xs...); }) , (;) )
  constexpr bool isObjCBuiltinType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCBuiltinType, Xs...); }) , (;) )
  constexpr bool isObjCARCBridgableType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCARCBridgableType, Xs...); }) , (;) )
  constexpr bool isCARCBridgableType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isCARCBridgableType, Xs...); }) , (;) )
  constexpr bool isTemplateTypeParmType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isTemplateTypeParmType, Xs...); }) , (;) )
  constexpr bool isNullPtrType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isNullPtrType, Xs...); }) , (;) )
  constexpr bool isAlignValT() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isAlignValT, Xs...); }) , (;) )
  constexpr bool isStdByteType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isStdByteType, Xs...); }) , (;) )
  constexpr bool isAtomicType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isAtomicType, Xs...); }) , (;) )
  constexpr bool isOCLImage1dROType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage1dROType, Xs...); }) , (;) )
  constexpr bool isOCLImage1dArrayROType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage1dArrayROType, Xs...); }) , (;) )
  constexpr bool isOCLImage1dBufferROType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage1dBufferROType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dROType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dROType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dArrayROType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dArrayROType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dDepthROType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dDepthROType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dArrayDepthROType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dArrayDepthROType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dMSAAROType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dMSAAROType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dArrayMSAAROType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dArrayMSAAROType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dMSAADepthROType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dMSAADepthROType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dArrayMSAADepthROType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dArrayMSAADepthROType, Xs...); }) , (;) )
  constexpr bool isOCLImage3dROType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage3dROType, Xs...); }) , (;) )
  constexpr bool isOCLImage1dWOType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage1dWOType, Xs...); }) , (;) )
  constexpr bool isOCLImage1dArrayWOType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage1dArrayWOType, Xs...); }) , (;) )
  constexpr bool isOCLImage1dBufferWOType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage1dBufferWOType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dWOType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dWOType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dArrayWOType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dArrayWOType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dDepthWOType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dDepthWOType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dArrayDepthWOType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dArrayDepthWOType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dMSAAWOType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dMSAAWOType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dArrayMSAAWOType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dArrayMSAAWOType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dMSAADepthWOType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dMSAADepthWOType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dArrayMSAADepthWOType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dArrayMSAADepthWOType, Xs...); }) , (;) )
  constexpr bool isOCLImage3dWOType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage3dWOType, Xs...); }) , (;) )
  constexpr bool isOCLImage1dRWType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage1dRWType, Xs...); }) , (;) )
  constexpr bool isOCLImage1dArrayRWType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage1dArrayRWType, Xs...); }) , (;) )
  constexpr bool isOCLImage1dBufferRWType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage1dBufferRWType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dRWType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dRWType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dArrayRWType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dArrayRWType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dDepthRWType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dDepthRWType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dArrayDepthRWType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dArrayDepthRWType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dMSAARWType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dMSAARWType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dArrayMSAARWType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dArrayMSAARWType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dMSAADepthRWType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dMSAADepthRWType, Xs...); }) , (;) )
  constexpr bool isOCLImage2dArrayMSAADepthRWType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage2dArrayMSAADepthRWType, Xs...); }) , (;) )
  constexpr bool isOCLImage3dRWType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOCLImage3dRWType, Xs...); }) , (;) )
  constexpr bool isImageType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isImageType, Xs...); }) , (;) )
  constexpr bool isSamplerT() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isSamplerT, Xs...); }) , (;) )
  constexpr bool isEventT() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isEventT, Xs...); }) , (;) )
  constexpr bool isClkEventT() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isClkEventT, Xs...); }) , (;) )
  constexpr bool isQueueT() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isQueueT, Xs...); }) , (;) )
  constexpr bool isReserveIDT() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isReserveIDT, Xs...); }) , (;) )
  constexpr bool isPipeType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isPipeType, Xs...); }) , (;) )
  constexpr bool isOpenCLSpecificType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOpenCLSpecificType, Xs...); }) , (;) )
  /// Determines if this type, which must satisfy
  /// isObjCLifetimeType(), is implicitly __unsafe_unretained rather
  /// than implicitly __strong.
  constexpr bool isObjCARCImplicitlyUnretainedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isObjCARCImplicitlyUnretainedType, Xs...); }) , (;) )
  /// Return the implicit lifetime for this type, which must not be dependent.
  constexpr enum clang::Qualifiers::ObjCLifetime getObjCARCImplicitLifetime() const IFMETA_ELSE( ({    return (enum clang::Qualifiers::ObjCLifetime)__reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getObjCARCImplicitLifetime, Xs...); }) , (;) )
  using ScalarTypeKind = enum refldetail::clang::Type::ScalarTypeKind;
  /// Given that this is a scalar type, classify it.
  constexpr enum clang::Type::ScalarTypeKind getScalarTypeKind() const IFMETA_ELSE( ({    return (enum clang::Type::ScalarTypeKind)__reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getScalarTypeKind, Xs...); }) , (;) )
  /// Whether this type is a dependent type, meaning that its definition
  /// somehow depends on a template parameter (C++ [temp.dep.type]).
  constexpr bool isDependentType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isDependentType, Xs...); }) , (;) )
  /// Determine whether this type is an instantiation-dependent type,
  /// meaning that the type involves a template parameter (even if the
  /// definition does not actually depend on the type substituted for that
  /// template parameter).
  constexpr bool isInstantiationDependentType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isInstantiationDependentType, Xs...); }) , (;) )
  /// Determine whether this type is an undeduced type, meaning that
  /// it somehow involves a C++11 'auto' type or similar which has not yet been
  /// deduced.
  constexpr bool isUndeducedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isUndeducedType, Xs...); }) , (;) )
  /// Whether this type is a variably-modified type (C99 6.7.5).
  constexpr bool isVariablyModifiedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isVariablyModifiedType, Xs...); }) , (;) )
  /// Whether this type involves a variable-length array type
  /// with a definite size.
  constexpr bool hasSizedVLAType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::hasSizedVLAType, Xs...); }) , (;) )
  /// Whether this type is or contains a local or unnamed type.
  constexpr bool hasUnnamedOrLocalType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::hasUnnamedOrLocalType, Xs...); }) , (;) )
  constexpr bool isOverloadableType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isOverloadableType, Xs...); }) , (;) )
  /// Determine wither this type is a C++ elaborated-type-specifier.
  constexpr bool isElaboratedTypeSpecifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isElaboratedTypeSpecifier, Xs...); }) , (;) )
  constexpr bool canDecayToPointerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::canDecayToPointerType, Xs...); }) , (;) )
  /// Whether this type is represented natively as a pointer.  This includes
  /// pointers, references, block pointers, and Objective-C interface,
  /// qualified id, and qualified interface types, as well as nullptr_t.
  constexpr bool hasPointerRepresentation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::hasPointerRepresentation, Xs...); }) , (;) )
  /// Whether this type can represent an objective pointer type for the
  /// purpose of GC'ability
  constexpr bool hasObjCPointerRepresentation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::hasObjCPointerRepresentation, Xs...); }) , (;) )
  /// Determine whether this type has an integer representation
  /// of some sort, e.g., it is an integer type or a vector.
  constexpr bool hasIntegerRepresentation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::hasIntegerRepresentation, Xs...); }) , (;) )
  /// Determine whether this type has an signed integer representation
  /// of some sort, e.g., it is an signed integer type or a vector.
  constexpr bool hasSignedIntegerRepresentation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::hasSignedIntegerRepresentation, Xs...); }) , (;) )
  /// Determine whether this type has an unsigned integer representation
  /// of some sort, e.g., it is an unsigned integer type or a vector.
  constexpr bool hasUnsignedIntegerRepresentation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::hasUnsignedIntegerRepresentation, Xs...); }) , (;) )
  /// Determine whether this type has a floating-point representation
  /// of some sort, e.g., it is a floating-point type or a vector thereof.
  constexpr bool hasFloatingRepresentation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::hasFloatingRepresentation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::RecordType *) )
  getAsStructureType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getAsStructureType, Xs...); }) , (;) )
  /// NOTE: getAs*ArrayType are methods on ASTContext.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::RecordType *) )
  getAsUnionType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getAsUnionType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ComplexType *) )
  getAsComplexIntegerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getAsComplexIntegerType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCObjectType *) )
  getAsObjCInterfaceType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getAsObjCInterfaceType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCObjectPointerType *) )
  getAsObjCInterfacePointerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getAsObjCInterfacePointerType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCObjectPointerType *) )
  getAsObjCQualifiedIdType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getAsObjCQualifiedIdType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCObjectPointerType *) )
  getAsObjCQualifiedClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getAsObjCQualifiedClassType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCObjectType *) )
  getAsObjCQualifiedInterfaceType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getAsObjCQualifiedInterfaceType, Xs...); }) , (;) )
  /// Retrieves the CXXRecordDecl that this type refers to, either
  /// because the type is a RecordType or because it is the injected-class-name
  /// type of a class template or class template partial specialization.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getAsCXXRecordDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getAsCXXRecordDecl, Xs...); }) , (;) )
  /// Retrieves the RecordDecl this type refers to.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::RecordDecl *) )
  getAsRecordDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getAsRecordDecl, Xs...); }) , (;) )
  /// Retrieves the TagDecl that this type refers to, either
  /// because the type is a TagType or because it is the injected-class-name
  /// type of a class template or class template partial specialization.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TagDecl *) )
  getAsTagDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getAsTagDecl, Xs...); }) , (;) )
  /// If this is a pointer or reference to a RecordType, return the
  /// CXXRecordDecl that the type refers to.
  ///
  /// If this is not a pointer or reference, or the type being pointed to does
  /// not refer to a CXXRecordDecl, returns NULL.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXRecordDecl *) )
  getPointeeCXXRecordDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getPointeeCXXRecordDecl, Xs...); }) , (;) )
  /// Get the DeducedType whose type will be deduced for a variable with
  /// an initializer of this type. This looks through declarators like pointer
  /// types, but not through decltype or typedefs.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeducedType *) )
  getContainedDeducedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getContainedDeducedType, Xs...); }) , (;) )
  /// Get the AutoType whose type will be deduced for a variable with
  /// an initializer of this type. This looks through declarators like pointer
  /// types, but not through decltype or typedefs.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::AutoType *) )
  getContainedAutoType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getContainedAutoType, Xs...); }) , (;) )
  /// Determine whether this type was written with a leading 'auto'
  /// corresponding to a trailing return type (possibly for a nested
  /// function type within a pointer to function type or similar).
  constexpr bool hasAutoForTrailingReturnType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::hasAutoForTrailingReturnType, Xs...); }) , (;) )
  /// A variant of getAs<> for array types which silently discards
  /// qualifiers from the outermost type.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ArrayType *) )
  getAsArrayTypeUnsafe() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getAsArrayTypeUnsafe, Xs...); }) , (;) )
  /// A variant of castAs<> for array type which silently discards
  /// qualifiers from the outermost type.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ArrayType *) )
  castAsArrayTypeUnsafe() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::castAsArrayTypeUnsafe, Xs...); }) , (;) )
  /// Get the base element type of this type, potentially discarding type
  /// qualifiers.  This should never be used when type qualifiers
  /// are meaningful.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getBaseElementTypeUnsafe() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getBaseElementTypeUnsafe, Xs...); }) , (;) )
  /// If this is an array type, return the element type of the array,
  /// potentially with type qualifiers missing.
  /// This should never be used when type qualifiers are meaningful.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getArrayElementTypeNoTypeQual() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getArrayElementTypeNoTypeQual, Xs...); }) , (;) )
  /// If this is a pointer type, return the pointee type.
  /// If this is an array type, return the array element type.
  /// This should never be used when type qualifiers are meaningful.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getPointeeOrArrayElementType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getPointeeOrArrayElementType, Xs...); }) , (;) )
  /// If this is a pointer, ObjC object pointer, or block
  /// pointer, this returns the respective pointee.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPointeeType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getPointeeType, Xs...); }) , (;) )
  /// Return the specified type with any "sugar" removed from the type,
  /// removing any typedefs, typeofs, etc., as well as any qualifiers.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getUnqualifiedDesugaredType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getUnqualifiedDesugaredType, Xs...); }) , (;) )
  /// More type predicates useful for type checking/promotion
  constexpr bool isPromotableIntegerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isPromotableIntegerType, Xs...); }) , (;) )
  /// Return true if this is an integer type that is
  /// signed, according to C99 6.2.5p4 [char, signed char, short, int, long..],
  /// or an enum decl which has a signed representation.
  constexpr bool isSignedIntegerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isSignedIntegerType, Xs...); }) , (;) )
  /// Return true if this is an integer type that is
  /// unsigned, according to C99 6.2.5p6 [which returns true for _Bool],
  /// or an enum decl which has an unsigned representation.
  constexpr bool isUnsignedIntegerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isUnsignedIntegerType, Xs...); }) , (;) )
  /// Determines whether this is an integer type that is signed or an
  /// enumeration types whose underlying type is a signed integer type.
  constexpr bool isSignedIntegerOrEnumerationType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isSignedIntegerOrEnumerationType, Xs...); }) , (;) )
  /// Determines whether this is an integer type that is unsigned or an
  /// enumeration types whose underlying type is a unsigned integer type.
  constexpr bool isUnsignedIntegerOrEnumerationType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isUnsignedIntegerOrEnumerationType, Xs...); }) , (;) )
  /// Return true if this is a fixed point type according to
  /// ISO/IEC JTC1 SC22 WG14 N1169.
  constexpr bool isFixedPointType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isFixedPointType, Xs...); }) , (;) )
  /// Return true if this is a saturated fixed point type according to
  /// ISO/IEC JTC1 SC22 WG14 N1169. This type can be signed or unsigned.
  constexpr bool isSaturatedFixedPointType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isSaturatedFixedPointType, Xs...); }) , (;) )
  /// Return true if this is a saturated fixed point type according to
  /// ISO/IEC JTC1 SC22 WG14 N1169. This type can be signed or unsigned.
  constexpr bool isUnsaturatedFixedPointType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isUnsaturatedFixedPointType, Xs...); }) , (;) )
  /// Return true if this is a fixed point type that is signed according
  /// to ISO/IEC JTC1 SC22 WG14 N1169. This type can also be saturated.
  constexpr bool isSignedFixedPointType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isSignedFixedPointType, Xs...); }) , (;) )
  /// Return true if this is a fixed point type that is unsigned according
  /// to ISO/IEC JTC1 SC22 WG14 N1169. This type can also be saturated.
  constexpr bool isUnsignedFixedPointType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isUnsignedFixedPointType, Xs...); }) , (;) )
  /// Return true if this is not a variable sized type,
  /// according to the rules of C99 6.7.5p3.  It is not legal to call this on
  /// incomplete types.
  constexpr bool isConstantSizeType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isConstantSizeType, Xs...); }) , (;) )
  /// Returns true if this type can be represented by some
  /// set of type specifiers.
  constexpr bool isSpecifierType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isSpecifierType, Xs...); }) , (;) )
  /// Determine the linkage of this type.
  constexpr enum clang::Linkage getLinkage() const IFMETA_ELSE( ({    return (enum clang::Linkage)__reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getLinkage, Xs...); }) , (;) )
  /// Determine the visibility of this type.
  constexpr enum clang::Visibility getVisibility() const IFMETA_ELSE( ({    return (enum clang::Visibility)__reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getVisibility, Xs...); }) , (;) )
  /// Return true if the visibility was explicitly set is the code.
  constexpr bool isVisibilityExplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isVisibilityExplicit, Xs...); }) , (;) )
  /// Determine the linkage and visibility of this type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::LinkageInfo) )
  getLinkageAndVisibility() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getLinkageAndVisibility, Xs...); }) , (;) )
  /// True if the computed linkage is valid. Used for consistency
  /// checking. Should always return true.
  constexpr bool isLinkageValid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::isLinkageValid, Xs...); }) , (;) )
  /// Determine whether the given type can have a nullability
  /// specifier applied to it, i.e., if it is any kind of pointer type.
  ///
  /// \param ResultIfUnknown The value to return if we don't yet know whether
  ///        this type can have nullability because it is dependent.
  constexpr bool canHaveNullability(bool ResultIfUnknown = true) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::canHaveNullability, Xs..., ResultIfUnknown); }) , (;) )
  /// Determines if this is an ObjC interface type that may accept type
  /// parameters.
  constexpr bool acceptsObjCTypeParams() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::acceptsObjCTypeParams, Xs...); }) , (;) )
  constexpr const char * getTypeClassName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getTypeClassName, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getCanonicalTypeInternal() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::getCanonicalTypeInternal, Xs...); }) , (;) )
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::dump, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void dump(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Type, reflenums::clang__Type::dump1, Xs..., Y0s...); }) , (;) )
};

enum clang::BuiltinType::Kind : unsigned int {
  OCLImage1dRO,
  OCLImage1dArrayRO,
  OCLImage1dBufferRO,
  OCLImage2dRO,
  OCLImage2dArrayRO,
  OCLImage2dDepthRO,
  OCLImage2dArrayDepthRO,
  OCLImage2dMSAARO,
  OCLImage2dArrayMSAARO,
  OCLImage2dMSAADepthRO,
  OCLImage2dArrayMSAADepthRO,
  OCLImage3dRO,
  OCLImage1dWO,
  OCLImage1dArrayWO,
  OCLImage1dBufferWO,
  OCLImage2dWO,
  OCLImage2dArrayWO,
  OCLImage2dDepthWO,
  OCLImage2dArrayDepthWO,
  OCLImage2dMSAAWO,
  OCLImage2dArrayMSAAWO,
  OCLImage2dMSAADepthWO,
  OCLImage2dArrayMSAADepthWO,
  OCLImage3dWO,
  OCLImage1dRW,
  OCLImage1dArrayRW,
  OCLImage1dBufferRW,
  OCLImage2dRW,
  OCLImage2dArrayRW,
  OCLImage2dDepthRW,
  OCLImage2dArrayDepthRW,
  OCLImage2dMSAARW,
  OCLImage2dArrayMSAARW,
  OCLImage2dMSAADepthRW,
  OCLImage2dArrayMSAADepthRW,
  OCLImage3dRW,
  Void,
  Bool,
  Char_U,
  UChar,
  WChar_U,
  Char8,
  Char16,
  Char32,
  UShort,
  UInt,
  ULong,
  ULongLong,
  UInt128,
  Char_S,
  SChar,
  WChar_S,
  Short,
  Int,
  Long,
  LongLong,
  Int128,
  ShortAccum,
  Accum,
  LongAccum,
  UShortAccum,
  UAccum,
  ULongAccum,
  ShortFract,
  Fract,
  LongFract,
  UShortFract,
  UFract,
  ULongFract,
  SatShortAccum,
  SatAccum,
  SatLongAccum,
  SatUShortAccum,
  SatUAccum,
  SatULongAccum,
  SatShortFract,
  SatFract,
  SatLongFract,
  SatUShortFract,
  SatUFract,
  SatULongFract,
  Half,
  Float,
  Double,
  LongDouble,
  Float16,
  Float128,
  NullPtr,
  ObjCId,
  ObjCClass,
  ObjCSel,
  OCLSampler,
  OCLEvent,
  OCLClkEvent,
  OCLQueue,
  OCLReserveID,
  Dependent,
  Overload,
  BoundMember,
  PseudoObject,
  UnknownAny,
  BuiltinFn,
  ARCUnbridgedCast,
  OMPArraySection,
  LastKind = 103,
};

/// This class is used for builtin types like 'int'.  Builtin
/// types are always canonical and have a literal name field.
M_template_rtpack(Xs)
struct clang::BuiltinType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__BuiltinType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::BuiltinType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using Kind = enum refldetail::clang::BuiltinType::Kind;
  constexpr enum clang::BuiltinType::Kind getKind() const IFMETA_ELSE( ({    return (enum clang::BuiltinType::Kind)__reflect_prop(reflenums::RK_clang__BuiltinType, reflenums::clang__BuiltinType::getKind, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * getName(IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::PrintingPolicy &)) Policy) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinType, reflenums::clang__BuiltinType::getName, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * getNameAsCString(IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::PrintingPolicy &)) Policy) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinType, reflenums::clang__BuiltinType::getNameAsCString, Xs..., Y0s...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinType, reflenums::clang__BuiltinType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinType, reflenums::clang__BuiltinType::desugar, Xs...); }) , (;) )
  constexpr bool isInteger() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinType, reflenums::clang__BuiltinType::isInteger, Xs...); }) , (;) )
  constexpr bool isSignedInteger() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinType, reflenums::clang__BuiltinType::isSignedInteger, Xs...); }) , (;) )
  constexpr bool isUnsignedInteger() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinType, reflenums::clang__BuiltinType::isUnsignedInteger, Xs...); }) , (;) )
  constexpr bool isFloatingPoint() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinType, reflenums::clang__BuiltinType::isFloatingPoint, Xs...); }) , (;) )
  /// Determines whether the given kind corresponds to a placeholder type.
  static constexpr bool isPlaceholderTypeKind(enum clang::BuiltinType::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinType, reflenums::clang__BuiltinType::isPlaceholderTypeKind, Xs..., K); }) , (;) )
  /// Determines whether this type is a placeholder type, i.e. a type
  /// which cannot appear in arbitrary positions in a fully-formed
  /// expression.
  constexpr bool isPlaceholderType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinType, reflenums::clang__BuiltinType::isPlaceholderType, Xs...); }) , (;) )
  /// Determines whether this type is a placeholder type other than
  /// Overload.  Most placeholder types require only syntactic
  /// information about their context in order to be resolved (e.g.
  /// whether it is a call expression), which means they can (and
  /// should) be resolved in an earlier "phase" of analysis.
  /// Overload expressions sometimes pick up further information
  /// from their context, like whether the context expects a
  /// specific function-pointer type, and so frequently need
  /// special treatment.
  constexpr bool isNonOverloadPlaceholderType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinType, reflenums::clang__BuiltinType::isNonOverloadPlaceholderType, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinType, reflenums::clang__BuiltinType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Complex values, per C99 6.2.5p11.  This supports the C99 complex
/// types (_Complex float etc) as well as the GCC integer complex extensions.
M_template_rtpack(Xs)
struct clang::ComplexType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ComplexType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ComplexType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getElementType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ComplexType, reflenums::clang__ComplexType::getElementType, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ComplexType, reflenums::clang__ComplexType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ComplexType, reflenums::clang__ComplexType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) Element) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ComplexType, reflenums::clang__ComplexType::Profile, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ComplexType, reflenums::clang__ComplexType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Sugar for parentheses used when specifying types.
M_template_rtpack(Xs)
struct clang::ParenType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ParenType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ParenType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getInnerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenType, reflenums::clang__ParenType::getInnerType, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenType, reflenums::clang__ParenType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenType, reflenums::clang__ParenType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) Inner) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ParenType, reflenums::clang__ParenType::Profile, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenType, reflenums::clang__ParenType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// PointerType - C99 6.7.5.1 - Pointer Declarators.
M_template_rtpack(Xs)
struct clang::PointerType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__PointerType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::PointerType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPointeeType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PointerType, reflenums::clang__PointerType::getPointeeType, Xs...); }) , (;) )
  /// Returns true if address spaces of pointers overlap.
  /// OpenCL v2.0 defines conversion rules for pointers to different
  /// address spaces (OpenCLC v2.0 s6.5.5) and notion of overlapping
  /// address spaces.
  /// CL1.1 or CL1.2:
  ///   address spaces overlap iff they are they same.
  /// CL2.0 adds:
  ///   __generic overlaps with any address space except for __constant.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isAddressSpaceOverlapping(IFMETA_ELSE((const clang::PointerType::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::PointerType &)) other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PointerType, reflenums::clang__PointerType::isAddressSpaceOverlapping, Xs..., Y0s...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PointerType, reflenums::clang__PointerType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PointerType, reflenums::clang__PointerType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) Pointee) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__PointerType, reflenums::clang__PointerType::Profile, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PointerType, reflenums::clang__PointerType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a type which was implicitly adjusted by the semantic
/// engine for arbitrary reasons.  For example, array and function types can
/// decay, and function types can have their calling conventions adjusted.
M_template_rtpack(Xs)
struct clang::AdjustedType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__AdjustedType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::AdjustedType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getOriginalType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AdjustedType, reflenums::clang__AdjustedType::getOriginalType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAdjustedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AdjustedType, reflenums::clang__AdjustedType::getAdjustedType, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AdjustedType, reflenums::clang__AdjustedType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AdjustedType, reflenums::clang__AdjustedType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) Orig, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) New) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__AdjustedType, reflenums::clang__AdjustedType::Profile, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AdjustedType, reflenums::clang__AdjustedType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a pointer type decayed from an array or function type.
M_template_rtpack(Xs)
struct clang::DecayedType::impl : impl_offset_t<clang::AdjustedType, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DecayedType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DecayedType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDecayedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DecayedType, reflenums::clang__DecayedType::getDecayedType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPointeeType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DecayedType, reflenums::clang__DecayedType::getPointeeType, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DecayedType, reflenums::clang__DecayedType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Pointer to a block type.
/// This type is to represent types syntactically represented as
/// "void (^)(int)", etc. Pointee is required to always be a function type.
M_template_rtpack(Xs)
struct clang::BlockPointerType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__BlockPointerType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::BlockPointerType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPointeeType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockPointerType, reflenums::clang__BlockPointerType::getPointeeType, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockPointerType, reflenums::clang__BlockPointerType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockPointerType, reflenums::clang__BlockPointerType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) Pointee) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__BlockPointerType, reflenums::clang__BlockPointerType::Profile, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockPointerType, reflenums::clang__BlockPointerType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Base for LValueReferenceType and RValueReferenceType
M_template_rtpack(Xs)
struct clang::ReferenceType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ReferenceType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ReferenceType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isSpelledAsLValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReferenceType, reflenums::clang__ReferenceType::isSpelledAsLValue, Xs...); }) , (;) )
  constexpr bool isInnerRef() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReferenceType, reflenums::clang__ReferenceType::isInnerRef, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPointeeTypeAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReferenceType, reflenums::clang__ReferenceType::getPointeeTypeAsWritten, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPointeeType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReferenceType, reflenums::clang__ReferenceType::getPointeeType, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) Referencee, bool SpelledAsLValue) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ReferenceType, reflenums::clang__ReferenceType::Profile, Xs..., Y0s..., Y1s..., SpelledAsLValue); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReferenceType, reflenums::clang__ReferenceType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// An lvalue reference type, per C++11 [dcl.ref].
M_template_rtpack(Xs)
struct clang::LValueReferenceType::impl : impl_offset_t<clang::ReferenceType, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__LValueReferenceType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::LValueReferenceType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LValueReferenceType, reflenums::clang__LValueReferenceType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LValueReferenceType, reflenums::clang__LValueReferenceType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LValueReferenceType, reflenums::clang__LValueReferenceType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// An rvalue reference type, per C++11 [dcl.ref].
M_template_rtpack(Xs)
struct clang::RValueReferenceType::impl : impl_offset_t<clang::ReferenceType, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__RValueReferenceType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::RValueReferenceType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RValueReferenceType, reflenums::clang__RValueReferenceType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RValueReferenceType, reflenums::clang__RValueReferenceType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RValueReferenceType, reflenums::clang__RValueReferenceType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A pointer to member type per C++ 8.3.3 - Pointers to members.
///
/// This includes both pointers to data members and pointer to member functions.
M_template_rtpack(Xs)
struct clang::MemberPointerType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__MemberPointerType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::MemberPointerType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPointeeType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberPointerType, reflenums::clang__MemberPointerType::getPointeeType, Xs...); }) , (;) )
  /// Returns true if the member type (i.e. the pointee type) is a
  /// function type rather than a data-member type.
  constexpr bool isMemberFunctionPointer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberPointerType, reflenums::clang__MemberPointerType::isMemberFunctionPointer, Xs...); }) , (;) )
  /// Returns true if the member type (i.e. the pointee type) is a
  /// data type rather than a function type.
  constexpr bool isMemberDataPointer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberPointerType, reflenums::clang__MemberPointerType::isMemberDataPointer, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberPointerType, reflenums::clang__MemberPointerType::getClass, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getMostRecentCXXRecordDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberPointerType, reflenums::clang__MemberPointerType::getMostRecentCXXRecordDecl, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberPointerType, reflenums::clang__MemberPointerType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberPointerType, reflenums::clang__MemberPointerType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) Pointee, IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y2s...> *), (const typename meta::clang::Type *)) Class) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__MemberPointerType, reflenums::clang__MemberPointerType::Profile, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr void Profile(Y0 p0, Y1 p1, ptrwrp<Y2> p2) {
      return Profile(p0, p1, p2.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberPointerType, reflenums::clang__MemberPointerType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Capture whether this is a normal array (e.g. int X[4])
/// an array with a static size (e.g. int X[static 4]), or an array
/// with a star size (e.g. int X[*]).
/// 'static' is only allowed on function parameters.
enum clang::ArrayType::ArraySizeModifier : unsigned int {
  Normal,
  Static,
  Star,
};

/// Represents an array type, per C99 6.7.5.2 - Array Declarators.
M_template_rtpack(Xs)
struct clang::ArrayType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ArrayType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ArrayType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using ArraySizeModifier = enum refldetail::clang::ArrayType::ArraySizeModifier;
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getElementType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayType, reflenums::clang__ArrayType::getElementType, Xs...); }) , (;) )
  constexpr enum clang::ArrayType::ArraySizeModifier getSizeModifier() const IFMETA_ELSE( ({    return (enum clang::ArrayType::ArraySizeModifier)__reflect_prop(reflenums::RK_clang__ArrayType, reflenums::clang__ArrayType::getSizeModifier, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Qualifiers) )
  getIndexTypeQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayType, reflenums::clang__ArrayType::getIndexTypeQualifiers, Xs...); }) , (;) )
  constexpr unsigned int getIndexTypeCVRQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayType, reflenums::clang__ArrayType::getIndexTypeCVRQualifiers, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayType, reflenums::clang__ArrayType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents the canonical version of C arrays with a specified constant size.
/// For example, the canonical type for 'int A[4 + 4*100]' is a
/// ConstantArrayType where the element type is 'int' and the size is 404.
M_template_rtpack(Xs)
struct clang::ConstantArrayType::impl : impl_offset_t<clang::ArrayType, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ConstantArrayType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ConstantArrayType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::APInt &) )
  getSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstantArrayType, reflenums::clang__ConstantArrayType::getSize, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstantArrayType, reflenums::clang__ConstantArrayType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstantArrayType, reflenums::clang__ConstantArrayType::desugar, Xs...); }) , (;) )
  /// Determine the number of bits required to address a member of
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr unsigned int getNumAddressingBits(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) ElementType, IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y2s...>), (const typename meta::llvm::APInt &)) NumElements) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstantArrayType, reflenums::clang__ConstantArrayType::getNumAddressingBits, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  /// Determine the maximum number of active bits that an array's size
  /// can require, which limits the maximum size of the array.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr unsigned int getMaxSizeBits(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstantArrayType, reflenums::clang__ConstantArrayType::getMaxSizeBits, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) ET, IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y2s...>), (const typename meta::llvm::APInt &)) ArraySize, enum clang::ArrayType::ArraySizeModifier SizeMod, unsigned int TypeQuals) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ConstantArrayType, reflenums::clang__ConstantArrayType::Profile, Xs..., Y0s..., Y1s..., Y2s..., SizeMod, TypeQuals); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstantArrayType, reflenums::clang__ConstantArrayType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a C array with an unspecified size.  For example 'int A[]' has
/// an IncompleteArrayType where the element type is 'int' and the size is
/// unspecified.
M_template_rtpack(Xs)
struct clang::IncompleteArrayType::impl : impl_offset_t<clang::ArrayType, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__IncompleteArrayType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::IncompleteArrayType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IncompleteArrayType, reflenums::clang__IncompleteArrayType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IncompleteArrayType, reflenums::clang__IncompleteArrayType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IncompleteArrayType, reflenums::clang__IncompleteArrayType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) ET, enum clang::ArrayType::ArraySizeModifier SizeMod, unsigned int TypeQuals) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__IncompleteArrayType, reflenums::clang__IncompleteArrayType::Profile, Xs..., Y0s..., Y1s..., SizeMod, TypeQuals); }) , (;) )
};

/// Represents a C array with a specified size that is not an
/// integer-constant-expression.  For example, 'int s[x+foo()]'.
/// Since the size expression is an arbitrary expression, we store it as such.
///
/// Note: VariableArrayType's aren't uniqued (since the expressions aren't) and
/// should not be: two lexically equivalent variable array types could mean
/// different things, for example, these variables do not have the same type
/// dynamically:
///
/// void foo(int x) {
///   int Y[x];
///   ++x;
///   int Z[x];
/// }
M_template_rtpack(Xs)
struct clang::VariableArrayType::impl : impl_offset_t<clang::ArrayType, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__VariableArrayType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::VariableArrayType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSizeExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VariableArrayType, reflenums::clang__VariableArrayType::getSizeExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getBracketsRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VariableArrayType, reflenums::clang__VariableArrayType::getBracketsRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLBracketLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VariableArrayType, reflenums::clang__VariableArrayType::getLBracketLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRBracketLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VariableArrayType, reflenums::clang__VariableArrayType::getRBracketLoc, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VariableArrayType, reflenums::clang__VariableArrayType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VariableArrayType, reflenums::clang__VariableArrayType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VariableArrayType, reflenums::clang__VariableArrayType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents an array type in C++ whose size is a value-dependent expression.
///
/// For example:
/// \code
/// template<typename T, int Size>
/// class array {
///   T data[Size];
/// };
/// \endcode
///
/// For these types, we won't actually know what the array bound is
/// until template instantiation occurs, at which point this will
/// become either a ConstantArrayType or a VariableArrayType.
M_template_rtpack(Xs)
struct clang::DependentSizedArrayType::impl : impl_offset_t<clang::ArrayType, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DependentSizedArrayType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DependentSizedArrayType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSizeExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentSizedArrayType, reflenums::clang__DependentSizedArrayType::getSizeExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getBracketsRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentSizedArrayType, reflenums::clang__DependentSizedArrayType::getBracketsRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLBracketLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentSizedArrayType, reflenums::clang__DependentSizedArrayType::getLBracketLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRBracketLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentSizedArrayType, reflenums::clang__DependentSizedArrayType::getRBracketLoc, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentSizedArrayType, reflenums::clang__DependentSizedArrayType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentSizedArrayType, reflenums::clang__DependentSizedArrayType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentSizedArrayType, reflenums::clang__DependentSizedArrayType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) ET, enum clang::ArrayType::ArraySizeModifier SizeMod, unsigned int TypeQuals, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::Expr *)) E) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DependentSizedArrayType, reflenums::clang__DependentSizedArrayType::Profile, Xs..., Y0s..., Y1s..., Y2s..., SizeMod, TypeQuals, Y3s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr void Profile(Y0 p0, Y1 p1, Y2 p2, enum clang::ArrayType::ArraySizeModifier p3, unsigned int p4, ptrwrp<Y3> p5) {
      return Profile(p0, p1, p2, p3, p4, p5.get());
  }), () )
};

/// Represents an extended address space qualifier where the input address space
/// value is dependent. Non-dependent address spaces are not represented with a
/// special Type subclass; they are stored on an ExtQuals node as part of a QualType.
///
/// For example:
/// \code
/// template<typename T, int AddrSpace>
/// class AddressSpace {
///   typedef T __attribute__((address_space(AddrSpace))) type;
/// }
/// \endcode
M_template_rtpack(Xs)
struct clang::DependentAddressSpaceType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DependentAddressSpaceType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DependentAddressSpaceType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getAddrSpaceExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentAddressSpaceType, reflenums::clang__DependentAddressSpaceType::getAddrSpaceExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPointeeType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentAddressSpaceType, reflenums::clang__DependentAddressSpaceType::getPointeeType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAttributeLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentAddressSpaceType, reflenums::clang__DependentAddressSpaceType::getAttributeLoc, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentAddressSpaceType, reflenums::clang__DependentAddressSpaceType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentAddressSpaceType, reflenums::clang__DependentAddressSpaceType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentAddressSpaceType, reflenums::clang__DependentAddressSpaceType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) PointeeType, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::Expr *)) AddrSpaceExpr) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DependentAddressSpaceType, reflenums::clang__DependentAddressSpaceType::Profile, Xs..., Y0s..., Y1s..., Y2s..., Y3s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr void Profile(Y0 p0, Y1 p1, Y2 p2, ptrwrp<Y3> p3) {
      return Profile(p0, p1, p2, p3.get());
  }), () )
};

/// Represents an extended vector type where either the type or size is
/// dependent.
///
/// For example:
/// \code
/// template<typename T, int Size>
/// class vector {
///   typedef T __attribute__((ext_vector_type(Size))) type;
/// }
/// \endcode
M_template_rtpack(Xs)
struct clang::DependentSizedExtVectorType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DependentSizedExtVectorType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DependentSizedExtVectorType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSizeExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentSizedExtVectorType, reflenums::clang__DependentSizedExtVectorType::getSizeExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getElementType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentSizedExtVectorType, reflenums::clang__DependentSizedExtVectorType::getElementType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAttributeLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentSizedExtVectorType, reflenums::clang__DependentSizedExtVectorType::getAttributeLoc, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentSizedExtVectorType, reflenums::clang__DependentSizedExtVectorType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentSizedExtVectorType, reflenums::clang__DependentSizedExtVectorType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentSizedExtVectorType, reflenums::clang__DependentSizedExtVectorType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) ElementType, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::Expr *)) SizeExpr) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DependentSizedExtVectorType, reflenums::clang__DependentSizedExtVectorType::Profile, Xs..., Y0s..., Y1s..., Y2s..., Y3s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr void Profile(Y0 p0, Y1 p1, Y2 p2, ptrwrp<Y3> p3) {
      return Profile(p0, p1, p2, p3.get());
  }), () )
};

enum clang::VectorType::VectorKind : unsigned int {
  /// not a target-specific vector type
  GenericVector,
  /// is AltiVec vector
  AltiVecVector,
  /// is AltiVec 'vector Pixel'
  AltiVecPixel,
  /// is AltiVec 'vector bool ...'
  AltiVecBool,
  /// is ARM Neon vector
  NeonVector,
  /// is ARM Neon polynomial vector
  NeonPolyVector,
};

/// Represents a GCC generic vector type. This type is created using
/// __attribute__((vector_size(n)), where "n" specifies the vector size in
/// bytes; or from an Altivec __vector or vector declaration.
/// Since the constructor takes the number of vector elements, the
/// client is responsible for converting the size into the number of elements.
M_template_rtpack(Xs)
struct clang::VectorType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__VectorType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::VectorType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using VectorKind = enum refldetail::clang::VectorType::VectorKind;
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getElementType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VectorType, reflenums::clang__VectorType::getElementType, Xs...); }) , (;) )
  constexpr unsigned int getNumElements() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VectorType, reflenums::clang__VectorType::getNumElements, Xs...); }) , (;) )
  static constexpr bool isVectorSizeTooLarge(unsigned int NumElements) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VectorType, reflenums::clang__VectorType::isVectorSizeTooLarge, Xs..., NumElements); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VectorType, reflenums::clang__VectorType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VectorType, reflenums::clang__VectorType::desugar, Xs...); }) , (;) )
  constexpr enum clang::VectorType::VectorKind getVectorKind() const IFMETA_ELSE( ({    return (enum clang::VectorType::VectorKind)__reflect_prop(reflenums::RK_clang__VectorType, reflenums::clang__VectorType::getVectorKind, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) ElementType, unsigned int NumElements, enum clang::Type::TypeClass TypeClass, enum clang::VectorType::VectorKind VecKind) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__VectorType, reflenums::clang__VectorType::Profile, Xs..., Y0s..., Y1s..., NumElements, TypeClass, VecKind); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VectorType, reflenums::clang__VectorType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a vector type where either the type or size is dependent.
////
/// For example:
/// \code
/// template<typename T, int Size>
/// class vector {
///   typedef T __attribute__((vector_size(Size))) type;
/// }
/// \endcode
M_template_rtpack(Xs)
struct clang::DependentVectorType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DependentVectorType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DependentVectorType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSizeExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentVectorType, reflenums::clang__DependentVectorType::getSizeExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getElementType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentVectorType, reflenums::clang__DependentVectorType::getElementType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAttributeLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentVectorType, reflenums::clang__DependentVectorType::getAttributeLoc, Xs...); }) , (;) )
  constexpr enum clang::VectorType::VectorKind getVectorKind() const IFMETA_ELSE( ({    return (enum clang::VectorType::VectorKind)__reflect_prop(reflenums::RK_clang__DependentVectorType, reflenums::clang__DependentVectorType::getVectorKind, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentVectorType, reflenums::clang__DependentVectorType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentVectorType, reflenums::clang__DependentVectorType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentVectorType, reflenums::clang__DependentVectorType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) ElementType, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y3s...> *), (const typename meta::clang::Expr *)) SizeExpr, enum clang::VectorType::VectorKind VecKind) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DependentVectorType, reflenums::clang__DependentVectorType::Profile, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., VecKind); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr void Profile(Y0 p0, Y1 p1, Y2 p2, ptrwrp<Y3> p3, enum clang::VectorType::VectorKind p4) {
      return Profile(p0, p1, p2, p3.get(), p4);
  }), () )
};

/// ExtVectorType - Extended vector type. This type is created using
/// __attribute__((ext_vector_type(n)), where "n" is the number of elements.
/// Unlike vector_size, ext_vector_type is only allowed on typedef's. This
/// class enables syntactic extensions, like Vector Components for accessing
/// points (as .xyzw), colors (as .rgba), and textures (modeled after OpenGL
/// Shading Language).
M_template_rtpack(Xs)
struct clang::ExtVectorType::impl : impl_offset_t<clang::VectorType, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ExtVectorType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ExtVectorType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  static constexpr int getPointAccessorIdx(char c) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorType, reflenums::clang__ExtVectorType::getPointAccessorIdx, Xs..., c); }) , (;) )
  static constexpr int getNumericAccessorIdx(char c) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorType, reflenums::clang__ExtVectorType::getNumericAccessorIdx, Xs..., c); }) , (;) )
  static constexpr int getAccessorIdx(char c, bool isNumericAccessor) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorType, reflenums::clang__ExtVectorType::getAccessorIdx, Xs..., c, isNumericAccessor); }) , (;) )
  constexpr bool isAccessorWithinNumElements(char c, bool isNumericAccessor) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorType, reflenums::clang__ExtVectorType::isAccessorWithinNumElements, Xs..., c, isNumericAccessor); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorType, reflenums::clang__ExtVectorType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorType, reflenums::clang__ExtVectorType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorType, reflenums::clang__ExtVectorType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// FunctionType - C99 6.7.5.3 - Function Declarators.  This is the common base
/// class of FunctionNoProtoType and FunctionProtoType.
M_template_rtpack(Xs)
struct clang::FunctionType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FunctionType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FunctionType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template_rtpack(Zs) using ExtInfo = struct refldetail::clang::FunctionType::ExtInfo::M_template impl M_targpack(Zs);
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getReturnType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType, reflenums::clang__FunctionType::getReturnType, Xs...); }) , (;) )
  constexpr bool getHasRegParm() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType, reflenums::clang__FunctionType::getHasRegParm, Xs...); }) , (;) )
  constexpr unsigned int getRegParmType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType, reflenums::clang__FunctionType::getRegParmType, Xs...); }) , (;) )
  /// Determine whether this function type includes the GNU noreturn
  /// attribute. The C++11 [[noreturn]] attribute does not affect the function
  /// type.
  constexpr bool getNoReturnAttr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType, reflenums::clang__FunctionType::getNoReturnAttr, Xs...); }) , (;) )
  constexpr enum clang::CallingConv getCallConv() const IFMETA_ELSE( ({    return (enum clang::CallingConv)__reflect_prop(reflenums::RK_clang__FunctionType, reflenums::clang__FunctionType::getCallConv, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionType::ExtInfo) )
  getExtInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType, reflenums::clang__FunctionType::getExtInfo, Xs...); }) , (;) )
  constexpr bool isConst() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType, reflenums::clang__FunctionType::isConst, Xs...); }) , (;) )
  constexpr bool isVolatile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType, reflenums::clang__FunctionType::isVolatile, Xs...); }) , (;) )
  constexpr bool isRestrict() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType, reflenums::clang__FunctionType::isRestrict, Xs...); }) , (;) )
  /// Determine the type of an expression that calls a function of
  /// this type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getCallResultType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType, reflenums::clang__FunctionType::getCallResultType, Xs..., Y0s...); }) , (;) )
  static constexpr const char * getNameForCallConv(enum clang::CallingConv CC) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType, reflenums::clang__FunctionType::getNameForCallConv, Xs..., CC); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType, reflenums::clang__FunctionType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A class which abstracts out some details necessary for
  /// making a call.
  ///
  /// It is not actually used directly for storing this information in
  /// a FunctionType, although FunctionType does currently use the
  /// same bit-pattern.
  ///
M_template_rtpack(Xs)
struct clang::FunctionType::ExtInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FunctionType__ExtInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FunctionType::ExtInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool getNoReturn() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::getNoReturn, Xs...); }) , (;) )
  constexpr bool getProducesResult() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::getProducesResult, Xs...); }) , (;) )
  constexpr bool getNoCallerSavedRegs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::getNoCallerSavedRegs, Xs...); }) , (;) )
  constexpr bool getNoCfCheck() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::getNoCfCheck, Xs...); }) , (;) )
  constexpr bool getHasRegParm() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::getHasRegParm, Xs...); }) , (;) )
  constexpr unsigned int getRegParm() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::getRegParm, Xs...); }) , (;) )
  constexpr enum clang::CallingConv getCC() const IFMETA_ELSE( ({    return (enum clang::CallingConv)__reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::getCC, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const clang::FunctionType::ExtInfo::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FunctionType::ExtInfo)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const clang::FunctionType::ExtInfo::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FunctionType::ExtInfo)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::operator_not_eq, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionType::ExtInfo) )
  withNoReturn(bool noReturn) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::withNoReturn, Xs..., noReturn); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionType::ExtInfo) )
  withProducesResult(bool producesResult) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::withProducesResult, Xs..., producesResult); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionType::ExtInfo) )
  withNoCallerSavedRegs(bool noCallerSavedRegs) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::withNoCallerSavedRegs, Xs..., noCallerSavedRegs); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionType::ExtInfo) )
  withNoCfCheck(bool noCfCheck) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::withNoCfCheck, Xs..., noCfCheck); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionType::ExtInfo) )
  withRegParm(unsigned int RegParm) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::withRegParm, Xs..., RegParm); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionType::ExtInfo) )
  withCallingConv(enum clang::CallingConv cc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::withCallingConv, Xs..., cc); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__FunctionType__ExtInfo, reflenums::clang__FunctionType__ExtInfo::Profile, Xs..., Y0s...); }) , (;) )
};

/// Represents a K&R-style 'int foo()' function, which has
/// no information available about its arguments.
M_template_rtpack(Xs)
struct clang::FunctionNoProtoType::impl : impl_offset_t<clang::FunctionType, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 32 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FunctionNoProtoType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FunctionNoProtoType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionNoProtoType, reflenums::clang__FunctionNoProtoType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionNoProtoType, reflenums::clang__FunctionNoProtoType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) ResultType, IFMETA_ELSE((const clang::FunctionType::ExtInfo::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::FunctionType::ExtInfo)) Info) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__FunctionNoProtoType, reflenums::clang__FunctionNoProtoType::Profile, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionNoProtoType, reflenums::clang__FunctionNoProtoType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a prototype with parameter type info, e.g.
/// 'int foo(int)' or 'int foo(void)'.  'void' is represented as having no
/// parameters, not as having a single void parameter. Such a type can have an
/// exception specification, but this specification is not part of the canonical
/// type.
M_template_rtpack(Xs)
struct clang::FunctionProtoType::impl : impl_offset_t<clang::FunctionType, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 32 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FunctionProtoType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FunctionProtoType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template_rtpack(Zs) using ExtParameterInfo = struct refldetail::clang::FunctionProtoType::ExtParameterInfo::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ExceptionSpecInfo = struct refldetail::clang::FunctionProtoType::ExceptionSpecInfo::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using ExtProtoInfo = struct refldetail::clang::FunctionProtoType::ExtProtoInfo::M_template impl M_targpack(Zs);
  constexpr unsigned int getNumParams() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getNumParams, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getParamType(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getParamType, Xs..., i); }) , (;) )
  RANGE_REFLECTION(clang::FunctionProtoType, getParamTypes,
      constexpr auto getParamTypes() const ,
      (typename meta::clang::QualType),
      (reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getParamTypes, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionProtoType::ExtProtoInfo) )
  getExtProtoInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getExtProtoInfo, Xs...); }) , (;) )
  /// Get the kind of exception specification on this function.
  constexpr enum clang::ExceptionSpecificationType getExceptionSpecType() const IFMETA_ELSE( ({    return (enum clang::ExceptionSpecificationType)__reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getExceptionSpecType, Xs...); }) , (;) )
  /// Return whether this function has any kind of exception spec.
  constexpr bool hasExceptionSpec() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::hasExceptionSpec, Xs...); }) , (;) )
  /// Return whether this function has a dynamic (throw) exception spec.
  constexpr bool hasDynamicExceptionSpec() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::hasDynamicExceptionSpec, Xs...); }) , (;) )
  /// Return whether this function has a noexcept exception spec.
  constexpr bool hasNoexceptExceptionSpec() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::hasNoexceptExceptionSpec, Xs...); }) , (;) )
  /// Return whether this function has a dependent exception spec.
  constexpr bool hasDependentExceptionSpec() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::hasDependentExceptionSpec, Xs...); }) , (;) )
  /// Return whether this function has an instantiation-dependent exception
  /// spec.
  constexpr bool hasInstantiationDependentExceptionSpec() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::hasInstantiationDependentExceptionSpec, Xs...); }) , (;) )
  constexpr unsigned int getNumExceptions() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getNumExceptions, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getExceptionType(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getExceptionType, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getNoexceptExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getNoexceptExpr, Xs...); }) , (;) )
  /// If this function type has an exception specification which hasn't
  /// been determined yet (either because it has not been evaluated or because
  /// it has not been instantiated), this is the function whose exception
  /// specification is represented by this type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  getExceptionSpecDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getExceptionSpecDecl, Xs...); }) , (;) )
  /// If this function type has an uninstantiated exception
  /// specification, this is the function whose exception specification
  /// should be instantiated to find the exception specification for
  /// this type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  getExceptionSpecTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getExceptionSpecTemplate, Xs...); }) , (;) )
  /// Determine whether this function type has a non-throwing exception
  /// specification.
  constexpr enum clang::CanThrowResult canThrow() const IFMETA_ELSE( ({    return (enum clang::CanThrowResult)__reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::canThrow, Xs...); }) , (;) )
  /// Determine whether this function type has a non-throwing exception
  /// specification. If this depends on template arguments, returns
  /// \c ResultIfDependent.
  constexpr bool isNothrow(bool ResultIfDependent = false) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::isNothrow, Xs..., ResultIfDependent); }) , (;) )
  constexpr bool isVariadic() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::isVariadic, Xs...); }) , (;) )
  /// Determines whether this function prototype contains a
  /// parameter pack at the end.
  ///
  /// A function template whose last parameter is a parameter pack can be
  /// called with an arbitrary number of arguments, much like a variadic
  /// function.
  constexpr bool isTemplateVariadic() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::isTemplateVariadic, Xs...); }) , (;) )
  constexpr bool hasTrailingReturn() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::hasTrailingReturn, Xs...); }) , (;) )
  constexpr unsigned int getTypeQuals() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getTypeQuals, Xs...); }) , (;) )
  /// Retrieve the ref-qualifier associated with this function type.
  constexpr enum clang::RefQualifierKind getRefQualifier() const IFMETA_ELSE( ({    return (enum clang::RefQualifierKind)__reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getRefQualifier, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::FunctionProtoType, param_types,
      constexpr auto param_types() const ,
      (const typename meta::clang::QualType),
      (reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::param_types, Xs...), () )
  RANGE_REFLECTION(clang::FunctionProtoType, exceptions,
      constexpr auto exceptions() const ,
      (typename meta::clang::QualType),
      (reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::exceptions, Xs...), () )
  /// Is there any interesting extra information for any of the parameters
  /// of this function type?
  constexpr bool hasExtParameterInfos() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::hasExtParameterInfos, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::FunctionProtoType, getExtParameterInfos,
      constexpr auto getExtParameterInfos() const ,
      (typename meta::clang::FunctionProtoType::ExtParameterInfo),
      (reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getExtParameterInfos, Xs...), () )
  /// Return a pointer to the beginning of the array of extra parameter
  /// information, if present, or else null if none of the parameters
  /// carry it.  This is equivalent to getExtProtoInfo().ExtParameterInfos.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionProtoType::ExtParameterInfo *) )
  getExtParameterInfosOrNull() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getExtParameterInfosOrNull, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionProtoType::ExtParameterInfo) )
  getExtParameterInfo(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getExtParameterInfo, Xs..., I); }) , (;) )
  constexpr enum clang::ParameterABI getParameterABI(unsigned int I) const IFMETA_ELSE( ({    return (enum clang::ParameterABI)__reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::getParameterABI, Xs..., I); }) , (;) )
  constexpr bool isParamConsumed(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::isParamConsumed, Xs..., I); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void printExceptionSpecification(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::printExceptionSpecification, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) Result, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/1, Y2s...> *), (const typename meta::clang::QualType *)) ArgTys, unsigned int NumArgs, IFMETA_ELSE((const clang::FunctionProtoType::ExtProtoInfo::template impl</*ptrorref=*/1, Y3s...>), (const typename meta::clang::FunctionProtoType::ExtProtoInfo &)) EPI, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y4s...>), (const typename meta::clang::ASTContext &)) Context, bool Canonical) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__FunctionProtoType, reflenums::clang__FunctionProtoType::Profile, Xs..., Y0s..., Y1s..., Y2s..., NumArgs, Y3s..., Y4s..., Canonical); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr void Profile(Y0 p0, Y1 p1, ptrwrp<Y2> p2, unsigned int p3, Y3 p4, Y4 p5, bool p6) {
      return Profile(p0, p1, p2.get(), p3, p4, p5, p6);
  }), () )
};

/// Interesting information about a specific parameter that can't simply
  /// be reflected in parameter's type.
  ///
  /// It makes sense to model language features this way when there's some
  /// sort of parameter-specific override (such as an attribute) that
  /// affects how the function is called.  For example, the ARC ns_consumed
  /// attribute changes whether a parameter is passed at +0 (the default)
  /// or +1 (ns_consumed).  This must be reflected in the function type,
  /// but isn't really a change to the parameter type.
  ///
  /// One serious disadvantage of modelling language features this way is
  /// that they generally do not work with language features that attempt
  /// to destructure types.  For example, template argument deduction will
  /// not be able to match a parameter declared as
  ///   T (*)(U)
  /// against an argument of type
  ///   void (*)(__attribute__((ns_consumed)) id)
  /// because the substitution of T=void, U=id into the former will
  /// not produce the latter.
M_template_rtpack(Xs)
struct clang::FunctionProtoType::ExtParameterInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FunctionProtoType__ExtParameterInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FunctionProtoType::ExtParameterInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Return the ABI treatment of this parameter.
  constexpr enum clang::ParameterABI getABI() const IFMETA_ELSE( ({    return (enum clang::ParameterABI)__reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtParameterInfo, reflenums::clang__FunctionProtoType__ExtParameterInfo::getABI, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionProtoType::ExtParameterInfo) )
  withABI(enum clang::ParameterABI kind) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtParameterInfo, reflenums::clang__FunctionProtoType__ExtParameterInfo::withABI, Xs..., kind); }) , (;) )
  /// Is this parameter considered "consumed" by Objective-C ARC?
    /// Consumed parameters must have retainable object type.
  constexpr bool isConsumed() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtParameterInfo, reflenums::clang__FunctionProtoType__ExtParameterInfo::isConsumed, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionProtoType::ExtParameterInfo) )
  withIsConsumed(bool consumed) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtParameterInfo, reflenums::clang__FunctionProtoType__ExtParameterInfo::withIsConsumed, Xs..., consumed); }) , (;) )
  constexpr bool hasPassObjectSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtParameterInfo, reflenums::clang__FunctionProtoType__ExtParameterInfo::hasPassObjectSize, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionProtoType::ExtParameterInfo) )
  withHasPassObjectSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtParameterInfo, reflenums::clang__FunctionProtoType__ExtParameterInfo::withHasPassObjectSize, Xs...); }) , (;) )
  constexpr bool isNoEscape() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtParameterInfo, reflenums::clang__FunctionProtoType__ExtParameterInfo::isNoEscape, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionProtoType::ExtParameterInfo) )
  withIsNoEscape(bool NoEscape) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtParameterInfo, reflenums::clang__FunctionProtoType__ExtParameterInfo::withIsNoEscape, Xs..., NoEscape); }) , (;) )
  constexpr unsigned char getOpaqueValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtParameterInfo, reflenums::clang__FunctionProtoType__ExtParameterInfo::getOpaqueValue, Xs...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionProtoType::ExtParameterInfo) )
  getFromOpaqueValue(unsigned char data) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtParameterInfo, reflenums::clang__FunctionProtoType__ExtParameterInfo::getFromOpaqueValue, Xs..., data); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator==(IFMETA_ELSE((const clang::FunctionProtoType::ExtParameterInfo::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FunctionProtoType::ExtParameterInfo)) lhs, IFMETA_ELSE((const clang::FunctionProtoType::ExtParameterInfo::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::FunctionProtoType::ExtParameterInfo)) rhs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtParameterInfo, reflenums::clang__FunctionProtoType__ExtParameterInfo::operator_eq_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator!=(IFMETA_ELSE((const clang::FunctionProtoType::ExtParameterInfo::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FunctionProtoType::ExtParameterInfo)) lhs, IFMETA_ELSE((const clang::FunctionProtoType::ExtParameterInfo::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::FunctionProtoType::ExtParameterInfo)) rhs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtParameterInfo, reflenums::clang__FunctionProtoType__ExtParameterInfo::operator_not_eq, Xs..., Y0s..., Y1s...); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::FunctionProtoType::ExceptionSpecInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FunctionProtoType__ExceptionSpecInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FunctionProtoType::ExceptionSpecInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// The kind of exception specification this is.
  enum clang::ExceptionSpecificationType Type
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExceptionSpecInfo, reflenums::clang__FunctionProtoType__ExceptionSpecInfo::Type, Xs...);), (;) )
  /// Noexcept expression, if this is a computed noexcept specification.
  M_REFLTYPED_FIELD(NoexceptExpr, (typename meta::clang::Expr *), __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExceptionSpecInfo, reflenums::clang__FunctionProtoType__ExceptionSpecInfo::NoexceptExpr, Xs...))
  /// The function whose exception specification this is, for
    /// EST_Unevaluated and EST_Uninstantiated.
  M_REFLTYPED_FIELD(SourceDecl, (typename meta::clang::FunctionDecl *), __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExceptionSpecInfo, reflenums::clang__FunctionProtoType__ExceptionSpecInfo::SourceDecl, Xs...))
  /// The function template whose exception specification this is instantiated
    /// from, for EST_Uninstantiated.
  M_REFLTYPED_FIELD(SourceTemplate, (typename meta::clang::FunctionDecl *), __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExceptionSpecInfo, reflenums::clang__FunctionProtoType__ExceptionSpecInfo::SourceTemplate, Xs...))
};

/// Extra information about a function prototype.
M_template_rtpack(Xs)
struct clang::FunctionProtoType::ExtProtoInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FunctionProtoType__ExtProtoInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FunctionProtoType::ExtProtoInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_REFLTYPED_FIELD(ExtInfo, (typename meta::clang::FunctionType::ExtInfo), __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtProtoInfo, reflenums::clang__FunctionProtoType__ExtProtoInfo::ExtInfo, Xs...))
  bool Variadic
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtProtoInfo, reflenums::clang__FunctionProtoType__ExtProtoInfo::Variadic, Xs...);), (;) )
  bool HasTrailingReturn
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtProtoInfo, reflenums::clang__FunctionProtoType__ExtProtoInfo::HasTrailingReturn, Xs...);), (;) )
  unsigned char TypeQuals
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtProtoInfo, reflenums::clang__FunctionProtoType__ExtProtoInfo::TypeQuals, Xs...);), (;) )
  enum clang::RefQualifierKind RefQualifier
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtProtoInfo, reflenums::clang__FunctionProtoType__ExtProtoInfo::RefQualifier, Xs...);), (;) )
  M_REFLTYPED_FIELD(ExceptionSpec, (typename meta::clang::FunctionProtoType::ExceptionSpecInfo), __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtProtoInfo, reflenums::clang__FunctionProtoType__ExtProtoInfo::ExceptionSpec, Xs...))
  M_REFLTYPED_FIELD(ExtParameterInfos, (const typename meta::clang::FunctionProtoType::ExtParameterInfo *), __reflect_prop(reflenums::RK_clang__FunctionProtoType__ExtProtoInfo, reflenums::clang__FunctionProtoType__ExtProtoInfo::ExtParameterInfos, Xs...))
};

/// Represents the dependent type named by a dependently-scoped
/// typename using declaration, e.g.
///   using typename Base<T>::foo;
///
/// Template instantiation turns these into the underlying type.
M_template_rtpack(Xs)
struct clang::UnresolvedUsingType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UnresolvedUsingType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UnresolvedUsingType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedUsingTypenameDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingType, reflenums::clang__UnresolvedUsingType::getDecl, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingType, reflenums::clang__UnresolvedUsingType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingType, reflenums::clang__UnresolvedUsingType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingType, reflenums::clang__UnresolvedUsingType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::UnresolvedUsingTypenameDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::UnresolvedUsingTypenameDecl *)) D) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__UnresolvedUsingType, reflenums::clang__UnresolvedUsingType::Profile, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  static constexpr void Profile(Y0 p0, ptrwrp<Y1> p1) {
      return Profile(p0, p1.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::TypedefType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypedefType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypedefType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefNameDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefType, reflenums::clang__TypedefType::getDecl, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefType, reflenums::clang__TypedefType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefType, reflenums::clang__TypedefType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefType, reflenums::clang__TypedefType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a `typeof` (or __typeof__) expression (a GCC extension).
M_template_rtpack(Xs)
struct clang::TypeOfExprType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypeOfExprType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypeOfExprType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getUnderlyingExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeOfExprType, reflenums::clang__TypeOfExprType::getUnderlyingExpr, Xs...); }) , (;) )
  /// Remove a single level of sugar.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeOfExprType, reflenums::clang__TypeOfExprType::desugar, Xs...); }) , (;) )
  /// Returns whether this type directly provides sugar.
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeOfExprType, reflenums::clang__TypeOfExprType::isSugared, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeOfExprType, reflenums::clang__TypeOfExprType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents `typeof(type)`, a GCC extension.
M_template_rtpack(Xs)
struct clang::TypeOfType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypeOfType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypeOfType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getUnderlyingType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeOfType, reflenums::clang__TypeOfType::getUnderlyingType, Xs...); }) , (;) )
  /// Remove a single level of sugar.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeOfType, reflenums::clang__TypeOfType::desugar, Xs...); }) , (;) )
  /// Returns whether this type directly provides sugar.
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeOfType, reflenums::clang__TypeOfType::isSugared, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeOfType, reflenums::clang__TypeOfType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents the type `decltype(expr)` (C++11).
M_template_rtpack(Xs)
struct clang::DecltypeType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DecltypeType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DecltypeType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getUnderlyingExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DecltypeType, reflenums::clang__DecltypeType::getUnderlyingExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getUnderlyingType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DecltypeType, reflenums::clang__DecltypeType::getUnderlyingType, Xs...); }) , (;) )
  /// Remove a single level of sugar.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DecltypeType, reflenums::clang__DecltypeType::desugar, Xs...); }) , (;) )
  /// Returns whether this type directly provides sugar.
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DecltypeType, reflenums::clang__DecltypeType::isSugared, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DecltypeType, reflenums::clang__DecltypeType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// \brief Representation of reflected types.
///
/// This represents the set of types formed using the typename specifier
/// on a non-dependent expression.
///
///   struct S;
///   void f() {
///     typename($S) foo ;
///   }
///
/// As with decltype types, we preserve the underlying expression.
///
/// \todo Consider merging this implementation with DecltypeType and maybe
/// TypeofType. They all appear to have the same internal structure.
M_template_rtpack(Xs)
struct clang::ReflectedType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ReflectedType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ReflectedType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// \brief Returns the reflection of a type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getTypeReflection() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectedType, reflenums::clang__ReflectedType::getTypeReflection, Xs...); }) , (;) )
  /// \brief Returns the underlying type; the one reflected.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getUnderlyingType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectedType, reflenums::clang__ReflectedType::getUnderlyingType, Xs...); }) , (;) )
  /// \brief Returns whether this type provides sugar.
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectedType, reflenums::clang__ReflectedType::isSugared, Xs...); }) , (;) )
  /// \brief Removes one level of sugar.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectedType, reflenums::clang__ReflectedType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectedType, reflenums::clang__ReflectedType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

enum clang::UnaryTransformType::UTTKind : unsigned int {
  EnumUnderlyingType,
};

/// A unary type transform, which is a type constructed from another.
M_template_rtpack(Xs)
struct clang::UnaryTransformType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UnaryTransformType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UnaryTransformType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using UTTKind = enum refldetail::clang::UnaryTransformType::UTTKind;
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryTransformType, reflenums::clang__UnaryTransformType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryTransformType, reflenums::clang__UnaryTransformType::desugar, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getUnderlyingType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryTransformType, reflenums::clang__UnaryTransformType::getUnderlyingType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBaseType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryTransformType, reflenums::clang__UnaryTransformType::getBaseType, Xs...); }) , (;) )
  constexpr enum clang::UnaryTransformType::UTTKind getUTTKind() const IFMETA_ELSE( ({    return (enum clang::UnaryTransformType::UTTKind)__reflect_prop(reflenums::RK_clang__UnaryTransformType, reflenums::clang__UnaryTransformType::getUTTKind, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryTransformType, reflenums::clang__UnaryTransformType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::TagType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TagType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TagType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TagDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagType, reflenums::clang__TagType::getDecl, Xs...); }) , (;) )
  /// Determines whether this type is in the process of being defined.
  constexpr bool isBeingDefined() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagType, reflenums::clang__TagType::isBeingDefined, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagType, reflenums::clang__TagType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A helper class that allows the use of isa/cast/dyncast
/// to detect TagType objects of structs/unions/classes.
M_template_rtpack(Xs)
struct clang::RecordType::impl : impl_offset_t<clang::TagType, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__RecordType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::RecordType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::RecordDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordType, reflenums::clang__RecordType::getDecl, Xs...); }) , (;) )
  /// Recursively check all fields in the record for const-ness. If any field
  /// is declared const, return true. Otherwise, return false.
  constexpr bool hasConstFields() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordType, reflenums::clang__RecordType::hasConstFields, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordType, reflenums::clang__RecordType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordType, reflenums::clang__RecordType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordType, reflenums::clang__RecordType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A helper class that allows the use of isa/cast/dyncast
/// to detect TagType objects of enums.
M_template_rtpack(Xs)
struct clang::EnumType::impl : impl_offset_t<clang::TagType, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__EnumType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::EnumType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::EnumDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumType, reflenums::clang__EnumType::getDecl, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumType, reflenums::clang__EnumType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumType, reflenums::clang__EnumType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumType, reflenums::clang__EnumType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

enum clang::AttributedType::Kind : unsigned int {
  attr_address_space,
  attr_regparm,
  attr_vector_size,
  attr_neon_vector_type,
  attr_neon_polyvector_type,
  FirstExprOperandKind = 0,
  LastExprOperandKind = 4,
  attr_objc_gc,
  attr_objc_ownership,
  attr_pcs,
  attr_pcs_vfp,
  FirstEnumOperandKind = 5,
  LastEnumOperandKind = 8,
  attr_noreturn,
  attr_nocf_check,
  attr_cdecl,
  attr_fastcall,
  attr_stdcall,
  attr_thiscall,
  attr_regcall,
  attr_pascal,
  attr_swiftcall,
  attr_vectorcall,
  attr_inteloclbicc,
  attr_ms_abi,
  attr_sysv_abi,
  attr_preserve_most,
  attr_preserve_all,
  attr_ptr32,
  attr_ptr64,
  attr_sptr,
  attr_uptr,
  attr_nonnull,
  attr_ns_returns_retained,
  attr_nullable,
  attr_null_unspecified,
  attr_objc_kindof,
  attr_objc_inert_unsafe_unretained,
  attr_lifetimebound,
};

/// An attributed type is a type to which a type attribute has been applied.
///
/// The "modified type" is the fully-sugared type to which the attributed
/// type was applied; generally it is not canonically equivalent to the
/// attributed type. The "equivalent type" is the minimally-desugared type
/// which the type is canonically equivalent to.
///
/// For example, in the following attributed type:
///     int32_t __attribute__((vector_size(16)))
///   - the modified type is the TypedefType for int32_t
///   - the equivalent type is VectorType(16, int32_t)
///   - the canonical type is VectorType(16, int)
M_template_rtpack(Xs)
struct clang::AttributedType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__AttributedType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::AttributedType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using Kind = enum refldetail::clang::AttributedType::Kind;
  constexpr enum clang::AttributedType::Kind getAttrKind() const IFMETA_ELSE( ({    return (enum clang::AttributedType::Kind)__reflect_prop(reflenums::RK_clang__AttributedType, reflenums::clang__AttributedType::getAttrKind, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getModifiedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedType, reflenums::clang__AttributedType::getModifiedType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getEquivalentType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedType, reflenums::clang__AttributedType::getEquivalentType, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedType, reflenums::clang__AttributedType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedType, reflenums::clang__AttributedType::desugar, Xs...); }) , (;) )
  /// Does this attribute behave like a type qualifier?
  ///
  /// A type qualifier adjusts a type to provide specialized rules for
  /// a specific object, like the standard const and volatile qualifiers.
  /// This includes attributes controlling things like nullability,
  /// address spaces, and ARC ownership.  The value of the object is still
  /// largely described by the modified type.
  ///
  /// In contrast, many type attributes "rewrite" their modified type to
  /// produce a fundamentally different type, not necessarily related in any
  /// formalizable way to the original type.  For example, calling convention
  /// and vector attributes are not simple type qualifiers.
  ///
  /// Type qualifiers are often, but not always, reflected in the canonical
  /// type.
  constexpr bool isQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedType, reflenums::clang__AttributedType::isQualifier, Xs...); }) , (;) )
  constexpr bool isMSTypeSpec() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedType, reflenums::clang__AttributedType::isMSTypeSpec, Xs...); }) , (;) )
  constexpr bool isCallingConv() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedType, reflenums::clang__AttributedType::isCallingConv, Xs...); }) , (;) )
  /// Retrieve the attribute kind corresponding to the given
  /// nullability kind.
  static constexpr enum clang::AttributedType::Kind getNullabilityAttrKind(enum clang::NullabilityKind kind) IFMETA_ELSE( ({    return (enum clang::AttributedType::Kind)__reflect_prop(reflenums::RK_clang__AttributedType, reflenums::clang__AttributedType::getNullabilityAttrKind, Xs..., kind); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, enum clang::AttributedType::Kind attrKind, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) modified, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) equivalent) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__AttributedType, reflenums::clang__AttributedType::Profile, Xs..., Y0s..., attrKind, Y1s..., Y2s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedType, reflenums::clang__AttributedType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::TemplateTypeParmType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TemplateTypeParmType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TemplateTypeParmType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr unsigned int getDepth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmType, reflenums::clang__TemplateTypeParmType::getDepth, Xs...); }) , (;) )
  constexpr unsigned int getIndex() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmType, reflenums::clang__TemplateTypeParmType::getIndex, Xs...); }) , (;) )
  constexpr bool isParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmType, reflenums::clang__TemplateTypeParmType::isParameterPack, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateTypeParmDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmType, reflenums::clang__TemplateTypeParmType::getDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmType, reflenums::clang__TemplateTypeParmType::getIdentifier, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmType, reflenums::clang__TemplateTypeParmType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmType, reflenums::clang__TemplateTypeParmType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, unsigned int Depth, unsigned int Index, bool ParameterPack, IFMETA_ELSE((const clang::TemplateTypeParmDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::TemplateTypeParmDecl *)) TTPDecl) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__TemplateTypeParmType, reflenums::clang__TemplateTypeParmType::Profile, Xs..., Y0s..., Depth, Index, ParameterPack, Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  static constexpr void Profile(Y0 p0, unsigned int p1, unsigned int p2, bool p3, ptrwrp<Y1> p4) {
      return Profile(p0, p1, p2, p3, p4.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmType, reflenums::clang__TemplateTypeParmType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents the result of substituting a type for a template
/// type parameter.
///
/// Within an instantiated template, all template type parameters have
/// been replaced with these.  They are used solely to record that a
/// type was originally written as a template type parameter;
/// therefore they are never canonical.
M_template_rtpack(Xs)
struct clang::SubstTemplateTypeParmType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SubstTemplateTypeParmType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SubstTemplateTypeParmType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Gets the template parameter that was substituted for.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateTypeParmType *) )
  getReplacedParameter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTypeParmType, reflenums::clang__SubstTemplateTypeParmType::getReplacedParameter, Xs...); }) , (;) )
  /// Gets the type that was substituted for the template
  /// parameter.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getReplacementType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTypeParmType, reflenums::clang__SubstTemplateTypeParmType::getReplacementType, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTypeParmType, reflenums::clang__SubstTemplateTypeParmType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTypeParmType, reflenums::clang__SubstTemplateTypeParmType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::TemplateTypeParmType::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::TemplateTypeParmType *)) Replaced, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) Replacement) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__SubstTemplateTypeParmType, reflenums::clang__SubstTemplateTypeParmType::Profile, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr void Profile(Y0 p0, ptrwrp<Y1> p1, Y2 p2) {
      return Profile(p0, p1.get(), p2);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTypeParmType, reflenums::clang__SubstTemplateTypeParmType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents the result of substituting a set of types for a template
/// type parameter pack.
///
/// When a pack expansion in the source code contains multiple parameter packs
/// and those parameter packs correspond to different levels of template
/// parameter lists, this type node is used to represent a template type
/// parameter pack from an outer level, which has already had its argument pack
/// substituted but that still lives within a pack expansion that itself
/// could not be instantiated. When actually performing a substitution into
/// that pack expansion (e.g., when all template parameters have corresponding
/// arguments), this type will be replaced with the \c SubstTemplateTypeParmType
/// at the current pack substitution index.
M_template_rtpack(Xs)
struct clang::SubstTemplateTypeParmPackType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SubstTemplateTypeParmPackType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SubstTemplateTypeParmPackType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTypeParmPackType, reflenums::clang__SubstTemplateTypeParmPackType::getIdentifier, Xs...); }) , (;) )
  /// Gets the template parameter that was substituted for.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateTypeParmType *) )
  getReplacedParameter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTypeParmPackType, reflenums::clang__SubstTemplateTypeParmPackType::getReplacedParameter, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTypeParmPackType, reflenums::clang__SubstTemplateTypeParmPackType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTypeParmPackType, reflenums::clang__SubstTemplateTypeParmPackType::desugar, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateArgument) )
  getArgumentPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTypeParmPackType, reflenums::clang__SubstTemplateTypeParmPackType::getArgumentPack, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::TemplateTypeParmType::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::TemplateTypeParmType *)) Replaced, IFMETA_ELSE((const clang::TemplateArgument::template impl</*ptrorref=*/1, Y2s...>), (const typename meta::clang::TemplateArgument &)) ArgPack) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__SubstTemplateTypeParmPackType, reflenums::clang__SubstTemplateTypeParmPackType::Profile, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr void Profile(Y0 p0, ptrwrp<Y1> p1, Y2 p2) {
      return Profile(p0, p1.get(), p2);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstTemplateTypeParmPackType, reflenums::clang__SubstTemplateTypeParmPackType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Common base class for placeholders for types that get replaced by
/// placeholder type deduction: C++11 auto, C++14 decltype(auto), C++17 deduced
/// class template types, and (eventually) constrained type names from the C++
/// Concepts TS.
///
/// These types are usually a placeholder for a deduced type. However, before
/// the initializer is attached, or (usually) if the initializer is
/// type-dependent, there is no deduced type and the type is canonical. In
/// the latter case, it is also a dependent type.
M_template_rtpack(Xs)
struct clang::DeducedType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DeducedType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DeducedType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeducedType, reflenums::clang__DeducedType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeducedType, reflenums::clang__DeducedType::desugar, Xs...); }) , (;) )
  /// Get the type deduced for this placeholder type, or null if it's
  /// either not been deduced or was deduced to a dependent type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDeducedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeducedType, reflenums::clang__DeducedType::getDeducedType, Xs...); }) , (;) )
  constexpr bool isDeduced() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeducedType, reflenums::clang__DeducedType::isDeduced, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeducedType, reflenums::clang__DeducedType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a C++11 auto or C++14 decltype(auto) type.
M_template_rtpack(Xs)
struct clang::AutoType::impl : impl_offset_t<clang::DeducedType, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__AutoType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::AutoType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isDecltypeAuto() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AutoType, reflenums::clang__AutoType::isDecltypeAuto, Xs...); }) , (;) )
  constexpr enum clang::AutoTypeKeyword getKeyword() const IFMETA_ELSE( ({    return (enum clang::AutoTypeKeyword)__reflect_prop(reflenums::RK_clang__AutoType, reflenums::clang__AutoType::getKeyword, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) Deduced, enum clang::AutoTypeKeyword Keyword, bool IsDependent) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__AutoType, reflenums::clang__AutoType::Profile, Xs..., Y0s..., Y1s..., Keyword, IsDependent); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AutoType, reflenums::clang__AutoType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a C++17 deduced template specialization type.
M_template_rtpack(Xs)
struct clang::DeducedTemplateSpecializationType::impl : impl_offset_t<clang::DeducedType, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DeducedTemplateSpecializationType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DeducedTemplateSpecializationType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the name of the template that we are deducing.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getTemplateName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeducedTemplateSpecializationType, reflenums::clang__DeducedTemplateSpecializationType::getTemplateName, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::TemplateName::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::TemplateName)) Template, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) Deduced, bool IsDependent) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DeducedTemplateSpecializationType, reflenums::clang__DeducedTemplateSpecializationType::Profile, Xs..., Y0s..., Y1s..., Y2s..., IsDependent); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeducedTemplateSpecializationType, reflenums::clang__DeducedTemplateSpecializationType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a type template specialization; the template
/// must be a class template, a type alias template, or a template
/// template parameter.  A template which cannot be resolved to one of
/// these, e.g. because it is written with a dependent scope
/// specifier, is instead represented as a
/// @c DependentTemplateSpecializationType.
///
/// A non-dependent template specialization type is always "sugar",
/// typically for a \c RecordType.  For example, a class template
/// specialization type of \c vector<int> will refer to a tag type for
/// the instantiation \c std::vector<int, std::allocator<int>>
///
/// Template specializations are dependent if either the template or
/// any of the template arguments are dependent, in which case the
/// type may also be canonical.
///
/// Instances of this type are allocated with a trailing array of
/// TemplateArguments, followed by a QualType representing the
/// non-canonical aliased type when the template is a type alias
/// template.
M_template_rtpack(Xs)
struct clang::TemplateSpecializationType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TemplateSpecializationType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TemplateSpecializationType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// True if this template specialization type matches a current
  /// instantiation in the context in which it is found.
  constexpr bool isCurrentInstantiation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateSpecializationType, reflenums::clang__TemplateSpecializationType::isCurrentInstantiation, Xs...); }) , (;) )
  /// Determine if this template specialization type is for a type alias
  /// template that has been substituted.
  ///
  /// Nearly every template specialization type whose template is an alias
  /// template will be substituted. However, this is not the case when
  /// the specialization contains a pack expansion but the template alias
  /// does not have a corresponding parameter pack, e.g.,
  ///
  /// \code
  /// template<typename T, typename U, typename V> struct S;
  /// template<typename T, typename U> using A = S<T, int, U>;
  /// template<typename... Ts> struct X {
  ///   typedef A<Ts...> type; // not a type alias
  /// };
  /// \endcode
  constexpr bool isTypeAlias() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateSpecializationType, reflenums::clang__TemplateSpecializationType::isTypeAlias, Xs...); }) , (;) )
  /// Get the aliased type, if this is a specialization of a type alias
  /// template.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAliasedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateSpecializationType, reflenums::clang__TemplateSpecializationType::getAliasedType, Xs...); }) , (;) )
  /// Retrieve the name of the template that we are specializing.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getTemplateName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateSpecializationType, reflenums::clang__TemplateSpecializationType::getTemplateName, Xs...); }) , (;) )
  /// Retrieve the template arguments.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgument *) )
  getArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateSpecializationType, reflenums::clang__TemplateSpecializationType::getArgs, Xs...); }) , (;) )
  /// Retrieve the number of template arguments.
  constexpr unsigned int getNumArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateSpecializationType, reflenums::clang__TemplateSpecializationType::getNumArgs, Xs...); }) , (;) )
  /// Retrieve a specific template argument as a type.
  /// \pre \c isArgType(Arg)
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgument &) )
  getArg(unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateSpecializationType, reflenums::clang__TemplateSpecializationType::getArg, Xs..., Idx); }) , (;) )
  RANGE_REFLECTION(clang::TemplateSpecializationType, template_arguments,
      constexpr auto template_arguments() const ,
      (typename meta::clang::TemplateArgument),
      (reflenums::RK_clang__TemplateSpecializationType, reflenums::clang__TemplateSpecializationType::template_arguments, Xs...), () )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateSpecializationType, reflenums::clang__TemplateSpecializationType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateSpecializationType, reflenums::clang__TemplateSpecializationType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateSpecializationType, reflenums::clang__TemplateSpecializationType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGECLASS_SIZE_AND_GET(clang__TemplateSpecializationType, const typename meta::clang::TemplateArgument);
};

/// The injected class name of a C++ class template or class
/// template partial specialization.  Used to record that a type was
/// spelled with a bare identifier rather than as a template-id; the
/// equivalent for non-templated classes is just RecordType.
///
/// Injected class name types are always dependent.  Template
/// instantiation turns these into RecordTypes.
///
/// Injected class name types are always canonical.  This works
/// because it is impossible to compare an injected class name type
/// with the corresponding non-injected template type, for the same
/// reason that it is impossible to directly compare template
/// parameters from different dependent contexts: injected class name
/// types can only occur within the scope of a particular templated
/// declaration, and within that scope every template specialization
/// will canonicalize to the injected class name (when appropriate
/// according to the rules of the language).
M_template_rtpack(Xs)
struct clang::InjectedClassNameType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__InjectedClassNameType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::InjectedClassNameType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getInjectedSpecializationType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InjectedClassNameType, reflenums::clang__InjectedClassNameType::getInjectedSpecializationType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateSpecializationType *) )
  getInjectedTST() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InjectedClassNameType, reflenums::clang__InjectedClassNameType::getInjectedTST, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getTemplateName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InjectedClassNameType, reflenums::clang__InjectedClassNameType::getTemplateName, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InjectedClassNameType, reflenums::clang__InjectedClassNameType::getDecl, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InjectedClassNameType, reflenums::clang__InjectedClassNameType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InjectedClassNameType, reflenums::clang__InjectedClassNameType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InjectedClassNameType, reflenums::clang__InjectedClassNameType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// The kind of a tag type.
enum clang::TagTypeKind : unsigned int {
  /// The "struct" keyword.
  TTK_Struct,
  /// The "__interface" keyword.
  TTK_Interface,
  /// The "union" keyword.
  TTK_Union,
  /// The "class" keyword.
  TTK_Class,
  /// The "enum" keyword.
  TTK_Enum,
};

/// The elaboration keyword that precedes a qualified type name or
/// introduces an elaborated-type-specifier.
enum clang::ElaboratedTypeKeyword : unsigned int {
  /// The "struct" keyword introduces the elaborated-type-specifier.
  ETK_Struct,
  /// The "__interface" keyword introduces the elaborated-type-specifier.
  ETK_Interface,
  /// The "union" keyword introduces the elaborated-type-specifier.
  ETK_Union,
  /// The "class" keyword introduces the elaborated-type-specifier.
  ETK_Class,
  /// The "enum" keyword introduces the elaborated-type-specifier.
  ETK_Enum,
  /// The "typename" keyword precedes the qualified type name, e.g.,
  /// \c typename T::type.
  ETK_Typename,
  /// No keyword precedes the qualified type name.
  ETK_None,
};

/// A helper class for Type nodes having an ElaboratedTypeKeyword.
/// The keyword in stored in the free bits of the base class.
/// Also provides a few static helpers for converting and printing
/// elaborated type keyword and tag type kind enumerations.
M_template_rtpack(Xs)
struct clang::TypeWithKeyword::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypeWithKeyword;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypeWithKeyword::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr enum clang::ElaboratedTypeKeyword getKeyword() const IFMETA_ELSE( ({    return (enum clang::ElaboratedTypeKeyword)__reflect_prop(reflenums::RK_clang__TypeWithKeyword, reflenums::clang__TypeWithKeyword::getKeyword, Xs...); }) , (;) )
  /// Converts a type specifier (DeclSpec::TST) into an elaborated type keyword.
  static constexpr enum clang::ElaboratedTypeKeyword getKeywordForTypeSpec(unsigned int TypeSpec) IFMETA_ELSE( ({    return (enum clang::ElaboratedTypeKeyword)__reflect_prop(reflenums::RK_clang__TypeWithKeyword, reflenums::clang__TypeWithKeyword::getKeywordForTypeSpec, Xs..., TypeSpec); }) , (;) )
  /// Converts a type specifier (DeclSpec::TST) into a tag type kind.
  /// It is an error to provide a type specifier which *isn't* a tag kind here.
  static constexpr enum clang::TagTypeKind getTagTypeKindForTypeSpec(unsigned int TypeSpec) IFMETA_ELSE( ({    return (enum clang::TagTypeKind)__reflect_prop(reflenums::RK_clang__TypeWithKeyword, reflenums::clang__TypeWithKeyword::getTagTypeKindForTypeSpec, Xs..., TypeSpec); }) , (;) )
  /// Converts a TagTypeKind into an elaborated type keyword.
  static constexpr enum clang::ElaboratedTypeKeyword getKeywordForTagTypeKind(enum clang::TagTypeKind Tag) IFMETA_ELSE( ({    return (enum clang::ElaboratedTypeKeyword)__reflect_prop(reflenums::RK_clang__TypeWithKeyword, reflenums::clang__TypeWithKeyword::getKeywordForTagTypeKind, Xs..., Tag); }) , (;) )
  /// Converts an elaborated type keyword into a TagTypeKind.
  /// It is an error to provide an elaborated type keyword
  /// which *isn't* a tag kind here.
  static constexpr enum clang::TagTypeKind getTagTypeKindForKeyword(enum clang::ElaboratedTypeKeyword Keyword) IFMETA_ELSE( ({    return (enum clang::TagTypeKind)__reflect_prop(reflenums::RK_clang__TypeWithKeyword, reflenums::clang__TypeWithKeyword::getTagTypeKindForKeyword, Xs..., Keyword); }) , (;) )
  static constexpr bool KeywordIsTagTypeKind(enum clang::ElaboratedTypeKeyword Keyword) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeWithKeyword, reflenums::clang__TypeWithKeyword::KeywordIsTagTypeKind, Xs..., Keyword); }) , (;) )
  static constexpr const char * getKeywordName(enum clang::ElaboratedTypeKeyword Keyword) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeWithKeyword, reflenums::clang__TypeWithKeyword::getKeywordName, Xs..., Keyword); }) , (;) )
  static constexpr const char * getTagTypeKindName(enum clang::TagTypeKind Kind) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeWithKeyword, reflenums::clang__TypeWithKeyword::getTagTypeKindName, Xs..., Kind); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeWithKeyword, reflenums::clang__TypeWithKeyword::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a type that was referred to using an elaborated type
/// keyword, e.g., struct S, or via a qualified name, e.g., N::M::type,
/// or both.
///
/// This type is used to keep track of a type name as written in the
/// source code, including tag keywords and any nested-name-specifiers.
/// The type itself is always "sugar", used to express what was written
/// in the source code but containing no additional semantic information.
M_template_rtpack(Xs)
struct clang::ElaboratedType::impl : impl_offset_t<clang::TypeWithKeyword, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ElaboratedType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ElaboratedType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the qualification on this type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ElaboratedType, reflenums::clang__ElaboratedType::getQualifier, Xs...); }) , (;) )
  /// Retrieve the type named by the qualified-id.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getNamedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ElaboratedType, reflenums::clang__ElaboratedType::getNamedType, Xs...); }) , (;) )
  /// Remove a single level of sugar.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ElaboratedType, reflenums::clang__ElaboratedType::desugar, Xs...); }) , (;) )
  /// Returns whether this type directly provides sugar.
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ElaboratedType, reflenums::clang__ElaboratedType::isSugared, Xs...); }) , (;) )
  /// Return the (re)declaration of this type owned by this occurrence of this
  /// type, or nullptr if none.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TagDecl *) )
  getOwnedTagDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ElaboratedType, reflenums::clang__ElaboratedType::getOwnedTagDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, enum clang::ElaboratedTypeKeyword Keyword, IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::NestedNameSpecifier *)) NNS, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) NamedType, IFMETA_ELSE((const clang::TagDecl::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::TagDecl *)) OwnedTagDecl) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ElaboratedType, reflenums::clang__ElaboratedType::Profile, Xs..., Y0s..., Keyword, Y1s..., Y2s..., Y3s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr void Profile(Y0 p0, enum clang::ElaboratedTypeKeyword p1, ptrwrp<Y1> p2, Y2 p3, ptrwrp<Y3> p4) {
      return Profile(p0, p1, p2.get(), p3, p4.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ElaboratedType, reflenums::clang__ElaboratedType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a qualified type name for which the type name is
/// dependent.
///
/// DependentNameType represents a class of dependent types that involve a
/// possibly dependent nested-name-specifier (e.g., "T::") followed by a
/// name of a type. The DependentNameType may start with a "typename" (for a
/// typename-specifier), "class", "struct", "union", or "enum" (for a
/// dependent elaborated-type-specifier), or nothing (in contexts where we
/// know that we must be referring to a type, e.g., in a base class specifier).
/// Typically the nested-name-specifier is dependent, but in MSVC compatibility
/// mode, this type is used with non-dependent names to delay name lookup until
/// instantiation.
M_template_rtpack(Xs)
struct clang::DependentNameType::impl : impl_offset_t<clang::TypeWithKeyword, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DependentNameType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DependentNameType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the qualification on this type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentNameType, reflenums::clang__DependentNameType::getQualifier, Xs...); }) , (;) )
  /// Retrieve the type named by the typename specifier as an identifier.
  ///
  /// This routine will return a non-NULL identifier pointer when the
  /// form of the original typename was terminated by an identifier,
  /// e.g., "typename T::type".
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::IdentifierInfo *) )
  getIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentNameType, reflenums::clang__DependentNameType::getIdentifier, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentNameType, reflenums::clang__DependentNameType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentNameType, reflenums::clang__DependentNameType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, enum clang::ElaboratedTypeKeyword Keyword, IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::NestedNameSpecifier *)) NNS, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y2s...> *), (const typename meta::clang::IdentifierInfo *)) Name) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DependentNameType, reflenums::clang__DependentNameType::Profile, Xs..., Y0s..., Keyword, Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr void Profile(Y0 p0, enum clang::ElaboratedTypeKeyword p1, ptrwrp<Y1> p2, ptrwrp<Y2> p3) {
      return Profile(p0, p1, p2.get(), p3.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentNameType, reflenums::clang__DependentNameType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a template specialization type whose template cannot be
/// resolved, e.g.
///   A<T>::template B<T>
M_template_rtpack(Xs)
struct clang::DependentTemplateSpecializationType::impl : impl_offset_t<clang::TypeWithKeyword, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DependentTemplateSpecializationType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DependentTemplateSpecializationType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentTemplateSpecializationType, reflenums::clang__DependentTemplateSpecializationType::getQualifier, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::IdentifierInfo *) )
  getIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentTemplateSpecializationType, reflenums::clang__DependentTemplateSpecializationType::getIdentifier, Xs...); }) , (;) )
  /// Retrieve the template arguments.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgument *) )
  getArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentTemplateSpecializationType, reflenums::clang__DependentTemplateSpecializationType::getArgs, Xs...); }) , (;) )
  /// Retrieve the number of template arguments.
  constexpr unsigned int getNumArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentTemplateSpecializationType, reflenums::clang__DependentTemplateSpecializationType::getNumArgs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgument &) )
  getArg(unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentTemplateSpecializationType, reflenums::clang__DependentTemplateSpecializationType::getArg, Xs..., Idx); }) , (;) )
  RANGE_REFLECTION(clang::DependentTemplateSpecializationType, template_arguments,
      constexpr auto template_arguments() const ,
      (typename meta::clang::TemplateArgument),
      (reflenums::RK_clang__DependentTemplateSpecializationType, reflenums::clang__DependentTemplateSpecializationType::template_arguments, Xs...), () )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentTemplateSpecializationType, reflenums::clang__DependentTemplateSpecializationType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentTemplateSpecializationType, reflenums::clang__DependentTemplateSpecializationType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentTemplateSpecializationType, reflenums::clang__DependentTemplateSpecializationType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGECLASS_SIZE_AND_GET(clang__DependentTemplateSpecializationType, const typename meta::clang::TemplateArgument);
};

/// Represents a pack expansion of types.
///
/// Pack expansions are part of C++11 variadic templates. A pack
/// expansion contains a pattern, which itself contains one or more
/// "unexpanded" parameter packs. When instantiated, a pack expansion
/// produces a series of types, each instantiated from the pattern of
/// the expansion, where the Ith instantiation of the pattern uses the
/// Ith arguments bound to each of the unexpanded parameter packs. The
/// pack expansion is considered to "expand" these unexpanded
/// parameter packs.
///
/// \code
/// template<typename ...Types> struct tuple;
///
/// template<typename ...Types>
/// struct tuple_of_references {
///   typedef tuple<Types&...> type;
/// };
/// \endcode
///
/// Here, the pack expansion \c Types&... is represented via a
/// PackExpansionType whose pattern is Types&.
M_template_rtpack(Xs)
struct clang::PackExpansionType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__PackExpansionType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::PackExpansionType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the pattern of this pack expansion, which is the
  /// type that will be repeatedly instantiated when instantiating the
  /// pack expansion itself.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPattern() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PackExpansionType, reflenums::clang__PackExpansionType::getPattern, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PackExpansionType, reflenums::clang__PackExpansionType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PackExpansionType, reflenums::clang__PackExpansionType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PackExpansionType, reflenums::clang__PackExpansionType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a type parameter type in Objective C. It can take
/// a list of protocols.
M_template_rtpack(Xs)
struct clang::ObjCTypeParamType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCTypeParamType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCTypeParamType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  RANGE_REFLECTION(clang::ObjCTypeParamType, quals,
      constexpr auto quals() const ,
      (typename meta::clang::ObjCProtocolDecl *const),
      (reflenums::RK_clang__ObjCTypeParamType, reflenums::clang__ObjCTypeParamType::quals, Xs...), () )
  constexpr bool qual_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamType, reflenums::clang__ObjCTypeParamType::qual_empty, Xs...); }) , (;) )
  constexpr unsigned int getNumProtocols() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamType, reflenums::clang__ObjCTypeParamType::getNumProtocols, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCProtocolDecl *) )
  getProtocol(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamType, reflenums::clang__ObjCTypeParamType::getProtocol, Xs..., I); }) , (;) )
  RANGE_REFLECTION(clang::ObjCTypeParamType, getProtocols,
      constexpr auto getProtocols() const ,
      (typename meta::clang::ObjCProtocolDecl *),
      (reflenums::RK_clang__ObjCTypeParamType, reflenums::clang__ObjCTypeParamType::getProtocols, Xs...), () )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamType, reflenums::clang__ObjCTypeParamType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamType, reflenums::clang__ObjCTypeParamType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamType, reflenums::clang__ObjCTypeParamType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCTypeParamDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamType, reflenums::clang__ObjCTypeParamType::getDecl, Xs...); }) , (;) )
};

/// Represents a class type in Objective C.
///
/// Every Objective C type is a combination of a base type, a set of
/// type arguments (optional, for parameterized classes) and a list of
/// protocols.
///
/// Given the following declarations:
/// \code
///   \@class C<T>;
///   \@protocol P;
/// \endcode
///
/// 'C' is an ObjCInterfaceType C.  It is sugar for an ObjCObjectType
/// with base C and no protocols.
///
/// 'C<P>' is an unspecialized ObjCObjectType with base C and protocol list [P].
/// 'C<C*>' is a specialized ObjCObjectType with type arguments 'C*' and no
/// protocol list.
/// 'C<C*><P>' is a specialized ObjCObjectType with base C, type arguments 'C*',
/// and protocol list [P].
///
/// 'id' is a TypedefType which is sugar for an ObjCObjectPointerType whose
/// pointee is an ObjCObjectType with base BuiltinType::ObjCIdType
/// and no protocols.
///
/// 'id<P>' is an ObjCObjectPointerType whose pointee is an ObjCObjectType
/// with base BuiltinType::ObjCIdType and protocol list [P].  Eventually
/// this should get its own sugar class to better represent the source.
M_template_rtpack(Xs)
struct clang::ObjCObjectType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCObjectType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCObjectType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  RANGE_REFLECTION(clang::ObjCObjectType, quals,
      constexpr auto quals() const ,
      (typename meta::clang::ObjCProtocolDecl *const),
      (reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::quals, Xs...), () )
  constexpr bool qual_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::qual_empty, Xs...); }) , (;) )
  constexpr unsigned int getNumProtocols() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::getNumProtocols, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCProtocolDecl *) )
  getProtocol(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::getProtocol, Xs..., I); }) , (;) )
  RANGE_REFLECTION(clang::ObjCObjectType, getProtocols,
      constexpr auto getProtocols() const ,
      (typename meta::clang::ObjCProtocolDecl *),
      (reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::getProtocols, Xs...), () )
  /// Gets the base type of this object type.  This is always (possibly
  /// sugar for) one of:
  ///  - the 'id' builtin type (as opposed to the 'id' type visible to the
  ///    user, which is a typedef for an ObjCObjectPointerType)
  ///  - the 'Class' builtin type (same caveat)
  ///  - an ObjCObjectType (currently always an ObjCInterfaceType)
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBaseType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::getBaseType, Xs...); }) , (;) )
  constexpr bool isObjCId() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isObjCId, Xs...); }) , (;) )
  constexpr bool isObjCClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isObjCClass, Xs...); }) , (;) )
  constexpr bool isObjCUnqualifiedId() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isObjCUnqualifiedId, Xs...); }) , (;) )
  constexpr bool isObjCUnqualifiedClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isObjCUnqualifiedClass, Xs...); }) , (;) )
  constexpr bool isObjCUnqualifiedIdOrClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isObjCUnqualifiedIdOrClass, Xs...); }) , (;) )
  constexpr bool isObjCQualifiedId() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isObjCQualifiedId, Xs...); }) , (;) )
  constexpr bool isObjCQualifiedClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isObjCQualifiedClass, Xs...); }) , (;) )
  /// Gets the interface declaration for this object type, if the base type
  /// really is an interface.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCInterfaceDecl *) )
  getInterface() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::getInterface, Xs...); }) , (;) )
  /// Determine whether this object type is "specialized", meaning
  /// that it has type arguments.
  constexpr bool isSpecialized() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isSpecialized, Xs...); }) , (;) )
  /// Determine whether this object type was written with type arguments.
  constexpr bool isSpecializedAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isSpecializedAsWritten, Xs...); }) , (;) )
  /// Determine whether this object type is "unspecialized", meaning
  /// that it has no type arguments.
  constexpr bool isUnspecialized() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isUnspecialized, Xs...); }) , (;) )
  /// Determine whether this object type is "unspecialized" as
  /// written, meaning that it has no type arguments.
  constexpr bool isUnspecializedAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isUnspecializedAsWritten, Xs...); }) , (;) )
  /// Retrieve the type arguments of this object type (semantically).
  RANGE_REFLECTION(clang::ObjCObjectType, getTypeArgs,
      constexpr auto getTypeArgs() const ,
      (typename meta::clang::QualType),
      (reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::getTypeArgs, Xs...), () )
  /// Retrieve the type arguments of this object type as they were
  /// written.
  RANGE_REFLECTION(clang::ObjCObjectType, getTypeArgsAsWritten,
      constexpr auto getTypeArgsAsWritten() const ,
      (typename meta::clang::QualType),
      (reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::getTypeArgsAsWritten, Xs...), () )
  /// Whether this is a "__kindof" type as written.
  constexpr bool isKindOfTypeAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isKindOfTypeAsWritten, Xs...); }) , (;) )
  /// Whether this ia a "__kindof" type (semantically).
  constexpr bool isKindOfType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isKindOfType, Xs...); }) , (;) )
  /// Retrieve the type of the superclass of this object type.
  ///
  /// This operation substitutes any type arguments into the
  /// superclass of the current class type, potentially producing a
  /// specialization of the superclass type. Produces a null type if
  /// there is no superclass.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getSuperClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::getSuperClassType, Xs...); }) , (;) )
  /// Strip off the Objective-C "kindof" type and (with it) any
  /// protocol qualifiers.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  stripObjCKindOfTypeAndQuals(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::stripObjCKindOfTypeAndQuals, Xs..., Y0s...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectType, reflenums::clang__ObjCObjectType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Interfaces are the core concept in Objective-C for object oriented design.
/// They basically correspond to C++ classes.  There are two kinds of interface
/// types: normal interfaces like `NSString`, and qualified interfaces, which
/// are qualified with a protocol list like `NSString<NSCopyable, NSAmazing>`.
///
/// ObjCInterfaceType guarantees the following properties when considered
/// as a subtype of its superclass, ObjCObjectType:
///   - There are no protocol qualifiers.  To reinforce this, code which
///     tries to invoke the protocol methods via an ObjCInterfaceType will
///     fail to compile.
///   - It is its own base type.  That is, if T is an ObjCInterfaceType*,
///     T->getBaseType() == QualType(T, 0).
M_template_rtpack(Xs)
struct clang::ObjCInterfaceType::impl : impl_offset_t<clang::ObjCObjectType, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCInterfaceType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCInterfaceType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Get the declaration of this interface.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCInterfaceDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceType, reflenums::clang__ObjCInterfaceType::getDecl, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceType, reflenums::clang__ObjCInterfaceType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceType, reflenums::clang__ObjCInterfaceType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceType, reflenums::clang__ObjCInterfaceType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a pointer to an Objective C object.
///
/// These are constructed from pointer declarators when the pointee type is
/// an ObjCObjectType (or sugar for one).  In addition, the 'id' and 'Class'
/// types are typedefs for these, and the protocol-qualified types 'id<P>'
/// and 'Class<P>' are translated into these.
///
/// Pointers to pointers to Objective C objects are still PointerTypes;
/// only the first level of pointer gets it own type implementation.
M_template_rtpack(Xs)
struct clang::ObjCObjectPointerType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCObjectPointerType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCObjectPointerType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Gets the type pointed to by this ObjC pointer.
  /// The result will always be an ObjCObjectType or sugar thereof.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPointeeType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::getPointeeType, Xs...); }) , (;) )
  /// Gets the type pointed to by this ObjC pointer.  Always returns non-null.
  ///
  /// This method is equivalent to getPointeeType() except that
  /// it discards any typedefs (or other sugar) between this
  /// type and the "outermost" object type.  So for:
  /// \code
  ///   \@class A; \@protocol P; \@protocol Q;
  ///   typedef A<P> AP;
  ///   typedef A A1;
  ///   typedef A1<P> A1P;
  ///   typedef A1P<Q> A1PQ;
  /// \endcode
  /// For 'A*', getObjectType() will return 'A'.
  /// For 'A<P>*', getObjectType() will return 'A<P>'.
  /// For 'AP*', getObjectType() will return 'A<P>'.
  /// For 'A1*', getObjectType() will return 'A'.
  /// For 'A1<P>*', getObjectType() will return 'A1<P>'.
  /// For 'A1P*', getObjectType() will return 'A1<P>'.
  /// For 'A1PQ*', getObjectType() will return 'A1<Q>', because
  ///   adding protocols to a protocol-qualified base discards the
  ///   old qualifiers (for now).  But if it didn't, getObjectType()
  ///   would return 'A1P<Q>' (and we'd have to make iterating over
  ///   qualifiers more complicated).
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCObjectType *) )
  getObjectType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::getObjectType, Xs...); }) , (;) )
  /// If this pointer points to an Objective C
  /// \@interface type, gets the type for that interface.  Any protocol
  /// qualifiers on the interface are ignored.
  ///
  /// \return null if the base type for this pointer is 'id' or 'Class'
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceType *) )
  getInterfaceType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::getInterfaceType, Xs...); }) , (;) )
  /// If this pointer points to an Objective \@interface
  /// type, gets the declaration for that interface.
  ///
  /// \return null if the base type for this pointer is 'id' or 'Class'
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCInterfaceDecl *) )
  getInterfaceDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::getInterfaceDecl, Xs...); }) , (;) )
  /// True if this is equivalent to the 'id' type, i.e. if
  /// its object type is the primitive 'id' type with no protocols.
  constexpr bool isObjCIdType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::isObjCIdType, Xs...); }) , (;) )
  /// True if this is equivalent to the 'Class' type,
  /// i.e. if its object tive is the primitive 'Class' type with no protocols.
  constexpr bool isObjCClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::isObjCClassType, Xs...); }) , (;) )
  /// True if this is equivalent to the 'id' or 'Class' type,
  constexpr bool isObjCIdOrClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::isObjCIdOrClassType, Xs...); }) , (;) )
  /// True if this is equivalent to 'id<P>' for some non-empty set of
  /// protocols.
  constexpr bool isObjCQualifiedIdType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::isObjCQualifiedIdType, Xs...); }) , (;) )
  /// True if this is equivalent to 'Class<P>' for some non-empty set of
  /// protocols.
  constexpr bool isObjCQualifiedClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::isObjCQualifiedClassType, Xs...); }) , (;) )
  /// Whether this is a "__kindof" type.
  constexpr bool isKindOfType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::isKindOfType, Xs...); }) , (;) )
  /// Whether this type is specialized, meaning that it has type arguments.
  constexpr bool isSpecialized() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::isSpecialized, Xs...); }) , (;) )
  /// Whether this type is specialized, meaning that it has type arguments.
  constexpr bool isSpecializedAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::isSpecializedAsWritten, Xs...); }) , (;) )
  /// Whether this type is unspecialized, meaning that is has no type arguments.
  constexpr bool isUnspecialized() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::isUnspecialized, Xs...); }) , (;) )
  /// Determine whether this object type is "unspecialized" as
  /// written, meaning that it has no type arguments.
  constexpr bool isUnspecializedAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::isUnspecializedAsWritten, Xs...); }) , (;) )
  /// Retrieve the type arguments for this type.
  RANGE_REFLECTION(clang::ObjCObjectPointerType, getTypeArgs,
      constexpr auto getTypeArgs() const ,
      (typename meta::clang::QualType),
      (reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::getTypeArgs, Xs...), () )
  /// Retrieve the type arguments for this type.
  RANGE_REFLECTION(clang::ObjCObjectPointerType, getTypeArgsAsWritten,
      constexpr auto getTypeArgsAsWritten() const ,
      (typename meta::clang::QualType),
      (reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::getTypeArgsAsWritten, Xs...), () )
  RANGE_REFLECTION(clang::ObjCObjectPointerType, quals,
      constexpr auto quals() const ,
      (typename meta::clang::ObjCProtocolDecl *const),
      (reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::quals, Xs...), () )
  constexpr bool qual_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::qual_empty, Xs...); }) , (;) )
  /// Return the number of qualifying protocols on the object type.
  constexpr unsigned int getNumProtocols() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::getNumProtocols, Xs...); }) , (;) )
  /// Retrieve a qualifying protocol by index on the object type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCProtocolDecl *) )
  getProtocol(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::getProtocol, Xs..., I); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::desugar, Xs...); }) , (;) )
  /// Retrieve the type of the superclass of this object pointer type.
  ///
  /// This operation substitutes any type arguments into the
  /// superclass of the current class type, potentially producing a
  /// pointer to a specialization of the superclass type. Produces a
  /// null type if there is no superclass.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getSuperClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::getSuperClassType, Xs...); }) , (;) )
  /// Strip off the Objective-C "kindof" type and (with it) any
  /// protocol qualifiers.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCObjectPointerType *) )
  stripObjCKindOfTypeAndQuals(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::stripObjCKindOfTypeAndQuals, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) T) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::Profile, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCObjectPointerType, reflenums::clang__ObjCObjectPointerType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::AtomicType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__AtomicType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::AtomicType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Gets the type contained by this atomic type, i.e.
  /// the type returned by performing an atomic load of this atomic type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getValueType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicType, reflenums::clang__AtomicType::getValueType, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicType, reflenums::clang__AtomicType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicType, reflenums::clang__AtomicType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) T) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__AtomicType, reflenums::clang__AtomicType::Profile, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicType, reflenums::clang__AtomicType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// PipeType - OpenCL20.
M_template_rtpack(Xs)
struct clang::PipeType::impl : impl_offset_t<clang::Type, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 24 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__PipeType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::PipeType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getElementType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PipeType, reflenums::clang__PipeType::getElementType, Xs...); }) , (;) )
  constexpr bool isSugared() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PipeType, reflenums::clang__PipeType::isSugared, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  desugar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PipeType, reflenums::clang__PipeType::desugar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) T, bool isRead) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__PipeType, reflenums::clang__PipeType::Profile, Xs..., Y0s..., Y1s..., isRead); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PipeType, reflenums::clang__PipeType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  constexpr bool isReadOnly() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PipeType, reflenums::clang__PipeType::isReadOnly, Xs...); }) , (;) )
};

/// Enumeration specifying the different kinds of C++ overloaded
/// operators.
enum clang::OverloadedOperatorKind : int {
  ///< Not an overloaded operator
  OO_None,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_New,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Delete,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Array_New,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Array_Delete,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Plus,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Minus,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Star,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Slash,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Percent,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Caret,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Amp,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Pipe,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Tilde,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Exclaim,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Equal,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Less,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Greater,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_PlusEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_MinusEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_StarEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_SlashEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_PercentEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_CaretEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_AmpEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_PipeEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_LessLess,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_GreaterGreater,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_LessLessEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_GreaterGreaterEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_EqualEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_ExclaimEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_LessEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_GreaterEqual,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Spaceship,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_AmpAmp,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_PipePipe,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_PlusPlus,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_MinusMinus,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Comma,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_ArrowStar,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Arrow,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Call,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Subscript,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Conditional,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  OO_Coawait,
  /// @file OperatorKinds.def
///
/// In this file, each of the overloadable C++ operators is enumerated
/// with either the OVERLOADED_OPERATOR or OVERLOADED_OPERATOR_MULTI
/// macro, each of which can be specified by the code including this
/// file. OVERLOADED_OPERATOR is used for single-token operators
/// (e.g., "+"), and has six arguments:
///
/// Name: The name of the token. OO_Name will be the name of the
/// corresponding enumerator in OverloadedOperatorKind in
/// OperatorKinds.h.
///
/// Spelling: A string that provides a canonical spelling for the
/// operator, e.g., "operator+".
///
/// Token: The name of the token that specifies the operator, e.g.,
/// "plus" for operator+ or "greatergreaterequal" for
/// "operator>>=". With a "kw_" prefix, the token name can be used as
/// an enumerator into the TokenKind enumeration.
///
/// Unary: True if the operator can be declared as a unary operator.
///
/// Binary: True if the operator can be declared as a binary
/// operator. Note that some operators (e.g., "operator+" and
/// "operator*") can be both unary and binary.
///
/// MemberOnly: True if this operator can only be declared as a
/// non-static member function. False if the operator can be both a
/// non-member function and a non-static member function.
///
/// OVERLOADED_OPERATOR_MULTI is used to enumerate the multi-token
/// overloaded operator names, e.g., "operator delete []". The macro
/// has all of the parameters of OVERLOADED_OPERATOR except Token,
/// which is omitted.
  NUM_OVERLOADED_OPERATORS,
};

enum clang::PragmaMSCommentKind : unsigned int {
  PCK_Unknown,
  PCK_Linker,
  PCK_Lib,
  PCK_Compiler,
  PCK_ExeStr,
  PCK_User,
};

/// A container of type source information.
///
/// A client can read the relevant info using TypeLoc wrappers, e.g:
/// @code
/// TypeLoc TL = TypeSourceInfo->getTypeLoc();
/// TL.getStartLoc().print(OS, SrcMgr);
/// @endcode
M_template_rtpack(Xs)
struct clang::TypeSourceInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypeSourceInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypeSourceInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Return the type wrapped by this type source info.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeSourceInfo, reflenums::clang__TypeSourceInfo::getType, Xs...); }) , (;) )
  /// Return the TypeLoc wrapper for the type source info.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeLoc) )
  getTypeLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeSourceInfo, reflenums::clang__TypeSourceInfo::getTypeLoc, Xs...); }) , (;) )
};

/// The top declaration context.
M_template_rtpack(Xs)
struct clang::TranslationUnitDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)>, impl_offset_t<clang::DeclContext, 40 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TranslationUnitDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TranslationUnitDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ASTContext &) )
  getASTContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TranslationUnitDecl, reflenums::clang__TranslationUnitDecl::getASTContext, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamespaceDecl *) )
  getAnonymousNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TranslationUnitDecl, reflenums::clang__TranslationUnitDecl::getAnonymousNamespace, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TranslationUnitDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TranslationUnitDecl, reflenums::clang__TranslationUnitDecl::Create, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TranslationUnitDecl, reflenums::clang__TranslationUnitDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TranslationUnitDecl, reflenums::clang__TranslationUnitDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a `#pragma comment` line. Always a child of
/// TranslationUnitDecl.
M_template_rtpack(Xs)
struct clang::PragmaCommentDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__PragmaCommentDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::PragmaCommentDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::PragmaCommentDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID, unsigned int ArgSize) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PragmaCommentDecl, reflenums::clang__PragmaCommentDecl::CreateDeserialized, Xs..., Y0s..., ID, ArgSize); }) , (;) )
  constexpr enum clang::PragmaMSCommentKind getCommentKind() const IFMETA_ELSE( ({    return (enum clang::PragmaMSCommentKind)__reflect_prop(reflenums::RK_clang__PragmaCommentDecl, reflenums::clang__PragmaCommentDecl::getCommentKind, Xs...); }) , (;) )
  constexpr const char * getArg() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PragmaCommentDecl, reflenums::clang__PragmaCommentDecl::getArg, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PragmaCommentDecl, reflenums::clang__PragmaCommentDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PragmaCommentDecl, reflenums::clang__PragmaCommentDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a `#pragma detect_mismatch` line. Always a child of
/// TranslationUnitDecl.
M_template_rtpack(Xs)
struct clang::PragmaDetectMismatchDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__PragmaDetectMismatchDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::PragmaDetectMismatchDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::PragmaDetectMismatchDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID, unsigned int NameValueSize) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PragmaDetectMismatchDecl, reflenums::clang__PragmaDetectMismatchDecl::CreateDeserialized, Xs..., Y0s..., ID, NameValueSize); }) , (;) )
  constexpr const char * getName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PragmaDetectMismatchDecl, reflenums::clang__PragmaDetectMismatchDecl::getName, Xs...); }) , (;) )
  constexpr const char * getValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PragmaDetectMismatchDecl, reflenums::clang__PragmaDetectMismatchDecl::getValue, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PragmaDetectMismatchDecl, reflenums::clang__PragmaDetectMismatchDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PragmaDetectMismatchDecl, reflenums::clang__PragmaDetectMismatchDecl::classofKind, Xs..., K); }) , (;) )
};

/// Declaration context for names declared as extern "C" in C++. This
/// is neither the semantic nor lexical context for such declarations, but is
/// used to check for conflicts with other extern "C" declarations. Example:
///
/// \code
///   namespace N { extern "C" void f(); } // #1
///   void N::f() {}                       // #2
///   namespace M { extern "C" void f(); } // #3
/// \endcode
///
/// The semantic context of #1 is namespace N and its lexical context is the
/// LinkageSpecDecl; the semantic context of #2 is namespace N and its lexical
/// context is the TU. However, both declarations are also visible in the
/// extern "C" context.
///
/// The declaration at #3 finds it is a redeclaration of \c N::f through
/// lookup in the extern "C" context.
M_template_rtpack(Xs)
struct clang::ExternCContextDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)>, impl_offset_t<clang::DeclContext, 40 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ExternCContextDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ExternCContextDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ExternCContextDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::TranslationUnitDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::TranslationUnitDecl *)) TU) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExternCContextDecl, reflenums::clang__ExternCContextDecl::Create, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ExternCContextDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1) {
      return Create(p0, p1.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExternCContextDecl, reflenums::clang__ExternCContextDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExternCContextDecl, reflenums::clang__ExternCContextDecl::classofKind, Xs..., K); }) , (;) )
};

/// This represents a decl that may have a name.  Many decls have names such
/// as ObjCMethodDecl, but not \@class, etc.
///
/// Note that not every NamedDecl is actually named (e.g., a struct might
/// be anonymous), and not every name is an identifier.
M_template_rtpack(Xs)
struct clang::NamedDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__NamedDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::NamedDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Get the identifier that names this declaration, if there is one.
  ///
  /// This will return NULL if this declaration has no name (e.g., for
  /// an unnamed class) or if the name is a special name (C++ constructor,
  /// Objective-C selector, etc.).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::getIdentifier, Xs...); }) , (;) )
  /// Get the name of identifier for this declaration as a StringRef.
  ///
  /// This requires that the declaration have a name and that it be a simple
  /// identifier.
  constexpr const char * getName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::getName, Xs...); }) , (;) )
  /// Get a human-readable name for the declaration, even if it is one of the
  /// special kinds of names (C++ constructor, Objective-C selector, etc).
  ///
  /// Creating this name requires expensive string manipulation, so it should
  /// be called only when performance doesn't matter. For simple declarations,
  /// getNameAsCString() should suffice.
  constexpr const char * getNameAsString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::getNameAsString, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void printName(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) os) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::printName, Xs..., Y0s...); }) , (;) )
  /// Get the actual, stored name of the declaration, which may be a special
  /// name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationName) )
  getDeclName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::getDeclName, Xs...); }) , (;) )
  /// Returns a human-readable qualified name for this declaration, like
  /// A::B::i, for i being member of namespace A::B.
  ///
  /// If the declaration is not a member of context which can be named (record,
  /// namespace), it will return the same result as printName().
  ///
  /// Creating this name is expensive, so it should be called only when
  /// performance doesn't matter.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void printQualifiedName(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::printQualifiedName, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void printQualifiedName(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::printQualifiedName1, Xs..., Y0s..., Y1s...); }) , (;) )
  constexpr const char * getQualifiedNameAsString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::getQualifiedNameAsString, Xs...); }) , (;) )
  /// Appends a human-readable name for this declaration into the given stream.
  ///
  /// This is the method invoked by Sema when displaying a NamedDecl
  /// in a diagnostic.  It does not necessarily produce the same
  /// result as printName(); for example, class template
  /// specializations are printed with their template arguments.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void getNameForDiagnostic(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy, bool Qualified) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::getNameForDiagnostic, Xs..., Y0s..., Y1s..., Qualified); }) , (;) )
  /// Determine whether this declaration, if known to be well-formed within
  /// its context, will replace the declaration OldD if introduced into scope.
  ///
  /// A declaration will replace another declaration if, for example, it is
  /// a redeclaration of the same variable or function, but not if it is a
  /// declaration of a different kind (function vs. class) or an overloaded
  /// function.
  ///
  /// \param IsKnownNewer \c true if this declaration is known to be newer
  /// than \p OldD (for instance, if this declaration is newly-created).
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool declarationReplaces(IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::NamedDecl *)) OldD, bool IsKnownNewer = true) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::declarationReplaces, Xs..., Y0s..., IsKnownNewer); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool declarationReplaces(ptrwrp<Y0> p0, bool p1 = true) const {
      return declarationReplaces(p0.get(), p1);
  }), () )
  /// Determine whether this declaration has linkage.
  constexpr bool hasLinkage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::hasLinkage, Xs...); }) , (;) )
  /// Determine whether this declaration is a C++ class member.
  constexpr bool isCXXClassMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::isCXXClassMember, Xs...); }) , (;) )
  /// Determine whether the given declaration is an instance member of
  /// a C++ class.
  constexpr bool isCXXInstanceMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::isCXXInstanceMember, Xs...); }) , (;) )
  /// Determine what kind of linkage this entity has.
  ///
  /// This is not the linkage as defined by the standard or the codegen notion
  /// of linkage. It is just an implementation detail that is used to compute
  /// those.
  constexpr enum clang::Linkage getLinkageInternal() const IFMETA_ELSE( ({    return (enum clang::Linkage)__reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::getLinkageInternal, Xs...); }) , (;) )
  /// Get the linkage from a semantic point of view. Entities in
  /// anonymous namespaces are external (in c++98).
  constexpr enum clang::Linkage getFormalLinkage() const IFMETA_ELSE( ({    return (enum clang::Linkage)__reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::getFormalLinkage, Xs...); }) , (;) )
  /// True if this decl has external linkage.
  constexpr bool hasExternalFormalLinkage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::hasExternalFormalLinkage, Xs...); }) , (;) )
  constexpr bool isExternallyVisible() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::isExternallyVisible, Xs...); }) , (;) )
  /// Determine whether this declaration can be redeclared in a
  /// different translation unit.
  constexpr bool isExternallyDeclarable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::isExternallyDeclarable, Xs...); }) , (;) )
  /// Determines the visibility of this entity.
  constexpr enum clang::Visibility getVisibility() const IFMETA_ELSE( ({    return (enum clang::Visibility)__reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::getVisibility, Xs...); }) , (;) )
  /// Determines the linkage and visibility of this entity.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::LinkageInfo) )
  getLinkageAndVisibility() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::getLinkageAndVisibility, Xs...); }) , (;) )
  /// True if the computed linkage is valid. Used for consistency
  /// checking. Should always return true.
  constexpr bool isLinkageValid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::isLinkageValid, Xs...); }) , (;) )
  /// True if something has required us to compute the linkage
  /// of this declaration.
  ///
  /// Language features which can retroactively change linkage (like a
  /// typedef name for linkage purposes) may need to consider this,
  /// but hopefully only in transitory ways during parsing.
  constexpr bool hasLinkageBeenComputed() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::hasLinkageBeenComputed, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamedDecl *) )
  getUnderlyingDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::getUnderlyingDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamedDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::getMostRecentDecl, Xs...); }) , (;) )
  constexpr enum clang::ObjCStringFormatFamily getObjCFStringFormattingFamily() const IFMETA_ELSE( ({    return (enum clang::ObjCStringFormatFamily)__reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::getObjCFStringFormattingFamily, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamedDecl, reflenums::clang__NamedDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents the declaration of a label.  Labels also have a
/// corresponding LabelStmt, which indicates the position that the label was
/// defined at.  For normal labels, the location of the decl is the same as the
/// location of the statement.  For GNU local labels (__label__), the decl
/// location is where the __label__ is.
M_template_rtpack(Xs)
struct clang::LabelDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__LabelDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::LabelDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LabelDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) IdentL, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::IdentifierInfo *)) II) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelDecl, reflenums::clang__LabelDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LabelDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, ptrwrp<Y3> p3) {
      return Create(p0, p1.get(), p2, p3.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LabelDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) IdentL, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::IdentifierInfo *)) II, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::SourceLocation)) GnuLabelL) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelDecl, reflenums::clang__LabelDecl::Create1, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LabelDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, ptrwrp<Y3> p3, Y4 p4) {
      return Create(p0, p1.get(), p2, p3.get(), p4);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LabelDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelDecl, reflenums::clang__LabelDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::LabelStmt *) )
  getStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelDecl, reflenums::clang__LabelDecl::getStmt, Xs...); }) , (;) )
  constexpr bool isGnuLocal() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelDecl, reflenums::clang__LabelDecl::isGnuLocal, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelDecl, reflenums::clang__LabelDecl::getSourceRange, Xs...); }) , (;) )
  constexpr bool isMSAsmLabel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelDecl, reflenums::clang__LabelDecl::isMSAsmLabel, Xs...); }) , (;) )
  constexpr bool isResolvedMSAsmLabel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelDecl, reflenums::clang__LabelDecl::isResolvedMSAsmLabel, Xs...); }) , (;) )
  constexpr const char * getMSAsmLabel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelDecl, reflenums::clang__LabelDecl::getMSAsmLabel, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelDecl, reflenums::clang__LabelDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelDecl, reflenums::clang__LabelDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represent a C++ namespace.
M_template_rtpack(Xs)
struct clang::NamespaceDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)>, impl_offset_t<clang::DeclContext, 48 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__NamespaceDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::NamespaceDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamespaceDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamespaceDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::getFirstDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamespaceDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::getMostRecentDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamespaceDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, bool Inline, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) IdLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::NamespaceDecl::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::NamespaceDecl *)) PrevDecl) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::Create, Xs..., Y0s..., Y1s..., Inline, Y2s..., Y3s..., Y4s..., Y5s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamespaceDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, bool p2, Y2 p3, Y3 p4, ptrwrp<Y4> p5, ptrwrp<Y5> p6) {
      return Create(p0, p1.get(), p2, p3, p4, p5.get(), p6.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamespaceDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// Returns true if this is an anonymous namespace declaration.
  ///
  /// For example:
  /// \code
  ///   namespace {
  ///     ...
  ///   };
  /// \endcode
  /// q.v. C++ [namespace.unnamed]
  constexpr bool isAnonymousNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::isAnonymousNamespace, Xs...); }) , (;) )
  /// Returns true if this is an inline namespace declaration.
  constexpr bool isInline() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::isInline, Xs...); }) , (;) )
  /// Get the original (first) namespace declaration.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamespaceDecl *) )
  getOriginalNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::getOriginalNamespace, Xs...); }) , (;) )
  /// Return true if this declaration is an original (first) declaration
  /// of the namespace. This is false for non-original (subsequent) namespace
  /// declarations and anonymous namespaces.
  constexpr bool isOriginalNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::isOriginalNamespace, Xs...); }) , (;) )
  /// Retrieve the anonymous namespace nested inside this namespace,
  /// if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamespaceDecl *) )
  getAnonymousNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::getAnonymousNamespace, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamespaceDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::getCanonicalDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRBraceLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::getRBraceLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceDecl, reflenums::clang__NamespaceDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represent the declaration of a variable (in which case it is
/// an lvalue) a function (in which case it is a function designator) or
/// an enum constant.
M_template_rtpack(Xs)
struct clang::ValueDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ValueDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ValueDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ValueDecl, reflenums::clang__ValueDecl::getType, Xs...); }) , (;) )
  /// Determine whether this symbol is weakly-imported,
  ///        or declared with the weak or weak-ref attr.
  constexpr bool isWeak() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ValueDecl, reflenums::clang__ValueDecl::isWeak, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ValueDecl, reflenums::clang__ValueDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ValueDecl, reflenums::clang__ValueDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a ValueDecl that came out of a declarator.
/// Contains type source information through TypeSourceInfo.
M_template_rtpack(Xs)
struct clang::DeclaratorDecl::impl : impl_offset_t<clang::ValueDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DeclaratorDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DeclaratorDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclaratorDecl, reflenums::clang__DeclaratorDecl::getTypeSourceInfo, Xs...); }) , (;) )
  /// Return start of source range ignoring outer template declarations.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getInnerLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclaratorDecl, reflenums::clang__DeclaratorDecl::getInnerLocStart, Xs...); }) , (;) )
  /// Return start of source range taking into account any outer template
  /// declarations.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOuterLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclaratorDecl, reflenums::clang__DeclaratorDecl::getOuterLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclaratorDecl, reflenums::clang__DeclaratorDecl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclaratorDecl, reflenums::clang__DeclaratorDecl::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclaratorDecl, reflenums::clang__DeclaratorDecl::getBeginLoc, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the name of this
  /// declaration, if it was present in the source.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclaratorDecl, reflenums::clang__DeclaratorDecl::getQualifier, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier (with source-location
  /// information) that qualifies the name of this declaration, if it was
  /// present in the source.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclaratorDecl, reflenums::clang__DeclaratorDecl::getQualifierLoc, Xs...); }) , (;) )
  constexpr unsigned int getNumTemplateParameterLists() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclaratorDecl, reflenums::clang__DeclaratorDecl::getNumTemplateParameterLists, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateParameterList *) )
  getTemplateParameterList(unsigned int index) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclaratorDecl, reflenums::clang__DeclaratorDecl::getTemplateParameterList, Xs..., index); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTypeSpecStartLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclaratorDecl, reflenums::clang__DeclaratorDecl::getTypeSpecStartLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclaratorDecl, reflenums::clang__DeclaratorDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclaratorDecl, reflenums::clang__DeclaratorDecl::classofKind, Xs..., K); }) , (;) )
};

/// Structure used to store a statement, the constant value to
/// which it was evaluated (if any), and whether or not the statement
/// is an integral constant expression (if known).
M_template_rtpack(Xs)
struct clang::EvaluatedStmt::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__EvaluatedStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::EvaluatedStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Whether this statement was already evaluated.
  bool WasEvaluated
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__EvaluatedStmt, reflenums::clang__EvaluatedStmt::WasEvaluated, Xs...);), (;) )
  /// Whether this statement is being evaluated.
  bool IsEvaluating
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__EvaluatedStmt, reflenums::clang__EvaluatedStmt::IsEvaluating, Xs...);), (;) )
  /// Whether we already checked whether this statement was an
  /// integral constant expression.
  bool CheckedICE
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__EvaluatedStmt, reflenums::clang__EvaluatedStmt::CheckedICE, Xs...);), (;) )
  /// Whether we are checking whether this statement is an
  /// integral constant expression.
  bool CheckingICE
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__EvaluatedStmt, reflenums::clang__EvaluatedStmt::CheckingICE, Xs...);), (;) )
  /// Whether this statement is an integral constant expression,
  /// or in C++11, whether the statement is a constant expression. Only
  /// valid if CheckedICE is true.
  bool IsICE
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__EvaluatedStmt, reflenums::clang__EvaluatedStmt::IsICE, Xs...);), (;) )
  M_REFLTYPED_FIELD(Value, (typename meta::clang::Stmt *), __reflect_prop(reflenums::RK_clang__EvaluatedStmt, reflenums::clang__EvaluatedStmt::Value, Xs...))
};

/// Initialization styles.
enum clang::VarDecl::InitializationStyle : unsigned int {
  /// C-style initialization with assignment
  CInit,
  /// Call-style initialization (C++98)
  CallInit,
  /// Direct list-initialization (C++11)
  ListInit,
};

/// Kinds of thread-local storage.
enum clang::VarDecl::TLSKind : unsigned int {
  /// Not a TLS variable.
  TLS_None,
  /// TLS with a known-constant initializer.
  TLS_Static,
  /// TLS with a dynamic initializer.
  TLS_Dynamic,
};

enum clang::VarDecl::DefinitionKind : unsigned int {
  /// This declaration is only a declaration.
  DeclarationOnly,
  /// This declaration is a tentative definition.
  TentativeDefinition,
  /// This declaration is definitely a definition.
  Definition,
};

/// Represents a variable declaration or definition.
M_template_rtpack(Xs)
struct clang::VarDecl::impl : impl_offset_t<clang::DeclaratorDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__VarDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::VarDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getFirstDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getMostRecentDecl, Xs...); }) , (;) )
  using InitializationStyle = enum refldetail::clang::VarDecl::InitializationStyle;
  using TLSKind = enum refldetail::clang::VarDecl::TLSKind;
  /// Return the string used to specify the storage class \p SC.
  ///
  /// It is illegal to call this function with SC == None.
  static constexpr const char * getStorageClassSpecifierString(enum clang::StorageClass SC) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getStorageClassSpecifierString, Xs..., SC); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) IdLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, enum clang::StorageClass S) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., S); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, Y5 p5, ptrwrp<Y6> p6, enum clang::StorageClass p7) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5, p6.get(), p7);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::DeclarationNameInfo)) NameInfo, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, enum clang::StorageClass S) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::Create1, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., S); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, ptrwrp<Y5> p5, enum clang::StorageClass p6) {
      return Create(p0, p1.get(), p2, p3, p4, p5.get(), p6);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getSourceRange, Xs...); }) , (;) )
  /// Returns the storage class as written in the source. For the
  /// computed linkage of symbol, see getLinkage.
  constexpr enum clang::StorageClass getStorageClass() const IFMETA_ELSE( ({    return (enum clang::StorageClass)__reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getStorageClass, Xs...); }) , (;) )
  constexpr enum clang::ThreadStorageClassSpecifier getTSCSpec() const IFMETA_ELSE( ({    return (enum clang::ThreadStorageClassSpecifier)__reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getTSCSpec, Xs...); }) , (;) )
  constexpr enum clang::VarDecl::TLSKind getTLSKind() const IFMETA_ELSE( ({    return (enum clang::VarDecl::TLSKind)__reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getTLSKind, Xs...); }) , (;) )
  /// Returns true if a variable with function scope is a non-static local
  /// variable.
  constexpr bool hasLocalStorage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::hasLocalStorage, Xs...); }) , (;) )
  /// Returns true if a variable with function scope is a static local
  /// variable.
  constexpr bool isStaticLocal() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isStaticLocal, Xs...); }) , (;) )
  /// Returns true if a variable has extern or __private_extern__
  /// storage.
  constexpr bool hasExternalStorage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::hasExternalStorage, Xs...); }) , (;) )
  /// Returns true for all variables that do not have local storage.
  ///
  /// This includes all global variables as well as static variables declared
  /// within a function.
  constexpr bool hasGlobalStorage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::hasGlobalStorage, Xs...); }) , (;) )
  /// Get the storage duration of this variable, per C++ [basic.stc].
  constexpr enum clang::StorageDuration getStorageDuration() const IFMETA_ELSE( ({    return (enum clang::StorageDuration)__reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getStorageDuration, Xs...); }) , (;) )
  /// Compute the language linkage.
  constexpr enum clang::LanguageLinkage getLanguageLinkage() const IFMETA_ELSE( ({    return (enum clang::LanguageLinkage)__reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getLanguageLinkage, Xs...); }) , (;) )
  /// Determines whether this variable is a variable with external, C linkage.
  constexpr bool isExternC() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isExternC, Xs...); }) , (;) )
  /// Determines whether this variable's context is, or is nested within,
  /// a C++ extern "C" linkage spec.
  constexpr bool isInExternCContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isInExternCContext, Xs...); }) , (;) )
  /// Determines whether this variable's context is, or is nested within,
  /// a C++ extern "C++" linkage spec.
  constexpr bool isInExternCXXContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isInExternCXXContext, Xs...); }) , (;) )
  /// Returns true for local variable declarations other than parameters.
  /// Note that this includes static variables inside of functions. It also
  /// includes variables inside blocks.
  ///
  ///   void foo() { int x; static int y; extern int z; }
  constexpr bool isLocalVarDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isLocalVarDecl, Xs...); }) , (;) )
  /// Similar to isLocalVarDecl but also includes parameters.
  constexpr bool isLocalVarDeclOrParm() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isLocalVarDeclOrParm, Xs...); }) , (;) )
  /// Similar to isLocalVarDecl, but excludes variables declared in blocks.
  constexpr bool isFunctionOrMethodVarDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isFunctionOrMethodVarDecl, Xs...); }) , (;) )
  /// Determines whether this is a static data member.
  ///
  /// This will only be true in C++, and applies to, e.g., the
  /// variable 'x' in:
  /// \code
  /// struct S {
  ///   static int x;
  /// };
  /// \endcode
  constexpr bool isStaticDataMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isStaticDataMember, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getCanonicalDecl, Xs...); }) , (;) )
  using DefinitionKind = enum refldetail::clang::VarDecl::DefinitionKind;
  /// Check whether this declaration is a definition. If this could be
  /// a tentative definition (in C), don't check whether there's an overriding
  /// definition.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum clang::VarDecl::DefinitionKind isThisDeclarationADefinition(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) p0) const IFMETA_ELSE( ({    return (enum clang::VarDecl::DefinitionKind)__reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isThisDeclarationADefinition, Xs..., Y0s...); }) , (;) )
  constexpr enum clang::VarDecl::DefinitionKind isThisDeclarationADefinition() const IFMETA_ELSE( ({    return (enum clang::VarDecl::DefinitionKind)__reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isThisDeclarationADefinition1, Xs...); }) , (;) )
  /// Check whether this variable is defined in this translation unit.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum clang::VarDecl::DefinitionKind hasDefinition(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) p0) const IFMETA_ELSE( ({    return (enum clang::VarDecl::DefinitionKind)__reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::hasDefinition, Xs..., Y0s...); }) , (;) )
  constexpr enum clang::VarDecl::DefinitionKind hasDefinition() const IFMETA_ELSE( ({    return (enum clang::VarDecl::DefinitionKind)__reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::hasDefinition1, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarDecl *) )
  getActingDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getActingDefinition, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarDecl *) )
  getDefinition(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getDefinition, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarDecl *) )
  getDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getDefinition1, Xs...); }) , (;) )
  /// Determine whether this is or was instantiated from an out-of-line
  /// definition of a static data member.
  constexpr bool isOutOfLine() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isOutOfLine, Xs...); }) , (;) )
  /// Returns true for file scoped variable declaration.
  constexpr bool isFileVarDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isFileVarDecl, Xs...); }) , (;) )
  /// Get the initializer for this variable, no matter which
  /// declaration it is attached to.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getAnyInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getAnyInitializer, Xs...); }) , (;) )
  /// Get the initializer for this variable, no matter which
  /// declaration it is attached to. Also get that declaration.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getAnyInitializer(IFMETA_ELSE((const clang::VarDecl::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::VarDecl *&)) D) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getAnyInitializer1, Xs..., Y0s...); }) , (;) )
  constexpr bool hasInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::hasInit, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getInit, Xs...); }) , (;) )
  /// Determine whether this variable's value can be used in a
  /// constant expression, according to the relevant language standard.
  /// This only checks properties of the declaration, and does not check
  /// whether the initializer is in fact a constant expression.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isUsableInConstantExpressions(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isUsableInConstantExpressions, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::EvaluatedStmt *) )
  ensureEvaluatedStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::ensureEvaluatedStmt, Xs...); }) , (;) )
  /// Attempt to evaluate the value of the initializer attached to this
  /// declaration, and produce notes explaining why it cannot be evaluated or is
  /// not a constant expression. Returns a pointer to the value if evaluation
  /// succeeded, 0 otherwise.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::APValue *) )
  evaluateValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::evaluateValue, Xs...); }) , (;) )
  /// Return the already-evaluated value of this variable's
  /// initializer, or NULL if the value is not yet known. Returns pointer
  /// to untyped APValue if the value could not be evaluated.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::APValue *) )
  getEvaluatedValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getEvaluatedValue, Xs...); }) , (;) )
  /// Determines whether it is already known whether the
  /// initializer is an integral constant expression or not.
  constexpr bool isInitKnownICE() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isInitKnownICE, Xs...); }) , (;) )
  /// Determines whether the initializer is an integral constant
  /// expression, or in C++11, whether the initializer is a constant
  /// expression.
  ///
  /// \pre isInitKnownICE()
  constexpr bool isInitICE() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isInitICE, Xs...); }) , (;) )
  /// Determine whether the value of the initializer attached to this
  /// declaration is an integral constant expression.
  constexpr bool checkInitIsICE() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::checkInitIsICE, Xs...); }) , (;) )
  /// The style of initialization for this declaration.
  ///
  /// C-style initialization is "int x = 1;". Call-style initialization is
  /// a C++98 direct-initializer, e.g. "int x(1);". The Init expression will be
  /// the expression inside the parens or a "ClassType(a,b,c)" class constructor
  /// expression for class types. List-style initialization is C++11 syntax,
  /// e.g. "int x{1};". Clients can distinguish between different forms of
  /// initialization by checking this value. In particular, "int x = {1};" is
  /// C-style, "int x({1})" is call-style, and "int x{1};" is list-style; the
  /// Init expression in all three cases is an InitListExpr.
  constexpr enum clang::VarDecl::InitializationStyle getInitStyle() const IFMETA_ELSE( ({    return (enum clang::VarDecl::InitializationStyle)__reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getInitStyle, Xs...); }) , (;) )
  /// Whether the initializer is a direct-initializer (list or call).
  constexpr bool isDirectInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isDirectInit, Xs...); }) , (;) )
  /// If this definition should pretend to be a declaration.
  constexpr bool isThisDeclarationADemotedDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isThisDeclarationADemotedDefinition, Xs...); }) , (;) )
  /// Determine whether this variable is the exception variable in a
  /// C++ catch statememt or an Objective-C \@catch statement.
  constexpr bool isExceptionVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isExceptionVariable, Xs...); }) , (;) )
  /// Determine whether this local variable can be used with the named
  /// return value optimization (NRVO).
  ///
  /// The named return value optimization (NRVO) works by marking certain
  /// non-volatile local variables of class type as NRVO objects. These
  /// locals can be allocated within the return slot of their containing
  /// function, in which case there is no need to copy the object to the
  /// return slot when returning from the function. Within the function body,
  /// each return that returns the NRVO object will have this variable as its
  /// NRVO candidate.
  constexpr bool isNRVOVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isNRVOVariable, Xs...); }) , (;) )
  /// Determine whether this variable is the for-range-declaration in
  /// a C++0x for-range statement.
  constexpr bool isCXXForRangeDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isCXXForRangeDecl, Xs...); }) , (;) )
  /// Determine whether this variable is a for-loop declaration for a
  /// for-in statement in Objective-C.
  constexpr bool isObjCForDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isObjCForDecl, Xs...); }) , (;) )
  /// Determine whether this variable is an ARC pseudo-__strong
  /// variable.  A pseudo-__strong variable has a __strong-qualified
  /// type but does not actually retain the object written into it.
  /// Generally such variables are also 'const' for safety.
  constexpr bool isARCPseudoStrong() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isARCPseudoStrong, Xs...); }) , (;) )
  /// Whether this variable is (C++1z) inline.
  constexpr bool isInline() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isInline, Xs...); }) , (;) )
  constexpr bool isInlineSpecified() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isInlineSpecified, Xs...); }) , (;) )
  /// Whether this variable is (C++11) constexpr.
  constexpr bool isConstexpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isConstexpr, Xs...); }) , (;) )
  /// Whether this variable is the implicit variable for a lambda init-capture.
  constexpr bool isInitCapture() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isInitCapture, Xs...); }) , (;) )
  /// Whether this local extern variable declaration's previous declaration
  /// was declared in the same block scope. Only correct in C++.
  constexpr bool isPreviousDeclInSameBlockScope() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isPreviousDeclInSameBlockScope, Xs...); }) , (;) )
  /// Retrieve the variable declaration from which this variable could
  /// be instantiated, if it is an instantiation (rather than a non-template).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getTemplateInstantiationPattern() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getTemplateInstantiationPattern, Xs...); }) , (;) )
  /// If this variable is an instantiated static data member of a
  /// class template specialization, returns the templated static data member
  /// from which it was instantiated.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getInstantiatedFromStaticDataMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getInstantiatedFromStaticDataMember, Xs...); }) , (;) )
  /// If this variable is an instantiation of a variable template or a
  /// static data member of a class template, determine what kind of
  /// template specialization or instantiation this is.
  constexpr enum clang::TemplateSpecializationKind getTemplateSpecializationKind() const IFMETA_ELSE( ({    return (enum clang::TemplateSpecializationKind)__reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getTemplateSpecializationKind, Xs...); }) , (;) )
  /// If this variable is an instantiation of a variable template or a
  /// static data member of a class template, determine its point of
  /// instantiation.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getPointOfInstantiation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getPointOfInstantiation, Xs...); }) , (;) )
  /// If this variable is an instantiation of a static data member of a
  /// class template specialization, retrieves the member specialization
  /// information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::MemberSpecializationInfo *) )
  getMemberSpecializationInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getMemberSpecializationInfo, Xs...); }) , (;) )
  /// Retrieves the variable template that is described by this
  /// variable declaration.
  ///
  /// Every variable template is represented as a VarTemplateDecl and a
  /// VarDecl. The former contains template properties (such as
  /// the template parameter lists) while the latter contains the
  /// actual description of the template's
  /// contents. VarTemplateDecl::getTemplatedDecl() retrieves the
  /// VarDecl that from a VarTemplateDecl, while
  /// getDescribedVarTemplate() retrieves the VarTemplateDecl from
  /// a VarDecl.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarTemplateDecl *) )
  getDescribedVarTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::getDescribedVarTemplate, Xs...); }) , (;) )
  constexpr bool isKnownToBeDefined() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::isKnownToBeDefined, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarDecl, reflenums::clang__VarDecl::classofKind, Xs..., K); }) , (;) )
};

/// Defines the kind of the implicit parameter: is this an implicit parameter
/// with pointer to 'this', 'self', '_cmd', virtual table pointers, captured
/// context or something else.
enum clang::ImplicitParamDecl::ImplicitParamKind : unsigned int {
  /// Parameter for Objective-C 'self' argument
  ObjCSelf,
  /// Parameter for Objective-C '_cmd' argument
  ObjCCmd,
  /// Parameter for C++ 'this' argument
  CXXThis,
  /// Parameter for C++ virtual table pointers
  CXXVTT,
  /// Parameter for captured context
  CapturedContext,
  /// Other implicit parameter
  Other,
};

M_template_rtpack(Xs)
struct clang::ImplicitParamDecl::impl : impl_offset_t<clang::VarDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ImplicitParamDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ImplicitParamDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using ImplicitParamKind = enum refldetail::clang::ImplicitParamDecl::ImplicitParamKind;
  /// Create implicit parameter.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImplicitParamDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) IdLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::QualType)) T, enum clang::ImplicitParamDecl::ImplicitParamKind ParamKind) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitParamDecl, reflenums::clang__ImplicitParamDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., ParamKind); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImplicitParamDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, ptrwrp<Y3> p3, Y4 p4, enum clang::ImplicitParamDecl::ImplicitParamKind p5) {
      return Create(p0, p1.get(), p2, p3.get(), p4, p5);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImplicitParamDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) T, enum clang::ImplicitParamDecl::ImplicitParamKind ParamKind) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitParamDecl, reflenums::clang__ImplicitParamDecl::Create1, Xs..., Y0s..., Y1s..., ParamKind); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImplicitParamDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitParamDecl, reflenums::clang__ImplicitParamDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// Returns the implicit parameter kind.
  constexpr enum clang::ImplicitParamDecl::ImplicitParamKind getParameterKind() const IFMETA_ELSE( ({    return (enum clang::ImplicitParamDecl::ImplicitParamKind)__reflect_prop(reflenums::RK_clang__ImplicitParamDecl, reflenums::clang__ImplicitParamDecl::getParameterKind, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitParamDecl, reflenums::clang__ImplicitParamDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitParamDecl, reflenums::clang__ImplicitParamDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a parameter to a function.
M_template_rtpack(Xs)
struct clang::ParmVarDecl::impl : impl_offset_t<clang::VarDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ParmVarDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ParmVarDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ParmVarDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) IdLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, enum clang::StorageClass S, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y7s...> *), (typename meta::clang::Expr *)) DefArg) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., S, Y7s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ParmVarDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, Y5 p5, ptrwrp<Y6> p6, enum clang::StorageClass p7, ptrwrp<Y7> p8) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5, p6.get(), p7, p8.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ParmVarDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::getSourceRange, Xs...); }) , (;) )
  constexpr bool isObjCMethodParameter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::isObjCMethodParameter, Xs...); }) , (;) )
  constexpr unsigned int getFunctionScopeDepth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::getFunctionScopeDepth, Xs...); }) , (;) )
  /// Returns the index of this parameter in its prototype or method scope.
  constexpr unsigned int getFunctionScopeIndex() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::getFunctionScopeIndex, Xs...); }) , (;) )
  constexpr enum clang::Decl::ObjCDeclQualifier getObjCDeclQualifier() const IFMETA_ELSE( ({    return (enum clang::Decl::ObjCDeclQualifier)__reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::getObjCDeclQualifier, Xs...); }) , (;) )
  /// True if the value passed to this parameter must undergo
  /// K&R-style default argument promotion:
  ///
  /// C99 6.5.2.2.
  ///   If the expression that denotes the called function has a type
  ///   that does not include a prototype, the integer promotions are
  ///   performed on each argument, and arguments that have type float
  ///   are promoted to double.
  constexpr bool isKNRPromoted() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::isKNRPromoted, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getDefaultArg() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::getDefaultArg, Xs...); }) , (;) )
  /// Retrieve the source range that covers the entire default
  /// argument.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getDefaultArgRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::getDefaultArgRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getUninstantiatedDefaultArg() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::getUninstantiatedDefaultArg, Xs...); }) , (;) )
  /// Determines whether this parameter has a default argument,
  /// either parsed or not.
  constexpr bool hasDefaultArg() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::hasDefaultArg, Xs...); }) , (;) )
  /// Determines whether this parameter has a default argument that has not
  /// yet been parsed. This will occur during the processing of a C++ class
  /// whose member functions have default arguments, e.g.,
  /// @code
  ///   class X {
  ///   public:
  ///     void f(int x = 17); // x has an unparsed default argument now
  ///   }; // x has a regular default argument now
  /// @endcode
  constexpr bool hasUnparsedDefaultArg() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::hasUnparsedDefaultArg, Xs...); }) , (;) )
  constexpr bool hasUninstantiatedDefaultArg() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::hasUninstantiatedDefaultArg, Xs...); }) , (;) )
  constexpr bool hasInheritedDefaultArg() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::hasInheritedDefaultArg, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getOriginalType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::getOriginalType, Xs...); }) , (;) )
  /// Determine whether this parameter is actually a function
  /// parameter pack.
  constexpr bool isParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::isParameterPack, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParmVarDecl, reflenums::clang__ParmVarDecl::classofKind, Xs..., K); }) , (;) )
};

/// The kind of templated function a FunctionDecl can be.
enum clang::FunctionDecl::TemplatedKind : unsigned int {
  TK_NonTemplate,
  TK_FunctionTemplate,
  TK_MemberSpecialization,
  TK_FunctionTemplateSpecialization,
  TK_DependentFunctionTemplateSpecialization,
};

/// Represents a function declaration or definition.
///
/// Since a given function can be declared several times in a program,
/// there may be several FunctionDecls that correspond to that
/// function. Only one of those FunctionDecls will be found when
/// traversing the list of declarations in the context of the
/// FunctionDecl (e.g., the translation unit); this FunctionDecl
/// contains all of the information known about the function. Other,
/// previous declarations of the function are available via the
/// getPreviousDecl() chain.
M_template_rtpack(Xs)
struct clang::FunctionDecl::impl : impl_offset_t<clang::DeclaratorDecl, 0 M_c M_pack(Xs)>, impl_offset_t<clang::DeclContext, 72 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FunctionDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FunctionDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getFirstDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getMostRecentDecl, Xs...); }) , (;) )
  using TemplatedKind = enum refldetail::clang::FunctionDecl::TemplatedKind;
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) NLoc, IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::DeclarationName)) N, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, enum clang::StorageClass SC, bool isInlineSpecified = false, bool hasWrittenPrototype = true, bool isConstexprSpecified = false) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., SC, isInlineSpecified, hasWrittenPrototype, isConstexprSpecified); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, Y5 p5, ptrwrp<Y6> p6, enum clang::StorageClass p7, bool p8 = false, bool p9 = true, bool p10 = false) {
      return Create(p0, p1.get(), p2, p3, p4, p5, p6.get(), p7, p8, p9, p10);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/1, Y3s...>), (const typename meta::clang::DeclarationNameInfo &)) NameInfo, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, enum clang::StorageClass SC, bool isInlineSpecified, bool hasWrittenPrototype, bool isConstexprSpecified = false) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::Create1, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., SC, isInlineSpecified, hasWrittenPrototype, isConstexprSpecified); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, ptrwrp<Y5> p5, enum clang::StorageClass p6, bool p7, bool p8, bool p9 = false) {
      return Create(p0, p1.get(), p2, p3, p4, p5.get(), p6, p7, p8, p9);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationNameInfo) )
  getNameInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getNameInfo, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void getNameForDiagnostic(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy, bool Qualified) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getNameForDiagnostic, Xs..., Y0s..., Y1s..., Qualified); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getSourceRange, Xs...); }) , (;) )
  /// Returns true if the function has a body.
  ///
  /// The function body might be in any of the (re-)declarations of this
  /// function. The variant that accepts a FunctionDecl pointer will set that
  /// function declaration to the actual declaration containing the body (if
  /// there is one).
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool hasBody(IFMETA_ELSE((const clang::FunctionDecl::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::FunctionDecl *&)) Definition) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::hasBody, Xs..., Y0s...); }) , (;) )
  constexpr bool hasBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::hasBody1, Xs...); }) , (;) )
  /// Returns whether the function has a trivial body that does not require any
  /// specific codegen.
  constexpr bool hasTrivialBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::hasTrivialBody, Xs...); }) , (;) )
  /// Returns true if the function has a definition that does not need to be
  /// instantiated.
  ///
  /// The variant that accepts a FunctionDecl pointer will set that function
  /// declaration to the declaration that is a definition (if there is one).
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isDefined(IFMETA_ELSE((const clang::FunctionDecl::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::FunctionDecl *&)) Definition) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isDefined, Xs..., Y0s...); }) , (;) )
  constexpr bool isDefined() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isDefined1, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionDecl *) )
  getDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getDefinition, Xs...); }) , (;) )
  /// Retrieve the body (definition) of the function. The function body might be
  /// in any of the (re-)declarations of this function. The variant that accepts
  /// a FunctionDecl pointer will set that function declaration to the actual
  /// declaration containing the body (if there is one).
  /// NOTE: For checking if there is a body, use hasBody() instead, to avoid
  /// unnecessary AST de-serialization of the body.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getBody(IFMETA_ELSE((const clang::FunctionDecl::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::FunctionDecl *&)) Definition) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getBody, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getBody1, Xs...); }) , (;) )
  /// Returns whether this specific declaration of the function is also a
  /// definition that does not contain uninstantiated body.
  ///
  /// This does not determine whether the function has been defined (e.g., in a
  /// previous definition); for that information, use isDefined.
  constexpr bool isThisDeclarationADefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isThisDeclarationADefinition, Xs...); }) , (;) )
  /// Returns whether this specific declaration of the function has a body.
  constexpr bool doesThisDeclarationHaveABody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::doesThisDeclarationHaveABody, Xs...); }) , (;) )
  /// Whether this function is variadic.
  constexpr bool isVariadic() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isVariadic, Xs...); }) , (;) )
  /// Whether this function is marked as virtual explicitly.
  constexpr bool isVirtualAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isVirtualAsWritten, Xs...); }) , (;) )
  /// Whether this virtual function is pure, i.e. makes the containing class
  /// abstract.
  constexpr bool isPure() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isPure, Xs...); }) , (;) )
  /// Whether this templated function will be late parsed.
  constexpr bool isLateTemplateParsed() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isLateTemplateParsed, Xs...); }) , (;) )
  /// Whether this function is "trivial" in some specialized C++ senses.
  /// Can only be true for default constructors, copy constructors,
  /// copy assignment operators, and destructors.  Not meaningful until
  /// the class has been fully built by Sema.
  constexpr bool isTrivial() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isTrivial, Xs...); }) , (;) )
  constexpr bool isTrivialForCall() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isTrivialForCall, Xs...); }) , (;) )
  /// Whether this function is defaulted per C++0x. Only valid for
  /// special member functions.
  constexpr bool isDefaulted() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isDefaulted, Xs...); }) , (;) )
  /// Whether this function is explicitly defaulted per C++0x. Only valid
  /// for special member functions.
  constexpr bool isExplicitlyDefaulted() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isExplicitlyDefaulted, Xs...); }) , (;) )
  /// Whether falling off this function implicitly returns null/zero.
  /// If a more specific implicit return value is required, front-ends
  /// should synthesize the appropriate return statements.
  constexpr bool hasImplicitReturnZero() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::hasImplicitReturnZero, Xs...); }) , (;) )
  /// Whether this function has a prototype, either because one
  /// was explicitly written or because it was "inherited" by merging
  /// a declaration without a prototype with a declaration that has a
  /// prototype.
  constexpr bool hasPrototype() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::hasPrototype, Xs...); }) , (;) )
  constexpr bool hasWrittenPrototype() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::hasWrittenPrototype, Xs...); }) , (;) )
  /// Whether this function inherited its prototype from a
  /// previous declaration.
  constexpr bool hasInheritedPrototype() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::hasInheritedPrototype, Xs...); }) , (;) )
  /// Whether this is a (C++11) constexpr function or constexpr constructor.
  constexpr bool isConstexpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isConstexpr, Xs...); }) , (;) )
  /// Whether the instantiation of this function is pending.
  /// This bit is set when the decision to instantiate this function is made
  /// and unset if and when the function body is created. That leaves out
  /// cases where instantiation did not happen because the template definition
  /// was not seen in this TU. This bit remains set in those cases, under the
  /// assumption that the instantiation will happen in some other TU.
  constexpr bool instantiationIsPending() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::instantiationIsPending, Xs...); }) , (;) )
  /// Indicates the function uses __try.
  constexpr bool usesSEHTry() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::usesSEHTry, Xs...); }) , (;) )
  /// Whether this function has been deleted.
  ///
  /// A function that is "deleted" (via the C++0x "= delete" syntax)
  /// acts like a normal function, except that it cannot actually be
  /// called or have its address taken. Deleted functions are
  /// typically used in C++ overload resolution to attract arguments
  /// whose type or lvalue/rvalue-ness would permit the use of a
  /// different overload that would behave incorrectly. For example,
  /// one might use deleted functions to ban implicit conversion from
  /// a floating-point number to an Integer type:
  ///
  /// @code
  /// struct Integer {
  ///   Integer(long); // construct from a long
  ///   Integer(double) = delete; // no construction from float or double
  ///   Integer(long double) = delete; // no construction from long double
  /// };
  /// @endcode
  constexpr bool isDeleted() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isDeleted, Xs...); }) , (;) )
  constexpr bool isDeletedAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isDeletedAsWritten, Xs...); }) , (;) )
  /// Determines whether this function is "main", which is the
  /// entry point into an executable program.
  constexpr bool isMain() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isMain, Xs...); }) , (;) )
  /// Determines whether this function is a MSVCRT user defined entry
  /// point.
  constexpr bool isMSVCRTEntryPoint() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isMSVCRTEntryPoint, Xs...); }) , (;) )
  /// Determines whether this operator new or delete is one
  /// of the reserved global placement operators:
  ///    void *operator new(size_t, void *);
  ///    void *operator new[](size_t, void *);
  ///    void operator delete(void *, void *);
  ///    void operator delete[](void *, void *);
  /// These functions have special behavior under [new.delete.placement]:
  ///    These functions are reserved, a C++ program may not define
  ///    functions that displace the versions in the Standard C++ library.
  ///    The provisions of [basic.stc.dynamic] do not apply to these
  ///    reserved placement forms of operator new and operator delete.
  ///
  /// This function must be an allocation or deallocation function.
  constexpr bool isReservedGlobalPlacementOperator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isReservedGlobalPlacementOperator, Xs...); }) , (;) )
  /// Determines whether this function is one of the replaceable
  /// global allocation functions:
  ///    void *operator new(size_t);
  ///    void *operator new(size_t, const std::nothrow_t &) noexcept;
  ///    void *operator new[](size_t);
  ///    void *operator new[](size_t, const std::nothrow_t &) noexcept;
  ///    void operator delete(void *) noexcept;
  ///    void operator delete(void *, std::size_t) noexcept;      [C++1y]
  ///    void operator delete(void *, const std::nothrow_t &) noexcept;
  ///    void operator delete[](void *) noexcept;
  ///    void operator delete[](void *, std::size_t) noexcept;    [C++1y]
  ///    void operator delete[](void *, const std::nothrow_t &) noexcept;
  /// These functions have special behavior under C++1y [expr.new]:
  ///    An implementation is allowed to omit a call to a replaceable global
  ///    allocation function. [...]
  ///
  /// If this function is an aligned allocation/deallocation function, return
  /// true through IsAligned.
  constexpr bool isReplaceableGlobalAllocationFunction(bool * IsAligned = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isReplaceableGlobalAllocationFunction, Xs..., IsAligned); }) , (;) )
  /// Determine whether this is a destroying operator delete.
  constexpr bool isDestroyingOperatorDelete() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isDestroyingOperatorDelete, Xs...); }) , (;) )
  /// Compute the language linkage.
  constexpr enum clang::LanguageLinkage getLanguageLinkage() const IFMETA_ELSE( ({    return (enum clang::LanguageLinkage)__reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getLanguageLinkage, Xs...); }) , (;) )
  /// Determines whether this function is a function with
  /// external, C linkage.
  constexpr bool isExternC() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isExternC, Xs...); }) , (;) )
  /// Determines whether this function's context is, or is nested within,
  /// a C++ extern "C" linkage spec.
  constexpr bool isInExternCContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isInExternCContext, Xs...); }) , (;) )
  /// Determines whether this function's context is, or is nested within,
  /// a C++ extern "C++" linkage spec.
  constexpr bool isInExternCXXContext() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isInExternCXXContext, Xs...); }) , (;) )
  /// Determines whether this is a global function.
  constexpr bool isGlobal() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isGlobal, Xs...); }) , (;) )
  /// Determines whether this function is known to be 'noreturn', through
  /// an attribute on its declaration or its type.
  constexpr bool isNoReturn() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isNoReturn, Xs...); }) , (;) )
  /// True if the function was a definition but its body was skipped.
  constexpr bool hasSkippedBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::hasSkippedBody, Xs...); }) , (;) )
  /// True if this function will eventually have a body, once it's fully parsed.
  constexpr bool willHaveBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::willHaveBody, Xs...); }) , (;) )
  /// \brief True if this function is a metaprogram.
  constexpr bool isMetaprogram() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isMetaprogram, Xs...); }) , (;) )
  /// True if this function is considered a multiversioned function.
  constexpr bool isMultiVersion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isMultiVersion, Xs...); }) , (;) )
  /// True if this function is a multiversioned dispatch function as a part of
  /// the cpu_specific/cpu_dispatch functionality.
  constexpr bool isCPUDispatchMultiVersion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isCPUDispatchMultiVersion, Xs...); }) , (;) )
  /// True if this function is a multiversioned processor specific function as a
  /// part of the cpu_specific/cpu_dispatch functionality.
  constexpr bool isCPUSpecificMultiVersion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isCPUSpecificMultiVersion, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getCanonicalDecl, Xs...); }) , (;) )
  constexpr unsigned int getBuiltinID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getBuiltinID, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::FunctionDecl, parameters,
      constexpr auto parameters() const ,
      (typename meta::clang::ParmVarDecl *),
      (reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::parameters, Xs...), () )
  constexpr bool param_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::param_empty, Xs...); }) , (;) )
  constexpr unsigned long param_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::param_size, Xs...); }) , (;) )
  /// Return the number of parameters this function must have based on its
  /// FunctionType.  This is the length of the ParamInfo array after it has been
  /// created.
  constexpr unsigned int getNumParams() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getNumParams, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ParmVarDecl *) )
  getParamDecl(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getParamDecl, Xs..., i); }) , (;) )
  /// Returns the minimum number of arguments needed to call this function. This
  /// may be fewer than the number of function parameters, if some of the
  /// parameters have default arguments (in C++).
  constexpr unsigned int getMinRequiredArguments() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getMinRequiredArguments, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getReturnType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getReturnType, Xs...); }) , (;) )
  /// Attempt to compute an informative source range covering the
  /// function return type. This may omit qualifiers and other information with
  /// limited representation in the AST.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getReturnTypeSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getReturnTypeSourceRange, Xs...); }) , (;) )
  /// Attempt to compute an informative source range covering the
  /// function exception specification, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getExceptionSpecSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getExceptionSpecSourceRange, Xs...); }) , (;) )
  /// Determine the type of an expression that calls this function.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getCallResultType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getCallResultType, Xs...); }) , (;) )
  /// Returns the WarnUnusedResultAttr that is either declared on this
  /// function, or its return type declaration.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Attr *) )
  getUnusedResultAttr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getUnusedResultAttr, Xs...); }) , (;) )
  /// Returns true if this function or its return type has the
  /// warn_unused_result attribute.
  constexpr bool hasUnusedResultAttr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::hasUnusedResultAttr, Xs...); }) , (;) )
  /// Returns the storage class as written in the source. For the
  /// computed linkage of symbol, see getLinkage.
  constexpr enum clang::StorageClass getStorageClass() const IFMETA_ELSE( ({    return (enum clang::StorageClass)__reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getStorageClass, Xs...); }) , (;) )
  /// Determine whether the "inline" keyword was specified for this
  /// function.
  constexpr bool isInlineSpecified() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isInlineSpecified, Xs...); }) , (;) )
  /// Determine whether this function should be inlined, because it is
  /// either marked "inline" or "constexpr" or is a member function of a class
  /// that was defined in the class body.
  constexpr bool isInlined() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isInlined, Xs...); }) , (;) )
  constexpr bool isInlineDefinitionExternallyVisible() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isInlineDefinitionExternallyVisible, Xs...); }) , (;) )
  constexpr bool isMSExternInline() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isMSExternInline, Xs...); }) , (;) )
  constexpr bool doesDeclarationForceExternallyVisibleDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::doesDeclarationForceExternallyVisibleDefinition, Xs...); }) , (;) )
  /// Whether this function declaration represents an C++ overloaded
  /// operator, e.g., "operator+".
  constexpr bool isOverloadedOperator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isOverloadedOperator, Xs...); }) , (;) )
  constexpr enum clang::OverloadedOperatorKind getOverloadedOperator() const IFMETA_ELSE( ({    return (enum clang::OverloadedOperatorKind)__reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getOverloadedOperator, Xs...); }) , (;) )
  /// The literal suffix identifier this function represents, if any.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::IdentifierInfo *) )
  getLiteralIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getLiteralIdentifier, Xs...); }) , (;) )
  /// If this function is an instantiation of a member function
  /// of a class template specialization, retrieves the function from
  /// which it was instantiated.
  ///
  /// This routine will return non-NULL for (non-templated) member
  /// functions of class templates and for instantiations of function
  /// templates. For example, given:
  ///
  /// \code
  /// template<typename T>
  /// struct X {
  ///   void f(T);
  /// };
  /// \endcode
  ///
  /// The declaration for X<int>::f is a (non-templated) FunctionDecl
  /// whose parent is the class template specialization X<int>. For
  /// this declaration, getInstantiatedFromFunction() will return
  /// the FunctionDecl X<T>::A. When a complete definition of
  /// X<int>::A is required, it will be instantiated from the
  /// declaration returned by getInstantiatedFromMemberFunction().
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  getInstantiatedFromMemberFunction() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getInstantiatedFromMemberFunction, Xs...); }) , (;) )
  /// What kind of templated function this is.
  constexpr enum clang::FunctionDecl::TemplatedKind getTemplatedKind() const IFMETA_ELSE( ({    return (enum clang::FunctionDecl::TemplatedKind)__reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getTemplatedKind, Xs...); }) , (;) )
  /// If this function is an instantiation of a member function of a
  /// class template specialization, retrieves the member specialization
  /// information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::MemberSpecializationInfo *) )
  getMemberSpecializationInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getMemberSpecializationInfo, Xs...); }) , (;) )
  /// Retrieves the function template that is described by this
  /// function declaration.
  ///
  /// Every function template is represented as a FunctionTemplateDecl
  /// and a FunctionDecl (or something derived from FunctionDecl). The
  /// former contains template properties (such as the template
  /// parameter lists) while the latter contains the actual
  /// description of the template's
  /// contents. FunctionTemplateDecl::getTemplatedDecl() retrieves the
  /// FunctionDecl that describes the function template,
  /// getDescribedFunctionTemplate() retrieves the
  /// FunctionTemplateDecl from a FunctionDecl.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionTemplateDecl *) )
  getDescribedFunctionTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getDescribedFunctionTemplate, Xs...); }) , (;) )
  /// Determine whether this function is a function template
  /// specialization.
  constexpr bool isFunctionTemplateSpecialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isFunctionTemplateSpecialization, Xs...); }) , (;) )
  /// Retrieve the class scope template pattern that this function
  ///  template specialization is instantiated from.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  getClassScopeSpecializationPattern() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getClassScopeSpecializationPattern, Xs...); }) , (;) )
  /// If this function is actually a function template specialization,
  /// retrieve information about this function template specialization.
  /// Otherwise, returns NULL.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionTemplateSpecializationInfo *) )
  getTemplateSpecializationInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getTemplateSpecializationInfo, Xs...); }) , (;) )
  /// Determines whether this function is a function template
  /// specialization or a member of a class template specialization that can
  /// be implicitly instantiated.
  constexpr bool isImplicitlyInstantiable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isImplicitlyInstantiable, Xs...); }) , (;) )
  /// Determines if the given function was instantiated from a
  /// function template.
  constexpr bool isTemplateInstantiation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isTemplateInstantiation, Xs...); }) , (;) )
  /// Retrieve the function declaration from which this function could
  /// be instantiated, if it is an instantiation (rather than a non-template
  /// or a specialization, for example).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  getTemplateInstantiationPattern() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getTemplateInstantiationPattern, Xs...); }) , (;) )
  /// Retrieve the primary template that this function template
  /// specialization either specializes or was instantiated from.
  ///
  /// If this function declaration is not a function template specialization,
  /// returns NULL.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionTemplateDecl *) )
  getPrimaryTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getPrimaryTemplate, Xs...); }) , (;) )
  /// Retrieve the template arguments used to produce this function
  /// template specialization from the primary template.
  ///
  /// If this function declaration is not a function template specialization,
  /// returns NULL.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentList *) )
  getTemplateSpecializationArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getTemplateSpecializationArgs, Xs...); }) , (;) )
  /// Retrieve the template argument list as written in the sources,
  /// if any.
  ///
  /// If this function declaration is not a function template specialization
  /// or if it had no explicit template argument list, returns NULL.
  /// Note that it an explicit template argument list may be written empty,
  /// e.g., template<> void foo<>(char* s);
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ASTTemplateArgumentListInfo *) )
  getTemplateSpecializationArgsAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getTemplateSpecializationArgsAsWritten, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DependentFunctionTemplateSpecializationInfo *) )
  getDependentSpecializationInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getDependentSpecializationInfo, Xs...); }) , (;) )
  /// Determine what kind of template instantiation this function
  /// represents.
  constexpr enum clang::TemplateSpecializationKind getTemplateSpecializationKind() const IFMETA_ELSE( ({    return (enum clang::TemplateSpecializationKind)__reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getTemplateSpecializationKind, Xs...); }) , (;) )
  /// Retrieve the (first) point of instantiation of a function template
  /// specialization or a member of a class template specialization.
  ///
  /// \returns the first point of instantiation, if this function was
  /// instantiated from a template; otherwise, returns an invalid source
  /// location.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getPointOfInstantiation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getPointOfInstantiation, Xs...); }) , (;) )
  /// Determine whether this is or was instantiated from an out-of-line
  /// definition of a member function.
  constexpr bool isOutOfLine() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::isOutOfLine, Xs...); }) , (;) )
  /// Identify a memory copying or setting function.
  /// If the given function is a memory copy or setting function, returns
  /// the corresponding Builtin ID. If the function is not a memory function,
  /// returns 0.
  constexpr unsigned int getMemoryFunctionKind() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getMemoryFunctionKind, Xs...); }) , (;) )
  /// Returns cached ODRHash of the function.  This must have been previously
  /// computed and stored.
  constexpr unsigned int getODRHash() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::getODRHash, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionDecl, reflenums::clang__FunctionDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a member of a struct/union/class.
M_template_rtpack(Xs)
struct clang::FieldDecl::impl : impl_offset_t<clang::DeclaratorDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FieldDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FieldDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FieldDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::getFirstDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FieldDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) IdLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y7s...> *), (typename meta::clang::Expr *)) BW, bool Mutable, enum clang::InClassInitStyle InitStyle) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., Y7s..., Mutable, InitStyle); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FieldDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, Y5 p5, ptrwrp<Y6> p6, ptrwrp<Y7> p7, bool p8, enum clang::InClassInitStyle p9) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5, p6.get(), p7.get(), p8, p9);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FieldDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::DeclarationNameInfo)) NameInfo, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::Expr *)) BW, bool Mutable, enum clang::InClassInitStyle InitStyle) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::Create1, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., Mutable, InitStyle); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FieldDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, ptrwrp<Y5> p5, ptrwrp<Y6> p6, bool p7, enum clang::InClassInitStyle p8) {
      return Create(p0, p1.get(), p2, p3, p4, p5.get(), p6.get(), p7, p8);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FieldDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// Returns the index of this field within its record,
  /// as appropriate for passing to ASTRecordLayout::getFieldOffset.
  constexpr unsigned int getFieldIndex() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::getFieldIndex, Xs...); }) , (;) )
  /// Determines whether this field is mutable (C++ only).
  constexpr bool isMutable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::isMutable, Xs...); }) , (;) )
  /// Determines whether this field is a bitfield.
  constexpr bool isBitField() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::isBitField, Xs...); }) , (;) )
  /// Determines whether this is an unnamed bitfield.
  constexpr bool isUnnamedBitfield() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::isUnnamedBitfield, Xs...); }) , (;) )
  /// Determines whether this field is a
  /// representative for an anonymous struct or union. Such fields are
  /// unnamed and are implicitly generated by the implementation to
  /// store the data for the anonymous union or struct.
  constexpr bool isAnonymousStructOrUnion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::isAnonymousStructOrUnion, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getBitWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::getBitWidth, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getBitWidthValue(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::getBitWidthValue, Xs..., Y0s...); }) , (;) )
  /// Is this a zero-length bit-field? Such bit-fields aren't really bit-fields
  /// at all and instead act as a separator between contiguous runs of other
  /// bit-fields.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isZeroLengthBitField(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::isZeroLengthBitField, Xs..., Y0s...); }) , (;) )
  /// Get the kind of (C++11) default member initializer that this field has.
  constexpr enum clang::InClassInitStyle getInClassInitStyle() const IFMETA_ELSE( ({    return (enum clang::InClassInitStyle)__reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::getInClassInitStyle, Xs...); }) , (;) )
  /// Determine whether this member has a C++11 default member initializer.
  constexpr bool hasInClassInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::hasInClassInitializer, Xs...); }) , (;) )
  /// Get the C++11 default member initializer for this member, or null if one
  /// has not been set. If a valid declaration has a default member initializer,
  /// but this returns null, then we have not parsed and attached it yet.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getInClassInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::getInClassInitializer, Xs...); }) , (;) )
  /// Determine whether this member captures the variable length array
  /// type.
  constexpr bool hasCapturedVLAType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::hasCapturedVLAType, Xs...); }) , (;) )
  /// Get the captured variable length array type.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VariableArrayType *) )
  getCapturedVLAType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::getCapturedVLAType, Xs...); }) , (;) )
  /// Returns the parent of this field declaration, which
  /// is the struct in which this field is defined.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::RecordDecl *) )
  getParent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::getParent, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FieldDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::getCanonicalDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FieldDecl, reflenums::clang__FieldDecl::classofKind, Xs..., K); }) , (;) )
};

/// An instance of this object exists for each enum constant
/// that is defined.  For example, in "enum X {a,b}", each of a/b are
/// EnumConstantDecl's, X is an instance of EnumDecl, and the type of a/b is a
/// TagType for the X EnumDecl.
M_template_rtpack(Xs)
struct clang::EnumConstantDecl::impl : impl_offset_t<clang::ValueDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__EnumConstantDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::EnumConstantDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::EnumConstantDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumConstantDecl, reflenums::clang__EnumConstantDecl::getFirstDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::EnumConstantDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::EnumDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::EnumDecl *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) L, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::Expr *)) E, IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y6s...>), (const typename meta::llvm::APSInt &)) V) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumConstantDecl, reflenums::clang__EnumConstantDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::EnumConstantDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, ptrwrp<Y3> p3, Y4 p4, ptrwrp<Y5> p5, Y6 p6) {
      return Create(p0, p1.get(), p2, p3.get(), p4, p5.get(), p6);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::EnumConstantDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumConstantDecl, reflenums::clang__EnumConstantDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getInitExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumConstantDecl, reflenums::clang__EnumConstantDecl::getInitExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::APSInt &) )
  getInitVal() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumConstantDecl, reflenums::clang__EnumConstantDecl::getInitVal, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumConstantDecl, reflenums::clang__EnumConstantDecl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::EnumConstantDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumConstantDecl, reflenums::clang__EnumConstantDecl::getCanonicalDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumConstantDecl, reflenums::clang__EnumConstantDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumConstantDecl, reflenums::clang__EnumConstantDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a field injected from an anonymous union/struct into the parent
/// scope. These are always implicit.
M_template_rtpack(Xs)
struct clang::IndirectFieldDecl::impl : impl_offset_t<clang::ValueDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__IndirectFieldDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::IndirectFieldDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::IndirectFieldDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectFieldDecl, reflenums::clang__IndirectFieldDecl::getFirstDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::IndirectFieldDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectFieldDecl, reflenums::clang__IndirectFieldDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  RANGE_REFLECTION(clang::IndirectFieldDecl, chain,
      constexpr auto chain() const ,
      (typename meta::clang::NamedDecl *),
      (reflenums::RK_clang__IndirectFieldDecl, reflenums::clang__IndirectFieldDecl::chain, Xs...), () )
  constexpr unsigned int getChainingSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectFieldDecl, reflenums::clang__IndirectFieldDecl::getChainingSize, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FieldDecl *) )
  getAnonField() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectFieldDecl, reflenums::clang__IndirectFieldDecl::getAnonField, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getVarDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectFieldDecl, reflenums::clang__IndirectFieldDecl::getVarDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::IndirectFieldDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectFieldDecl, reflenums::clang__IndirectFieldDecl::getCanonicalDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectFieldDecl, reflenums::clang__IndirectFieldDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectFieldDecl, reflenums::clang__IndirectFieldDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a declaration of a type.
M_template_rtpack(Xs)
struct clang::TypeDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypeDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypeDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getTypeForDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeDecl, reflenums::clang__TypeDecl::getTypeForDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeDecl, reflenums::clang__TypeDecl::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeDecl, reflenums::clang__TypeDecl::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeDecl, reflenums::clang__TypeDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeDecl, reflenums::clang__TypeDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeDecl, reflenums::clang__TypeDecl::classofKind, Xs..., K); }) , (;) )
};

/// Base class for declarations which introduce a typedef-name.
M_template_rtpack(Xs)
struct clang::TypedefNameDecl::impl : impl_offset_t<clang::TypeDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypedefNameDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypedefNameDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TypedefNameDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefNameDecl, reflenums::clang__TypedefNameDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TypedefNameDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefNameDecl, reflenums::clang__TypedefNameDecl::getFirstDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TypedefNameDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefNameDecl, reflenums::clang__TypedefNameDecl::getMostRecentDecl, Xs...); }) , (;) )
  constexpr bool isModed() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefNameDecl, reflenums::clang__TypedefNameDecl::isModed, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefNameDecl, reflenums::clang__TypedefNameDecl::getTypeSourceInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getUnderlyingType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefNameDecl, reflenums::clang__TypedefNameDecl::getUnderlyingType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TypedefNameDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefNameDecl, reflenums::clang__TypedefNameDecl::getCanonicalDecl, Xs...); }) , (;) )
  /// Retrieves the tag declaration for which this is the typedef name for
  /// linkage purposes, if any.
  ///
  /// \param AnyRedecl Look for the tag declaration in any redeclaration of
  /// this typedef declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TagDecl *) )
  getAnonDeclWithTypedefName(bool AnyRedecl = false) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefNameDecl, reflenums::clang__TypedefNameDecl::getAnonDeclWithTypedefName, Xs..., AnyRedecl); }) , (;) )
  /// Determines if this typedef shares a name and spelling location with its
  /// underlying tag type, as is the case with the NS_ENUM macro.
  constexpr bool isTransparentTag() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefNameDecl, reflenums::clang__TypedefNameDecl::isTransparentTag, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefNameDecl, reflenums::clang__TypedefNameDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefNameDecl, reflenums::clang__TypedefNameDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents the declaration of a typedef-name via the 'typedef'
/// type specifier.
M_template_rtpack(Xs)
struct clang::TypedefDecl::impl : impl_offset_t<clang::TypedefNameDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypedefDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypedefDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) IdLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefDecl, reflenums::clang__TypedefDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, ptrwrp<Y5> p5) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefDecl, reflenums::clang__TypedefDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefDecl, reflenums::clang__TypedefDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefDecl, reflenums::clang__TypedefDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypedefDecl, reflenums::clang__TypedefDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents the declaration of a typedef-name via a C++11
/// alias-declaration.
M_template_rtpack(Xs)
struct clang::TypeAliasDecl::impl : impl_offset_t<clang::TypedefNameDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypeAliasDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypeAliasDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeAliasDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) IdLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasDecl, reflenums::clang__TypeAliasDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeAliasDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, ptrwrp<Y5> p5) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeAliasDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasDecl, reflenums::clang__TypeAliasDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasDecl, reflenums::clang__TypeAliasDecl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeAliasTemplateDecl *) )
  getDescribedAliasTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasDecl, reflenums::clang__TypeAliasDecl::getDescribedAliasTemplate, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasDecl, reflenums::clang__TypeAliasDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasDecl, reflenums::clang__TypeAliasDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents the declaration of a struct/union/class/enum.
M_template_rtpack(Xs)
struct clang::TagDecl::impl : impl_offset_t<clang::TypeDecl, 0 M_c M_pack(Xs)>, impl_offset_t<clang::DeclContext, 64 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TagDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TagDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TagDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TagDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getFirstDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TagDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getMostRecentDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getBraceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getBraceRange, Xs...); }) , (;) )
  /// Return SourceLocation representing start of source
  /// range ignoring outer template declarations.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getInnerLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getInnerLocStart, Xs...); }) , (;) )
  /// Return SourceLocation representing start of source
  /// range taking into account any outer template declarations.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOuterLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getOuterLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TagDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getCanonicalDecl, Xs...); }) , (;) )
  /// Return true if this declaration is a completion definition of the type.
  /// Provided for consistency.
  constexpr bool isThisDeclarationADefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::isThisDeclarationADefinition, Xs...); }) , (;) )
  /// Return true if this decl has its body fully specified.
  constexpr bool isCompleteDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::isCompleteDefinition, Xs...); }) , (;) )
  /// Return true if this complete decl is
  /// required to be complete for some existing use.
  constexpr bool isCompleteDefinitionRequired() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::isCompleteDefinitionRequired, Xs...); }) , (;) )
  /// Return true if this decl is currently being defined.
  constexpr bool isBeingDefined() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::isBeingDefined, Xs...); }) , (;) )
  constexpr bool isEmbeddedInDeclarator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::isEmbeddedInDeclarator, Xs...); }) , (;) )
  constexpr bool isFreeStanding() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::isFreeStanding, Xs...); }) , (;) )
  /// Whether this declaration declares a type that is
  /// dependent, i.e., a type that somehow depends on template
  /// parameters.
  constexpr bool isDependentType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::isDependentType, Xs...); }) , (;) )
  /// Returns the TagDecl that actually defines this
  ///  struct/union/class/enum.  When determining whether or not a
  ///  struct/union/class/enum has a definition, one should use this
  ///  method as opposed to 'isDefinition'.  'isDefinition' indicates
  ///  whether or not a specific TagDecl is defining declaration, not
  ///  whether or not the struct/union/class/enum type is defined.
  ///  This method returns NULL if there is no TagDecl that defines
  ///  the struct/union/class/enum.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TagDecl *) )
  getDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getDefinition, Xs...); }) , (;) )
  constexpr const char * getKindName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getKindName, Xs...); }) , (;) )
  constexpr enum clang::TagTypeKind getTagKind() const IFMETA_ELSE( ({    return (enum clang::TagTypeKind)__reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getTagKind, Xs...); }) , (;) )
  constexpr bool isStruct() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::isStruct, Xs...); }) , (;) )
  constexpr bool isInterface() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::isInterface, Xs...); }) , (;) )
  constexpr bool isClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::isClass, Xs...); }) , (;) )
  constexpr bool isUnion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::isUnion, Xs...); }) , (;) )
  constexpr bool isEnum() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::isEnum, Xs...); }) , (;) )
  /// Is this tag type named, either directly or via being defined in
  /// a typedef of this type?
  ///
  /// C++11 [basic.link]p8:
  ///   A type is said to have linkage if and only if:
  ///     - it is a class or enumeration type that is named (or has a
  ///       name for linkage purposes) and the name has linkage; ...
  /// C++11 [dcl.typedef]p9:
  ///   If the typedef declaration defines an unnamed class (or enum),
  ///   the first typedef-name declared by the declaration to be that
  ///   class type (or enum type) is used to denote the class type (or
  ///   enum type) for linkage purposes only.
  ///
  /// C does not have an analogous rule, but the same concept is
  /// nonetheless useful in some places.
  constexpr bool hasNameForLinkage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::hasNameForLinkage, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefNameDecl *) )
  getTypedefNameForAnonDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getTypedefNameForAnonDecl, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the name of this
  /// declaration, if it was present in the source.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getQualifier, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier (with source-location
  /// information) that qualifies the name of this declaration, if it was
  /// present in the source.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getQualifierLoc, Xs...); }) , (;) )
  constexpr unsigned int getNumTemplateParameterLists() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getNumTemplateParameterLists, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateParameterList *) )
  getTemplateParameterList(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::getTemplateParameterList, Xs..., i); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TagDecl, reflenums::clang__TagDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents an enum.  In C++11, enums can be forward-declared
/// with a fixed underlying type, and in C we allow them to be forward-declared
/// with no underlying type as an extension.
M_template_rtpack(Xs)
struct clang::EnumDecl::impl : impl_offset_t<clang::TagDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__EnumDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::EnumDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::EnumDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getCanonicalDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::EnumDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::EnumDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getMostRecentDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::EnumDecl *) )
  getDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getDefinition, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::EnumDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) IdLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::EnumDecl::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::EnumDecl *)) PrevDecl, bool IsScoped, bool IsScopedUsingClassTag, bool IsFixed) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., IsScoped, IsScopedUsingClassTag, IsFixed); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::EnumDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, ptrwrp<Y5> p5, bool p6, bool p7, bool p8) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5.get(), p6, p7, p8);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::EnumDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  RANGE_REFLECTION(clang::EnumDecl, enumerators,
      constexpr auto enumerators() const ,
      (typename meta::clang::EnumConstantDecl *),
      (reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::enumerators, Xs...), () )
  /// Return the integer type that enumerators should promote to.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPromotionType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getPromotionType, Xs...); }) , (;) )
  /// Return the integer type this enum decl corresponds to.
  /// This returns a null QualType for an enum forward definition with no fixed
  /// underlying type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getIntegerType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getIntegerType, Xs...); }) , (;) )
  /// Return the type source info for the underlying integer type,
  /// if no type source info exists, return 0.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getIntegerTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getIntegerTypeSourceInfo, Xs...); }) , (;) )
  /// Retrieve the source range that covers the underlying type if
  /// specified.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getIntegerTypeRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getIntegerTypeRange, Xs...); }) , (;) )
  /// Returns the width in bits required to store all the
  /// non-negative enumerators of this enum.
  constexpr unsigned int getNumPositiveBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getNumPositiveBits, Xs...); }) , (;) )
  /// Returns the width in bits required to store all the
  /// negative enumerators of this enum.  These widths include
  /// the rightmost leading 1;  that is:
  ///
  /// MOST NEGATIVE ENUMERATOR     PATTERN     NUM NEGATIVE BITS
  /// ------------------------     -------     -----------------
  ///                       -1     1111111                     1
  ///                      -10     1110110                     5
  ///                     -101     1001011                     8
  constexpr unsigned int getNumNegativeBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getNumNegativeBits, Xs...); }) , (;) )
  /// Returns true if this is a C++11 scoped enumeration.
  constexpr bool isScoped() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::isScoped, Xs...); }) , (;) )
  /// Returns true if this is a C++11 scoped enumeration.
  constexpr bool isScopedUsingClassTag() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::isScopedUsingClassTag, Xs...); }) , (;) )
  /// Returns true if this is an Objective-C, C++11, or
  /// Microsoft-style enumeration with a fixed underlying type.
  constexpr bool isFixed() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::isFixed, Xs...); }) , (;) )
  /// Returns true if this can be considered a complete type.
  constexpr bool isComplete() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::isComplete, Xs...); }) , (;) )
  /// Returns true if this enum is either annotated with
  /// enum_extensibility(closed) or isn't annotated with enum_extensibility.
  constexpr bool isClosed() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::isClosed, Xs...); }) , (;) )
  /// Returns true if this enum is annotated with flag_enum and isn't annotated
  /// with enum_extensibility(open).
  constexpr bool isClosedFlag() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::isClosedFlag, Xs...); }) , (;) )
  /// Returns true if this enum is annotated with neither flag_enum nor
  /// enum_extensibility(open).
  constexpr bool isClosedNonFlag() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::isClosedNonFlag, Xs...); }) , (;) )
  /// Retrieve the enum definition from which this enumeration could
  /// be instantiated, if it is an instantiation (rather than a non-template).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::EnumDecl *) )
  getTemplateInstantiationPattern() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getTemplateInstantiationPattern, Xs...); }) , (;) )
  /// Returns the enumeration (declared within the template)
  /// from which this enumeration type was instantiated, or NULL if
  /// this enumeration was not instantiated from any template.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::EnumDecl *) )
  getInstantiatedFromMemberEnum() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getInstantiatedFromMemberEnum, Xs...); }) , (;) )
  /// If this enumeration is a member of a specialization of a
  /// templated class, determine what kind of template specialization
  /// or instantiation this is.
  constexpr enum clang::TemplateSpecializationKind getTemplateSpecializationKind() const IFMETA_ELSE( ({    return (enum clang::TemplateSpecializationKind)__reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getTemplateSpecializationKind, Xs...); }) , (;) )
  /// If this enumeration is an instantiation of a member enumeration of
  /// a class template specialization, retrieves the member specialization
  /// information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::MemberSpecializationInfo *) )
  getMemberSpecializationInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::getMemberSpecializationInfo, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EnumDecl, reflenums::clang__EnumDecl::classofKind, Xs..., K); }) , (;) )
};

/// Enum that represents the different ways arguments are passed to and
/// returned from function calls. This takes into account the target-specific
/// and version-specific rules along with the rules determined by the
/// language.
enum clang::RecordDecl::ArgPassingKind : unsigned int {
  /// The argument of this type can be passed directly in registers.
  APK_CanPassInRegs,
  /// The argument of this type cannot be passed directly in registers.
  /// Records containing this type as a subobject are not forced to be passed
  /// indirectly. This value is used only in C++. This value is required by
  /// C++ because, in uncommon situations, it is possible for a class to have
  /// only trivial copy/move constructors even when one of its subobjects has
  /// a non-trivial copy/move constructor (if e.g. the corresponding copy/move
  /// constructor in the derived class is deleted).
  APK_CannotPassInRegs,
  /// The argument of this type cannot be passed directly in registers.
  /// Records containing this type as a subobject are forced to be passed
  /// indirectly.
  APK_CanNeverPassInRegs,
};

/// Represents a struct/union/class.  For example:
///   struct X;                  // Forward declaration, no "body".
///   union Y { int A, B; };     // Has body with members A and B (FieldDecls).
/// This decl will be marked invalid if *any* members are invalid.
M_template_rtpack(Xs)
struct clang::RecordDecl::impl : impl_offset_t<clang::TagDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__RecordDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::RecordDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using ArgPassingKind = enum refldetail::clang::RecordDecl::ArgPassingKind;
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::RecordDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, enum clang::TagTypeKind TK, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) IdLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::RecordDecl::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::RecordDecl *)) PrevDecl = {}) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::Create, Xs..., Y0s..., TK, Y1s..., Y2s..., Y3s..., Y4s..., Y5s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::RecordDecl *) )
  Create(Y0 p0, enum clang::TagTypeKind p1, ptrwrp<Y1> p2, Y2 p3, Y3 p4, ptrwrp<Y4> p5, ptrwrp<Y5> p6 = {}) {
      return Create(p0, p1, p2.get(), p3, p4, p5.get(), p6.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::RecordDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::RecordDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::RecordDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::getMostRecentDecl, Xs...); }) , (;) )
  constexpr bool hasFlexibleArrayMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::hasFlexibleArrayMember, Xs...); }) , (;) )
  /// Whether this is an anonymous struct or union. To be an anonymous
  /// struct or union, it must have been declared without a name and
  /// there must be no objects of this type declared, e.g.,
  /// @code
  ///   union { int i; float f; };
  /// @endcode
  /// is an anonymous union but neither of the following are:
  /// @code
  ///  union X { int i; float f; };
  ///  union { int i; float f; } obj;
  /// @endcode
  constexpr bool isAnonymousStructOrUnion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::isAnonymousStructOrUnion, Xs...); }) , (;) )
  constexpr bool hasObjectMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::hasObjectMember, Xs...); }) , (;) )
  constexpr bool hasVolatileMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::hasVolatileMember, Xs...); }) , (;) )
  constexpr bool hasLoadedFieldsFromExternalStorage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::hasLoadedFieldsFromExternalStorage, Xs...); }) , (;) )
  /// Functions to query basic properties of non-trivial C structs.
  constexpr bool isNonTrivialToPrimitiveDefaultInitialize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::isNonTrivialToPrimitiveDefaultInitialize, Xs...); }) , (;) )
  constexpr bool isNonTrivialToPrimitiveCopy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::isNonTrivialToPrimitiveCopy, Xs...); }) , (;) )
  constexpr bool isNonTrivialToPrimitiveDestroy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::isNonTrivialToPrimitiveDestroy, Xs...); }) , (;) )
  /// Determine whether this class can be passed in registers. In C++ mode,
  /// it must have at least one trivial, non-deleted copy or move constructor.
  /// FIXME: This should be set as part of completeDefinition.
  constexpr bool canPassInRegisters() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::canPassInRegisters, Xs...); }) , (;) )
  constexpr enum clang::RecordDecl::ArgPassingKind getArgPassingRestrictions() const IFMETA_ELSE( ({    return (enum clang::RecordDecl::ArgPassingKind)__reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::getArgPassingRestrictions, Xs...); }) , (;) )
  constexpr bool isParamDestroyedInCallee() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::isParamDestroyedInCallee, Xs...); }) , (;) )
  /// Determines whether this declaration represents the
  /// injected class name.
  ///
  /// The injected class name in C++ is the name of the class that
  /// appears inside the class itself. For example:
  ///
  /// \code
  /// struct C {
  ///   // C is implicitly declared here as a synonym for the class name.
  /// };
  ///
  /// C::C c; // same as "C c;"
  /// \endcode
  constexpr bool isInjectedClassName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::isInjectedClassName, Xs...); }) , (;) )
  /// Determine whether this record is a class describing a lambda
  /// function object.
  constexpr bool isLambda() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::isLambda, Xs...); }) , (;) )
  /// Determine whether this record is a record for captured variables in
  /// CapturedStmt construct.
  constexpr bool isCapturedRecord() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::isCapturedRecord, Xs...); }) , (;) )
  /// Returns the RecordDecl that actually defines
  ///  this struct/union/class.  When determining whether or not a
  ///  struct/union/class is completely defined, one should use this
  ///  method as opposed to 'isCompleteDefinition'.
  ///  'isCompleteDefinition' indicates whether or not a specific
  ///  RecordDecl is a completed definition, not whether or not the
  ///  record type is defined.  This method returns NULL if there is
  ///  no RecordDecl that defines the struct/union/tag.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::RecordDecl *) )
  getDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::getDefinition, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::RecordDecl, fields,
      constexpr auto fields() const ,
      (typename meta::clang::FieldDecl *),
      (reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::fields, Xs...), () )
  constexpr bool field_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::field_empty, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::classofKind, Xs..., K); }) , (;) )
  /// Get whether or not this is an ms_struct which can
  /// be turned on with an attribute, pragma, or -mms-bitfields
  /// commandline option.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isMsStruct(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::isMsStruct, Xs..., Y0s...); }) , (;) )
  /// Whether we are allowed to insert extra padding between fields.
  /// These padding are added to help AddressSanitizer detect
  /// intra-object-overflow bugs.
  constexpr bool mayInsertExtraPadding(bool EmitRemark = false) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::mayInsertExtraPadding, Xs..., EmitRemark); }) , (;) )
  /// Finds the first data member which has a name.
  /// nullptr is returned if no named data member exists.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FieldDecl *) )
  findFirstNamedDataMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RecordDecl, reflenums::clang__RecordDecl::findFirstNamedDataMember, Xs...); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::FileScopeAsmDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FileScopeAsmDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FileScopeAsmDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FileScopeAsmDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::StringLiteral::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::StringLiteral *)) Str, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) AsmLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::SourceLocation)) RParenLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileScopeAsmDecl, reflenums::clang__FileScopeAsmDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FileScopeAsmDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, ptrwrp<Y2> p2, Y3 p3, Y4 p4) {
      return Create(p0, p1.get(), p2.get(), p3, p4);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FileScopeAsmDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileScopeAsmDecl, reflenums::clang__FileScopeAsmDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAsmLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileScopeAsmDecl, reflenums::clang__FileScopeAsmDecl::getAsmLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileScopeAsmDecl, reflenums::clang__FileScopeAsmDecl::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileScopeAsmDecl, reflenums::clang__FileScopeAsmDecl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::StringLiteral *) )
  getAsmString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileScopeAsmDecl, reflenums::clang__FileScopeAsmDecl::getAsmString, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileScopeAsmDecl, reflenums::clang__FileScopeAsmDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FileScopeAsmDecl, reflenums::clang__FileScopeAsmDecl::classofKind, Xs..., K); }) , (;) )
};

/// Pepresents a block literal declaration, which is like an
/// unnamed FunctionDecl.  For example:
/// ^{ statement-body }   or   ^(int arg1, float arg2){ statement-body }
M_template_rtpack(Xs)
struct clang::BlockDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)>, impl_offset_t<clang::DeclContext, 40 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__BlockDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::BlockDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template_rtpack(Zs) using Capture = struct refldetail::clang::BlockDecl::Capture::M_template impl M_targpack(Zs);
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::BlockDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) L) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::Create, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::BlockDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2) {
      return Create(p0, p1.get(), p2);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::BlockDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getCaretLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::getCaretLocation, Xs...); }) , (;) )
  constexpr bool isVariadic() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::isVariadic, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CompoundStmt *) )
  getCompoundBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::getCompoundBody, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::getBody, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getSignatureAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::getSignatureAsWritten, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::BlockDecl, parameters,
      constexpr auto parameters() const ,
      (typename meta::clang::ParmVarDecl *),
      (reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::parameters, Xs...), () )
  constexpr bool param_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::param_empty, Xs...); }) , (;) )
  constexpr unsigned long param_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::param_size, Xs...); }) , (;) )
  constexpr unsigned int getNumParams() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::getNumParams, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ParmVarDecl *) )
  getParamDecl(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::getParamDecl, Xs..., i); }) , (;) )
  /// True if this block (or its nested blocks) captures
  /// anything of local storage from its enclosing scopes.
  constexpr bool hasCaptures() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::hasCaptures, Xs...); }) , (;) )
  /// Returns the number of captured variables.
  /// Does not include an entry for 'this'.
  constexpr unsigned int getNumCaptures() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::getNumCaptures, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::BlockDecl, captures,
      constexpr auto captures() const ,
      (typename meta::clang::BlockDecl::Capture),
      (reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::captures, Xs...), () )
  constexpr bool capturesCXXThis() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::capturesCXXThis, Xs...); }) , (;) )
  constexpr bool blockMissingReturnType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::blockMissingReturnType, Xs...); }) , (;) )
  constexpr bool isConversionFromLambda() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::isConversionFromLambda, Xs...); }) , (;) )
  constexpr bool doesNotEscape() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::doesNotEscape, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool capturesVariable(IFMETA_ELSE((const clang::VarDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::VarDecl *)) var) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::capturesVariable, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool capturesVariable(ptrwrp<Y0> p0) const {
      return capturesVariable(p0.get());
  }), () )
  constexpr unsigned int getBlockManglingNumber() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::getBlockManglingNumber, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Decl *) )
  getBlockManglingContextDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::getBlockManglingContextDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl, reflenums::clang__BlockDecl::classofKind, Xs..., K); }) , (;) )
};

/// A class which contains all the information about a particular
  /// captured value.
M_template_rtpack(Xs)
struct clang::BlockDecl::Capture::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__BlockDecl__Capture;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::BlockDecl::Capture::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// The variable being captured.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl__Capture, reflenums::clang__BlockDecl__Capture::getVariable, Xs...); }) , (;) )
  /// Whether this is a "by ref" capture, i.e. a capture of a __block
    /// variable.
  constexpr bool isByRef() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl__Capture, reflenums::clang__BlockDecl__Capture::isByRef, Xs...); }) , (;) )
  /// Whether this is a nested capture, i.e. the variable captured
    /// is not from outside the immediately enclosing function/block.
  constexpr bool isNested() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl__Capture, reflenums::clang__BlockDecl__Capture::isNested, Xs...); }) , (;) )
  constexpr bool hasCopyExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl__Capture, reflenums::clang__BlockDecl__Capture::hasCopyExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCopyExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockDecl__Capture, reflenums::clang__BlockDecl__Capture::getCopyExpr, Xs...); }) , (;) )
};

/// Represents the body of a CapturedStmt, and serves as its DeclContext.
M_template_rtpack(Xs)
struct clang::CapturedDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)>, impl_offset_t<clang::DeclContext, 40 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CapturedDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CapturedDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CapturedDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, unsigned int NumParams) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedDecl, reflenums::clang__CapturedDecl::Create, Xs..., Y0s..., Y1s..., NumParams); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CapturedDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, unsigned int p2) {
      return Create(p0, p1.get(), p2);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CapturedDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID, unsigned int NumParams) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedDecl, reflenums::clang__CapturedDecl::CreateDeserialized, Xs..., Y0s..., ID, NumParams); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedDecl, reflenums::clang__CapturedDecl::getBody, Xs...); }) , (;) )
  constexpr bool isNothrow() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedDecl, reflenums::clang__CapturedDecl::isNothrow, Xs...); }) , (;) )
  constexpr unsigned int getNumParams() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedDecl, reflenums::clang__CapturedDecl::getNumParams, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImplicitParamDecl *) )
  getParam(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedDecl, reflenums::clang__CapturedDecl::getParam, Xs..., i); }) , (;) )
  RANGE_REFLECTION(clang::CapturedDecl, parameters,
      constexpr auto parameters() const ,
      (typename meta::clang::ImplicitParamDecl *),
      (reflenums::RK_clang__CapturedDecl, reflenums::clang__CapturedDecl::parameters, Xs...), () )
  /// Retrieve the parameter containing captured variables.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImplicitParamDecl *) )
  getContextParam() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedDecl, reflenums::clang__CapturedDecl::getContextParam, Xs...); }) , (;) )
  constexpr unsigned int getContextParamPosition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedDecl, reflenums::clang__CapturedDecl::getContextParamPosition, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedDecl, reflenums::clang__CapturedDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedDecl, reflenums::clang__CapturedDecl::classofKind, Xs..., K); }) , (;) )
};

/// Describes a module import declaration, which makes the contents
/// of the named module visible in the current translation unit.
///
/// An import declaration imports the named module (or submodule). For example:
/// \code
///   @import std.vector;
/// \endcode
///
/// Import declarations can also be implicitly generated from
/// \#include/\#import directives.
M_template_rtpack(Xs)
struct clang::ImportDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ImportDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ImportDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Create a new module import declaration for an implicitly-generated
  /// import.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImportDecl *) )
  CreateImplicit(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::Module::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::Module *)) Imported, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::SourceLocation)) EndLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImportDecl, reflenums::clang__ImportDecl::CreateImplicit, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImportDecl *) )
  CreateImplicit(Y0 p0, ptrwrp<Y1> p1, Y2 p2, ptrwrp<Y3> p3, Y4 p4) {
      return CreateImplicit(p0, p1.get(), p2, p3.get(), p4);
  }), () )
  /// Create a new, deserialized module import declaration.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImportDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID, unsigned int NumLocations) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImportDecl, reflenums::clang__ImportDecl::CreateDeserialized, Xs..., Y0s..., ID, NumLocations); }) , (;) )
  /// Retrieve the module that was imported by the import declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Module *) )
  getImportedModule() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImportDecl, reflenums::clang__ImportDecl::getImportedModule, Xs...); }) , (;) )
  /// Retrieves the locations of each of the identifiers that make up
  /// the complete module name in the import declaration.
  ///
  /// This will return an empty array if the locations of the individual
  /// identifiers aren't available.
  RANGE_REFLECTION(clang::ImportDecl, getIdentifierLocs,
      constexpr auto getIdentifierLocs() const ,
      (typename meta::clang::SourceLocation),
      (reflenums::RK_clang__ImportDecl, reflenums::clang__ImportDecl::getIdentifierLocs, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImportDecl, reflenums::clang__ImportDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImportDecl, reflenums::clang__ImportDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImportDecl, reflenums::clang__ImportDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a C++ Modules TS module export declaration.
///
/// For example:
/// \code
///   export void foo();
/// \endcode
M_template_rtpack(Xs)
struct clang::ExportDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)>, impl_offset_t<clang::DeclContext, 40 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ExportDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ExportDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ExportDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) ExportLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExportDecl, reflenums::clang__ExportDecl::Create, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ExportDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2) {
      return Create(p0, p1.get(), p2);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ExportDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExportDecl, reflenums::clang__ExportDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExportLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExportDecl, reflenums::clang__ExportDecl::getExportLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRBraceLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExportDecl, reflenums::clang__ExportDecl::getRBraceLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExportDecl, reflenums::clang__ExportDecl::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExportDecl, reflenums::clang__ExportDecl::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExportDecl, reflenums::clang__ExportDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExportDecl, reflenums::clang__ExportDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExportDecl, reflenums::clang__ExportDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents an empty-declaration.
M_template_rtpack(Xs)
struct clang::EmptyDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__EmptyDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::EmptyDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::EmptyDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) L) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EmptyDecl, reflenums::clang__EmptyDecl::Create, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::EmptyDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2) {
      return Create(p0, p1.get(), p2);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::EmptyDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EmptyDecl, reflenums::clang__EmptyDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EmptyDecl, reflenums::clang__EmptyDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__EmptyDecl, reflenums::clang__EmptyDecl::classofKind, Xs..., K); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::DeclGroup::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DeclGroup;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DeclGroup::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclGroup *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y1s...> * *), (typename meta::clang::Decl **)) Decls, unsigned int NumDecls) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclGroup, reflenums::clang__DeclGroup::Create, Xs..., Y0s..., Y1s..., NumDecls); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclGroup *) )
  Create(Y0 p0, ptrwrp<Y1> p1, unsigned int p2) {
      return Create(p0, p1.get(), p2);
  }), () )
  constexpr unsigned int size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclGroup, reflenums::clang__DeclGroup::size, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Decl *const &) )
  operator[](unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclGroup, reflenums::clang__DeclGroup::operator_sub, Xs..., i); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::DeclGroupRef::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DeclGroupRef;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DeclGroupRef::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclGroupRef) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y1s...> * *), (typename meta::clang::Decl **)) Decls, unsigned int NumDecls) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclGroupRef, reflenums::clang__DeclGroupRef::Create, Xs..., Y0s..., Y1s..., NumDecls); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclGroupRef) )
  Create(Y0 p0, ptrwrp<Y1> p1, unsigned int p2) {
      return Create(p0, p1.get(), p2);
  }), () )
  constexpr bool isNull() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclGroupRef, reflenums::clang__DeclGroupRef::isNull, Xs...); }) , (;) )
  constexpr bool isSingleDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclGroupRef, reflenums::clang__DeclGroupRef::isSingleDecl, Xs...); }) , (;) )
  constexpr bool isDeclGroup() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclGroupRef, reflenums::clang__DeclGroupRef::isDeclGroup, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Decl *) )
  getSingleDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclGroupRef, reflenums::clang__DeclGroupRef::getSingleDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclGroup &) )
  getDeclGroup() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclGroupRef, reflenums::clang__DeclGroupRef::getDeclGroup, Xs...); }) , (;) )
  constexpr void * getAsOpaquePtr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclGroupRef, reflenums::clang__DeclGroupRef::getAsOpaquePtr, Xs...); }) , (;) )
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclGroupRef) )
  getFromOpaquePtr(void * Ptr) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclGroupRef, reflenums::clang__DeclGroupRef::getFromOpaquePtr, Xs..., Ptr); }) , (;) )
  RANGECLASS_SIZE_AND_GET(clang__DeclGroupRef, typename meta::clang::Decl *const);
};

/// The different kinds of captured statement.
enum clang::CapturedRegionKind : unsigned int {
  CR_Default,
  CR_ObjCAtFinally,
  CR_OpenMP,
};

enum clang::Stmt::StmtClass : unsigned int {
  NoStmtClass = 0,
  GCCAsmStmtClass,
  MSAsmStmtClass,
  firstAsmStmtConstant = 1,
  lastAsmStmtConstant = 2,
  AttributedStmtClass,
  BreakStmtClass,
  CXXCatchStmtClass,
  CXXPackExpansionStmtClass,
  CXXTupleExpansionStmtClass,
  firstCXXExpansionStmtConstant = 6,
  lastCXXExpansionStmtConstant = 7,
  CXXForRangeStmtClass,
  CXXQueueMetaparseStmtClass,
  CXXTryStmtClass,
  CapturedStmtClass,
  CompoundStmtClass,
  ContinueStmtClass,
  CoreturnStmtClass,
  CoroutineBodyStmtClass,
  DeclStmtClass,
  DoStmtClass,
  BinaryConditionalOperatorClass,
  ConditionalOperatorClass,
  firstAbstractConditionalOperatorConstant = 18,
  lastAbstractConditionalOperatorConstant = 19,
  AddrLabelExprClass,
  ArrayInitIndexExprClass,
  ArrayInitLoopExprClass,
  ArraySubscriptExprClass,
  ArrayTypeTraitExprClass,
  AsTypeExprClass,
  AtomicExprClass,
  BinaryOperatorClass,
  CompoundAssignOperatorClass,
  firstBinaryOperatorConstant = 27,
  lastBinaryOperatorConstant = 28,
  BlockExprClass,
  CXXBindTemporaryExprClass,
  CXXBoolLiteralExprClass,
  CXXConcatenateExprClass,
  CXXConstantExprClass,
  CXXConstructExprClass,
  CXXTemporaryObjectExprClass,
  firstCXXConstructExprConstant = 34,
  lastCXXConstructExprConstant = 35,
  CXXDefaultArgExprClass,
  CXXDefaultInitExprClass,
  CXXDeleteExprClass,
  CXXDependentIdExprClass,
  CXXDependentScopeMemberExprClass,
  CXXFoldExprClass,
  CXXInheritedCtorInitExprClass,
  CXXMetaparseExprClass,
  CXXNewExprClass,
  CXXNoexceptExprClass,
  CXXNullPtrLiteralExprClass,
  CXXPseudoDestructorExprClass,
  CXXScalarValueInitExprClass,
  CXXStdInitializerListExprClass,
  CXXThisExprClass,
  CXXThrowExprClass,
  CXXTypeidExprClass,
  CXXUnresolvedConstructExprClass,
  CXXUuidofExprClass,
  CallExprClass,
  CUDAKernelCallExprClass,
  CXXMemberCallExprClass,
  CXXOperatorCallExprClass,
  UserDefinedLiteralClass,
  firstCallExprConstant = 55,
  lastCallExprConstant = 59,
  CStyleCastExprClass,
  CXXFunctionalCastExprClass,
  CXXConstCastExprClass,
  CXXDynamicCastExprClass,
  CXXReinterpretCastExprClass,
  CXXStaticCastExprClass,
  firstCXXNamedCastExprConstant = 62,
  lastCXXNamedCastExprConstant = 65,
  ObjCBridgedCastExprClass,
  firstExplicitCastExprConstant = 60,
  lastExplicitCastExprConstant = 66,
  ImplicitCastExprClass,
  firstCastExprConstant = 60,
  lastCastExprConstant = 67,
  CharacterLiteralClass,
  ChooseExprClass,
  CompilerDiagnosticExprClass,
  CompilerMessageExprClass,
  CompoundLiteralExprClass,
  ConvertVectorExprClass,
  CoawaitExprClass,
  CoyieldExprClass,
  firstCoroutineSuspendExprConstant = 74,
  lastCoroutineSuspendExprConstant = 75,
  DeclRefExprClass,
  DependentCoawaitExprClass,
  DependentScopeDeclRefExprClass,
  DesignatedInitExprClass,
  DesignatedInitUpdateExprClass,
  ExprWithCleanupsClass,
  ExpressionTraitExprClass,
  ExtVectorElementExprClass,
  FixedPointLiteralClass,
  FloatingLiteralClass,
  FunctionParmPackExprClass,
  GNUNullExprClass,
  GenericSelectionExprClass,
  ImaginaryLiteralClass,
  ImplicitValueInitExprClass,
  InitListExprClass,
  IntegerLiteralClass,
  LambdaExprClass,
  MSPropertyRefExprClass,
  MSPropertySubscriptExprClass,
  MaterializeTemporaryExprClass,
  MemberExprClass,
  NoInitExprClass,
  OMPArraySectionExprClass,
  ObjCArrayLiteralClass,
  ObjCAvailabilityCheckExprClass,
  ObjCBoolLiteralExprClass,
  ObjCBoxedExprClass,
  ObjCDictionaryLiteralClass,
  ObjCEncodeExprClass,
  ObjCIndirectCopyRestoreExprClass,
  ObjCIsaExprClass,
  ObjCIvarRefExprClass,
  ObjCMessageExprClass,
  ObjCPropertyRefExprClass,
  ObjCProtocolExprClass,
  ObjCSelectorExprClass,
  ObjCStringLiteralClass,
  ObjCSubscriptRefExprClass,
  OffsetOfExprClass,
  OpaqueValueExprClass,
  UnresolvedLookupExprClass,
  UnresolvedMemberExprClass,
  firstOverloadExprConstant = 117,
  lastOverloadExprConstant = 118,
  PackExpansionExprClass,
  ParenExprClass,
  ParenListExprClass,
  PredefinedExprClass,
  PseudoObjectExprClass,
  ReflectDeleteExprClass,
  ReflectNewExprClass,
  ReflectionExprClass,
  ReflectionTraitExprClass,
  ShuffleVectorExprClass,
  SizeOfPackExprClass,
  StmtExprClass,
  StringLiteralClass,
  SubstNonTypeTemplateParmExprClass,
  SubstNonTypeTemplateParmPackExprClass,
  TypeTraitExprClass,
  TypoExprClass,
  UnaryExprOrTypeTraitExprClass,
  UnaryOperatorClass,
  VAArgExprClass,
  firstExprConstant = 18,
  lastExprConstant = 138,
  ForStmtClass,
  GotoStmtClass,
  IfStmtClass,
  IndirectGotoStmtClass,
  LabelStmtClass,
  MSDependentExistsStmtClass,
  NullStmtClass,
  OMPAtomicDirectiveClass,
  OMPBarrierDirectiveClass,
  OMPCancelDirectiveClass,
  OMPCancellationPointDirectiveClass,
  OMPCriticalDirectiveClass,
  OMPFlushDirectiveClass,
  OMPDistributeDirectiveClass,
  OMPDistributeParallelForDirectiveClass,
  OMPDistributeParallelForSimdDirectiveClass,
  OMPDistributeSimdDirectiveClass,
  OMPForDirectiveClass,
  OMPForSimdDirectiveClass,
  OMPParallelForDirectiveClass,
  OMPParallelForSimdDirectiveClass,
  OMPSimdDirectiveClass,
  OMPTargetParallelForSimdDirectiveClass,
  OMPTargetSimdDirectiveClass,
  OMPTargetTeamsDistributeDirectiveClass,
  OMPTargetTeamsDistributeParallelForDirectiveClass,
  OMPTargetTeamsDistributeParallelForSimdDirectiveClass,
  OMPTargetTeamsDistributeSimdDirectiveClass,
  OMPTaskLoopDirectiveClass,
  OMPTaskLoopSimdDirectiveClass,
  OMPTeamsDistributeDirectiveClass,
  OMPTeamsDistributeParallelForDirectiveClass,
  OMPTeamsDistributeParallelForSimdDirectiveClass,
  OMPTeamsDistributeSimdDirectiveClass,
  firstOMPLoopDirectiveConstant = 152,
  lastOMPLoopDirectiveConstant = 172,
  OMPMasterDirectiveClass,
  OMPOrderedDirectiveClass,
  OMPParallelDirectiveClass,
  OMPParallelSectionsDirectiveClass,
  OMPSectionDirectiveClass,
  OMPSectionsDirectiveClass,
  OMPSingleDirectiveClass,
  OMPTargetDataDirectiveClass,
  OMPTargetDirectiveClass,
  OMPTargetEnterDataDirectiveClass,
  OMPTargetExitDataDirectiveClass,
  OMPTargetParallelDirectiveClass,
  OMPTargetParallelForDirectiveClass,
  OMPTargetTeamsDirectiveClass,
  OMPTargetUpdateDirectiveClass,
  OMPTaskDirectiveClass,
  OMPTaskgroupDirectiveClass,
  OMPTaskwaitDirectiveClass,
  OMPTaskyieldDirectiveClass,
  OMPTeamsDirectiveClass,
  firstOMPExecutableDirectiveConstant = 146,
  lastOMPExecutableDirectiveConstant = 192,
  ObjCAtCatchStmtClass,
  ObjCAtFinallyStmtClass,
  ObjCAtSynchronizedStmtClass,
  ObjCAtThrowStmtClass,
  ObjCAtTryStmtClass,
  ObjCAutoreleasePoolStmtClass,
  ObjCForCollectionStmtClass,
  ReturnStmtClass,
  SEHExceptStmtClass,
  SEHFinallyStmtClass,
  SEHLeaveStmtClass,
  SEHTryStmtClass,
  CaseStmtClass,
  DefaultStmtClass,
  firstSwitchCaseConstant = 205,
  lastSwitchCaseConstant = 206,
  SwitchStmtClass,
  WhileStmtClass,
  firstStmtConstant = 1,
  lastStmtConstant = 208,
};

/// Stmt - This represents one statement.
///
M_template_rtpack(Xs)
struct clang::Stmt::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Stmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Stmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using StmtClass = enum refldetail::clang::Stmt::StmtClass;
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr void * operator new(unsigned long bytes, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int alignment = 8) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::operator_new, Xs..., bytes, Y0s..., alignment); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr void * operator new(unsigned long bytes, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ASTContext *)) C, unsigned int alignment = 8) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::operator_new1, Xs..., bytes, Y0s..., alignment); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr void * operator new(unsigned long p0, ptrwrp<Y0> p1, unsigned int p2 = 8) {
      return operator new(p0, p1.get(), p2);
  }), () )
  static constexpr void * operator new(unsigned long bytes, void * mem) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::operator_new2, Xs..., bytes, mem); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr void operator delete(void * p0, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) p1, unsigned int p2) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::operator_delete, Xs..., p0, Y0s..., p2); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr void operator delete(void * p0, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ASTContext *)) p1, unsigned int p2) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::operator_delete1, Xs..., p0, Y0s..., p2); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr void operator delete(void * p0, ptrwrp<Y0> p1, unsigned int p2) {
      return operator delete(p0, p1.get(), p2);
  }), () )
  static constexpr void operator delete(void * p0, unsigned long p1) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::operator_delete2, Xs..., p0, p1); }) , (;) )
  static constexpr void operator delete(void * p0, void * p1) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::operator_delete3, Xs..., p0, p1); }) , (;) )
  M_template_rtpack(Zs) using EmptyShell = struct refldetail::clang::Stmt::EmptyShell::M_template impl M_targpack(Zs);
  constexpr enum clang::Stmt::StmtClass getStmtClass() const IFMETA_ELSE( ({    return (enum clang::Stmt::StmtClass)__reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::getStmtClass, Xs...); }) , (;) )
  constexpr const char * getStmtClassName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::getStmtClassName, Xs...); }) , (;) )
  /// SourceLocation tokens are not useful in isolation - they are low level
  /// value objects created/interpreted by SourceManager. We assume AST
  /// clients will have a pointer to the respective SourceManager.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::getEndLoc, Xs...); }) , (;) )
  static constexpr void addStmtClass(const enum clang::Stmt::StmtClass s) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::addStmtClass, Xs..., s); }) , (;) )
  static constexpr void EnableStatistics() IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::EnableStatistics, Xs...); }) , (;) )
  static constexpr void PrintStats() IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::PrintStats, Xs...); }) , (;) )
  /// Dumps the specified AST fragment and all subtrees to
  /// \c llvm::errs().
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::dump, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void dump(IFMETA_ELSE((const clang::SourceManager::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::SourceManager &)) SM) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::dump1, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void dump(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::SourceManager::template impl</*ptrorref=*/1, Y1s...>), (typename meta::clang::SourceManager &)) SM) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::dump2, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void dump(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::dump3, Xs..., Y0s...); }) , (;) )
  /// dumpColor - same as dump(), but forces color highlighting.
  constexpr void dumpColor() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::dumpColor, Xs...); }) , (;) )
  /// dumpPretty/printPretty - These two methods do a "pretty print" of the AST
  /// back to its original source language syntax.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void dumpPretty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::dumpPretty, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  constexpr void printPretty(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrinterHelper::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::PrinterHelper *)) Helper, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y2s...>), (const typename meta::clang::PrintingPolicy &)) Policy, unsigned int Indentation = 0, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y3s...> *), (const typename meta::clang::ASTContext *)) Context = {}) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::printPretty, Xs..., Y0s..., Y1s..., Y2s..., Indentation, Y3s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  constexpr void printPretty(Y0 p0, ptrwrp<Y1> p1, Y2 p2, unsigned int p3 = 0, ptrwrp<Y3> p4 = {}) const {
      return printPretty(p0, p1.get(), p2, p3, p4.get());
  }), () )
  /// viewAST - Visualize an AST rooted at this Stmt* using GraphViz.  Only
  ///   works on systems with GraphViz (Mac OS X) or dot+gv installed.
  constexpr void viewAST() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::viewAST, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  IgnoreImplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::IgnoreImplicit, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  IgnoreContainers(bool IgnoreCaptured = false) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::IgnoreContainers, Xs..., IgnoreCaptured); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  stripLabelLikeStatements() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::stripLabelLikeStatements, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::Stmt, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__Stmt, reflenums::clang__Stmt::children, Xs...), () )
  /// Produce a unique representation of the given statement.
  ///
  /// \param ID once the profiling operation is complete, will contain
  /// the unique representation of the given statement.
  ///
  /// \param Context the AST context in which the statement resides
  ///
  /// \param Canonical whether the profile should be based on the canonical
  /// representation of this statement (e.g., where non-type template
  /// parameters are identified by index/level rather than their
  /// declaration pointers) or the exact representation of the statement as
  /// written in the source.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Context, bool Canonical) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Stmt, reflenums::clang__Stmt::Profile, Xs..., Y0s..., Y1s..., Canonical); }) , (;) )
};

/// A placeholder type used to construct an empty shell of a
  /// type, that will be filled in later (e.g., by some
  /// de-serialization).
M_template_rtpack(Xs)
struct clang::Stmt::EmptyShell::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Stmt__EmptyShell;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Stmt::EmptyShell::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
};

/// DeclStmt - Adaptor class for mixing declarations with statements and
/// expressions. For example, CompoundStmt mixes statements, expressions
/// and declarations (variables, types). Another example is ForStmt, where
/// the first statement can be an expression or a declaration.
M_template_rtpack(Xs)
struct clang::DeclStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DeclStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DeclStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// isSingleDecl - This method returns true if this DeclStmt refers
  /// to a single Decl.
  constexpr bool isSingleDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclStmt, reflenums::clang__DeclStmt::isSingleDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Decl *) )
  getSingleDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclStmt, reflenums::clang__DeclStmt::getSingleDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclGroupRef) )
  getDeclGroup() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclStmt, reflenums::clang__DeclStmt::getDeclGroup, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getStartLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclStmt, reflenums::clang__DeclStmt::getStartLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclStmt, reflenums::clang__DeclStmt::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclStmt, reflenums::clang__DeclStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclStmt, reflenums::clang__DeclStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclStmt, reflenums::clang__DeclStmt::getLocEnd, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclStmt, reflenums::clang__DeclStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::DeclStmt, decls,
      constexpr auto decls() const ,
      (typename meta::clang::Decl *const),
      (reflenums::RK_clang__DeclStmt, reflenums::clang__DeclStmt::decls, Xs...), () )
};

/// NullStmt - This is the null statement ";": C99 6.8.3p3.
///
M_template_rtpack(Xs)
struct clang::NullStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__NullStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::NullStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getSemiLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NullStmt, reflenums::clang__NullStmt::getSemiLoc, Xs...); }) , (;) )
  constexpr bool hasLeadingEmptyMacro() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NullStmt, reflenums::clang__NullStmt::hasLeadingEmptyMacro, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NullStmt, reflenums::clang__NullStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NullStmt, reflenums::clang__NullStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NullStmt, reflenums::clang__NullStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NullStmt, reflenums::clang__NullStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NullStmt, reflenums::clang__NullStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// CompoundStmt - This represents a group of statements like { stmt stmt }.
M_template_rtpack(Xs)
struct clang::CompoundStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CompoundStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CompoundStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CompoundStmt *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumStmts) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::CreateEmpty, Xs..., Y0s..., NumStmts); }) , (;) )
  constexpr bool body_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::body_empty, Xs...); }) , (;) )
  constexpr unsigned int size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::size, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CompoundStmt, body,
      constexpr auto body() const ,
      (typename meta::clang::Stmt *const),
      (reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::body, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  body_front() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::body_front, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  body_back() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::body_back, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLBracLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::getLBracLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRBracLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::getRBracLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::CompoundStmt, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__CompoundStmt, reflenums::clang__CompoundStmt::children, Xs...), () )
};

M_template_rtpack(Xs)
struct clang::SwitchCase::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SwitchCase;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SwitchCase::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::SwitchCase *) )
  getNextSwitchCase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchCase, reflenums::clang__SwitchCase::getNextSwitchCase, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getKeywordLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchCase, reflenums::clang__SwitchCase::getKeywordLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getColonLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchCase, reflenums::clang__SwitchCase::getColonLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getSubStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchCase, reflenums::clang__SwitchCase::getSubStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchCase, reflenums::clang__SwitchCase::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchCase, reflenums::clang__SwitchCase::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchCase, reflenums::clang__SwitchCase::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchCase, reflenums::clang__SwitchCase::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchCase, reflenums::clang__SwitchCase::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::CaseStmt::impl : impl_offset_t<clang::SwitchCase, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CaseStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CaseStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getCaseLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CaseStmt, reflenums::clang__CaseStmt::getCaseLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEllipsisLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CaseStmt, reflenums::clang__CaseStmt::getEllipsisLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getColonLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CaseStmt, reflenums::clang__CaseStmt::getColonLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getLHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CaseStmt, reflenums::clang__CaseStmt::getLHS, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getRHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CaseStmt, reflenums::clang__CaseStmt::getRHS, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getSubStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CaseStmt, reflenums::clang__CaseStmt::getSubStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CaseStmt, reflenums::clang__CaseStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CaseStmt, reflenums::clang__CaseStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CaseStmt, reflenums::clang__CaseStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CaseStmt, reflenums::clang__CaseStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CaseStmt, reflenums::clang__CaseStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::DefaultStmt::impl : impl_offset_t<clang::SwitchCase, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DefaultStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DefaultStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getSubStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DefaultStmt, reflenums::clang__DefaultStmt::getSubStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getDefaultLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DefaultStmt, reflenums::clang__DefaultStmt::getDefaultLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getColonLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DefaultStmt, reflenums::clang__DefaultStmt::getColonLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DefaultStmt, reflenums::clang__DefaultStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DefaultStmt, reflenums::clang__DefaultStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DefaultStmt, reflenums::clang__DefaultStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DefaultStmt, reflenums::clang__DefaultStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DefaultStmt, reflenums::clang__DefaultStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// LabelStmt - Represents a label, which has a substatement.  For example:
///    foo: return;
M_template_rtpack(Xs)
struct clang::LabelStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__LabelStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::LabelStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getIdentLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelStmt, reflenums::clang__LabelStmt::getIdentLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::LabelDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelStmt, reflenums::clang__LabelStmt::getDecl, Xs...); }) , (;) )
  constexpr const char * getName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelStmt, reflenums::clang__LabelStmt::getName, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getSubStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelStmt, reflenums::clang__LabelStmt::getSubStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelStmt, reflenums::clang__LabelStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelStmt, reflenums::clang__LabelStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelStmt, reflenums::clang__LabelStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelStmt, reflenums::clang__LabelStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LabelStmt, reflenums::clang__LabelStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents an attribute applied to a statement.
///
/// Represents an attribute applied to a statement. For example:
///   [[omp::for(...)]] for (...) { ... }
M_template_rtpack(Xs)
struct clang::AttributedStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__AttributedStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::AttributedStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::AttributedStmt *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumAttrs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedStmt, reflenums::clang__AttributedStmt::CreateEmpty, Xs..., Y0s..., NumAttrs); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAttrLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedStmt, reflenums::clang__AttributedStmt::getAttrLoc, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::AttributedStmt, getAttrs,
      constexpr auto getAttrs() const ,
      (const typename meta::clang::Attr *),
      (reflenums::RK_clang__AttributedStmt, reflenums::clang__AttributedStmt::getAttrs, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getSubStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedStmt, reflenums::clang__AttributedStmt::getSubStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedStmt, reflenums::clang__AttributedStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedStmt, reflenums::clang__AttributedStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedStmt, reflenums::clang__AttributedStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedStmt, reflenums::clang__AttributedStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AttributedStmt, reflenums::clang__AttributedStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// IfStmt - This represents an if/then/else.
M_template_rtpack(Xs)
struct clang::IfStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__IfStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::IfStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the variable declared in this "if" statement, if any.
  ///
  /// In the following example, "x" is the condition variable.
  /// \code
  /// if (int x = foo()) {
  ///   printf("x is %d", x);
  /// }
  /// \endcode
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getConditionVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::getConditionVariable, Xs...); }) , (;) )
  /// If this IfStmt has a condition variable, return the faux DeclStmt
  /// associated with the creation of that condition variable.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclStmt *) )
  getConditionVariableDeclStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::getConditionVariableDeclStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::getInit, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getCond() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::getCond, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getThen() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::getThen, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getElse() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::getElse, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getIfLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::getIfLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getElseLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::getElseLoc, Xs...); }) , (;) )
  constexpr bool isConstexpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::isConstexpr, Xs...); }) , (;) )
  constexpr bool isObjCAvailabilityCheck() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::isObjCAvailabilityCheck, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IfStmt, reflenums::clang__IfStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// SwitchStmt - This represents a 'switch' stmt.
M_template_rtpack(Xs)
struct clang::SwitchStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SwitchStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SwitchStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the variable declared in this "switch" statement, if any.
  ///
  /// In the following example, "x" is the condition variable.
  /// \code
  /// switch (int x = foo()) {
  ///   case 0: break;
  ///   // ...
  /// }
  /// \endcode
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getConditionVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchStmt, reflenums::clang__SwitchStmt::getConditionVariable, Xs...); }) , (;) )
  /// If this SwitchStmt has a condition variable, return the faux DeclStmt
  /// associated with the creation of that condition variable.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclStmt *) )
  getConditionVariableDeclStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchStmt, reflenums::clang__SwitchStmt::getConditionVariableDeclStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchStmt, reflenums::clang__SwitchStmt::getInit, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getCond() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchStmt, reflenums::clang__SwitchStmt::getCond, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchStmt, reflenums::clang__SwitchStmt::getBody, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::SwitchCase *) )
  getSwitchCaseList() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchStmt, reflenums::clang__SwitchStmt::getSwitchCaseList, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getSwitchLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchStmt, reflenums::clang__SwitchStmt::getSwitchLoc, Xs...); }) , (;) )
  /// Returns true if the SwitchStmt is a switch of an enum value and all cases
  /// have been explicitly covered.
  constexpr bool isAllEnumCasesCovered() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchStmt, reflenums::clang__SwitchStmt::isAllEnumCasesCovered, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchStmt, reflenums::clang__SwitchStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchStmt, reflenums::clang__SwitchStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchStmt, reflenums::clang__SwitchStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchStmt, reflenums::clang__SwitchStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SwitchStmt, reflenums::clang__SwitchStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// WhileStmt - This represents a 'while' stmt.
M_template_rtpack(Xs)
struct clang::WhileStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__WhileStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::WhileStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the variable declared in this "while" statement, if any.
  ///
  /// In the following example, "x" is the condition variable.
  /// \code
  /// while (int x = random()) {
  ///   // ...
  /// }
  /// \endcode
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getConditionVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__WhileStmt, reflenums::clang__WhileStmt::getConditionVariable, Xs...); }) , (;) )
  /// If this WhileStmt has a condition variable, return the faux DeclStmt
  /// associated with the creation of that condition variable.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclStmt *) )
  getConditionVariableDeclStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__WhileStmt, reflenums::clang__WhileStmt::getConditionVariableDeclStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getCond() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__WhileStmt, reflenums::clang__WhileStmt::getCond, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__WhileStmt, reflenums::clang__WhileStmt::getBody, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getWhileLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__WhileStmt, reflenums::clang__WhileStmt::getWhileLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__WhileStmt, reflenums::clang__WhileStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__WhileStmt, reflenums::clang__WhileStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__WhileStmt, reflenums::clang__WhileStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__WhileStmt, reflenums::clang__WhileStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__WhileStmt, reflenums::clang__WhileStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// DoStmt - This represents a 'do/while' stmt.
M_template_rtpack(Xs)
struct clang::DoStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DoStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DoStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getCond() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DoStmt, reflenums::clang__DoStmt::getCond, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DoStmt, reflenums::clang__DoStmt::getBody, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getDoLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DoStmt, reflenums::clang__DoStmt::getDoLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getWhileLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DoStmt, reflenums::clang__DoStmt::getWhileLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DoStmt, reflenums::clang__DoStmt::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DoStmt, reflenums::clang__DoStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DoStmt, reflenums::clang__DoStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DoStmt, reflenums::clang__DoStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DoStmt, reflenums::clang__DoStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DoStmt, reflenums::clang__DoStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ForStmt - This represents a 'for (init;cond;inc)' stmt.  Note that any of
/// the init/cond/inc parts of the ForStmt will be null if they were not
/// specified in the source.
M_template_rtpack(Xs)
struct clang::ForStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ForStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ForStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the variable declared in this "for" statement, if any.
  ///
  /// In the following example, "y" is the condition variable.
  /// \code
  /// for (int x = random(); int y = mangle(x); ++x) {
  ///   // ...
  /// }
  /// \endcode
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getConditionVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::getConditionVariable, Xs...); }) , (;) )
  /// If this ForStmt has a condition variable, return the faux DeclStmt
  /// associated with the creation of that condition variable.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclStmt *) )
  getConditionVariableDeclStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::getConditionVariableDeclStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::getInit, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getCond() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::getCond, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getInc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::getInc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::getBody, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getForLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::getForLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::getLParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ForStmt, reflenums::clang__ForStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// GotoStmt - This represents a direct goto.
M_template_rtpack(Xs)
struct clang::GotoStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__GotoStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::GotoStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::LabelDecl *) )
  getLabel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GotoStmt, reflenums::clang__GotoStmt::getLabel, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getGotoLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GotoStmt, reflenums::clang__GotoStmt::getGotoLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLabelLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GotoStmt, reflenums::clang__GotoStmt::getLabelLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GotoStmt, reflenums::clang__GotoStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GotoStmt, reflenums::clang__GotoStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GotoStmt, reflenums::clang__GotoStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GotoStmt, reflenums::clang__GotoStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GotoStmt, reflenums::clang__GotoStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// IndirectGotoStmt - This represents an indirect goto.
M_template_rtpack(Xs)
struct clang::IndirectGotoStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__IndirectGotoStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::IndirectGotoStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getGotoLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectGotoStmt, reflenums::clang__IndirectGotoStmt::getGotoLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getStarLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectGotoStmt, reflenums::clang__IndirectGotoStmt::getStarLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getTarget() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectGotoStmt, reflenums::clang__IndirectGotoStmt::getTarget, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::LabelDecl *) )
  getConstantTarget() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectGotoStmt, reflenums::clang__IndirectGotoStmt::getConstantTarget, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectGotoStmt, reflenums::clang__IndirectGotoStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectGotoStmt, reflenums::clang__IndirectGotoStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectGotoStmt, reflenums::clang__IndirectGotoStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectGotoStmt, reflenums::clang__IndirectGotoStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IndirectGotoStmt, reflenums::clang__IndirectGotoStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ContinueStmt - This represents a continue.
M_template_rtpack(Xs)
struct clang::ContinueStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ContinueStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ContinueStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getContinueLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ContinueStmt, reflenums::clang__ContinueStmt::getContinueLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ContinueStmt, reflenums::clang__ContinueStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ContinueStmt, reflenums::clang__ContinueStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ContinueStmt, reflenums::clang__ContinueStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ContinueStmt, reflenums::clang__ContinueStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ContinueStmt, reflenums::clang__ContinueStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// BreakStmt - This represents a break.
M_template_rtpack(Xs)
struct clang::BreakStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__BreakStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::BreakStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBreakLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BreakStmt, reflenums::clang__BreakStmt::getBreakLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BreakStmt, reflenums::clang__BreakStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BreakStmt, reflenums::clang__BreakStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BreakStmt, reflenums::clang__BreakStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BreakStmt, reflenums::clang__BreakStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BreakStmt, reflenums::clang__BreakStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ReturnStmt - This represents a return, optionally of an expression:
///   return;
///   return 4;
///
/// Note that GCC allows return with no argument in a function declared to
/// return a value, and it allows returning a value in functions declared to
/// return void.  We explicitly model this in the AST, which means you can't
/// depend on the return type of the function and the presence of an argument.
M_template_rtpack(Xs)
struct clang::ReturnStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ReturnStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ReturnStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getRetValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReturnStmt, reflenums::clang__ReturnStmt::getRetValue, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getReturnLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReturnStmt, reflenums::clang__ReturnStmt::getReturnLoc, Xs...); }) , (;) )
  /// Retrieve the variable that might be used for the named return
  /// value optimization.
  ///
  /// The optimization itself can only be performed if the variable is
  /// also marked as an NRVO object.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarDecl *) )
  getNRVOCandidate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReturnStmt, reflenums::clang__ReturnStmt::getNRVOCandidate, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReturnStmt, reflenums::clang__ReturnStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReturnStmt, reflenums::clang__ReturnStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReturnStmt, reflenums::clang__ReturnStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReturnStmt, reflenums::clang__ReturnStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReturnStmt, reflenums::clang__ReturnStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// AsmStmt is the base class for GCCAsmStmt and MSAsmStmt.
M_template_rtpack(Xs)
struct clang::AsmStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__AsmStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::AsmStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAsmLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getAsmLoc, Xs...); }) , (;) )
  constexpr bool isSimple() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::isSimple, Xs...); }) , (;) )
  constexpr bool isVolatile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::isVolatile, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getEndLoc, Xs...); }) , (;) )
  /// Assemble final IR asm string.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * generateAsmString(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::generateAsmString, Xs..., Y0s...); }) , (;) )
  constexpr unsigned int getNumOutputs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getNumOutputs, Xs...); }) , (;) )
  /// getOutputConstraint - Return the constraint string for the specified
  /// output operand.  All output constraints are known to be non-empty (either
  /// '=' or '+').
  constexpr const char * getOutputConstraint(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getOutputConstraint, Xs..., i); }) , (;) )
  /// isOutputPlusConstraint - Return true if the specified output constraint
  /// is a "+" constraint (which is both an input and an output) or false if it
  /// is an "=" constraint (just an output).
  constexpr bool isOutputPlusConstraint(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::isOutputPlusConstraint, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getOutputExpr(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getOutputExpr, Xs..., i); }) , (;) )
  /// getNumPlusOperands - Return the number of output operands that have a "+"
  /// constraint.
  constexpr unsigned int getNumPlusOperands() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getNumPlusOperands, Xs...); }) , (;) )
  constexpr unsigned int getNumInputs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getNumInputs, Xs...); }) , (;) )
  /// getInputConstraint - Return the specified input constraint.  Unlike output
  /// constraints, these can be empty.
  constexpr const char * getInputConstraint(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getInputConstraint, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getInputExpr(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getInputExpr, Xs..., i); }) , (;) )
  constexpr unsigned int getNumClobbers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getNumClobbers, Xs...); }) , (;) )
  constexpr const char * getClobber(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::getClobber, Xs..., i); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::AsmStmt, inputs,
      constexpr auto inputs() const ,
      (const typename meta::clang::Expr *const),
      (reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::inputs, Xs...), () )
  RANGE_REFLECTION(clang::AsmStmt, outputs,
      constexpr auto outputs() const ,
      (const typename meta::clang::Expr *const),
      (reflenums::RK_clang__AsmStmt, reflenums::clang__AsmStmt::outputs, Xs...), () )
};

/// This represents a GCC inline-assembly statement extension.
M_template_rtpack(Xs)
struct clang::GCCAsmStmt::impl : impl_offset_t<clang::AsmStmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__GCCAsmStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::GCCAsmStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::StringLiteral *) )
  getAsmString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getAsmString, Xs...); }) , (;) )
  /// Assemble final IR asm string.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * generateAsmString(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::generateAsmString, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getOutputIdentifier(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getOutputIdentifier, Xs..., i); }) , (;) )
  constexpr const char * getOutputName(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getOutputName, Xs..., i); }) , (;) )
  constexpr const char * getOutputConstraint(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getOutputConstraint, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::StringLiteral *) )
  getOutputConstraintLiteral(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getOutputConstraintLiteral, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getOutputExpr(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getOutputExpr, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getInputIdentifier(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getInputIdentifier, Xs..., i); }) , (;) )
  constexpr const char * getInputName(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getInputName, Xs..., i); }) , (;) )
  constexpr const char * getInputConstraint(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getInputConstraint, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::StringLiteral *) )
  getInputConstraintLiteral(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getInputConstraintLiteral, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getInputExpr(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getInputExpr, Xs..., i); }) , (;) )
  /// getNamedOperand - Given a symbolic operand reference like %[foo],
  /// translate this into a numeric value needed to reference the same operand.
  /// This returns -1 if the operand name is invalid.
  constexpr int getNamedOperand(const char * SymbolicName) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getNamedOperand, Xs..., SymbolicName); }) , (;) )
  constexpr const char * getClobber(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getClobber, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::StringLiteral *) )
  getClobberStringLiteral(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getClobberStringLiteral, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GCCAsmStmt, reflenums::clang__GCCAsmStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents a Microsoft inline-assembly statement extension.
M_template_rtpack(Xs)
struct clang::MSAsmStmt::impl : impl_offset_t<clang::AsmStmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__MSAsmStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::MSAsmStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLBraceLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getLBraceLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getEndLoc, Xs...); }) , (;) )
  constexpr bool hasBraces() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::hasBraces, Xs...); }) , (;) )
  constexpr const char * getAsmString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getAsmString, Xs...); }) , (;) )
  /// Assemble final IR asm string.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * generateAsmString(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::generateAsmString, Xs..., Y0s...); }) , (;) )
  constexpr const char * getOutputConstraint(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getOutputConstraint, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getOutputExpr(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getOutputExpr, Xs..., i); }) , (;) )
  constexpr const char * getInputConstraint(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getInputConstraint, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getInputExpr(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getInputExpr, Xs..., i); }) , (;) )
  RANGE_REFLECTION(clang::MSAsmStmt, getAllConstraints,
      constexpr auto getAllConstraints() const ,
      (const char *),
      (reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getAllConstraints, Xs...), () )
  RANGE_REFLECTION(clang::MSAsmStmt, getClobbers,
      constexpr auto getClobbers() const ,
      (const char *),
      (reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getClobbers, Xs...), () )
  RANGE_REFLECTION(clang::MSAsmStmt, getAllExprs,
      constexpr auto getAllExprs() const ,
      (typename meta::clang::Expr *),
      (reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getAllExprs, Xs...), () )
  constexpr const char * getClobber(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getClobber, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::getLocEnd, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSAsmStmt, reflenums::clang__MSAsmStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::SEHExceptStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SEHExceptStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SEHExceptStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SEHExceptStmt *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) ExceptLoc, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::Expr *)) FilterExpr, IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::Stmt *)) Block) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHExceptStmt, reflenums::clang__SEHExceptStmt::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SEHExceptStmt *) )
  Create(Y0 p0, Y1 p1, ptrwrp<Y2> p2, ptrwrp<Y3> p3) {
      return Create(p0, p1, p2.get(), p3.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHExceptStmt, reflenums::clang__SEHExceptStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHExceptStmt, reflenums::clang__SEHExceptStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHExceptStmt, reflenums::clang__SEHExceptStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExceptLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHExceptStmt, reflenums::clang__SEHExceptStmt::getExceptLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHExceptStmt, reflenums::clang__SEHExceptStmt::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getFilterExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHExceptStmt, reflenums::clang__SEHExceptStmt::getFilterExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CompoundStmt *) )
  getBlock() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHExceptStmt, reflenums::clang__SEHExceptStmt::getBlock, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHExceptStmt, reflenums::clang__SEHExceptStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::SEHFinallyStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SEHFinallyStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SEHFinallyStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SEHFinallyStmt *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) FinallyLoc, IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::Stmt *)) Block) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHFinallyStmt, reflenums::clang__SEHFinallyStmt::Create, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SEHFinallyStmt *) )
  Create(Y0 p0, Y1 p1, ptrwrp<Y2> p2) {
      return Create(p0, p1, p2.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHFinallyStmt, reflenums::clang__SEHFinallyStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHFinallyStmt, reflenums::clang__SEHFinallyStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHFinallyStmt, reflenums::clang__SEHFinallyStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getFinallyLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHFinallyStmt, reflenums::clang__SEHFinallyStmt::getFinallyLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHFinallyStmt, reflenums::clang__SEHFinallyStmt::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CompoundStmt *) )
  getBlock() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHFinallyStmt, reflenums::clang__SEHFinallyStmt::getBlock, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHFinallyStmt, reflenums::clang__SEHFinallyStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::SEHTryStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SEHTryStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SEHTryStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SEHTryStmt *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, bool isCXXTry, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) TryLoc, IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::Stmt *)) TryBlock, IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::Stmt *)) Handler) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHTryStmt, reflenums::clang__SEHTryStmt::Create, Xs..., Y0s..., isCXXTry, Y1s..., Y2s..., Y3s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SEHTryStmt *) )
  Create(Y0 p0, bool p1, Y1 p2, ptrwrp<Y2> p3, ptrwrp<Y3> p4) {
      return Create(p0, p1, p2, p3.get(), p4.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHTryStmt, reflenums::clang__SEHTryStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHTryStmt, reflenums::clang__SEHTryStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHTryStmt, reflenums::clang__SEHTryStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTryLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHTryStmt, reflenums::clang__SEHTryStmt::getTryLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHTryStmt, reflenums::clang__SEHTryStmt::getEndLoc, Xs...); }) , (;) )
  constexpr bool getIsCXXTry() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHTryStmt, reflenums::clang__SEHTryStmt::getIsCXXTry, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CompoundStmt *) )
  getTryBlock() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHTryStmt, reflenums::clang__SEHTryStmt::getTryBlock, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getHandler() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHTryStmt, reflenums::clang__SEHTryStmt::getHandler, Xs...); }) , (;) )
  /// Returns 0 if not defined
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SEHExceptStmt *) )
  getExceptHandler() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHTryStmt, reflenums::clang__SEHTryStmt::getExceptHandler, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SEHFinallyStmt *) )
  getFinallyHandler() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHTryStmt, reflenums::clang__SEHTryStmt::getFinallyHandler, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHTryStmt, reflenums::clang__SEHTryStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a __leave statement.
M_template_rtpack(Xs)
struct clang::SEHLeaveStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SEHLeaveStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SEHLeaveStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLeaveLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHLeaveStmt, reflenums::clang__SEHLeaveStmt::getLeaveLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHLeaveStmt, reflenums::clang__SEHLeaveStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHLeaveStmt, reflenums::clang__SEHLeaveStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHLeaveStmt, reflenums::clang__SEHLeaveStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHLeaveStmt, reflenums::clang__SEHLeaveStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SEHLeaveStmt, reflenums::clang__SEHLeaveStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// The different capture forms: by 'this', by reference, capture for
/// variable-length array type etc.
enum clang::CapturedStmt::VariableCaptureKind : unsigned int {
  VCK_This,
  VCK_ByRef,
  VCK_ByCopy,
  VCK_VLAType,
};

/// This captures a statement into a function. For example, the following
/// pragma annotated compound statement can be represented as a CapturedStmt,
/// and this compound statement is the body of an anonymous outlined function.
/// @code
/// #pragma omp parallel
/// {
///   compute();
/// }
/// @endcode
M_template_rtpack(Xs)
struct clang::CapturedStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CapturedStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CapturedStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using VariableCaptureKind = enum refldetail::clang::CapturedStmt::VariableCaptureKind;
  M_template_rtpack(Zs) using Capture = struct refldetail::clang::CapturedStmt::Capture::M_template impl M_targpack(Zs);
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CapturedStmt *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, unsigned int NumCaptures) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::CreateDeserialized, Xs..., Y0s..., NumCaptures); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getCapturedStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::getCapturedStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CapturedDecl *) )
  getCapturedDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::getCapturedDecl, Xs...); }) , (;) )
  /// Retrieve the captured region kind.
  constexpr enum clang::CapturedRegionKind getCapturedRegionKind() const IFMETA_ELSE( ({    return (enum clang::CapturedRegionKind)__reflect_prop(reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::getCapturedRegionKind, Xs...); }) , (;) )
  /// Retrieve the record declaration for captured variables.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::RecordDecl *) )
  getCapturedRecordDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::getCapturedRecordDecl, Xs...); }) , (;) )
  /// True if this variable has been captured.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool capturesVariable(IFMETA_ELSE((const clang::VarDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::VarDecl *)) Var) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::capturesVariable, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool capturesVariable(ptrwrp<Y0> p0) const {
      return capturesVariable(p0.get());
  }), () )
  RANGE_REFLECTION(clang::CapturedStmt, captures,
      constexpr auto captures() const ,
      (const typename meta::clang::CapturedStmt::Capture),
      (reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::captures, Xs...), () )
  /// Retrieve the number of captures, including 'this'.
  constexpr unsigned int capture_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::capture_size, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CapturedStmt, capture_inits,
      constexpr auto capture_inits() const ,
      (typename meta::clang::Expr *const),
      (reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::capture_inits, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt, reflenums::clang__CapturedStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Describes the capture of either a variable, or 'this', or
  /// variable-length array type.
M_template_rtpack(Xs)
struct clang::CapturedStmt::Capture::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CapturedStmt__Capture;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CapturedStmt::Capture::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Determine the kind of capture.
  constexpr enum clang::CapturedStmt::VariableCaptureKind getCaptureKind() const IFMETA_ELSE( ({    return (enum clang::CapturedStmt::VariableCaptureKind)__reflect_prop(reflenums::RK_clang__CapturedStmt__Capture, reflenums::clang__CapturedStmt__Capture::getCaptureKind, Xs...); }) , (;) )
  /// Retrieve the source location at which the variable or 'this' was
    /// first used.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt__Capture, reflenums::clang__CapturedStmt__Capture::getLocation, Xs...); }) , (;) )
  /// Determine whether this capture handles the C++ 'this' pointer.
  constexpr bool capturesThis() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt__Capture, reflenums::clang__CapturedStmt__Capture::capturesThis, Xs...); }) , (;) )
  /// Determine whether this capture handles a variable (by reference).
  constexpr bool capturesVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt__Capture, reflenums::clang__CapturedStmt__Capture::capturesVariable, Xs...); }) , (;) )
  /// Determine whether this capture handles a variable by copy.
  constexpr bool capturesVariableByCopy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt__Capture, reflenums::clang__CapturedStmt__Capture::capturesVariableByCopy, Xs...); }) , (;) )
  /// Determine whether this capture handles a variable-length array
    /// type.
  constexpr bool capturesVariableArrayType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt__Capture, reflenums::clang__CapturedStmt__Capture::capturesVariableArrayType, Xs...); }) , (;) )
  /// Retrieve the declaration of the variable being captured.
    ///
    /// This operation is only valid if this capture captures a variable.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getCapturedVar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CapturedStmt__Capture, reflenums::clang__CapturedStmt__Capture::getCapturedVar, Xs...); }) , (;) )
};

/// The kind of template argument we're storing.
enum clang::TemplateArgument::ArgKind : unsigned int {
  /// Represents an empty template argument, e.g., one that has not
  /// been deduced.
  Null = 0,
  /// The template argument is a type.
  Type,
  /// The template argument is a declaration that was provided for a pointer,
  /// reference, or pointer to member non-type template parameter.
  Declaration,
  /// The template argument is a null pointer or null pointer to member that
  /// was provided for a non-type template parameter.
  NullPtr,
  /// The template argument is an integral value stored in an llvm::APSInt
  /// that was provided for an integral non-type template parameter.
  Integral,
  /// The template argument is a template name that was provided for a
  /// template template parameter.
  Template,
  /// The template argument is a pack expansion of a template name that was
  /// provided for a template template parameter.
  TemplateExpansion,
  /// The template argument is an expression, and we've not resolved it to one
  /// of the other forms yet, either because it's dependent or because we're
  /// representing a non-canonical template argument (for instance, in a
  /// TemplateSpecializationType). Also used to represent a non-dependent
  /// __uuidof expression (a Microsoft extension).
  Expression,
  /// The template argument is actually a parameter pack. Arguments are stored
  /// in the Args struct.
  Pack,
};

/// Represents a template argument.
M_template_rtpack(Xs)
struct clang::TemplateArgument::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TemplateArgument;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TemplateArgument::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using ArgKind = enum refldetail::clang::TemplateArgument::ArgKind;
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateArgument) )
  getEmptyPack() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getEmptyPack, Xs...); }) , (;) )
  /// Return the kind of stored template argument.
  constexpr enum clang::TemplateArgument::ArgKind getKind() const IFMETA_ELSE( ({    return (enum clang::TemplateArgument::ArgKind)__reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getKind, Xs...); }) , (;) )
  /// Determine whether this template argument has no value.
  constexpr bool isNull() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::isNull, Xs...); }) , (;) )
  /// Whether this template argument is dependent on a template
  /// parameter such that its result can change from one instantiation to
  /// another.
  constexpr bool isDependent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::isDependent, Xs...); }) , (;) )
  /// Whether this template argument is dependent on a template
  /// parameter.
  constexpr bool isInstantiationDependent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::isInstantiationDependent, Xs...); }) , (;) )
  /// Whether this template argument contains an unexpanded
  /// parameter pack.
  constexpr bool containsUnexpandedParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::containsUnexpandedParameterPack, Xs...); }) , (;) )
  /// Determine whether this template argument is a pack expansion.
  constexpr bool isPackExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::isPackExpansion, Xs...); }) , (;) )
  /// Retrieve the type for a type template argument.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAsType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getAsType, Xs...); }) , (;) )
  /// Retrieve the declaration for a declaration non-type
  /// template argument.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ValueDecl *) )
  getAsDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getAsDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getParamTypeForDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getParamTypeForDecl, Xs...); }) , (;) )
  /// Retrieve the type for null non-type template argument.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getNullPtrType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getNullPtrType, Xs...); }) , (;) )
  /// Retrieve the template name for a template name argument.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getAsTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getAsTemplate, Xs...); }) , (;) )
  /// Retrieve the template argument as a template name; if the argument
  /// is a pack expansion, return the pattern as a template name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getAsTemplateOrTemplatePattern() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getAsTemplateOrTemplatePattern, Xs...); }) , (;) )
  /// Retrieve the template argument as an integral value.
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  getAsIntegral() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getAsIntegral, Xs...); }) , (;) )
  /// Retrieve the type of the integral value.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getIntegralType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getIntegralType, Xs...); }) , (;) )
  /// If this is a non-type template argument, get its type. Otherwise,
  /// returns a null QualType.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getNonTypeTemplateArgumentType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getNonTypeTemplateArgumentType, Xs...); }) , (;) )
  /// Retrieve the template argument as an expression.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getAsExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getAsExpr, Xs...); }) , (;) )
  /// Iterator range referencing all of the elements of a template
  /// argument pack.
  RANGE_REFLECTION(clang::TemplateArgument, pack_elements,
      constexpr auto pack_elements() const ,
      (typename meta::clang::TemplateArgument),
      (reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::pack_elements, Xs...), () )
  /// The number of template arguments in the given template argument
  /// pack.
  constexpr unsigned int pack_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::pack_size, Xs...); }) , (;) )
  /// Return the array of arguments in this template argument pack.
  RANGE_REFLECTION(clang::TemplateArgument, getPackAsArray,
      constexpr auto getPackAsArray() const ,
      (typename meta::clang::TemplateArgument),
      (reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getPackAsArray, Xs...), () )
  /// Determines whether two template arguments are superficially the
  /// same.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool structurallyEquals(IFMETA_ELSE((const clang::TemplateArgument::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::TemplateArgument &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::structurallyEquals, Xs..., Y0s...); }) , (;) )
  /// When the template argument is a pack expansion, returns
  /// the pattern of the pack expansion.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateArgument) )
  getPackExpansionPattern() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::getPackExpansionPattern, Xs...); }) , (;) )
  /// Print this template argument to the given output stream.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void print(IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::PrintingPolicy &)) Policy, IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y1s...>), (typename meta::llvm::raw_ostream &)) Out) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::print, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Debugging aid that dumps the template argument.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void dump(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) Out) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::dump, Xs..., Y0s...); }) , (;) )
  /// Debugging aid that dumps the template argument to standard error.
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::dump1, Xs...); }) , (;) )
  /// Used to insert TemplateArguments into FoldingSets.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__TemplateArgument, reflenums::clang__TemplateArgument::Profile, Xs..., Y0s..., Y1s...); }) , (;) )
};

/// Location information for a TemplateArgument.
M_template_rtpack(Xs)
struct clang::TemplateArgumentLocInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TemplateArgumentLocInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TemplateArgumentLocInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getAsTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLocInfo, reflenums::clang__TemplateArgumentLocInfo::getAsTypeSourceInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getAsExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLocInfo, reflenums::clang__TemplateArgumentLocInfo::getAsExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getTemplateQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLocInfo, reflenums::clang__TemplateArgumentLocInfo::getTemplateQualifierLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTemplateNameLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLocInfo, reflenums::clang__TemplateArgumentLocInfo::getTemplateNameLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTemplateEllipsisLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLocInfo, reflenums::clang__TemplateArgumentLocInfo::getTemplateEllipsisLoc, Xs...); }) , (;) )
};

/// Location wrapper for a TemplateArgument.  TemplateArgument is to
/// TemplateArgumentLoc as Type is to TypeLoc.
M_template_rtpack(Xs)
struct clang::TemplateArgumentLoc::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TemplateArgumentLoc;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TemplateArgumentLoc::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// - Fetches the primary location of the argument.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLoc, reflenums::clang__TemplateArgumentLoc::getLocation, Xs...); }) , (;) )
  /// - Fetches the full source range of the argument.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLoc, reflenums::clang__TemplateArgumentLoc::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgument &) )
  getArgument() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLoc, reflenums::clang__TemplateArgumentLoc::getArgument, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateArgumentLocInfo) )
  getLocInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLoc, reflenums::clang__TemplateArgumentLoc::getLocInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLoc, reflenums::clang__TemplateArgumentLoc::getTypeSourceInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSourceExpression() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLoc, reflenums::clang__TemplateArgumentLoc::getSourceExpression, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSourceDeclExpression() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLoc, reflenums::clang__TemplateArgumentLoc::getSourceDeclExpression, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSourceNullPtrExpression() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLoc, reflenums::clang__TemplateArgumentLoc::getSourceNullPtrExpression, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSourceIntegralExpression() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLoc, reflenums::clang__TemplateArgumentLoc::getSourceIntegralExpression, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getTemplateQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLoc, reflenums::clang__TemplateArgumentLoc::getTemplateQualifierLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTemplateNameLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLoc, reflenums::clang__TemplateArgumentLoc::getTemplateNameLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTemplateEllipsisLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentLoc, reflenums::clang__TemplateArgumentLoc::getTemplateEllipsisLoc, Xs...); }) , (;) )
};

/// A convenient class for passing around template argument
/// information.  Designed to be passed by reference.
M_template_rtpack(Xs)
struct clang::TemplateArgumentListInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TemplateArgumentListInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TemplateArgumentListInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentListInfo, reflenums::clang__TemplateArgumentListInfo::getLAngleLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentListInfo, reflenums::clang__TemplateArgumentListInfo::getRAngleLoc, Xs...); }) , (;) )
  constexpr unsigned int size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentListInfo, reflenums::clang__TemplateArgumentListInfo::size, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentLoc *) )
  getArgumentArray() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentListInfo, reflenums::clang__TemplateArgumentListInfo::getArgumentArray, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::TemplateArgumentListInfo, arguments,
      constexpr auto arguments() const ,
      (typename meta::clang::TemplateArgumentLoc),
      (reflenums::RK_clang__TemplateArgumentListInfo, reflenums::clang__TemplateArgumentListInfo::arguments, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentLoc &) )
  operator[](unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentListInfo, reflenums::clang__TemplateArgumentListInfo::operator_sub, Xs..., I); }) , (;) )
};

/// Represents an explicit template argument list in C++, e.g.,
/// the "<int>" in "sort<int>".
/// This is safe to be used inside an AST node, in contrast with
/// TemplateArgumentListInfo.
M_template_rtpack(Xs)
struct clang::ASTTemplateArgumentListInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ASTTemplateArgumentListInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ASTTemplateArgumentListInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// The source location of the left angle bracket ('<').
  M_REFLTYPED_FIELD(LAngleLoc, (typename meta::clang::SourceLocation), __reflect_prop(reflenums::RK_clang__ASTTemplateArgumentListInfo, reflenums::clang__ASTTemplateArgumentListInfo::LAngleLoc, Xs...))
  /// The source location of the right angle bracket ('>').
  M_REFLTYPED_FIELD(RAngleLoc, (typename meta::clang::SourceLocation), __reflect_prop(reflenums::RK_clang__ASTTemplateArgumentListInfo, reflenums::clang__ASTTemplateArgumentListInfo::RAngleLoc, Xs...))
  /// The number of template arguments in TemplateArgs.
  unsigned int NumTemplateArgs
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__ASTTemplateArgumentListInfo, reflenums::clang__ASTTemplateArgumentListInfo::NumTemplateArgs, Xs...);), (;) )
  /// Retrieve the template arguments
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentLoc *) )
  getTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTTemplateArgumentListInfo, reflenums::clang__ASTTemplateArgumentListInfo::getTemplateArgs, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ASTTemplateArgumentListInfo, arguments,
      constexpr auto arguments() const ,
      (typename meta::clang::TemplateArgumentLoc),
      (reflenums::RK_clang__ASTTemplateArgumentListInfo, reflenums::clang__ASTTemplateArgumentListInfo::arguments, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentLoc &) )
  operator[](unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTTemplateArgumentListInfo, reflenums::clang__ASTTemplateArgumentListInfo::operator_sub, Xs..., I); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ASTTemplateArgumentListInfo *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::TemplateArgumentListInfo &)) List) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTTemplateArgumentListInfo, reflenums::clang__ASTTemplateArgumentListInfo::Create, Xs..., Y0s..., Y1s...); }) , (;) )
};

/// The kinds of TypeLocs.  Equivalent to the Type::TypeClass enum,
/// except it also defines a Qualified enum that corresponds to the
/// QualifiedLoc class.
enum clang::TypeLoc::TypeLocClass : unsigned int {
  Builtin = 0,
  Complex = 1,
  Pointer = 2,
  BlockPointer = 3,
  LValueReference = 4,
  RValueReference = 5,
  MemberPointer = 6,
  ConstantArray = 7,
  IncompleteArray = 8,
  VariableArray = 9,
  DependentSizedArray = 10,
  DependentSizedExtVector = 11,
  DependentAddressSpace = 12,
  Vector = 13,
  DependentVector = 14,
  ExtVector = 15,
  FunctionProto = 16,
  FunctionNoProto = 17,
  UnresolvedUsing = 18,
  Paren = 19,
  Typedef = 20,
  Adjusted = 21,
  Decayed = 22,
  TypeOfExpr = 23,
  TypeOf = 24,
  Decltype = 25,
  Reflected = 26,
  UnaryTransform = 27,
  Record = 28,
  Enum = 29,
  Elaborated = 30,
  Attributed = 31,
  TemplateTypeParm = 32,
  SubstTemplateTypeParm = 33,
  SubstTemplateTypeParmPack = 34,
  TemplateSpecialization = 35,
  Auto = 36,
  DeducedTemplateSpecialization = 37,
  InjectedClassName = 38,
  ////END
  DependentName = 39,
  ////END
  DependentTemplateSpecialization = 40,
  ////END
  PackExpansion = 41,
  ////END
  ObjCTypeParam = 42,
  ////END
  ObjCObject = 43,
  ////END
  ObjCInterface = 44,
  ////END
  ObjCObjectPointer = 45,
  ////END
  Pipe = 46,
  ////END
  Atomic = 47,
  ////END
  Qualified,
};

/// Base wrapper for a particular "section" of type source info.
///
/// A client should use the TypeLoc subclasses through castAs()/getAs()
/// in order to get at the actual information.
M_template_rtpack(Xs)
struct clang::TypeLoc::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypeLoc;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypeLoc::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using TypeLocClass = enum refldetail::clang::TypeLoc::TypeLocClass;
  constexpr enum clang::TypeLoc::TypeLocClass getTypeLocClass() const IFMETA_ELSE( ({    return (enum clang::TypeLoc::TypeLocClass)__reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getTypeLocClass, Xs...); }) , (;) )
  constexpr bool isNull() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::isNull, Xs...); }) , (;) )
  constexpr explicit operator bool() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::operator_bool, Xs...); }) , (;) )
  /// Returns the size of type source info data block for the given type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr unsigned int getFullDataSizeForType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Ty) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getFullDataSizeForType, Xs..., Y0s...); }) , (;) )
  /// Returns the alignment of type source info data block for
  /// the given type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr unsigned int getLocalAlignmentForType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Ty) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getLocalAlignmentForType, Xs..., Y0s...); }) , (;) )
  /// Get the type for which this source info wrapper provides
  /// information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getTypePtr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getTypePtr, Xs...); }) , (;) )
  /// Get the pointer where source information is stored.
  constexpr void * getOpaqueData() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getOpaqueData, Xs...); }) , (;) )
  /// Get the begin source location.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getBeginLoc, Xs...); }) , (;) )
  /// Get the end source location.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getEndLoc, Xs...); }) , (;) )
  /// Get the full source range.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getLocEnd, Xs...); }) , (;) )
  /// Get the local source range.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getLocalSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getLocalSourceRange, Xs...); }) , (;) )
  /// Returns the size of the type source info data block.
  constexpr unsigned int getFullDataSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getFullDataSize, Xs...); }) , (;) )
  /// Get the next TypeLoc pointed by this TypeLoc, e.g for "int*" the
  /// TypeLoc is a PointerLoc and next TypeLoc is for "int".
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeLoc) )
  getNextTypeLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getNextTypeLoc, Xs...); }) , (;) )
  /// Skips past any qualifiers, if this is qualified.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnqualTypeLoc) )
  getUnqualifiedLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::getUnqualifiedLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeLoc) )
  IgnoreParens() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::IgnoreParens, Xs...); }) , (;) )
  /// Find a type with the location of an explicit type qualifier.
  ///
  /// The result, if non-null, will be one of:
  ///   QualifiedTypeLoc
  ///   AtomicTypeLoc
  ///   AttributedTypeLoc, for those type attributes that behave as qualifiers
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeLoc) )
  findExplicitQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::findExplicitQualifierLoc, Xs...); }) , (;) )
  /// Initializes this to state that every location in this
  /// type is the given location.
  ///
  /// This method exists to provide a simple transition for code that
  /// relies on location-less types.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void initialize(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::initialize, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator==(IFMETA_ELSE((const clang::TypeLoc::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::TypeLoc &)) LHS, IFMETA_ELSE((const clang::TypeLoc::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::TypeLoc &)) RHS) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::operator_eq_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator!=(IFMETA_ELSE((const clang::TypeLoc::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::TypeLoc &)) LHS, IFMETA_ELSE((const clang::TypeLoc::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::TypeLoc &)) RHS) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::operator_not_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Find the location of the nullability specifier (__nonnull,
  /// __nullable, or __null_unspecifier), if there is one.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  findNullabilityLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeLoc, reflenums::clang__TypeLoc::findNullabilityLoc, Xs...); }) , (;) )
};

/// Wrapper of type source information for a type with
/// no direct qualifiers.
M_template_rtpack(Xs)
struct clang::UnqualTypeLoc::impl : impl_offset_t<clang::TypeLoc, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UnqualTypeLoc;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UnqualTypeLoc::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getTypePtr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnqualTypeLoc, reflenums::clang__UnqualTypeLoc::getTypePtr, Xs...); }) , (;) )
  constexpr enum clang::TypeLoc::TypeLocClass getTypeLocClass() const IFMETA_ELSE( ({    return (enum clang::TypeLoc::TypeLocClass)__reflect_prop(reflenums::RK_clang__UnqualTypeLoc, reflenums::clang__UnqualTypeLoc::getTypeLocClass, Xs...); }) , (;) )
};

/// Options for controlling comment parsing.
M_template_rtpack(Xs)
struct clang::CommentOptions::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CommentOptions;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CommentOptions::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Treat ordinary comments as documentation comments.
  bool ParseAllComments
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__CommentOptions, reflenums::clang__CommentOptions::ParseAllComments, Xs...);), (;) )
};

/// Information about a single command.
///
/// When reordering, adding or removing members please update the corresponding
/// TableGen backend.
M_template_rtpack(Xs)
struct clang::comments::CommandInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__comments__CommandInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::comments::CommandInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr unsigned int getID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::getID, Xs...); }) , (;) )
  const char * Name
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::Name, Xs...);), (;) )
  /// Name of the command that ends the verbatim block.
  const char * EndCommandName
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::EndCommandName, Xs...);), (;) )
  /// The ID of the command.
  unsigned int ID
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::ID, Xs...);), (;) )
  /// Number of word-like arguments for a given block command, except for
  /// \\param and \\tparam commands -- these have special argument parsers.
  unsigned int NumArgs
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::NumArgs, Xs...);), (;) )
  /// True if this command is a inline command (of any kind).
  bool IsInlineCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsInlineCommand, Xs...);), (;) )
  /// True if this command is a block command (of any kind).
  bool IsBlockCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsBlockCommand, Xs...);), (;) )
  /// True if this command is introducing a brief documentation
  /// paragraph (\or an alias).
  bool IsBriefCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsBriefCommand, Xs...);), (;) )
  /// True if this command is \\returns or an alias.
  bool IsReturnsCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsReturnsCommand, Xs...);), (;) )
  /// True if this command is introducing documentation for a function
  /// parameter (\\param or an alias).
  bool IsParamCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsParamCommand, Xs...);), (;) )
  /// True if this command is introducing documentation for
  /// a template parameter (\\tparam or an alias).
  bool IsTParamCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsTParamCommand, Xs...);), (;) )
  /// True if this command is \\throws or an alias.
  bool IsThrowsCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsThrowsCommand, Xs...);), (;) )
  /// True if this command is \\deprecated or an alias.
  bool IsDeprecatedCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsDeprecatedCommand, Xs...);), (;) )
  /// True if this is a \\headerfile-like command.
  bool IsHeaderfileCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsHeaderfileCommand, Xs...);), (;) )
  /// True if we don't want to warn about this command being passed an empty
  /// paragraph.  Meaningful only for block commands.
  bool IsEmptyParagraphAllowed
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsEmptyParagraphAllowed, Xs...);), (;) )
  /// True if this command is a verbatim-like block command.
  ///
  /// A verbatim-like block command eats every character (except line starting
  /// decorations) until matching end command is seen or comment end is hit.
  bool IsVerbatimBlockCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsVerbatimBlockCommand, Xs...);), (;) )
  /// True if this command is an end command for a verbatim-like block.
  bool IsVerbatimBlockEndCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsVerbatimBlockEndCommand, Xs...);), (;) )
  /// True if this command is a verbatim line command.
  ///
  /// A verbatim-like line command eats everything until a newline is seen or
  /// comment end is hit.
  bool IsVerbatimLineCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsVerbatimLineCommand, Xs...);), (;) )
  /// True if this command contains a declaration for the entity being
  /// documented.
  ///
  /// For example:
  /// \code
  ///   \fn void f(int a);
  /// \endcode
  bool IsDeclarationCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsDeclarationCommand, Xs...);), (;) )
  /// True if verbatim-like line command is a function declaration.
  bool IsFunctionDeclarationCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsFunctionDeclarationCommand, Xs...);), (;) )
  /// True if block command is further describing a container API; such
  /// as \@coclass, \@classdesign, etc.
  bool IsRecordLikeDetailCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsRecordLikeDetailCommand, Xs...);), (;) )
  /// True if block command is a container API; such as \@interface.
  bool IsRecordLikeDeclarationCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsRecordLikeDeclarationCommand, Xs...);), (;) )
  /// True if this command is unknown.  This \c CommandInfo object was
  /// created during parsing.
  bool IsUnknownCommand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__comments__CommandInfo, reflenums::clang__comments__CommandInfo::IsUnknownCommand, Xs...);), (;) )
};

/// This class provides information about commands that can be used
/// in comments.
M_template_rtpack(Xs)
struct clang::comments::CommandTraits::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__comments__CommandTraits;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::comments::CommandTraits::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::comments::CommandInfo *) )
  getCommandInfo(unsigned int CommandID) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__comments__CommandTraits, reflenums::clang__comments__CommandTraits::getCommandInfo, Xs..., CommandID); }) , (;) )
  /// \returns a CommandInfo object for a given command ID or
  /// NULL if \c CommandID is not a builtin command.
  static constexpr IFMETA_ELSE( (auto), (const typename meta::clang::comments::CommandInfo *) )
  getBuiltinCommandInfo(unsigned int CommandID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__comments__CommandTraits, reflenums::clang__comments__CommandTraits::getBuiltinCommandInfo, Xs..., CommandID); }) , (;) )
};

enum llvm::Triple::ArchType : unsigned int {
  UnknownArch,
  arm,
  armeb,
  aarch64,
  aarch64_be,
  arc,
  avr,
  bpfel,
  bpfeb,
  hexagon,
  mips,
  mipsel,
  mips64,
  mips64el,
  msp430,
  nios2,
  ppc,
  ppc64,
  ppc64le,
  r600,
  amdgcn,
  riscv32,
  riscv64,
  sparc,
  sparcv9,
  sparcel,
  systemz,
  tce,
  tcele,
  thumb,
  thumbeb,
  x86,
  x86_64,
  xcore,
  nvptx,
  nvptx64,
  le32,
  le64,
  amdil,
  amdil64,
  hsail,
  hsail64,
  spir,
  spir64,
  kalimba,
  shave,
  lanai,
  wasm32,
  wasm64,
  renderscript32,
  renderscript64,
  LastArchType = 50,
};

enum llvm::Triple::SubArchType : unsigned int {
  NoSubArch,
  ARMSubArch_v8_4a,
  ARMSubArch_v8_3a,
  ARMSubArch_v8_2a,
  ARMSubArch_v8_1a,
  ARMSubArch_v8,
  ARMSubArch_v8r,
  ARMSubArch_v8m_baseline,
  ARMSubArch_v8m_mainline,
  ARMSubArch_v7,
  ARMSubArch_v7em,
  ARMSubArch_v7m,
  ARMSubArch_v7s,
  ARMSubArch_v7k,
  ARMSubArch_v7ve,
  ARMSubArch_v6,
  ARMSubArch_v6m,
  ARMSubArch_v6k,
  ARMSubArch_v6t2,
  ARMSubArch_v5,
  ARMSubArch_v5te,
  ARMSubArch_v4t,
  KalimbaSubArch_v3,
  KalimbaSubArch_v4,
  KalimbaSubArch_v5,
};

enum llvm::Triple::VendorType : unsigned int {
  UnknownVendor,
  Apple,
  PC,
  SCEI,
  BGP,
  BGQ,
  Freescale,
  IBM,
  ImaginationTechnologies,
  MipsTechnologies,
  NVIDIA,
  CSR,
  Myriad,
  AMD,
  Mesa,
  SUSE,
  OpenEmbedded,
  LastVendorType = 16,
};

enum llvm::Triple::OSType : unsigned int {
  UnknownOS,
  Ananas,
  CloudABI,
  Darwin,
  DragonFly,
  FreeBSD,
  Fuchsia,
  IOS,
  KFreeBSD,
  Linux,
  Lv2,
  MacOSX,
  NetBSD,
  OpenBSD,
  Solaris,
  Win32,
  Haiku,
  Minix,
  RTEMS,
  NaCl,
  CNK,
  AIX,
  CUDA,
  NVCL,
  AMDHSA,
  PS4,
  ELFIAMCU,
  TvOS,
  WatchOS,
  Mesa3D,
  Contiki,
  AMDPAL,
  LastOSType = 31,
};

enum llvm::Triple::EnvironmentType : unsigned int {
  UnknownEnvironment,
  GNU,
  GNUABIN32,
  GNUABI64,
  GNUEABI,
  GNUEABIHF,
  GNUX32,
  CODE16,
  EABI,
  EABIHF,
  Android,
  Musl,
  MuslEABI,
  MuslEABIHF,
  MSVC,
  Itanium,
  Cygnus,
  CoreCLR,
  Simulator,
  LastEnvironmentType = 18,
};

enum llvm::Triple::ObjectFormatType : unsigned int {
  UnknownObjectFormat,
  COFF,
  ELF,
  MachO,
  Wasm,
};

/// Triple - Helper class for working with autoconf configuration names. For
/// historical reasons, we also call these 'triples' (they used to contain
/// exactly three fields).
///
/// Configuration names are strings in the canonical form:
///   ARCHITECTURE-VENDOR-OPERATING_SYSTEM
/// or
///   ARCHITECTURE-VENDOR-OPERATING_SYSTEM-ENVIRONMENT
///
/// This class is used for clients which want to support arbitrary
/// configuration names, but also want to implement certain special
/// behavior for particular configurations. This class isolates the mapping
/// from the components of the configuration name to well known IDs.
///
/// At its core the Triple class is designed to be a wrapper for a triple
/// string; the constructor does not change or normalize the triple string.
/// Clients that need to handle the non-canonical triples that users often
/// specify should use the normalize method.
///
/// See autoconf/config.guess for a glimpse into what configuration names
/// look like in practice.
M_template_rtpack(Xs)
struct llvm::Triple::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__Triple;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::Triple::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using ArchType = enum refldetail::llvm::Triple::ArchType;
  using SubArchType = enum refldetail::llvm::Triple::SubArchType;
  using VendorType = enum refldetail::llvm::Triple::VendorType;
  using OSType = enum refldetail::llvm::Triple::OSType;
  using EnvironmentType = enum refldetail::llvm::Triple::EnvironmentType;
  using ObjectFormatType = enum refldetail::llvm::Triple::ObjectFormatType;
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const llvm::Triple::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::Triple &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const llvm::Triple::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::Triple &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::operator_not_eq, Xs..., Y0s...); }) , (;) )
  /// normalize - Turn an arbitrary machine specification into the canonical
  /// triple form (or something sensible that the Triple class understands if
  /// nothing better can reasonably be done).  In particular, it handles the
  /// common case in which otherwise valid components are in the wrong order.
  static constexpr const char * normalize(const char * Str) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::normalize, Xs..., Str); }) , (;) )
  /// Return the normalized form of this triple's string.
  constexpr const char * normalize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::normalize1, Xs...); }) , (;) )
  /// getArch - Get the parsed architecture type of this triple.
  constexpr enum llvm::Triple::ArchType getArch() const IFMETA_ELSE( ({    return (enum llvm::Triple::ArchType)__reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getArch, Xs...); }) , (;) )
  /// getSubArch - get the parsed subarchitecture type for this triple.
  constexpr enum llvm::Triple::SubArchType getSubArch() const IFMETA_ELSE( ({    return (enum llvm::Triple::SubArchType)__reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getSubArch, Xs...); }) , (;) )
  /// getVendor - Get the parsed vendor type of this triple.
  constexpr enum llvm::Triple::VendorType getVendor() const IFMETA_ELSE( ({    return (enum llvm::Triple::VendorType)__reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getVendor, Xs...); }) , (;) )
  /// getOS - Get the parsed operating system type of this triple.
  constexpr enum llvm::Triple::OSType getOS() const IFMETA_ELSE( ({    return (enum llvm::Triple::OSType)__reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getOS, Xs...); }) , (;) )
  /// hasEnvironment - Does this triple have the optional environment
  /// (fourth) component?
  constexpr bool hasEnvironment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::hasEnvironment, Xs...); }) , (;) )
  /// getEnvironment - Get the parsed environment type of this triple.
  constexpr enum llvm::Triple::EnvironmentType getEnvironment() const IFMETA_ELSE( ({    return (enum llvm::Triple::EnvironmentType)__reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getEnvironment, Xs...); }) , (;) )
  /// getFormat - Get the object format for this triple.
  constexpr enum llvm::Triple::ObjectFormatType getObjectFormat() const IFMETA_ELSE( ({    return (enum llvm::Triple::ObjectFormatType)__reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getObjectFormat, Xs...); }) , (;) )
  /// getOSMajorVersion - Return just the major version number, this is
  /// specialized because it is a common query.
  constexpr unsigned int getOSMajorVersion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getOSMajorVersion, Xs...); }) , (;) )
  /// getArchName - Get the architecture (first) component of the
  /// triple.
  constexpr const char * getArchName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getArchName, Xs...); }) , (;) )
  /// getVendorName - Get the vendor (second) component of the triple.
  constexpr const char * getVendorName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getVendorName, Xs...); }) , (;) )
  /// getOSName - Get the operating system (third) component of the
  /// triple.
  constexpr const char * getOSName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getOSName, Xs...); }) , (;) )
  /// getEnvironmentName - Get the optional environment (fourth)
  /// component of the triple, or "" if empty.
  constexpr const char * getEnvironmentName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getEnvironmentName, Xs...); }) , (;) )
  /// getOSAndEnvironmentName - Get the operating system and optional
  /// environment components as a single string (separated by a '-'
  /// if the environment component is present).
  constexpr const char * getOSAndEnvironmentName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getOSAndEnvironmentName, Xs...); }) , (;) )
  /// Test whether the architecture is 64-bit
  ///
  /// Note that this tests for 64-bit pointer width, and nothing else. Note
  /// that we intentionally expose only three predicates, 64-bit, 32-bit, and
  /// 16-bit. The inner details of pointer width for particular architectures
  /// is not summed up in the triple, and so only a coarse grained predicate
  /// system is provided.
  constexpr bool isArch64Bit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isArch64Bit, Xs...); }) , (;) )
  /// Test whether the architecture is 32-bit
  ///
  /// Note that this tests for 32-bit pointer width, and nothing else.
  constexpr bool isArch32Bit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isArch32Bit, Xs...); }) , (;) )
  /// Test whether the architecture is 16-bit
  ///
  /// Note that this tests for 16-bit pointer width, and nothing else.
  constexpr bool isArch16Bit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isArch16Bit, Xs...); }) , (;) )
  /// isOSVersionLT - Helper function for doing comparisons against version
  /// numbers included in the target triple.
  constexpr bool isOSVersionLT(unsigned int Major, unsigned int Minor = 0, unsigned int Micro = 0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSVersionLT, Xs..., Major, Minor, Micro); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isOSVersionLT(IFMETA_ELSE((const llvm::Triple::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::Triple &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSVersionLT1, Xs..., Y0s...); }) , (;) )
  /// isMacOSXVersionLT - Comparison function for checking OS X version
  /// compatibility, which handles supporting skewed version numbering schemes
  /// used by the "darwin" triples.
  constexpr bool isMacOSXVersionLT(unsigned int Major, unsigned int Minor = 0, unsigned int Micro = 0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isMacOSXVersionLT, Xs..., Major, Minor, Micro); }) , (;) )
  /// isMacOSX - Is this a Mac OS X triple. For legacy reasons, we support both
  /// "darwin" and "osx" as OS X triples.
  constexpr bool isMacOSX() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isMacOSX, Xs...); }) , (;) )
  /// Is this an iOS triple.
  /// Note: This identifies tvOS as a variant of iOS. If that ever
  /// changes, i.e., if the two operating systems diverge or their version
  /// numbers get out of sync, that will need to be changed.
  /// watchOS has completely different version numbers so it is not included.
  constexpr bool isiOS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isiOS, Xs...); }) , (;) )
  /// Is this an Apple tvOS triple.
  constexpr bool isTvOS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isTvOS, Xs...); }) , (;) )
  /// Is this an Apple watchOS triple.
  constexpr bool isWatchOS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isWatchOS, Xs...); }) , (;) )
  constexpr bool isWatchABI() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isWatchABI, Xs...); }) , (;) )
  /// isOSDarwin - Is this a "Darwin" OS (OS X, iOS, or watchOS).
  constexpr bool isOSDarwin() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSDarwin, Xs...); }) , (;) )
  constexpr bool isSimulatorEnvironment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isSimulatorEnvironment, Xs...); }) , (;) )
  constexpr bool isOSNetBSD() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSNetBSD, Xs...); }) , (;) )
  constexpr bool isOSOpenBSD() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSOpenBSD, Xs...); }) , (;) )
  constexpr bool isOSFreeBSD() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSFreeBSD, Xs...); }) , (;) )
  constexpr bool isOSFuchsia() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSFuchsia, Xs...); }) , (;) )
  constexpr bool isOSDragonFly() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSDragonFly, Xs...); }) , (;) )
  constexpr bool isOSSolaris() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSSolaris, Xs...); }) , (;) )
  constexpr bool isOSIAMCU() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSIAMCU, Xs...); }) , (;) )
  constexpr bool isOSUnknown() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSUnknown, Xs...); }) , (;) )
  constexpr bool isGNUEnvironment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isGNUEnvironment, Xs...); }) , (;) )
  constexpr bool isOSContiki() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSContiki, Xs...); }) , (;) )
  /// Tests whether the OS is Haiku.
  constexpr bool isOSHaiku() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSHaiku, Xs...); }) , (;) )
  /// Checks if the environment could be MSVC.
  constexpr bool isWindowsMSVCEnvironment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isWindowsMSVCEnvironment, Xs...); }) , (;) )
  /// Checks if the environment is MSVC.
  constexpr bool isKnownWindowsMSVCEnvironment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isKnownWindowsMSVCEnvironment, Xs...); }) , (;) )
  constexpr bool isWindowsCoreCLREnvironment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isWindowsCoreCLREnvironment, Xs...); }) , (;) )
  constexpr bool isWindowsItaniumEnvironment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isWindowsItaniumEnvironment, Xs...); }) , (;) )
  constexpr bool isWindowsCygwinEnvironment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isWindowsCygwinEnvironment, Xs...); }) , (;) )
  constexpr bool isWindowsGNUEnvironment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isWindowsGNUEnvironment, Xs...); }) , (;) )
  /// Tests for either Cygwin or MinGW OS
  constexpr bool isOSCygMing() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSCygMing, Xs...); }) , (;) )
  /// Is this a "Windows" OS targeting a "MSVCRT.dll" environment.
  constexpr bool isOSMSVCRT() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSMSVCRT, Xs...); }) , (;) )
  /// Tests whether the OS is Windows.
  constexpr bool isOSWindows() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSWindows, Xs...); }) , (;) )
  /// Tests whether the OS is NaCl (Native Client)
  constexpr bool isOSNaCl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSNaCl, Xs...); }) , (;) )
  /// Tests whether the OS is Linux.
  constexpr bool isOSLinux() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSLinux, Xs...); }) , (;) )
  /// Tests whether the OS is kFreeBSD.
  constexpr bool isOSKFreeBSD() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSKFreeBSD, Xs...); }) , (;) )
  /// Tests whether the OS uses glibc.
  constexpr bool isOSGlibc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSGlibc, Xs...); }) , (;) )
  /// Tests whether the OS uses the ELF binary format.
  constexpr bool isOSBinFormatELF() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSBinFormatELF, Xs...); }) , (;) )
  /// Tests whether the OS uses the COFF binary format.
  constexpr bool isOSBinFormatCOFF() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSBinFormatCOFF, Xs...); }) , (;) )
  /// Tests whether the environment is MachO.
  constexpr bool isOSBinFormatMachO() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSBinFormatMachO, Xs...); }) , (;) )
  /// Tests whether the OS uses the Wasm binary format.
  constexpr bool isOSBinFormatWasm() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isOSBinFormatWasm, Xs...); }) , (;) )
  /// Tests whether the target is the PS4 CPU
  constexpr bool isPS4CPU() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isPS4CPU, Xs...); }) , (;) )
  /// Tests whether the target is the PS4 platform
  constexpr bool isPS4() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isPS4, Xs...); }) , (;) )
  /// Tests whether the target is Android
  constexpr bool isAndroid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isAndroid, Xs...); }) , (;) )
  constexpr bool isAndroidVersionLT(unsigned int Major) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isAndroidVersionLT, Xs..., Major); }) , (;) )
  /// Tests whether the environment is musl-libc
  constexpr bool isMusl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isMusl, Xs...); }) , (;) )
  /// Tests whether the target is NVPTX (32- or 64-bit).
  constexpr bool isNVPTX() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isNVPTX, Xs...); }) , (;) )
  /// Tests whether the target is Thumb (little and big endian).
  constexpr bool isThumb() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isThumb, Xs...); }) , (;) )
  /// Tests whether the target is ARM (little and big endian).
  constexpr bool isARM() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isARM, Xs...); }) , (;) )
  /// Tests whether the target is AArch64 (little and big endian).
  constexpr bool isAArch64() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isAArch64, Xs...); }) , (;) )
  /// Tests whether the target is MIPS 32-bit (little and big endian).
  constexpr bool isMIPS32() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isMIPS32, Xs...); }) , (;) )
  /// Tests whether the target is MIPS 64-bit (little and big endian).
  constexpr bool isMIPS64() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isMIPS64, Xs...); }) , (;) )
  /// Tests whether the target is MIPS (little and big endian, 32- or 64-bit).
  constexpr bool isMIPS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isMIPS, Xs...); }) , (;) )
  /// Tests whether the target supports comdat
  constexpr bool supportsCOMDAT() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::supportsCOMDAT, Xs...); }) , (;) )
  /// Tests whether the target uses emulated TLS as default.
  constexpr bool hasDefaultEmulatedTLS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::hasDefaultEmulatedTLS, Xs...); }) , (;) )
  /// Form a triple with a 32-bit variant of the current architecture.
  ///
  /// This can be used to move across "families" of architectures where useful.
  ///
  /// \returns A new triple with a 32-bit architecture or an unknown
  ///          architecture if no such variant can be found.
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Triple) )
  get32BitArchVariant() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::get32BitArchVariant, Xs...); }) , (;) )
  /// Form a triple with a 64-bit variant of the current architecture.
  ///
  /// This can be used to move across "families" of architectures where useful.
  ///
  /// \returns A new triple with a 64-bit architecture or an unknown
  ///          architecture if no such variant can be found.
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Triple) )
  get64BitArchVariant() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::get64BitArchVariant, Xs...); }) , (;) )
  /// Form a triple with a big endian variant of the current architecture.
  ///
  /// This can be used to move across "families" of architectures where useful.
  ///
  /// \returns A new triple with a big endian architecture or an unknown
  ///          architecture if no such variant can be found.
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Triple) )
  getBigEndianArchVariant() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getBigEndianArchVariant, Xs...); }) , (;) )
  /// Form a triple with a little endian variant of the current architecture.
  ///
  /// This can be used to move across "families" of architectures where useful.
  ///
  /// \returns A new triple with a little endian architecture or an unknown
  ///          architecture if no such variant can be found.
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Triple) )
  getLittleEndianArchVariant() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getLittleEndianArchVariant, Xs...); }) , (;) )
  /// Get the (LLVM) name of the minimum ARM CPU for the arch we are targeting.
  ///
  /// \param Arch the architecture name (e.g., "armv7s"). If it is an empty
  /// string then the triple's arch name is used.
  constexpr const char * getARMCPUForArch(const char * Arch = 0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getARMCPUForArch, Xs..., Arch); }) , (;) )
  /// Tests whether the target triple is little endian.
  ///
  /// \returns true if the triple is little endian, false otherwise.
  constexpr bool isLittleEndian() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isLittleEndian, Xs...); }) , (;) )
  /// Test whether target triples are compatible.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isCompatibleWith(IFMETA_ELSE((const llvm::Triple::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::Triple &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::isCompatibleWith, Xs..., Y0s...); }) , (;) )
  /// Merge target triples.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * merge(IFMETA_ELSE((const llvm::Triple::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::Triple &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::merge, Xs..., Y0s...); }) , (;) )
  /// getArchTypeName - Get the canonical name for the \p Kind architecture.
  static constexpr const char * getArchTypeName(enum llvm::Triple::ArchType Kind) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getArchTypeName, Xs..., Kind); }) , (;) )
  /// getArchTypePrefix - Get the "prefix" canonical name for the \p Kind
  /// architecture. This is the prefix used by the architecture specific
  /// builtins, and is suitable for passing to \see
  /// Intrinsic::getIntrinsicForGCCBuiltin().
  ///
  /// \return - The architecture prefix, or 0 if none is defined.
  static constexpr const char * getArchTypePrefix(enum llvm::Triple::ArchType Kind) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getArchTypePrefix, Xs..., Kind); }) , (;) )
  /// getVendorTypeName - Get the canonical name for the \p Kind vendor.
  static constexpr const char * getVendorTypeName(enum llvm::Triple::VendorType Kind) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getVendorTypeName, Xs..., Kind); }) , (;) )
  /// getOSTypeName - Get the canonical name for the \p Kind operating system.
  static constexpr const char * getOSTypeName(enum llvm::Triple::OSType Kind) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getOSTypeName, Xs..., Kind); }) , (;) )
  /// getEnvironmentTypeName - Get the canonical name for the \p Kind
  /// environment.
  static constexpr const char * getEnvironmentTypeName(enum llvm::Triple::EnvironmentType Kind) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getEnvironmentTypeName, Xs..., Kind); }) , (;) )
  /// getArchTypeForLLVMName - The canonical type for the given LLVM
  /// architecture name (e.g., "x86").
  static constexpr enum llvm::Triple::ArchType getArchTypeForLLVMName(const char * Str) IFMETA_ELSE( ({    return (enum llvm::Triple::ArchType)__reflect_prop(reflenums::RK_llvm__Triple, reflenums::llvm__Triple::getArchTypeForLLVMName, Xs..., Str); }) , (;) )
};

/// The basic Objective-C runtimes that we know about.
enum clang::ObjCRuntime::Kind : unsigned int {
  /// 'macosx' is the Apple-provided NeXT-derived runtime on Mac OS
  /// X platforms that use the non-fragile ABI; the version is a
  /// release of that OS.
  MacOSX,
  /// 'macosx-fragile' is the Apple-provided NeXT-derived runtime on
  /// Mac OS X platforms that use the fragile ABI; the version is a
  /// release of that OS.
  FragileMacOSX,
  /// 'ios' is the Apple-provided NeXT-derived runtime on iOS or the iOS
  /// simulator;  it is always non-fragile.  The version is a release
  /// version of iOS.
  iOS,
  /// 'watchos' is a variant of iOS for Apple's watchOS. The version
  /// is a release version of watchOS.
  WatchOS,
  /// 'gcc' is the Objective-C runtime shipped with GCC, implementing a
  /// fragile Objective-C ABI
  GCC,
  /// 'gnustep' is the modern non-fragile GNUstep runtime.
  GNUstep,
  /// 'objfw' is the Objective-C runtime included in ObjFW
  ObjFW,
};

/// The basic abstraction for the target Objective-C runtime.
M_template_rtpack(Xs)
struct clang::ObjCRuntime::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCRuntime;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCRuntime::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using Kind = enum refldetail::clang::ObjCRuntime::Kind;
  constexpr enum clang::ObjCRuntime::Kind getKind() const IFMETA_ELSE( ({    return (enum clang::ObjCRuntime::Kind)__reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::getKind, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::VersionTuple &) )
  getVersion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::getVersion, Xs...); }) , (;) )
  /// Does this runtime follow the set of implied behaviors for a
  /// "non-fragile" ABI?
  constexpr bool isNonFragile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::isNonFragile, Xs...); }) , (;) )
  /// The inverse of isNonFragile():  does this runtime follow the set of
  /// implied behaviors for a "fragile" ABI?
  constexpr bool isFragile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::isFragile, Xs...); }) , (;) )
  /// Is this runtime basically of the GNU family of runtimes?
  constexpr bool isGNUFamily() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::isGNUFamily, Xs...); }) , (;) )
  /// Is this runtime basically of the NeXT family of runtimes?
  constexpr bool isNeXTFamily() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::isNeXTFamily, Xs...); }) , (;) )
  /// Does this runtime allow ARC at all?
  constexpr bool allowsARC() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::allowsARC, Xs...); }) , (;) )
  /// Does this runtime natively provide the ARC entrypoints?
  ///
  /// ARC cannot be directly supported on a platform that does not provide
  /// these entrypoints, although it may be supportable via a stub
  /// library.
  constexpr bool hasNativeARC() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::hasNativeARC, Xs...); }) , (;) )
  /// Does this runtime supports optimized setter entrypoints?
  constexpr bool hasOptimizedSetter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::hasOptimizedSetter, Xs...); }) , (;) )
  /// Does this runtime allow the use of __weak?
  constexpr bool allowsWeak() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::allowsWeak, Xs...); }) , (;) )
  /// Does this runtime natively provide ARC-compliant 'weak'
  /// entrypoints?
  constexpr bool hasNativeWeak() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::hasNativeWeak, Xs...); }) , (;) )
  /// Does this runtime directly support the subscripting methods?
  ///
  /// This is really a property of the library, not the runtime.
  constexpr bool hasSubscripting() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::hasSubscripting, Xs...); }) , (;) )
  /// Does this runtime allow sizeof or alignof on object types?
  constexpr bool allowsSizeofAlignof() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::allowsSizeofAlignof, Xs...); }) , (;) )
  /// Does this runtime allow pointer arithmetic on objects?
  ///
  /// This covers +, -, ++, --, and (if isSubscriptPointerArithmetic()
  /// yields true) [].
  constexpr bool allowsPointerArithmetic() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::allowsPointerArithmetic, Xs...); }) , (;) )
  /// Is subscripting pointer arithmetic?
  constexpr bool isSubscriptPointerArithmetic() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::isSubscriptPointerArithmetic, Xs...); }) , (;) )
  /// Does this runtime provide an objc_terminate function?
  ///
  /// This is used in handlers for exceptions during the unwind process;
  /// without it, abort() must be used in pure ObjC files.
  constexpr bool hasTerminate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::hasTerminate, Xs...); }) , (;) )
  /// Does this runtime support weakly importing classes?
  constexpr bool hasWeakClassImport() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::hasWeakClassImport, Xs...); }) , (;) )
  /// Does this runtime use zero-cost exceptions?
  constexpr bool hasUnwindExceptions() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::hasUnwindExceptions, Xs...); }) , (;) )
  constexpr bool hasAtomicCopyHelper() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::hasAtomicCopyHelper, Xs...); }) , (;) )
  /// Is objc_unsafeClaimAutoreleasedReturnValue available?
  constexpr bool hasARCUnsafeClaimAutoreleasedReturnValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::hasARCUnsafeClaimAutoreleasedReturnValue, Xs...); }) , (;) )
  /// Are the empty collection symbols available?
  constexpr bool hasEmptyCollections() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::hasEmptyCollections, Xs...); }) , (;) )
  constexpr const char * getAsString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::getAsString, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator==(IFMETA_ELSE((const clang::ObjCRuntime::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ObjCRuntime &)) left, IFMETA_ELSE((const clang::ObjCRuntime::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ObjCRuntime &)) right) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::operator_eq_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator!=(IFMETA_ELSE((const clang::ObjCRuntime::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ObjCRuntime &)) left, IFMETA_ELSE((const clang::ObjCRuntime::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ObjCRuntime &)) right) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCRuntime, reflenums::clang__ObjCRuntime::operator_not_eq, Xs..., Y0s..., Y1s...); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::SanitizerSet::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SanitizerSet;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SanitizerSet::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Check if a certain (single) sanitizer is enabled.
  constexpr bool has(unsigned long long K) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SanitizerSet, reflenums::clang__SanitizerSet::has, Xs..., K); }) , (;) )
  /// Check if one or more sanitizers are enabled.
  constexpr bool hasOneOf(unsigned long long K) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SanitizerSet, reflenums::clang__SanitizerSet::hasOneOf, Xs..., K); }) , (;) )
  /// Returns true if at least one sanitizer is enabled.
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SanitizerSet, reflenums::clang__SanitizerSet::empty, Xs...); }) , (;) )
  /// Bitmask of enabled sanitizers.
  unsigned long long Mask
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__SanitizerSet, reflenums::clang__SanitizerSet::Mask, Xs...);), (;) )
};

/// Bitfields of LangOptions, split out from LangOptions in order to ensure that
/// this large collection of bitfields is a trivial class type.
M_template_rtpack(Xs)
struct clang::LangOptionsBase::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__LangOptionsBase;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::LangOptionsBase::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  bool C99
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::C99, Xs...);), (;) )
  bool C11
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::C11, Xs...);), (;) )
  bool C17
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::C17, Xs...);), (;) )
  bool MSVCCompat
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::MSVCCompat, Xs...);), (;) )
  bool MicrosoftExt
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::MicrosoftExt, Xs...);), (;) )
  bool AsmBlocks
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::AsmBlocks, Xs...);), (;) )
  bool Borland
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Borland, Xs...);), (;) )
  bool CPlusPlus
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CPlusPlus, Xs...);), (;) )
  bool CPlusPlus11
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CPlusPlus11, Xs...);), (;) )
  bool CPlusPlus14
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CPlusPlus14, Xs...);), (;) )
  bool CPlusPlus17
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CPlusPlus17, Xs...);), (;) )
  bool CPlusPlus2a
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CPlusPlus2a, Xs...);), (;) )
  bool ObjC1
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ObjC1, Xs...);), (;) )
  bool ObjC2
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ObjC2, Xs...);), (;) )
  bool ObjCDefaultSynthProperties
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ObjCDefaultSynthProperties, Xs...);), (;) )
  bool EncodeExtendedBlockSig
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::EncodeExtendedBlockSig, Xs...);), (;) )
  bool ObjCInferRelatedResultType
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ObjCInferRelatedResultType, Xs...);), (;) )
  bool AppExt
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::AppExt, Xs...);), (;) )
  bool Trigraphs
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Trigraphs, Xs...);), (;) )
  bool LineComment
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::LineComment, Xs...);), (;) )
  bool Bool
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Bool, Xs...);), (;) )
  bool Half
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Half, Xs...);), (;) )
  bool WChar
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::WChar, Xs...);), (;) )
  bool Char8
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Char8, Xs...);), (;) )
  bool DeclSpecKeyword
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::DeclSpecKeyword, Xs...);), (;) )
  bool DollarIdents
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::DollarIdents, Xs...);), (;) )
  bool AsmPreprocessor
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::AsmPreprocessor, Xs...);), (;) )
  bool GNUMode
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::GNUMode, Xs...);), (;) )
  bool GNUKeywords
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::GNUKeywords, Xs...);), (;) )
  bool ImplicitInt
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ImplicitInt, Xs...);), (;) )
  bool Digraphs
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Digraphs, Xs...);), (;) )
  bool HexFloats
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::HexFloats, Xs...);), (;) )
  bool CXXOperatorNames
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CXXOperatorNames, Xs...);), (;) )
  bool AppleKext
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::AppleKext, Xs...);), (;) )
  bool PascalStrings
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::PascalStrings, Xs...);), (;) )
  bool WritableStrings
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::WritableStrings, Xs...);), (;) )
  bool ConstStrings
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ConstStrings, Xs...);), (;) )
  bool LaxVectorConversions
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::LaxVectorConversions, Xs...);), (;) )
  bool AltiVec
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::AltiVec, Xs...);), (;) )
  bool ZVector
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ZVector, Xs...);), (;) )
  bool Exceptions
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Exceptions, Xs...);), (;) )
  bool ObjCExceptions
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ObjCExceptions, Xs...);), (;) )
  bool CXXExceptions
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CXXExceptions, Xs...);), (;) )
  bool DWARFExceptions
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::DWARFExceptions, Xs...);), (;) )
  bool SjLjExceptions
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::SjLjExceptions, Xs...);), (;) )
  bool SEHExceptions
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::SEHExceptions, Xs...);), (;) )
  bool ExternCNoUnwind
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ExternCNoUnwind, Xs...);), (;) )
  bool TraditionalCPP
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::TraditionalCPP, Xs...);), (;) )
  bool RTTI
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::RTTI, Xs...);), (;) )
  bool RTTIData
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::RTTIData, Xs...);), (;) )
  bool MSBitfields
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::MSBitfields, Xs...);), (;) )
  bool Freestanding
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Freestanding, Xs...);), (;) )
  bool NoBuiltin
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::NoBuiltin, Xs...);), (;) )
  bool NoMathBuiltin
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::NoMathBuiltin, Xs...);), (;) )
  bool GNUAsm
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::GNUAsm, Xs...);), (;) )
  bool CoroutinesTS
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CoroutinesTS, Xs...);), (;) )
  bool RelaxedTemplateTemplateArgs
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::RelaxedTemplateTemplateArgs, Xs...);), (;) )
  bool DoubleSquareBracketAttributes
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::DoubleSquareBracketAttributes, Xs...);), (;) )
  bool ThreadsafeStatics
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ThreadsafeStatics, Xs...);), (;) )
  bool POSIXThreads
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::POSIXThreads, Xs...);), (;) )
  bool Blocks
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Blocks, Xs...);), (;) )
  bool EmitAllDecls
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::EmitAllDecls, Xs...);), (;) )
  bool MathErrno
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::MathErrno, Xs...);), (;) )
  bool HeinousExtensions
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::HeinousExtensions, Xs...);), (;) )
  bool Modules
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Modules, Xs...);), (;) )
  bool ModulesTS
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ModulesTS, Xs...);), (;) )
  bool CompilingPCH
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CompilingPCH, Xs...);), (;) )
  bool BuildingPCHWithObjectFile
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::BuildingPCHWithObjectFile, Xs...);), (;) )
  bool ModulesDeclUse
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ModulesDeclUse, Xs...);), (;) )
  bool ModulesSearchAll
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ModulesSearchAll, Xs...);), (;) )
  bool ModulesStrictDeclUse
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ModulesStrictDeclUse, Xs...);), (;) )
  bool ModulesErrorRecovery
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ModulesErrorRecovery, Xs...);), (;) )
  bool ImplicitModules
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ImplicitModules, Xs...);), (;) )
  bool ModulesLocalVisibility
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ModulesLocalVisibility, Xs...);), (;) )
  bool Optimize
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Optimize, Xs...);), (;) )
  bool OptimizeSize
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::OptimizeSize, Xs...);), (;) )
  bool Static
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Static, Xs...);), (;) )
  unsigned int PackStruct
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::PackStruct, Xs...);), (;) )
  unsigned int MaxTypeAlign
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::MaxTypeAlign, Xs...);), (;) )
  bool AlignDouble
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::AlignDouble, Xs...);), (;) )
  unsigned int PICLevel
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::PICLevel, Xs...);), (;) )
  bool PIE
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::PIE, Xs...);), (;) )
  bool GNUInline
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::GNUInline, Xs...);), (;) )
  bool NoInlineDefine
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::NoInlineDefine, Xs...);), (;) )
  bool Deprecated
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Deprecated, Xs...);), (;) )
  bool FastMath
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::FastMath, Xs...);), (;) )
  bool FiniteMathOnly
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::FiniteMathOnly, Xs...);), (;) )
  bool UnsafeFPMath
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::UnsafeFPMath, Xs...);), (;) )
  bool ObjCGCBitmapPrint
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ObjCGCBitmapPrint, Xs...);), (;) )
  bool AccessControl
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::AccessControl, Xs...);), (;) )
  bool CharIsSigned
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CharIsSigned, Xs...);), (;) )
  unsigned int WCharSize
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::WCharSize, Xs...);), (;) )
  bool WCharIsSigned
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::WCharIsSigned, Xs...);), (;) )
  bool ShortEnums
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ShortEnums, Xs...);), (;) )
  bool OpenCL
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::OpenCL, Xs...);), (;) )
  unsigned int OpenCLVersion
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::OpenCLVersion, Xs...);), (;) )
  bool OpenCLCPlusPlus
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::OpenCLCPlusPlus, Xs...);), (;) )
  unsigned int OpenCLCPlusPlusVersion
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::OpenCLCPlusPlusVersion, Xs...);), (;) )
  bool NativeHalfType
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::NativeHalfType, Xs...);), (;) )
  bool NativeHalfArgsAndReturns
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::NativeHalfArgsAndReturns, Xs...);), (;) )
  bool HalfArgsAndReturns
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::HalfArgsAndReturns, Xs...);), (;) )
  bool CUDA
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CUDA, Xs...);), (;) )
  bool HIP
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::HIP, Xs...);), (;) )
  unsigned int OpenMP
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::OpenMP, Xs...);), (;) )
  bool OpenMPSimd
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::OpenMPSimd, Xs...);), (;) )
  bool OpenMPUseTLS
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::OpenMPUseTLS, Xs...);), (;) )
  bool OpenMPIsDevice
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::OpenMPIsDevice, Xs...);), (;) )
  bool OpenMPCUDAMode
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::OpenMPCUDAMode, Xs...);), (;) )
  bool OpenMPHostCXXExceptions
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::OpenMPHostCXXExceptions, Xs...);), (;) )
  bool RenderScript
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::RenderScript, Xs...);), (;) )
  bool CUDAIsDevice
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CUDAIsDevice, Xs...);), (;) )
  bool CUDAAllowVariadicFunctions
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CUDAAllowVariadicFunctions, Xs...);), (;) )
  bool CUDAHostDeviceConstexpr
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CUDAHostDeviceConstexpr, Xs...);), (;) )
  bool CUDADeviceApproxTranscendentals
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CUDADeviceApproxTranscendentals, Xs...);), (;) )
  bool CUDARelocatableDeviceCode
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CUDARelocatableDeviceCode, Xs...);), (;) )
  bool SizedDeallocation
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::SizedDeallocation, Xs...);), (;) )
  bool AlignedAllocation
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::AlignedAllocation, Xs...);), (;) )
  bool AlignedAllocationUnavailable
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::AlignedAllocationUnavailable, Xs...);), (;) )
  unsigned int NewAlignOverride
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::NewAlignOverride, Xs...);), (;) )
  bool ConceptsTS
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ConceptsTS, Xs...);), (;) )
  bool Reflection
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::Reflection, Xs...);), (;) )
  bool ModulesCodegen
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ModulesCodegen, Xs...);), (;) )
  bool ModulesDebugInfo
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ModulesDebugInfo, Xs...);), (;) )
  bool ElideConstructors
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ElideConstructors, Xs...);), (;) )
  bool DumpRecordLayouts
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::DumpRecordLayouts, Xs...);), (;) )
  bool DumpRecordLayoutsSimple
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::DumpRecordLayoutsSimple, Xs...);), (;) )
  bool DumpVTableLayouts
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::DumpVTableLayouts, Xs...);), (;) )
  bool NoConstantCFStrings
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::NoConstantCFStrings, Xs...);), (;) )
  bool InlineVisibilityHidden
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::InlineVisibilityHidden, Xs...);), (;) )
  bool ParseUnknownAnytype
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ParseUnknownAnytype, Xs...);), (;) )
  bool DebuggerSupport
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::DebuggerSupport, Xs...);), (;) )
  bool DebuggerCastResultToId
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::DebuggerCastResultToId, Xs...);), (;) )
  bool DebuggerObjCLiteral
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::DebuggerObjCLiteral, Xs...);), (;) )
  bool SpellChecking
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::SpellChecking, Xs...);), (;) )
  bool SinglePrecisionConstants
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::SinglePrecisionConstants, Xs...);), (;) )
  bool FastRelaxedMath
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::FastRelaxedMath, Xs...);), (;) )
  /// FP_CONTRACT mode (on/off/fast).
  bool NoBitFieldTypeAlign
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::NoBitFieldTypeAlign, Xs...);), (;) )
  bool HexagonQdsp6Compat
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::HexagonQdsp6Compat, Xs...);), (;) )
  bool ObjCAutoRefCount
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ObjCAutoRefCount, Xs...);), (;) )
  bool ObjCWeakRuntime
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ObjCWeakRuntime, Xs...);), (;) )
  bool ObjCWeak
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ObjCWeak, Xs...);), (;) )
  bool ObjCSubscriptingLegacyRuntime
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ObjCSubscriptingLegacyRuntime, Xs...);), (;) )
  bool CFProtectionBranch
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CFProtectionBranch, Xs...);), (;) )
  bool FakeAddressSpaceMap
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::FakeAddressSpaceMap, Xs...);), (;) )
  bool IncludeDefaultHeader
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::IncludeDefaultHeader, Xs...);), (;) )
  bool DelayedTemplateParsing
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::DelayedTemplateParsing, Xs...);), (;) )
  bool BlocksRuntimeOptional
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::BlocksRuntimeOptional, Xs...);), (;) )
  bool CompleteMemberPointers
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::CompleteMemberPointers, Xs...);), (;) )
  unsigned int ArrowDepth
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ArrowDepth, Xs...);), (;) )
  unsigned int InstantiationDepth
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::InstantiationDepth, Xs...);), (;) )
  unsigned int ConstexprCallDepth
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ConstexprCallDepth, Xs...);), (;) )
  unsigned int ConstexprStepLimit
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ConstexprStepLimit, Xs...);), (;) )
  unsigned int BracketDepth
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::BracketDepth, Xs...);), (;) )
  unsigned int NumLargeByValueCopy
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::NumLargeByValueCopy, Xs...);), (;) )
  unsigned int MSCompatibilityVersion
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::MSCompatibilityVersion, Xs...);), (;) )
  unsigned int VtorDispMode
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::VtorDispMode, Xs...);), (;) )
  bool ApplePragmaPack
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ApplePragmaPack, Xs...);), (;) )
  bool RetainCommentsFromSystemHeaders
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::RetainCommentsFromSystemHeaders, Xs...);), (;) )
  unsigned int SanitizeAddressFieldPadding
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::SanitizeAddressFieldPadding, Xs...);), (;) )
  bool XRayInstrument
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::XRayInstrument, Xs...);), (;) )
  bool XRayAlwaysEmitCustomEvents
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::XRayAlwaysEmitCustomEvents, Xs...);), (;) )
  bool XRayAlwaysEmitTypedEvents
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::XRayAlwaysEmitTypedEvents, Xs...);), (;) )
  bool ForceEmitVTables
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::ForceEmitVTables, Xs...);), (;) )
  bool AllowEditorPlaceholders
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::AllowEditorPlaceholders, Xs...);), (;) )
  unsigned int FunctionAlignment
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::FunctionAlignment, Xs...);), (;) )
  bool FixedPoint
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::FixedPoint, Xs...);), (;) )
  bool PaddingOnUnsignedFixedPoint
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptionsBase, reflenums::clang__LangOptionsBase::PaddingOnUnsignedFixedPoint, Xs...);), (;) )
};

enum clang::LangOptions::GCMode : unsigned int {
  NonGC,
  GCOnly,
  HybridGC,
};

enum clang::LangOptions::StackProtectorMode : unsigned int {
  SSPOff,
  SSPOn,
  SSPStrong,
  SSPReq,
};

enum clang::LangOptions::SignedOverflowBehaviorTy : unsigned int {
  SOB_Undefined,
  SOB_Defined,
  SOB_Trapping,
};

enum clang::LangOptions::CompilingModuleKind : unsigned int {
  /// Not compiling a module interface at all.
  CMK_None,
  /// Compiling a module from a module map.
  CMK_ModuleMap,
  /// Compiling a C++ modules TS module interface unit.
  CMK_ModuleInterface,
};

enum clang::LangOptions::PragmaMSPointersToMembersKind : unsigned int {
  PPTMK_BestCase,
  PPTMK_FullGeneralitySingleInheritance,
  PPTMK_FullGeneralityMultipleInheritance,
  PPTMK_FullGeneralityVirtualInheritance,
};

enum clang::LangOptions::DefaultCallingConvention : unsigned int {
  DCC_None,
  DCC_CDecl,
  DCC_FastCall,
  DCC_StdCall,
  DCC_VectorCall,
  DCC_RegCall,
};

enum clang::LangOptions::AddrSpaceMapMangling : unsigned int {
  ASMM_Target,
  ASMM_On,
  ASMM_Off,
};

enum clang::LangOptions::MSVCMajorVersion : unsigned int {
  MSVC2010 = 16,
  MSVC2012 = 17,
  MSVC2013 = 18,
  MSVC2015 = 19,
};

/// Clang versions with different platform ABI conformance.
enum class clang::LangOptions::ClangABI : int {
  /// Attempt to be ABI-compatible with code generated by Clang 3.8.x
  /// (SVN r257626). This causes <1 x long long> to be passed in an
  /// integer register instead of an SSE register on x64_64.
  Ver3_8,
  /// Attempt to be ABI-compatible with code generated by Clang 4.0.x
  /// (SVN r291814). This causes move operations to be ignored when
  /// determining whether a class type can be passed or returned directly.
  Ver4,
  /// Attempt to be ABI-compatible with code generated by Clang 6.0.x
  /// (SVN r321711). This causes determination of whether a type is
  /// standard-layout to ignore collisions between empty base classes
  /// and between base classes and member subobjects, which affects
  /// whether we reuse base class tail padding in some ABIs.
  Ver6,
  /// Conform to the underlying platform's C and C++ ABIs as closely
  /// as we can.
  Latest,
};

enum clang::LangOptions::FPContractModeKind : unsigned int {
  FPC_Off,
  FPC_On,
  FPC_Fast,
};

/// Keeps track of the various options that can be
/// enabled, which controls the dialect of C or C++ that is accepted.
M_template_rtpack(Xs)
struct clang::LangOptions::impl : impl_offset_t<clang::LangOptionsBase, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__LangOptions;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::LangOptions::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using GCMode = enum refldetail::clang::LangOptions::GCMode;
  using StackProtectorMode = enum refldetail::clang::LangOptions::StackProtectorMode;
  using SignedOverflowBehaviorTy = enum refldetail::clang::LangOptions::SignedOverflowBehaviorTy;
  using CompilingModuleKind = enum refldetail::clang::LangOptions::CompilingModuleKind;
  using PragmaMSPointersToMembersKind = enum refldetail::clang::LangOptions::PragmaMSPointersToMembersKind;
  using DefaultCallingConvention = enum refldetail::clang::LangOptions::DefaultCallingConvention;
  using AddrSpaceMapMangling = enum refldetail::clang::LangOptions::AddrSpaceMapMangling;
  using MSVCMajorVersion = enum refldetail::clang::LangOptions::MSVCMajorVersion;
  using ClangABI = enum refldetail::clang::LangOptions::ClangABI;
  using FPContractModeKind = enum refldetail::clang::LangOptions::FPContractModeKind;
  /// Set of enabled sanitizers.
  M_REFLTYPED_FIELD(Sanitize, (typename meta::clang::SanitizerSet), __reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::Sanitize, Xs...))
  M_REFLTYPED_FIELD(ObjCRuntime, (typename meta::clang::ObjCRuntime), __reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::ObjCRuntime, Xs...))
  /// Options for parsing comments.
  M_REFLTYPED_FIELD(CommentOpts, (typename meta::clang::CommentOptions), __reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::CommentOpts, Xs...))
  /// Indicates whether the front-end is explicitly told that the
  /// input is a header file (i.e. -x c-header).
  bool IsHeaderFile
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::IsHeaderFile, Xs...);), (;) )
  constexpr enum clang::LangOptions::CompilingModuleKind getCompilingModule() const IFMETA_ELSE( ({    return (enum clang::LangOptions::CompilingModuleKind)__reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::getCompilingModule, Xs...); }) , (;) )
  constexpr enum clang::LangOptions::PragmaMSPointersToMembersKind getMSPointerToMemberRepresentationMethod() const IFMETA_ELSE( ({    return (enum clang::LangOptions::PragmaMSPointersToMembersKind)__reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::getMSPointerToMemberRepresentationMethod, Xs...); }) , (;) )
  constexpr enum clang::LangOptions::DefaultCallingConvention getDefaultCallingConv() const IFMETA_ELSE( ({    return (enum clang::LangOptions::DefaultCallingConvention)__reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::getDefaultCallingConv, Xs...); }) , (;) )
  /// FP_CONTRACT mode (on/off/fast).
  constexpr enum clang::LangOptions::FPContractModeKind getDefaultFPContractMode() const IFMETA_ELSE( ({    return (enum clang::LangOptions::FPContractModeKind)__reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::getDefaultFPContractMode, Xs...); }) , (;) )
  constexpr enum clang::LangOptions::AddrSpaceMapMangling getAddressSpaceMapMangling() const IFMETA_ELSE( ({    return (enum clang::LangOptions::AddrSpaceMapMangling)__reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::getAddressSpaceMapMangling, Xs...); }) , (;) )
  constexpr enum clang::LangOptions::GCMode getGC() const IFMETA_ELSE( ({    return (enum clang::LangOptions::GCMode)__reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::getGC, Xs...); }) , (;) )
  constexpr enum clang::Visibility getValueVisibilityMode() const IFMETA_ELSE( ({    return (enum clang::Visibility)__reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::getValueVisibilityMode, Xs...); }) , (;) )
  constexpr enum clang::Visibility getTypeVisibilityMode() const IFMETA_ELSE( ({    return (enum clang::Visibility)__reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::getTypeVisibilityMode, Xs...); }) , (;) )
  constexpr enum clang::LangOptions::StackProtectorMode getStackProtector() const IFMETA_ELSE( ({    return (enum clang::LangOptions::StackProtectorMode)__reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::getStackProtector, Xs...); }) , (;) )
  constexpr enum clang::LangOptions::SignedOverflowBehaviorTy getSignedOverflowBehavior() const IFMETA_ELSE( ({    return (enum clang::LangOptions::SignedOverflowBehaviorTy)__reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::getSignedOverflowBehavior, Xs...); }) , (;) )
  constexpr enum clang::LangOptions::ClangABI getClangABICompat() const IFMETA_ELSE( ({    return (enum clang::LangOptions::ClangABI)__reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::getClangABICompat, Xs...); }) , (;) )
  /// Are we compiling a module interface (.cppm or module map)?
  constexpr bool isCompilingModule() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::isCompilingModule, Xs...); }) , (;) )
  /// Do we need to track the owning module for a local declaration?
  constexpr bool trackLocalOwningModule() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::trackLocalOwningModule, Xs...); }) , (;) )
  constexpr bool isSignedOverflowDefined() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::isSignedOverflowDefined, Xs...); }) , (;) )
  constexpr bool isSubscriptPointerArithmetic() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::isSubscriptPointerArithmetic, Xs...); }) , (;) )
  constexpr bool isCompatibleWithMSVC(enum clang::LangOptions::MSVCMajorVersion MajorVersion) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::isCompatibleWithMSVC, Xs..., MajorVersion); }) , (;) )
  /// Is this a libc/libm function that is no longer recognized as a
  /// builtin because a -fno-builtin-* option has been specified?
  constexpr bool isNoBuiltinFunc(const char * Name) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::isNoBuiltinFunc, Xs..., Name); }) , (;) )
  /// True if any ObjC types may have non-trivial lifetime qualifiers.
  constexpr bool allowsNonTrivialObjCLifetimeQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::allowsNonTrivialObjCLifetimeQualifiers, Xs...); }) , (;) )
  constexpr bool assumeFunctionsAreConvergent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::assumeFunctionsAreConvergent, Xs...); }) , (;) )
  /// Return the OpenCL C or C++ version as a VersionTuple.
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::VersionTuple) )
  getOpenCLVersionTuple() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LangOptions, reflenums::clang__LangOptions::getOpenCLVersionTuple, Xs...); }) , (;) )
};

/// Floating point control options
M_template_rtpack(Xs)
struct clang::FPOptions::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FPOptions;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FPOptions::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool allowFPContractWithinStatement() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FPOptions, reflenums::clang__FPOptions::allowFPContractWithinStatement, Xs...); }) , (;) )
  constexpr bool allowFPContractAcrossStatement() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FPOptions, reflenums::clang__FPOptions::allowFPContractAcrossStatement, Xs...); }) , (;) )
  /// Used to serialize this.
  constexpr unsigned int getInt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FPOptions, reflenums::clang__FPOptions::getInt, Xs...); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::PrinterHelper::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__PrinterHelper;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::PrinterHelper::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
};

/// Describes how types, statements, expressions, and declarations should be
/// printed.
///
/// This type is intended to be small and suitable for passing by value.
/// It is very frequently copied.
M_template_rtpack(Xs)
struct clang::PrintingPolicy::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__PrintingPolicy;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::PrintingPolicy::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// The number of spaces to use to indent each line.
  unsigned int Indentation
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::Indentation, Xs...);), (;) )
  /// Whether we should suppress printing of the actual specifiers for
  /// the given type or declaration.
  ///
  /// This flag is only used when we are printing declarators beyond
  /// the first declarator within a declaration group. For example, given:
  ///
  /// \code
  /// const int *x, *y;
  /// \endcode
  ///
  /// SuppressSpecifiers will be false when printing the
  /// declaration for "x", so that we will print "int *x"; it will be
  /// \c true when we print "y", so that we suppress printing the
  /// "const int" type specifier and instead only print the "*y".
  bool SuppressSpecifiers
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::SuppressSpecifiers, Xs...);), (;) )
  /// Whether type printing should skip printing the tag keyword.
  ///
  /// This is used when printing the inner type of elaborated types,
  /// (as the tag keyword is part of the elaborated type):
  ///
  /// \code
  /// struct Geometry::Point;
  /// \endcode
  bool SuppressTagKeyword
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::SuppressTagKeyword, Xs...);), (;) )
  /// When true, include the body of a tag definition.
  ///
  /// This is used to place the definition of a struct
  /// in the middle of another declaration as with:
  ///
  /// \code
  /// typedef struct { int x, y; } Point;
  /// \endcode
  bool IncludeTagDefinition
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::IncludeTagDefinition, Xs...);), (;) )
  /// Suppresses printing of scope specifiers.
  bool SuppressScope
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::SuppressScope, Xs...);), (;) )
  /// Suppress printing parts of scope specifiers that don't need
  /// to be written, e.g., for inline or anonymous namespaces.
  bool SuppressUnwrittenScope
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::SuppressUnwrittenScope, Xs...);), (;) )
  /// Suppress printing of variable initializers.
  ///
  /// This flag is used when printing the loop variable in a for-range
  /// statement. For example, given:
  ///
  /// \code
  /// for (auto x : coll)
  /// \endcode
  ///
  /// SuppressInitializers will be true when printing "auto x", so that the
  /// internal initializer constructed for x will not be printed.
  bool SuppressInitializers
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::SuppressInitializers, Xs...);), (;) )
  /// Whether we should print the sizes of constant array expressions as written
  /// in the sources.
  ///
  /// This flag determines whether array types declared as
  ///
  /// \code
  /// int a[4+10*10];
  /// char a[] = "A string";
  /// \endcode
  ///
  /// will be printed as written or as follows:
  ///
  /// \code
  /// int a[104];
  /// char a[9] = "A string";
  /// \endcode
  bool ConstantArraySizeAsWritten
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::ConstantArraySizeAsWritten, Xs...);), (;) )
  /// When printing an anonymous tag name, also print the location of that
  /// entity (e.g., "enum <anonymous at t.h:10:5>"). Otherwise, just prints
  /// "(anonymous)" for the name.
  bool AnonymousTagLocations
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::AnonymousTagLocations, Xs...);), (;) )
  /// When true, suppress printing of the __strong lifetime qualifier in ARC.
  bool SuppressStrongLifetime
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::SuppressStrongLifetime, Xs...);), (;) )
  /// When true, suppress printing of lifetime qualifier in ARC.
  bool SuppressLifetimeQualifiers
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::SuppressLifetimeQualifiers, Xs...);), (;) )
  /// When true, suppresses printing template arguments in names of C++
  /// constructors.
  bool SuppressTemplateArgsInCXXConstructors
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::SuppressTemplateArgsInCXXConstructors, Xs...);), (;) )
  /// Whether we can use 'bool' rather than '_Bool' (even if the language
  /// doesn't actually have 'bool', because, e.g., it is defined as a macro).
  bool Bool
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::Bool, Xs...);), (;) )
  /// Whether we can use 'restrict' rather than '__restrict'.
  bool Restrict
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::Restrict, Xs...);), (;) )
  /// Whether we can use 'alignof' rather than '__alignof'.
  bool Alignof
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::Alignof, Xs...);), (;) )
  /// Whether we can use '_Alignof' rather than '__alignof'.
  bool UnderscoreAlignof
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::UnderscoreAlignof, Xs...);), (;) )
  /// Whether we should use '(void)' rather than '()' for a function prototype
  /// with zero parameters.
  bool UseVoidForZeroParams
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::UseVoidForZeroParams, Xs...);), (;) )
  /// Provide a 'terse' output.
  ///
  /// For example, in this mode we don't print function bodies, class members,
  /// declarations inside namespaces etc.  Effectively, this should print
  /// only the requested declaration.
  bool TerseOutput
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::TerseOutput, Xs...);), (;) )
  /// When true, do certain refinement needed for producing proper declaration
  /// tag; such as, do not print attributes attached to the declaration.
  ///
  bool PolishForDeclaration
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::PolishForDeclaration, Xs...);), (;) )
  /// When true, print the half-precision floating-point type as 'half'
  /// instead of '__fp16'
  bool Half
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::Half, Xs...);), (;) )
  /// When true, print the built-in wchar_t type as __wchar_t. For use in
  /// Microsoft mode when wchar_t is not available.
  bool MSWChar
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::MSWChar, Xs...);), (;) )
  /// When true, include newlines after statements like "break", etc.
  bool IncludeNewlines
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::IncludeNewlines, Xs...);), (;) )
  /// Use whitespace and punctuation like MSVC does. In particular, this prints
  /// anonymous namespaces as `anonymous namespace' and does not insert spaces
  /// after template arguments.
  bool MSVCFormatting
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::MSVCFormatting, Xs...);), (;) )
  /// Whether we should print the constant expressions as written in the
  /// sources.
  ///
  /// This flag determines whether constants expressions like
  ///
  /// \code
  /// 0x10
  /// 2.5e3
  /// \endcode
  ///
  /// will be printed as written or as follows:
  ///
  /// \code
  /// 0x10
  /// 2.5e3
  /// \endcode
  bool ConstantsAsWritten
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::ConstantsAsWritten, Xs...);), (;) )
  /// When true, don't print the implicit 'self' or 'this' expressions.
  bool SuppressImplicitBase
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::SuppressImplicitBase, Xs...);), (;) )
  /// When true, print the fully qualified name of function declarations.
  /// This is the opposite of SuppressScope and thus overrules it.
  bool FullyQualifiedName
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__PrintingPolicy, reflenums::clang__PrintingPolicy::FullyQualifiedName, Xs...);), (;) )
};

/// Indicates whether a file or directory holds normal user code,
/// system code, or system code which is implicitly 'extern "C"' in C++ mode.
///
/// Entire directories can be tagged with this (this is maintained by
/// DirectoryLookup and friends) as can specific FileInfos when a \#pragma
/// system_header is seen or in various other cases.
///
enum clang::SrcMgr::CharacteristicKind : unsigned int {
  C_User,
  C_System,
  C_ExternCSystem,
  C_User_ModuleMap,
  C_System_ModuleMap,
};

/// One instance of this struct is kept for every file loaded or used.
  ///
  /// This object owns the MemoryBuffer object.
M_template_rtpack(Xs)
struct clang::SrcMgr::ContentCache::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SrcMgr__ContentCache;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SrcMgr::ContentCache::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Reference to the file entry representing this ContentCache.
    ///
    /// This reference does not own the FileEntry object.
    ///
    /// It is possible for this to be NULL if the ContentCache encapsulates
    /// an imaginary text buffer.
  M_REFLTYPED_FIELD(OrigEntry, (const typename meta::clang::FileEntry *), __reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::OrigEntry, Xs...))
  /// References the file which the contents were actually loaded from.
    ///
    /// Can be different from 'Entry' if we overridden the contents of one file
    /// with the contents of another file.
  M_REFLTYPED_FIELD(ContentsEntry, (const typename meta::clang::FileEntry *), __reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::ContentsEntry, Xs...))
  /// A bump pointer allocated array of offsets for each source line.
    ///
    /// This is lazily computed.  This is owned by the SourceManager
    /// BumpPointerAllocator object.
  unsigned int * SourceLineCache
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::SourceLineCache, Xs...);), (;) )
  /// The number of lines in this ContentCache.
    ///
    /// This is only valid if SourceLineCache is non-null.
  unsigned int NumLines
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::NumLines, Xs...);), (;) )
  /// Indicates whether the buffer itself was provided to override
    /// the actual file contents.
    ///
    /// When true, the original entry may be a virtual file that does not
    /// exist.
  bool BufferOverridden
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::BufferOverridden, Xs...);), (;) )
  /// True if this content cache was initially created for a source
    /// file considered as a system one.
  bool IsSystemFile
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::IsSystemFile, Xs...);), (;) )
  /// True if this file may be transient, that is, if it might not
    /// exist at some later point in time when this content entry is used,
    /// after serialization and deserialization.
  bool IsTransient
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::IsTransient, Xs...);), (;) )
  /// Returns the memory buffer for the associated content.
    ///
    /// \param Diag Object through which diagnostics will be emitted if the
    ///   buffer cannot be retrieved.
    ///
    /// \param Loc If specified, is the location that invalid file diagnostics
    ///   will be emitted at.
    ///
    /// \param Invalid If non-NULL, will be set \c true if an error occurred.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::MemoryBuffer *) )
  getBuffer(IFMETA_ELSE((const clang::DiagnosticsEngine::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::DiagnosticsEngine &)) Diag, IFMETA_ELSE((const clang::SourceManager::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::SourceManager &)) SM, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) Loc = {}, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::getBuffer, Xs..., Y0s..., Y1s..., Y2s..., Invalid); }) , (;) )
  /// Returns the size of the content encapsulated by this
    /// ContentCache.
    ///
    /// This can be the size of the source file or the size of an
    /// arbitrary scratch buffer.  If the ContentCache encapsulates a source
    /// file this size is retrieved from the file's FileEntry.
  constexpr unsigned int getSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::getSize, Xs...); }) , (;) )
  /// Returns the number of bytes actually mapped for this
    /// ContentCache.
    ///
    /// This can be 0 if the MemBuffer was not actually expanded.
  constexpr unsigned int getSizeBytesMapped() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::getSizeBytesMapped, Xs...); }) , (;) )
  /// Returns the kind of memory used to back the memory buffer for
    /// this content cache.  This is used for performance analysis.
  constexpr enum llvm::MemoryBuffer::BufferKind getMemoryBufferKind() const IFMETA_ELSE( ({    return (enum llvm::MemoryBuffer::BufferKind)__reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::getMemoryBufferKind, Xs...); }) , (;) )
  /// Get the underlying buffer, returning NULL if the buffer is not
    /// yet available.
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::MemoryBuffer *) )
  getRawBuffer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::getRawBuffer, Xs...); }) , (;) )
  /// Determine whether the buffer itself is invalid.
  constexpr bool isBufferInvalid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::isBufferInvalid, Xs...); }) , (;) )
  /// Determine whether the buffer should be freed.
  constexpr bool shouldFreeBuffer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ContentCache, reflenums::clang__SrcMgr__ContentCache::shouldFreeBuffer, Xs...); }) , (;) )
};

/// Information about a FileID, basically just the logical file
  /// that it represents and include stack information.
  ///
  /// Each FileInfo has include stack information, indicating where it came
  /// from. This information encodes the \#include chain that a token was
  /// expanded from. The main include file has an invalid IncludeLoc.
  ///
  /// FileInfos contain a "ContentCache *", with the contents of the file.
  ///
M_template_rtpack(Xs)
struct clang::SrcMgr::FileInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SrcMgr__FileInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SrcMgr::FileInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Return a FileInfo object.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SrcMgr::FileInfo) )
  get(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) IL, IFMETA_ELSE((const clang::SrcMgr::ContentCache::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::SrcMgr::ContentCache *)) Con, enum clang::SrcMgr::CharacteristicKind FileCharacter) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__FileInfo, reflenums::clang__SrcMgr__FileInfo::get, Xs..., Y0s..., Y1s..., FileCharacter); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SrcMgr::FileInfo) )
  get(Y0 p0, ptrwrp<Y1> p1, enum clang::SrcMgr::CharacteristicKind p2) {
      return get(p0, p1.get(), p2);
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getIncludeLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__FileInfo, reflenums::clang__SrcMgr__FileInfo::getIncludeLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::SrcMgr::ContentCache *) )
  getContentCache() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__FileInfo, reflenums::clang__SrcMgr__FileInfo::getContentCache, Xs...); }) , (;) )
  /// Return whether this is a system header or not.
  constexpr enum clang::SrcMgr::CharacteristicKind getFileCharacteristic() const IFMETA_ELSE( ({    return (enum clang::SrcMgr::CharacteristicKind)__reflect_prop(reflenums::RK_clang__SrcMgr__FileInfo, reflenums::clang__SrcMgr__FileInfo::getFileCharacteristic, Xs...); }) , (;) )
  /// Return true if this FileID has \#line directives in it.
  constexpr bool hasLineDirectives() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__FileInfo, reflenums::clang__SrcMgr__FileInfo::hasLineDirectives, Xs...); }) , (;) )
};

/// Each ExpansionInfo encodes the expansion location - where
  /// the token was ultimately expanded, and the SpellingLoc - where the actual
  /// character data for the token came from.
M_template_rtpack(Xs)
struct clang::SrcMgr::ExpansionInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SrcMgr__ExpansionInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SrcMgr::ExpansionInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getSpellingLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ExpansionInfo, reflenums::clang__SrcMgr__ExpansionInfo::getSpellingLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExpansionLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ExpansionInfo, reflenums::clang__SrcMgr__ExpansionInfo::getExpansionLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExpansionLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ExpansionInfo, reflenums::clang__SrcMgr__ExpansionInfo::getExpansionLocEnd, Xs...); }) , (;) )
  constexpr bool isExpansionTokenRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ExpansionInfo, reflenums::clang__SrcMgr__ExpansionInfo::isExpansionTokenRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharSourceRange) )
  getExpansionLocRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ExpansionInfo, reflenums::clang__SrcMgr__ExpansionInfo::getExpansionLocRange, Xs...); }) , (;) )
  constexpr bool isMacroArgExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ExpansionInfo, reflenums::clang__SrcMgr__ExpansionInfo::isMacroArgExpansion, Xs...); }) , (;) )
  constexpr bool isMacroBodyExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ExpansionInfo, reflenums::clang__SrcMgr__ExpansionInfo::isMacroBodyExpansion, Xs...); }) , (;) )
  constexpr bool isFunctionMacroExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ExpansionInfo, reflenums::clang__SrcMgr__ExpansionInfo::isFunctionMacroExpansion, Xs...); }) , (;) )
  /// Return a ExpansionInfo for an expansion.
    ///
    /// Start and End specify the expansion range (where the macro is
    /// expanded), and SpellingLoc specifies the spelling location (where
    /// the characters from the token come from). All three can refer to
    /// normal File SLocs or expansion locations.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SrcMgr::ExpansionInfo) )
  create(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) SpellingLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) Start, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) End, bool ExpansionIsTokenRange = true) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ExpansionInfo, reflenums::clang__SrcMgr__ExpansionInfo::create, Xs..., Y0s..., Y1s..., Y2s..., ExpansionIsTokenRange); }) , (;) )
  /// Return a special ExpansionInfo for the expansion of
    /// a macro argument into a function-like macro's body.
    ///
    /// ExpansionLoc specifies the expansion location (where the macro is
    /// expanded). This doesn't need to be a range because a macro is always
    /// expanded at a macro parameter reference, and macro parameters are
    /// always exactly one token. SpellingLoc specifies the spelling location
    /// (where the characters from the token come from). ExpansionLoc and
    /// SpellingLoc can both refer to normal File SLocs or expansion locations.
    ///
    /// Given the code:
    /// \code
    ///   #define F(x) f(x)
    ///   F(42);
    /// \endcode
    ///
    /// When expanding '\c F(42)', the '\c x' would call this with an
    /// SpellingLoc pointing at '\c 42' and an ExpansionLoc pointing at its
    /// location in the definition of '\c F'.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SrcMgr::ExpansionInfo) )
  createForMacroArg(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) SpellingLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) ExpansionLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ExpansionInfo, reflenums::clang__SrcMgr__ExpansionInfo::createForMacroArg, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Return a special ExpansionInfo representing a token that ends
    /// prematurely. This is used to model a '>>' token that has been split
    /// into '>' tokens and similar cases. Unlike for the other forms of
    /// expansion, the expansion range in this case is a character range, not
    /// a token range.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SrcMgr::ExpansionInfo) )
  createForTokenSplit(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) SpellingLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) Start, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) End) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__ExpansionInfo, reflenums::clang__SrcMgr__ExpansionInfo::createForTokenSplit, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
};

/// This is a discriminated union of FileInfo and ExpansionInfo.
  ///
  /// SourceManager keeps an array of these objects, and they are uniquely
  /// identified by the FileID datatype.
M_template_rtpack(Xs)
struct clang::SrcMgr::SLocEntry::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SrcMgr__SLocEntry;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SrcMgr::SLocEntry::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr unsigned int getOffset() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__SLocEntry, reflenums::clang__SrcMgr__SLocEntry::getOffset, Xs...); }) , (;) )
  constexpr bool isExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__SLocEntry, reflenums::clang__SrcMgr__SLocEntry::isExpansion, Xs...); }) , (;) )
  constexpr bool isFile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__SLocEntry, reflenums::clang__SrcMgr__SLocEntry::isFile, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::SrcMgr::FileInfo &) )
  getFile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__SLocEntry, reflenums::clang__SrcMgr__SLocEntry::getFile, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::SrcMgr::ExpansionInfo &) )
  getExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__SLocEntry, reflenums::clang__SrcMgr__SLocEntry::getExpansion, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SrcMgr::SLocEntry) )
  get(unsigned int Offset, IFMETA_ELSE((const clang::SrcMgr::FileInfo::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::SrcMgr::FileInfo &)) FI) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__SLocEntry, reflenums::clang__SrcMgr__SLocEntry::get, Xs..., Offset, Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SrcMgr::SLocEntry) )
  get(unsigned int Offset, IFMETA_ELSE((const clang::SrcMgr::ExpansionInfo::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::SrcMgr::ExpansionInfo &)) Expansion) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SrcMgr__SLocEntry, reflenums::clang__SrcMgr__SLocEntry::get1, Xs..., Offset, Y0s...); }) , (;) )
};

/// This class handles loading and caching of source files into memory.
///
/// This object owns the MemoryBuffer objects for all of the loaded
/// files and assigns unique FileID's for each unique \#include chain.
///
/// The SourceManager can be queried for information about SourceLocation
/// objects, turning them into either spelling or expansion locations. Spelling
/// locations represent where the bytes corresponding to a token came from and
/// expansion locations represent where the location is in the user's view. In
/// the case of a macro expansion, for example, the spelling location indicates
/// where the expanded token came from and the expansion location specifies
/// where it was expanded.
M_template_rtpack(Xs)
struct clang::SourceManager::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SourceManager;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SourceManager::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr void Retain() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::Retain, Xs...); }) , (;) )
  constexpr void Release() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::Release, Xs...); }) , (;) )
  static const unsigned int MaxLoadedOffset = 2147483648u;
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DiagnosticsEngine &) )
  getDiagnostics() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getDiagnostics, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FileManager &) )
  getFileManager() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getFileManager, Xs...); }) , (;) )
  /// True if non-system source files should be treated as volatile
  /// (likely to change while trying to use them).
  constexpr bool userFilesAreVolatile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::userFilesAreVolatile, Xs...); }) , (;) )
  /// Returns the FileID of the main source file.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FileID) )
  getMainFileID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getMainFileID, Xs...); }) , (;) )
  /// Get the file ID for the precompiled preamble if there is one.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FileID) )
  getPreambleFileID() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getPreambleFileID, Xs...); }) , (;) )
  /// Returns true if the file contents have been overridden.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isFileOverridden(IFMETA_ELSE((const clang::FileEntry::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::FileEntry *)) File) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isFileOverridden, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isFileOverridden(ptrwrp<Y0> p0) const {
      return isFileOverridden(p0.get());
  }), () )
  /// Return the buffer for the specified FileID.
  ///
  /// If there is an error opening this buffer the first time, this
  /// manufactures a temporary buffer and returns a non-empty error string.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::MemoryBuffer *) )
  getBuffer(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) Loc, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getBuffer, Xs..., Y0s..., Y1s..., Invalid); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::MemoryBuffer *) )
  getBuffer(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getBuffer1, Xs..., Y0s..., Invalid); }) , (;) )
  /// Returns the FileEntry record for the provided FileID.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FileEntry *) )
  getFileEntryForID(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getFileEntryForID, Xs..., Y0s...); }) , (;) )
  /// Returns the FileEntry record for the provided SLocEntry.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FileEntry *) )
  getFileEntryForSLocEntry(IFMETA_ELSE((const clang::SrcMgr::SLocEntry::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::SrcMgr::SLocEntry &)) sloc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getFileEntryForSLocEntry, Xs..., Y0s...); }) , (;) )
  /// Return a StringRef to the source buffer data for the
  /// specified FileID.
  ///
  /// \param FID The file ID whose contents will be returned.
  /// \param Invalid If non-NULL, will be set true if an error occurred.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * getBufferData(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getBufferData, Xs..., Y0s..., Invalid); }) , (;) )
  /// Get the number of FileIDs (files and macros) that were created
  /// during preprocessing of \p FID, including it.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getNumCreatedFIDsForFileID(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getNumCreatedFIDsForFileID, Xs..., Y0s...); }) , (;) )
  /// Set the number of FileIDs (files and macros) that were created
  /// during preprocessing of \p FID, including it.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void setNumCreatedFIDsForFileID(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID, unsigned int NumFIDs) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::setNumCreatedFIDsForFileID, Xs..., Y0s..., NumFIDs); }) , (;) )
  /// Return the FileID for a SourceLocation.
  ///
  /// This is a very hot method that is used for all SourceManager queries
  /// that start with a SourceLocation object.  It is responsible for finding
  /// the entry in SLocEntryTable which contains the specified location.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FileID) )
  getFileID(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) SpellingLoc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getFileID, Xs..., Y0s...); }) , (;) )
  /// Return the filename of the file containing a SourceLocation.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * getFilename(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) SpellingLoc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getFilename, Xs..., Y0s...); }) , (;) )
  /// Return the source location corresponding to the first byte of
  /// the specified file.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocForStartOfFile(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getLocForStartOfFile, Xs..., Y0s...); }) , (;) )
  /// Return the source location corresponding to the last byte of the
  /// specified file.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocForEndOfFile(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getLocForEndOfFile, Xs..., Y0s...); }) , (;) )
  /// Returns the include location if \p FID is a \#include'd file
  /// otherwise it returns an invalid location.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getIncludeLoc(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getIncludeLoc, Xs..., Y0s...); }) , (;) )
  /// Given a SourceLocation object \p Loc, return the expansion
  /// location referenced by the ID.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExpansionLoc(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getExpansionLoc, Xs..., Y0s...); }) , (;) )
  /// Given \p Loc, if it is a macro location return the expansion
  /// location or the spelling location, depending on if it comes from a
  /// macro argument or not.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getFileLoc(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getFileLoc, Xs..., Y0s...); }) , (;) )
  /// Return the start/end of the expansion information for an
  /// expansion location.
  ///
  /// \pre \p Loc is required to be an expansion location.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharSourceRange) )
  getImmediateExpansionRange(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getImmediateExpansionRange, Xs..., Y0s...); }) , (;) )
  /// Given a SourceLocation object, return the range of
  /// tokens covered by the expansion in the ultimate file.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharSourceRange) )
  getExpansionRange(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getExpansionRange, Xs..., Y0s...); }) , (;) )
  /// Given a SourceRange object, return the range of
  /// tokens or characters covered by the expansion in the ultimate file.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharSourceRange) )
  getExpansionRange(IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceRange)) Range) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getExpansionRange1, Xs..., Y0s...); }) , (;) )
  /// Given a CharSourceRange object, return the range of
  /// tokens or characters covered by the expansion in the ultimate file.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharSourceRange) )
  getExpansionRange(IFMETA_ELSE((const clang::CharSourceRange::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::CharSourceRange)) Range) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getExpansionRange2, Xs..., Y0s...); }) , (;) )
  /// Given a SourceLocation object, return the spelling
  /// location referenced by the ID.
  ///
  /// This is the place where the characters that make up the lexed token
  /// can be found.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getSpellingLoc(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getSpellingLoc, Xs..., Y0s...); }) , (;) )
  /// Given a SourceLocation object, return the spelling location
  /// referenced by the ID.
  ///
  /// This is the first level down towards the place where the characters
  /// that make up the lexed token can be found.  This should not generally
  /// be used by clients.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getImmediateSpellingLoc(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getImmediateSpellingLoc, Xs..., Y0s...); }) , (;) )
  /// Form a SourceLocation from a FileID and Offset pair.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getComposedLoc(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID, unsigned int Offset) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getComposedLoc, Xs..., Y0s..., Offset); }) , (;) )
  /// Returns the offset from the start of the file that the
  /// specified SourceLocation represents.
  ///
  /// This is not very meaningful for a macro ID.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getFileOffset(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) SpellingLoc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getFileOffset, Xs..., Y0s...); }) , (;) )
  /// Tests whether the given source location represents a macro
  /// argument's expansion into the function-like macro definition.
  ///
  /// \param StartLoc If non-null and function returns true, it is set to the
  /// start location of the macro argument expansion.
  ///
  /// Such source locations only appear inside of the expansion
  /// locations representing where a particular function-like macro was
  /// expanded.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isMacroArgExpansion(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::SourceLocation *)) StartLoc = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isMacroArgExpansion, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr bool isMacroArgExpansion(Y0 p0, ptrwrp<Y1> p1 = {}) const {
      return isMacroArgExpansion(p0, p1.get());
  }), () )
  /// Tests whether the given source location represents the expansion of
  /// a macro body.
  ///
  /// This is equivalent to testing whether the location is part of a macro
  /// expansion but not the expansion of an argument to a function-like macro.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isMacroBodyExpansion(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isMacroBodyExpansion, Xs..., Y0s...); }) , (;) )
  /// Returns true if the given MacroID location points at the beginning
  /// of the immediate macro expansion.
  ///
  /// \param MacroBegin If non-null and function returns true, it is set to the
  /// begin location of the immediate macro expansion.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isAtStartOfImmediateMacroExpansion(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::SourceLocation *)) MacroBegin = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isAtStartOfImmediateMacroExpansion, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr bool isAtStartOfImmediateMacroExpansion(Y0 p0, ptrwrp<Y1> p1 = {}) const {
      return isAtStartOfImmediateMacroExpansion(p0, p1.get());
  }), () )
  /// Returns true if the given MacroID location points at the character
  /// end of the immediate macro expansion.
  ///
  /// \param MacroEnd If non-null and function returns true, it is set to the
  /// character end location of the immediate macro expansion.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isAtEndOfImmediateMacroExpansion(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::SourceLocation *)) MacroEnd = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isAtEndOfImmediateMacroExpansion, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr bool isAtEndOfImmediateMacroExpansion(Y0 p0, ptrwrp<Y1> p1 = {}) const {
      return isAtEndOfImmediateMacroExpansion(p0, p1.get());
  }), () )
  /// Returns true if \p Loc is inside the [\p Start, +\p Length)
  /// chunk of the source location address space.
  ///
  /// If it's true and \p RelativeOffset is non-null, it will be set to the
  /// relative offset of \p Loc inside the chunk.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isInSLocAddrSpace(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) Start, unsigned int Length, unsigned int * RelativeOffset = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isInSLocAddrSpace, Xs..., Y0s..., Y1s..., Length, RelativeOffset); }) , (;) )
  /// Return true if both \p LHS and \p RHS are in the local source
  /// location address space or the loaded one.
  ///
  /// If it's true and \p RelativeOffset is non-null, it will be set to the
  /// offset of \p RHS relative to \p LHS.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isInSameSLocAddrSpace(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) LHS, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) RHS, int * RelativeOffset) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isInSameSLocAddrSpace, Xs..., Y0s..., Y1s..., RelativeOffset); }) , (;) )
  /// Return a pointer to the start of the specified location
  /// in the appropriate spelling MemoryBuffer.
  ///
  /// \param Invalid If non-NULL, will be set \c true if an error occurs.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * getCharacterData(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) SL, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getCharacterData, Xs..., Y0s..., Invalid); }) , (;) )
  /// Return the column # for the specified file position.
  ///
  /// This is significantly cheaper to compute than the line number.  This
  /// returns zero if the column number isn't known.  This may only be called
  /// on a file sloc, so you must choose a spelling or expansion location
  /// before calling this method.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getColumnNumber(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID, unsigned int FilePos, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getColumnNumber, Xs..., Y0s..., FilePos, Invalid); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getSpellingColumnNumber(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getSpellingColumnNumber, Xs..., Y0s..., Invalid); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getExpansionColumnNumber(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getExpansionColumnNumber, Xs..., Y0s..., Invalid); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getPresumedColumnNumber(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getPresumedColumnNumber, Xs..., Y0s..., Invalid); }) , (;) )
  /// Given a SourceLocation, return the spelling line number
  /// for the position indicated.
  ///
  /// This requires building and caching a table of line offsets for the
  /// MemoryBuffer, so this is not cheap: use only when about to emit a
  /// diagnostic.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getLineNumber(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID, unsigned int FilePos, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getLineNumber, Xs..., Y0s..., FilePos, Invalid); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getSpellingLineNumber(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getSpellingLineNumber, Xs..., Y0s..., Invalid); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getExpansionLineNumber(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getExpansionLineNumber, Xs..., Y0s..., Invalid); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getPresumedLineNumber(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getPresumedLineNumber, Xs..., Y0s..., Invalid); }) , (;) )
  /// Return the filename or buffer identifier of the buffer the
  /// location is in.
  ///
  /// Note that this name does not respect \#line directives.  Use
  /// getPresumedLoc for normal clients.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * getBufferName(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getBufferName, Xs..., Y0s..., Invalid); }) , (;) )
  /// Return the file characteristic of the specified source
  /// location, indicating whether this is a normal file, a system
  /// header, or an "implicit extern C" system header.
  ///
  /// This state can be modified with flags on GNU linemarker directives like:
  /// \code
  ///   # 4 "foo.h" 3
  /// \endcode
  /// which changes all source locations in the current file after that to be
  /// considered to be from a system header.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum clang::SrcMgr::CharacteristicKind getFileCharacteristic(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return (enum clang::SrcMgr::CharacteristicKind)__reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getFileCharacteristic, Xs..., Y0s...); }) , (;) )
  /// Returns the "presumed" location of a SourceLocation specifies.
  ///
  /// A "presumed location" can be modified by \#line or GNU line marker
  /// directives.  This provides a view on the data that a user should see
  /// in diagnostics, for example.
  ///
  /// Note that a presumed location is always given as the expansion point of
  /// an expansion location, not at the spelling location.
  ///
  /// \returns The presumed location of the specified SourceLocation. If the
  /// presumed location cannot be calculated (e.g., because \p Loc is invalid
  /// or the file containing \p Loc has changed on disk), returns an invalid
  /// presumed location.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::PresumedLoc) )
  getPresumedLoc(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, bool UseLineDirectives = true) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getPresumedLoc, Xs..., Y0s..., UseLineDirectives); }) , (;) )
  /// Returns whether the PresumedLoc for a given SourceLocation is
  /// in the main file.
  ///
  /// This computes the "presumed" location for a SourceLocation, then checks
  /// whether it came from a file other than the main file. This is different
  /// from isWrittenInMainFile() because it takes line marker directives into
  /// account.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isInMainFile(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isInMainFile, Xs..., Y0s...); }) , (;) )
  /// Returns true if the spelling locations for both SourceLocations
  /// are part of the same file buffer.
  ///
  /// This check ignores line marker directives.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isWrittenInSameFile(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc1, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) Loc2) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isWrittenInSameFile, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Returns true if the spelling location for the given location
  /// is in the main file buffer.
  ///
  /// This check ignores line marker directives.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isWrittenInMainFile(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isWrittenInMainFile, Xs..., Y0s...); }) , (;) )
  /// Returns if a SourceLocation is in a system header.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isInSystemHeader(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isInSystemHeader, Xs..., Y0s...); }) , (;) )
  /// Returns if a SourceLocation is in an "extern C" system header.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isInExternCSystemHeader(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isInExternCSystemHeader, Xs..., Y0s...); }) , (;) )
  /// Returns whether \p Loc is expanded from a macro in a system header.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isInSystemMacro(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isInSystemMacro, Xs..., Y0s...); }) , (;) )
  /// The size of the SLocEntry that \p FID represents.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getFileIDSize(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getFileIDSize, Xs..., Y0s...); }) , (;) )
  /// Given a specific FileID, returns true if \p Loc is inside that
  /// FileID chunk and sets relative offset (offset of \p Loc from beginning
  /// of FileID) to \p relativeOffset.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isInFileID(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::FileID)) FID, unsigned int * RelativeOffset = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isInFileID, Xs..., Y0s..., Y1s..., RelativeOffset); }) , (;) )
  /// Determine if the source manager has a line table.
  constexpr bool hasLineTable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::hasLineTable, Xs...); }) , (;) )
  /// Return the total amount of physical memory allocated by the
  /// ContentCache allocator.
  constexpr unsigned long getContentCacheSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getContentCacheSize, Xs...); }) , (;) )
  /// Return the amount of memory used for various side tables and
  /// data structures in the SourceManager.
  constexpr unsigned long getDataStructureSizes() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getDataStructureSizes, Xs...); }) , (;) )
  /// Get the source location for the given file:line:col triplet.
  ///
  /// If the source file is included multiple times, the source location will
  /// be based upon the first inclusion.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  translateFileLineCol(IFMETA_ELSE((const clang::FileEntry::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::FileEntry *)) SourceFile, unsigned int Line, unsigned int Col) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::translateFileLineCol, Xs..., Y0s..., Line, Col); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  translateFileLineCol(ptrwrp<Y0> p0, unsigned int p1, unsigned int p2) const {
      return translateFileLineCol(p0.get(), p1, p2);
  }), () )
  /// Get the FileID for the given file.
  ///
  /// If the source file is included multiple times, the FileID will be the
  /// first inclusion.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FileID) )
  translateFile(IFMETA_ELSE((const clang::FileEntry::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::FileEntry *)) SourceFile) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::translateFile, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FileID) )
  translateFile(ptrwrp<Y0> p0) const {
      return translateFile(p0.get());
  }), () )
  /// Get the source location in \p FID for the given line:col.
  /// Returns null location if \p FID is not a file SLocEntry.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  translateLineCol(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID, unsigned int Line, unsigned int Col) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::translateLineCol, Xs..., Y0s..., Line, Col); }) , (;) )
  /// If \p Loc points inside a function macro argument, the returned
  /// location will be the macro location in which the argument was expanded.
  /// If a macro argument is used multiple times, the expanded location will
  /// be at the first expansion of the argument.
  /// e.g.
  ///   MY_MACRO(foo);
  ///             ^
  /// Passing a file location pointing at 'foo', will yield a macro location
  /// where 'foo' was expanded into.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getMacroArgExpandedLocation(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getMacroArgExpandedLocation, Xs..., Y0s...); }) , (;) )
  /// Determines the order of 2 source locations in the translation unit.
  ///
  /// \returns true if LHS source location comes before RHS, false otherwise.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isBeforeInTranslationUnit(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) LHS, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isBeforeInTranslationUnit, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Determines the order of 2 source locations in the "source location
  /// address space".
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isBeforeInSLocAddrSpace(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) LHS, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isBeforeInSLocAddrSpace, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Determines the order of a source location and a source location
  /// offset in the "source location address space".
  ///
  /// Note that we always consider source locations loaded from
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isBeforeInSLocAddrSpace(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) LHS, unsigned int RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isBeforeInSLocAddrSpace1, Xs..., Y0s..., RHS); }) , (;) )
  /// Return true if the Point is within Start and End.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr bool isPointWithin(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Location, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) Start, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) End) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isPointWithin, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool hasFileInfo(IFMETA_ELSE((const clang::FileEntry::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::FileEntry *)) File) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::hasFileInfo, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool hasFileInfo(ptrwrp<Y0> p0) const {
      return hasFileInfo(p0.get());
  }), () )
  /// Print statistics to stderr.
  constexpr void PrintStats() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::PrintStats, Xs...); }) , (;) )
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::dump, Xs...); }) , (;) )
  /// Get the number of local SLocEntries we have.
  constexpr unsigned int local_sloc_entry_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::local_sloc_entry_size, Xs...); }) , (;) )
  /// Get a local SLocEntry. This is exposed for indexing.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::SrcMgr::SLocEntry &) )
  getLocalSLocEntry(unsigned int Index, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getLocalSLocEntry, Xs..., Index, Invalid); }) , (;) )
  /// Get the number of loaded SLocEntries we have.
  constexpr unsigned int loaded_sloc_entry_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::loaded_sloc_entry_size, Xs...); }) , (;) )
  /// Get a loaded SLocEntry. This is exposed for indexing.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::SrcMgr::SLocEntry &) )
  getLoadedSLocEntry(unsigned int Index, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getLoadedSLocEntry, Xs..., Index, Invalid); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::SrcMgr::SLocEntry &) )
  getSLocEntry(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID, bool * Invalid = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getSLocEntry, Xs..., Y0s..., Invalid); }) , (;) )
  constexpr unsigned int getNextLocalOffset() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getNextLocalOffset, Xs...); }) , (;) )
  /// Returns true if \p Loc came from a PCH/Module.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isLoadedSourceLocation(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isLoadedSourceLocation, Xs..., Y0s...); }) , (;) )
  /// Returns true if \p Loc did not come from a PCH/Module.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isLocalSourceLocation(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isLocalSourceLocation, Xs..., Y0s...); }) , (;) )
  /// Returns true if \p FID came from a PCH/Module.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isLoadedFileID(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isLoadedFileID, Xs..., Y0s...); }) , (;) )
  /// Returns true if \p FID did not come from a PCH/Module.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isLocalFileID(IFMETA_ELSE((const clang::FileID::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::FileID)) FID) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::isLocalFileID, Xs..., Y0s...); }) , (;) )
  /// Gets the location of the immediate macro caller, one level up the stack
  /// toward the initial macro typed into the source.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getImmediateMacroCallerLoc(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getImmediateMacroCallerLoc, Xs..., Y0s...); }) , (;) )
  /// \return Location of the top-level macro caller.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTopMacroCallerLoc(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SourceManager, reflenums::clang__SourceManager::getTopMacroCallerLoc, Xs..., Y0s...); }) , (;) )
};

enum clang::RawComment::CommentKind : unsigned int {
  ///< Invalid comment
  RCK_Invalid,
  ///< Any normal BCPL comments
  RCK_OrdinaryBCPL,
  ///< Any normal C comment
  RCK_OrdinaryC,
  ///< \code /// stuff \endcode
  RCK_BCPLSlash,
  ///< \code //! stuff \endcode
  RCK_BCPLExcl,
  ///< \code /** stuff */ \endcode
  RCK_JavaDoc,
  ///< \code /*! stuff */ \endcode, also used by HeaderDoc
  RCK_Qt,
  ///< Two or more documentation comments merged together
  RCK_Merged,
};

M_template_rtpack(Xs)
struct clang::RawComment::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__RawComment;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::RawComment::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using CommentKind = enum refldetail::clang::RawComment::CommentKind;
  constexpr enum clang::RawComment::CommentKind getKind() const IFMETA_ELSE( ({    return (enum clang::RawComment::CommentKind)__reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::getKind, Xs...); }) , (;) )
  constexpr bool isInvalid() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::isInvalid, Xs...); }) , (;) )
  constexpr bool isMerged() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::isMerged, Xs...); }) , (;) )
  /// Is this comment attached to any declaration?
  constexpr bool isAttached() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::isAttached, Xs...); }) , (;) )
  /// Returns true if it is a comment that should be put after a member:
  /// \code ///< stuff \endcode
  /// \code //!< stuff \endcode
  /// \code /**< stuff */ \endcode
  /// \code /*!< stuff */ \endcode
  constexpr bool isTrailingComment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::isTrailingComment, Xs...); }) , (;) )
  /// Returns true if it is a probable typo:
  /// \code //< stuff \endcode
  /// \code /*< stuff */ \endcode
  constexpr bool isAlmostTrailingComment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::isAlmostTrailingComment, Xs...); }) , (;) )
  /// Returns true if this comment is not a documentation comment.
  constexpr bool isOrdinary() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::isOrdinary, Xs...); }) , (;) )
  /// Returns true if this comment any kind of a documentation comment.
  constexpr bool isDocumentation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::isDocumentation, Xs...); }) , (;) )
  /// Returns raw comment text with comment markers.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * getRawText(IFMETA_ELSE((const clang::SourceManager::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::SourceManager &)) SourceMgr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::getRawText, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * getBriefText(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::getBriefText, Xs..., Y0s...); }) , (;) )
  /// Returns sanitized comment text, suitable for presentation in editor UIs.
  /// E.g. will transform:
  ///     // This is a long multiline comment.
  ///     //   Parts of it  might be indented.
  ///     /* The comments styles might be mixed. */
  ///  into
  ///     "This is a long multiline comment.\n"
  ///     "  Parts of it  might be indented.\n"
  ///     "The comments styles might be mixed."
  /// Also removes leading indentation and sanitizes some common cases:
  ///     /* This is a first line.
  ///      *   This is a second line. It is indented.
  ///      * This is a third line. */
  /// and
  ///     /* This is a first line.
  ///          This is a second line. It is indented.
  ///     This is a third line. */
  /// will both turn into:
  ///     "This is a first line.\n"
  ///     "  This is a second line. It is indented.\n"
  ///     "This is a third line."
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr const char * getFormattedText(IFMETA_ELSE((const clang::SourceManager::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::SourceManager &)) SourceMgr, IFMETA_ELSE((const clang::DiagnosticsEngine::template impl</*ptrorref=*/1, Y1s...>), (typename meta::clang::DiagnosticsEngine &)) Diags) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RawComment, reflenums::clang__RawComment::getFormattedText, Xs..., Y0s..., Y1s...); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::SanitizerBlacklist::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SanitizerBlacklist;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SanitizerBlacklist::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isBlacklistedGlobal(unsigned long long Mask, const char * GlobalName, const char * Category = 0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SanitizerBlacklist, reflenums::clang__SanitizerBlacklist::isBlacklistedGlobal, Xs..., Mask, GlobalName, Category); }) , (;) )
  constexpr bool isBlacklistedType(unsigned long long Mask, const char * MangledTypeName, const char * Category = 0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SanitizerBlacklist, reflenums::clang__SanitizerBlacklist::isBlacklistedType, Xs..., Mask, MangledTypeName, Category); }) , (;) )
  constexpr bool isBlacklistedFunction(unsigned long long Mask, const char * FunctionName) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SanitizerBlacklist, reflenums::clang__SanitizerBlacklist::isBlacklistedFunction, Xs..., Mask, FunctionName); }) , (;) )
  constexpr bool isBlacklistedFile(unsigned long long Mask, const char * FileName, const char * Category = 0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SanitizerBlacklist, reflenums::clang__SanitizerBlacklist::isBlacklistedFile, Xs..., Mask, FileName, Category); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isBlacklistedLocation(unsigned long long Mask, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, const char * Category = 0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SanitizerBlacklist, reflenums::clang__SanitizerBlacklist::isBlacklistedLocation, Xs..., Mask, Y0s..., Category); }) , (;) )
};

/// The basic C++ ABI kind.
enum clang::TargetCXXABI::Kind : unsigned int {
  /// The generic Itanium ABI is the standard ABI of most open-source
  /// and Unix-like platforms.  It is the primary ABI targeted by
  /// many compilers, including Clang and GCC.
  ///
  /// It is documented here:
  ///   http://www.codesourcery.com/public/cxx-abi/
  GenericItanium,
  /// The generic ARM ABI is a modified version of the Itanium ABI
  /// proposed by ARM for use on ARM-based platforms.
  ///
  /// These changes include:
  ///   - the representation of member function pointers is adjusted
  ///     to not conflict with the 'thumb' bit of ARM function pointers;
  ///   - constructors and destructors return 'this';
  ///   - guard variables are smaller;
  ///   - inline functions are never key functions;
  ///   - array cookies have a slightly different layout;
  ///   - additional convenience functions are specified;
  ///   - and more!
  ///
  /// It is documented here:
  ///    http://infocenter.arm.com
  ///                    /help/topic/com.arm.doc.ihi0041c/IHI0041C_cppabi.pdf
  GenericARM,
  /// The iOS ABI is a partial implementation of the ARM ABI.
  /// Several of the features of the ARM ABI were not fully implemented
  /// in the compilers that iOS was launched with.
  ///
  /// Essentially, the iOS ABI includes the ARM changes to:
  ///   - member function pointers,
  ///   - guard variables,
  ///   - array cookies, and
  ///   - constructor/destructor signatures.
  iOS,
  /// The iOS 64-bit ABI is follows ARM's published 64-bit ABI more
  /// closely, but we don't guarantee to follow it perfectly.
  ///
  /// It is documented here:
  ///    http://infocenter.arm.com
  ///                  /help/topic/com.arm.doc.ihi0059a/IHI0059A_cppabi64.pdf
  iOS64,
  /// WatchOS is a modernisation of the iOS ABI, which roughly means it's
  /// the iOS64 ABI ported to 32-bits. The primary difference from iOS64 is
  /// that RTTI objects must still be unique at the moment.
  WatchOS,
  /// The generic AArch64 ABI is also a modified version of the Itanium ABI,
  /// but it has fewer divergences than the 32-bit ARM ABI.
  ///
  /// The relevant changes from the generic ABI in this case are:
  ///   - representation of member function pointers adjusted as in ARM.
  ///   - guard variables  are smaller.
  GenericAArch64,
  /// The generic Mips ABI is a modified version of the Itanium ABI.
  ///
  /// At the moment, only change from the generic ABI in this case is:
  ///   - representation of member function pointers adjusted as in ARM.
  GenericMIPS,
  /// The WebAssembly ABI is a modified version of the Itanium ABI.
  ///
  /// The changes from the Itanium ABI are:
  ///   - representation of member function pointers is adjusted, as in ARM;
  ///   - member functions are not specially aligned;
  ///   - constructors and destructors return 'this', as in ARM;
  ///   - guard variables are 32-bit on wasm32, as in ARM;
  ///   - unused bits of guard variables are reserved, as in ARM;
  ///   - inline functions are never key functions, as in ARM;
  ///   - C++11 POD rules are used for tail padding, as in iOS64.
  ///
  /// TODO: At present the WebAssembly ABI is not considered stable, so none
  /// of these details is necessarily final yet.
  WebAssembly,
  /// The Microsoft ABI is the ABI used by Microsoft Visual Studio (and
  /// compatible compilers).
  ///
  /// FIXME: should this be split into Win32 and Win64 variants?
  ///
  /// Only scattered and incomplete official documentation exists.
  Microsoft,
};

/// When is record layout allowed to allocate objects in the tail
/// padding of a base class?
///
/// This decision cannot be changed without breaking platform ABI
/// compatibility, and yet it is tied to language guarantees which
/// the committee has so far seen fit to strengthen no less than
/// three separate times:
///   - originally, there were no restrictions at all;
///   - C++98 declared that objects could not be allocated in the
///     tail padding of a POD type;
///   - C++03 extended the definition of POD to include classes
///     containing member pointers; and
///   - C++11 greatly broadened the definition of POD to include
///     all trivial standard-layout classes.
/// Each of these changes technically took several existing
/// platforms and made them permanently non-conformant.
enum clang::TargetCXXABI::TailPaddingUseRules : unsigned int {
  /// The tail-padding of a base class is always theoretically
  /// available, even if it's POD.  This is not strictly conforming
  /// in any language mode.
  AlwaysUseTailPadding,
  /// Only allocate objects in the tail padding of a base class if
  /// the base class is not POD according to the rules of C++ TR1.
  /// This is non-strictly conforming in C++11 mode.
  UseTailPaddingUnlessPOD03,
  /// Only allocate objects in the tail padding of a base class if
  /// the base class is not POD according to the rules of C++11.
  UseTailPaddingUnlessPOD11,
};

/// The basic abstraction for the target C++ ABI.
M_template_rtpack(Xs)
struct clang::TargetCXXABI::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TargetCXXABI;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TargetCXXABI::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using Kind = enum refldetail::clang::TargetCXXABI::Kind;
  constexpr enum clang::TargetCXXABI::Kind getKind() const IFMETA_ELSE( ({    return (enum clang::TargetCXXABI::Kind)__reflect_prop(reflenums::RK_clang__TargetCXXABI, reflenums::clang__TargetCXXABI::getKind, Xs...); }) , (;) )
  /// Does this ABI generally fall into the Itanium family of ABIs?
  constexpr bool isItaniumFamily() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetCXXABI, reflenums::clang__TargetCXXABI::isItaniumFamily, Xs...); }) , (;) )
  /// Is this ABI an MSVC-compatible ABI?
  constexpr bool isMicrosoft() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetCXXABI, reflenums::clang__TargetCXXABI::isMicrosoft, Xs...); }) , (;) )
  /// Are member functions differently aligned?
  ///
  /// Many Itanium-style C++ ABIs require member functions to be aligned, so
  /// that a pointer to such a function is guaranteed to have a zero in the
  /// least significant bit, so that pointers to member functions can use that
  /// bit to distinguish between virtual and non-virtual functions. However,
  /// some Itanium-style C++ ABIs differentiate between virtual and non-virtual
  /// functions via other means, and consequently don't require that member
  /// functions be aligned.
  constexpr bool areMemberFunctionsAligned() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetCXXABI, reflenums::clang__TargetCXXABI::areMemberFunctionsAligned, Xs...); }) , (;) )
  /// Are arguments to a call destroyed left to right in the callee?
  /// This is a fundamental language change, since it implies that objects
  /// passed by value do *not* live to the end of the full expression.
  /// Temporaries passed to a function taking a const reference live to the end
  /// of the full expression as usual.  Both the caller and the callee must
  /// have access to the destructor, while only the caller needs the
  /// destructor if this is false.
  constexpr bool areArgsDestroyedLeftToRightInCallee() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetCXXABI, reflenums::clang__TargetCXXABI::areArgsDestroyedLeftToRightInCallee, Xs...); }) , (;) )
  /// Does this ABI have different entrypoints for complete-object
  /// and base-subobject constructors?
  constexpr bool hasConstructorVariants() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetCXXABI, reflenums::clang__TargetCXXABI::hasConstructorVariants, Xs...); }) , (;) )
  /// Does this ABI allow virtual bases to be primary base classes?
  constexpr bool hasPrimaryVBases() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetCXXABI, reflenums::clang__TargetCXXABI::hasPrimaryVBases, Xs...); }) , (;) )
  /// Does this ABI use key functions?  If so, class data such as the
  /// vtable is emitted with strong linkage by the TU containing the key
  /// function.
  constexpr bool hasKeyFunctions() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetCXXABI, reflenums::clang__TargetCXXABI::hasKeyFunctions, Xs...); }) , (;) )
  /// Can an out-of-line inline function serve as a key function?
  ///
  /// This flag is only useful in ABIs where type data (for example,
  /// vtables and type_info objects) are emitted only after processing
  /// the definition of a special "key" virtual function.  (This is safe
  /// because the ODR requires that every virtual function be defined
  /// somewhere in a program.)  This usually permits such data to be
  /// emitted in only a single object file, as opposed to redundantly
  /// in every object file that requires it.
  ///
  /// One simple and common definition of "key function" is the first
  /// virtual function in the class definition which is not defined there.
  /// This rule works very well when that function has a non-inline
  /// definition in some non-header file.  Unfortunately, when that
  /// function is defined inline, this rule requires the type data
  /// to be emitted weakly, as if there were no key function.
  ///
  /// The ARM ABI observes that the ODR provides an additional guarantee:
  /// a virtual function is always ODR-used, so if it is defined inline,
  /// that definition must appear in every translation unit that defines
  /// the class.  Therefore, there is no reason to allow such functions
  /// to serve as key functions.
  ///
  /// Because this changes the rules for emitting type data,
  /// it can cause type data to be emitted with both weak and strong
  /// linkage, which is not allowed on all platforms.  Therefore,
  /// exploiting this observation requires an ABI break and cannot be
  /// done on a generic Itanium platform.
  constexpr bool canKeyFunctionBeInline() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetCXXABI, reflenums::clang__TargetCXXABI::canKeyFunctionBeInline, Xs...); }) , (;) )
  using TailPaddingUseRules = enum refldetail::clang::TargetCXXABI::TailPaddingUseRules;
  constexpr enum clang::TargetCXXABI::TailPaddingUseRules getTailPaddingUseRules() const IFMETA_ELSE( ({    return (enum clang::TargetCXXABI::TailPaddingUseRules)__reflect_prop(reflenums::RK_clang__TargetCXXABI, reflenums::clang__TargetCXXABI::getTailPaddingUseRules, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator==(IFMETA_ELSE((const clang::TargetCXXABI::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::TargetCXXABI &)) left, IFMETA_ELSE((const clang::TargetCXXABI::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::TargetCXXABI &)) right) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetCXXABI, reflenums::clang__TargetCXXABI::operator_eq_eq, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  friend constexpr bool operator!=(IFMETA_ELSE((const clang::TargetCXXABI::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::TargetCXXABI &)) left, IFMETA_ELSE((const clang::TargetCXXABI::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::TargetCXXABI &)) right) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetCXXABI, reflenums::clang__TargetCXXABI::operator_not_eq, Xs..., Y0s..., Y1s...); }) , (;) )
};

/// OpenCL supported extensions and optional core features
M_template_rtpack(Xs)
struct clang::OpenCLOptions::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OpenCLOptions;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OpenCLOptions::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isKnown(const char * Ext) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpenCLOptions, reflenums::clang__OpenCLOptions::isKnown, Xs..., Ext); }) , (;) )
  constexpr bool isEnabled(const char * Ext) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpenCLOptions, reflenums::clang__OpenCLOptions::isEnabled, Xs..., Ext); }) , (;) )
  constexpr bool isSupported(const char * Ext, unsigned int CLVer) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpenCLOptions, reflenums::clang__OpenCLOptions::isSupported, Xs..., Ext, CLVer); }) , (;) )
  constexpr bool isSupportedCore(const char * Ext, unsigned int CLVer) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpenCLOptions, reflenums::clang__OpenCLOptions::isSupportedCore, Xs..., Ext, CLVer); }) , (;) )
  constexpr bool isSupportedExtension(const char * Ext, unsigned int CLVer) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpenCLOptions, reflenums::clang__OpenCLOptions::isSupportedExtension, Xs..., Ext, CLVer); }) , (;) )
};

enum class llvm::EABI : int {
  Unknown,
  Default,
  EABI4,
  EABI5,
  GNU,
};

/// Options for controlling the target.
M_template_rtpack(Xs)
struct clang::TargetOptions::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TargetOptions;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TargetOptions::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// The EABI version to use
  enum llvm::EABI EABIVersion
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__TargetOptions, reflenums::clang__TargetOptions::EABIVersion, Xs...);), (;) )
  /// Supported OpenCL extensions and optional core features.
  M_REFLTYPED_FIELD(SupportedOpenCLOptions, (typename meta::clang::OpenCLOptions), __reflect_prop(reflenums::RK_clang__TargetOptions, reflenums::clang__TargetOptions::SupportedOpenCLOptions, Xs...))
  /// If given, enables support for __int128_t and __uint128_t types.
  bool ForceEnableInt128
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__TargetOptions, reflenums::clang__TargetOptions::ForceEnableInt128, Xs...);), (;) )
  /// \brief If enabled, use 32-bit pointers for accessing const/local/shared
  /// address space.
  bool NVPTXUseShortPointers
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__TargetOptions, reflenums::clang__TargetOptions::NVPTXUseShortPointers, Xs...);), (;) )
};

/// Definitions of all of the base types for the Type system.  Based on this
/// value, you can cast to a class defined in DerivedTypes.h.
/// Note: If you add an element to this, you need to add an element to the
/// Type::getPrimitiveType function, or else things will break!
/// Also update LLVMTypeKind and LLVMGetTypeKind () in the C binding.
///
enum llvm::Type::TypeID : unsigned int {
  ///<  0: type with no size
  VoidTyID = 0,
  ///<  1: 16-bit floating point type
  HalfTyID,
  ///<  2: 32-bit floating point type
  FloatTyID,
  ///<  3: 64-bit floating point type
  DoubleTyID,
  ///<  4: 80-bit floating point type (X87)
  X86_FP80TyID,
  ///<  5: 128-bit floating point type (112-bit mantissa)
  FP128TyID,
  ///<  6: 128-bit floating point type (two 64-bits, PowerPC)
  PPC_FP128TyID,
  ///<  7: Labels
  LabelTyID,
  ///<  8: Metadata
  MetadataTyID,
  ///<  9: MMX vectors (64 bits, X86 specific)
  X86_MMXTyID,
  ///< 10: Tokens
  TokenTyID,
  ///< 11: Arbitrary bit width integers
  IntegerTyID,
  ///< 12: Functions
  FunctionTyID,
  ///< 13: Structures
  StructTyID,
  ///< 14: Arrays
  ArrayTyID,
  ///< 15: Pointers
  PointerTyID,
  ///< 16: SIMD 'packed' format, or other vector type
  VectorTyID,
};

/// The instances of the Type class are immutable: once they are created,
/// they are never changed.  Also note that only one instance of a particular
/// type is ever created.  Thus seeing if two types are equal is a matter of
/// doing a trivial pointer comparison. To enforce that no two equal instances
/// are created, Type instances can only be created via static factory methods
/// in class Type and in derived classes.  Once allocated, Types are never
/// free'd.
///
M_template_rtpack(Xs)
struct llvm::Type::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__Type;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::Type::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using TypeID = enum refldetail::llvm::Type::TypeID;
  /// Print the current type.
  /// Omit the type details if \p NoDetails == true.
  /// E.g., let %st = type { i32, i16 }
  /// When \p NoDetails is true, we only print %st.
  /// Put differently, \p NoDetails prints the type as if
  /// inlined with the operands when printing an instruction.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void print(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) O, bool IsForDebug = false, bool NoDetails = false) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::print, Xs..., Y0s..., IsForDebug, NoDetails); }) , (;) )
  constexpr void dump() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::dump, Xs...); }) , (;) )
  /// Return the type id for the type. This will return one of the TypeID enum
  /// elements defined above.
  constexpr enum llvm::Type::TypeID getTypeID() const IFMETA_ELSE( ({    return (enum llvm::Type::TypeID)__reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getTypeID, Xs...); }) , (;) )
  /// Return true if this is 'void'.
  constexpr bool isVoidTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isVoidTy, Xs...); }) , (;) )
  /// Return true if this is 'half', a 16-bit IEEE fp type.
  constexpr bool isHalfTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isHalfTy, Xs...); }) , (;) )
  /// Return true if this is 'float', a 32-bit IEEE fp type.
  constexpr bool isFloatTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isFloatTy, Xs...); }) , (;) )
  /// Return true if this is 'double', a 64-bit IEEE fp type.
  constexpr bool isDoubleTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isDoubleTy, Xs...); }) , (;) )
  /// Return true if this is x86 long double.
  constexpr bool isX86_FP80Ty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isX86_FP80Ty, Xs...); }) , (;) )
  /// Return true if this is 'fp128'.
  constexpr bool isFP128Ty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isFP128Ty, Xs...); }) , (;) )
  /// Return true if this is powerpc long double.
  constexpr bool isPPC_FP128Ty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isPPC_FP128Ty, Xs...); }) , (;) )
  /// Return true if this is one of the six floating-point types
  constexpr bool isFloatingPointTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isFloatingPointTy, Xs...); }) , (;) )
  /// Return true if this is X86 MMX.
  constexpr bool isX86_MMXTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isX86_MMXTy, Xs...); }) , (;) )
  /// Return true if this is a FP type or a vector of FP.
  constexpr bool isFPOrFPVectorTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isFPOrFPVectorTy, Xs...); }) , (;) )
  /// Return true if this is 'label'.
  constexpr bool isLabelTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isLabelTy, Xs...); }) , (;) )
  /// Return true if this is 'metadata'.
  constexpr bool isMetadataTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isMetadataTy, Xs...); }) , (;) )
  /// Return true if this is 'token'.
  constexpr bool isTokenTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isTokenTy, Xs...); }) , (;) )
  /// True if this is an instance of IntegerType.
  constexpr bool isIntegerTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isIntegerTy, Xs...); }) , (;) )
  /// Return true if this is an IntegerType of the given width.
  constexpr bool isIntegerTy(unsigned int Bitwidth) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isIntegerTy1, Xs..., Bitwidth); }) , (;) )
  /// Return true if this is an integer type or a vector of integer types.
  constexpr bool isIntOrIntVectorTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isIntOrIntVectorTy, Xs...); }) , (;) )
  /// Return true if this is an integer type or a vector of integer types of
  /// the given width.
  constexpr bool isIntOrIntVectorTy(unsigned int BitWidth) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isIntOrIntVectorTy1, Xs..., BitWidth); }) , (;) )
  /// Return true if this is an integer type or a pointer type.
  constexpr bool isIntOrPtrTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isIntOrPtrTy, Xs...); }) , (;) )
  /// True if this is an instance of FunctionType.
  constexpr bool isFunctionTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isFunctionTy, Xs...); }) , (;) )
  /// True if this is an instance of StructType.
  constexpr bool isStructTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isStructTy, Xs...); }) , (;) )
  /// True if this is an instance of ArrayType.
  constexpr bool isArrayTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isArrayTy, Xs...); }) , (;) )
  /// True if this is an instance of PointerType.
  constexpr bool isPointerTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isPointerTy, Xs...); }) , (;) )
  /// Return true if this is a pointer type or a vector of pointer types.
  constexpr bool isPtrOrPtrVectorTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isPtrOrPtrVectorTy, Xs...); }) , (;) )
  /// True if this is an instance of VectorType.
  constexpr bool isVectorTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isVectorTy, Xs...); }) , (;) )
  /// Return true if this type could be converted with a lossless BitCast to
  /// type 'Ty'. For example, i8* to i32*. BitCasts are valid for types of the
  /// same size only where no re-interpretation of the bits is done.
  /// Determine if this type could be losslessly bitcast to Ty
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool canLosslesslyBitCastTo(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::canLosslesslyBitCastTo, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool canLosslesslyBitCastTo(ptrwrp<Y0> p0) const {
      return canLosslesslyBitCastTo(p0.get());
  }), () )
  /// Return true if this type is empty, that is, it has no elements or all of
  /// its elements are empty.
  constexpr bool isEmptyTy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isEmptyTy, Xs...); }) , (;) )
  /// Return true if the type is "first class", meaning it is a valid type for a
  /// Value.
  constexpr bool isFirstClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isFirstClassType, Xs...); }) , (;) )
  /// Return true if the type is a valid type for a register in codegen. This
  /// includes all first-class types except struct and array types.
  constexpr bool isSingleValueType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isSingleValueType, Xs...); }) , (;) )
  /// Return true if the type is an aggregate type. This means it is valid as
  /// the first operand of an insertvalue or extractvalue instruction. This
  /// includes struct and array types, but does not include vector types.
  constexpr bool isAggregateType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isAggregateType, Xs...); }) , (;) )
  /// Return the basic size of this type if it is a primitive type. These are
  /// fixed by LLVM and are not target-dependent.
  /// This will return zero if the type does not have a size or is not a
  /// primitive type.
  ///
  /// Note that this may not reflect the size of memory allocated for an
  /// instance of the type or the number of bytes that are written when an
  /// instance of the type is stored to memory. The DataLayout class provides
  /// additional query functions to provide this information.
  ///
  constexpr unsigned int getPrimitiveSizeInBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getPrimitiveSizeInBits, Xs...); }) , (;) )
  /// If this is a vector type, return the getPrimitiveSizeInBits value for the
  /// element type. Otherwise return the getPrimitiveSizeInBits value for this
  /// type.
  constexpr unsigned int getScalarSizeInBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getScalarSizeInBits, Xs...); }) , (;) )
  /// Return the width of the mantissa of this type. This is only valid on
  /// floating-point types. If the FP type does not have a stable mantissa (e.g.
  /// ppc long double), this method returns -1.
  constexpr int getFPMantissaWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getFPMantissaWidth, Xs...); }) , (;) )
  /// If this is a vector type, return the element type, otherwise return
  /// 'this'.
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getScalarType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getScalarType, Xs...); }) , (;) )
  RANGE_REFLECTION(llvm::Type, subtypes,
      constexpr auto subtypes() const ,
      (typename meta::llvm::Type *),
      (reflenums::RK_llvm__Type, reflenums::llvm__Type::subtypes, Xs...), () )
  /// This method is used to implement the type iterator (defined at the end of
  /// the file). For derived types, this returns the types 'contained' in the
  /// derived type.
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getContainedType(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getContainedType, Xs..., i); }) , (;) )
  /// Return the number of types in the derived type.
  constexpr unsigned int getNumContainedTypes() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getNumContainedTypes, Xs...); }) , (;) )
  constexpr unsigned int getIntegerBitWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getIntegerBitWidth, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getFunctionParamType(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getFunctionParamType, Xs..., i); }) , (;) )
  constexpr unsigned int getFunctionNumParams() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getFunctionNumParams, Xs...); }) , (;) )
  constexpr bool isFunctionVarArg() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::isFunctionVarArg, Xs...); }) , (;) )
  constexpr const char * getStructName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getStructName, Xs...); }) , (;) )
  constexpr unsigned int getStructNumElements() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getStructNumElements, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getStructElementType(unsigned int N) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getStructElementType, Xs..., N); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getSequentialElementType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getSequentialElementType, Xs...); }) , (;) )
  constexpr unsigned long long getArrayNumElements() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getArrayNumElements, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getArrayElementType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getArrayElementType, Xs...); }) , (;) )
  constexpr unsigned int getVectorNumElements() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getVectorNumElements, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getVectorElementType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getVectorElementType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getPointerElementType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getPointerElementType, Xs...); }) , (;) )
  /// Get the address space of this pointer or pointer vector type.
  constexpr unsigned int getPointerAddressSpace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getPointerAddressSpace, Xs...); }) , (;) )
  /// Return a pointer to the current type. This is equivalent to
  /// PointerType::get(Foo, AddrSpace).
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::PointerType *) )
  getPointerTo(unsigned int AddrSpace = 0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__Type, reflenums::llvm__Type::getPointerTo, Xs..., AddrSpace); }) , (;) )
};

/// Class to represent integer types. Note that this class is also used to
/// represent the built-in integer types: Int1Ty, Int8Ty, Int16Ty, Int32Ty and
/// Int64Ty.
/// Integer representation type
M_template_rtpack(Xs)
struct llvm::IntegerType::impl : impl_offset_t<llvm::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__IntegerType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::IntegerType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Get the number of bits in this IntegerType
  constexpr unsigned int getBitWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__IntegerType, reflenums::llvm__IntegerType::getBitWidth, Xs...); }) , (;) )
  /// Return a bitmask with ones set for all of the bits that can be set by an
  /// unsigned version of this type. This is 0xFF for i8, 0xFFFF for i16, etc.
  constexpr unsigned long long getBitMask() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__IntegerType, reflenums::llvm__IntegerType::getBitMask, Xs...); }) , (;) )
  /// Return a uint64_t with just the most significant bit set (the sign bit, if
  /// the value is treated as a signed number).
  constexpr unsigned long long getSignBit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__IntegerType, reflenums::llvm__IntegerType::getSignBit, Xs...); }) , (;) )
  /// This method determines if the width of this IntegerType is a power-of-2
  /// in terms of 8 bit bytes.
  /// @returns true if this is a power-of-2 byte width.
  /// Is this a power-of-2 byte-width IntegerType ?
  constexpr bool isPowerOf2ByteWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__IntegerType, reflenums::llvm__IntegerType::isPowerOf2ByteWidth, Xs...); }) , (;) )
  /// Methods for support type inquiry through isa, cast, and dyn_cast.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::llvm::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__IntegerType, reflenums::llvm__IntegerType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Common super class of ArrayType, StructType and VectorType.
M_template_rtpack(Xs)
struct llvm::CompositeType::impl : impl_offset_t<llvm::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__CompositeType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::CompositeType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getTypeAtIndex(unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__CompositeType, reflenums::llvm__CompositeType::getTypeAtIndex, Xs..., Idx); }) , (;) )
  constexpr bool indexValid(unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__CompositeType, reflenums::llvm__CompositeType::indexValid, Xs..., Idx); }) , (;) )
  /// Methods for support type inquiry through isa, cast, and dyn_cast.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::llvm::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__CompositeType, reflenums::llvm__CompositeType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Class to represent struct types. There are two different kinds of struct
/// types: Literal structs and Identified structs.
///
/// Literal struct types (e.g. { i32, i32 }) are uniqued structurally, and must
/// always have a body when created.  You can get one of these by using one of
/// the StructType::get() forms.
///
/// Identified structs (e.g. %foo or %42) may optionally have a name and are not
/// uniqued.  The names for identified structs are managed at the LLVMContext
/// level, so there can only be a single identified struct with a given name in
/// a particular LLVMContext.  Identified structs may also optionally be opaque
/// (have no body specified).  You get one of these by using one of the
/// StructType::create() forms.
///
/// Independent of what kind of struct you have, the body of a struct type are
/// laid out in memory consecutively with the elements directly one after the
/// other (if the struct is packed) or (if not packed) with padding between the
/// elements as defined by DataLayout (which is required to match what the code
/// generator for a target expects).
///
M_template_rtpack(Xs)
struct llvm::StructType::impl : impl_offset_t<llvm::CompositeType, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__StructType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::StructType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isPacked() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructType, reflenums::llvm__StructType::isPacked, Xs...); }) , (;) )
  /// Return true if this type is uniqued by structural equivalence, false if it
  /// is a struct definition.
  constexpr bool isLiteral() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructType, reflenums::llvm__StructType::isLiteral, Xs...); }) , (;) )
  /// Return true if this is a type with an identity that has no body specified
  /// yet. These prints as 'opaque' in .ll files.
  constexpr bool isOpaque() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructType, reflenums::llvm__StructType::isOpaque, Xs...); }) , (;) )
  /// Return true if this is a named struct that has a non-empty name.
  constexpr bool hasName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructType, reflenums::llvm__StructType::hasName, Xs...); }) , (;) )
  /// Return the name for this struct type if it has an identity.
  /// This may return an empty string for an unnamed struct type.  Do not call
  /// this on an literal type.
  constexpr const char * getName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructType, reflenums::llvm__StructType::getName, Xs...); }) , (;) )
  /// Return true if the specified type is valid as a element type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool isValidElementType(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) ElemTy) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructType, reflenums::llvm__StructType::isValidElementType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool isValidElementType(ptrwrp<Y0> p0) {
      return isValidElementType(p0.get());
  }), () )
  RANGE_REFLECTION(llvm::StructType, elements,
      constexpr auto elements() const ,
      (typename meta::llvm::Type *),
      (reflenums::RK_llvm__StructType, reflenums::llvm__StructType::elements, Xs...), () )
  /// Return true if this is layout identical to the specified struct.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isLayoutIdentical(IFMETA_ELSE((const llvm::StructType::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::StructType *)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructType, reflenums::llvm__StructType::isLayoutIdentical, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isLayoutIdentical(ptrwrp<Y0> p0) const {
      return isLayoutIdentical(p0.get());
  }), () )
  /// Random access to the elements
  constexpr unsigned int getNumElements() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructType, reflenums::llvm__StructType::getNumElements, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getElementType(unsigned int N) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructType, reflenums::llvm__StructType::getElementType, Xs..., N); }) , (;) )
  /// Methods for support type inquiry through isa, cast, and dyn_cast.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::llvm::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructType, reflenums::llvm__StructType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Class to represent pointers.
M_template_rtpack(Xs)
struct llvm::PointerType::impl : impl_offset_t<llvm::Type, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__PointerType;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::PointerType::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// This constructs a pointer to an object of the specified type in a numbered
  /// address space.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::llvm::PointerType *) )
  get(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) ElementType, unsigned int AddressSpace) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__PointerType, reflenums::llvm__PointerType::get, Xs..., Y0s..., AddressSpace); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr IFMETA_ELSE( (auto), (typename meta::llvm::PointerType *) )
  get(ptrwrp<Y0> p0, unsigned int p1) {
      return get(p0.get(), p1);
  }), () )
  /// This constructs a pointer to an object of the specified type in the
  /// generic address space (address space zero).
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::llvm::PointerType *) )
  getUnqual(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) ElementType) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__PointerType, reflenums::llvm__PointerType::getUnqual, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr IFMETA_ELSE( (auto), (typename meta::llvm::PointerType *) )
  getUnqual(ptrwrp<Y0> p0) {
      return getUnqual(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getElementType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__PointerType, reflenums::llvm__PointerType::getElementType, Xs...); }) , (;) )
  /// Return true if the specified type is valid as a element type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool isValidElementType(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) ElemTy) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__PointerType, reflenums::llvm__PointerType::isValidElementType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool isValidElementType(ptrwrp<Y0> p0) {
      return isValidElementType(p0.get());
  }), () )
  /// Return true if we can load or store from a pointer to this type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool isLoadableOrStorableType(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) ElemTy) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__PointerType, reflenums::llvm__PointerType::isLoadableOrStorableType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool isLoadableOrStorableType(ptrwrp<Y0> p0) {
      return isLoadableOrStorableType(p0.get());
  }), () )
  /// Return the address space of the Pointer type.
  constexpr unsigned int getAddressSpace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__PointerType, reflenums::llvm__PointerType::getAddressSpace, Xs...); }) , (;) )
  /// Implement support type inquiry through isa, cast, and dyn_cast.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::llvm::Type *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__PointerType, reflenums::llvm__PointerType::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A parsed version of the target data layout string in and methods for
/// querying it.
///
/// The target data layout string is specified *by the target* - a frontend
/// generating LLVM IR is required to generate the right target data for the
/// target being codegen'd to.
M_template_rtpack(Xs)
struct llvm::DataLayout::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__DataLayout;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::DataLayout::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const llvm::DataLayout::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::DataLayout &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const llvm::DataLayout::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::DataLayout &)) Other) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::operator_not_eq, Xs..., Y0s...); }) , (;) )
  /// Layout endianness...
  constexpr bool isLittleEndian() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::isLittleEndian, Xs...); }) , (;) )
  constexpr bool isBigEndian() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::isBigEndian, Xs...); }) , (;) )
  /// Test if the DataLayout was constructed from an empty string.
  constexpr bool isDefault() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::isDefault, Xs...); }) , (;) )
  /// Returns true if the specified type is known to be a native integer
  /// type supported by the CPU.
  ///
  /// For example, i64 is not native on most 32-bit CPUs and i37 is not native
  /// on any known one. This returns false if the integer width is not legal.
  ///
  /// The width is specified in bits.
  constexpr bool isLegalInteger(unsigned long long Width) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::isLegalInteger, Xs..., Width); }) , (;) )
  constexpr bool isIllegalInteger(unsigned long long Width) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::isIllegalInteger, Xs..., Width); }) , (;) )
  /// Returns true if the given alignment exceeds the natural stack alignment.
  constexpr bool exceedsNaturalStackAlignment(unsigned int Align) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::exceedsNaturalStackAlignment, Xs..., Align); }) , (;) )
  constexpr unsigned int getStackAlignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getStackAlignment, Xs...); }) , (;) )
  constexpr unsigned int getAllocaAddrSpace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getAllocaAddrSpace, Xs...); }) , (;) )
  constexpr unsigned int getProgramAddressSpace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getProgramAddressSpace, Xs...); }) , (;) )
  constexpr bool hasMicrosoftFastStdCallMangling() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::hasMicrosoftFastStdCallMangling, Xs...); }) , (;) )
  /// Returns true if symbols with leading question marks should not receive IR
  /// mangling. True for Windows mangling modes.
  constexpr bool doNotMangleLeadingQuestionMark() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::doNotMangleLeadingQuestionMark, Xs...); }) , (;) )
  constexpr bool hasLinkerPrivateGlobalPrefix() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::hasLinkerPrivateGlobalPrefix, Xs...); }) , (;) )
  constexpr const char * getLinkerPrivateGlobalPrefix() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getLinkerPrivateGlobalPrefix, Xs...); }) , (;) )
  constexpr char getGlobalPrefix() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getGlobalPrefix, Xs...); }) , (;) )
  constexpr const char * getPrivateGlobalPrefix() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getPrivateGlobalPrefix, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr const char * getManglingComponent(IFMETA_ELSE((const llvm::Triple::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::Triple &)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getManglingComponent, Xs..., Y0s...); }) , (;) )
  /// Returns true if the specified type fits in a native integer type
  /// supported by the CPU.
  ///
  /// For example, if the CPU only supports i32 as a native integer type, then
  /// i27 fits in a legal integer type but i45 does not.
  constexpr bool fitsInLegalInteger(unsigned int Width) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::fitsInLegalInteger, Xs..., Width); }) , (;) )
  /// Layout pointer alignment
  constexpr unsigned int getPointerABIAlignment(unsigned int AS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getPointerABIAlignment, Xs..., AS); }) , (;) )
  /// Return target's alignment for stack-based pointers
  /// FIXME: The defaults need to be removed once all of
  /// the backends/clients are updated.
  constexpr unsigned int getPointerPrefAlignment(unsigned int AS = 0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getPointerPrefAlignment, Xs..., AS); }) , (;) )
  /// Layout pointer size
  /// FIXME: The defaults need to be removed once all of
  /// the backends/clients are updated.
  constexpr unsigned int getPointerSize(unsigned int AS = 0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getPointerSize, Xs..., AS); }) , (;) )
  constexpr unsigned int getIndexSize(unsigned int AS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getIndexSize, Xs..., AS); }) , (;) )
  /// Return the address spaces containing non-integral pointers.  Pointers in
  /// this address space don't have a well-defined bitwise representation.
  RANGE_REFLECTION(llvm::DataLayout, getNonIntegralAddressSpaces,
      constexpr auto getNonIntegralAddressSpaces() const ,
      (unsigned int),
      (reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getNonIntegralAddressSpaces, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isNonIntegralPointerType(IFMETA_ELSE((const llvm::PointerType::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::PointerType *)) PT) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::isNonIntegralPointerType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isNonIntegralPointerType(ptrwrp<Y0> p0) const {
      return isNonIntegralPointerType(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isNonIntegralPointerType(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::isNonIntegralPointerType1, Xs..., Y0s...); }) , (;) )
  /// Layout pointer size, in bits
  /// FIXME: The defaults need to be removed once all of
  /// the backends/clients are updated.
  constexpr unsigned int getPointerSizeInBits(unsigned int AS = 0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getPointerSizeInBits, Xs..., AS); }) , (;) )
  /// Size in bits of index used for address calculation in getelementptr.
  constexpr unsigned int getIndexSizeInBits(unsigned int AS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getIndexSizeInBits, Xs..., AS); }) , (;) )
  /// Layout pointer size, in bits, based on the type.  If this function is
  /// called with a pointer type, then the type size of the pointer is returned.
  /// If this function is called with a vector of pointers, then the type size
  /// of the pointer is returned.  This should only be called with a pointer or
  /// vector of pointers.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getPointerTypeSizeInBits(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) p0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getPointerTypeSizeInBits, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int getPointerTypeSizeInBits(ptrwrp<Y0> p0) const {
      return getPointerTypeSizeInBits(p0.get());
  }), () )
  /// Layout size of the index used in GEP calculation.
  /// The function should be called with pointer or vector of pointers type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getIndexTypeSizeInBits(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getIndexTypeSizeInBits, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int getIndexTypeSizeInBits(ptrwrp<Y0> p0) const {
      return getIndexTypeSizeInBits(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getPointerTypeSize(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getPointerTypeSize, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int getPointerTypeSize(ptrwrp<Y0> p0) const {
      return getPointerTypeSize(p0.get());
  }), () )
  /// Returns the number of bits necessary to hold the specified type.
  ///
  /// For example, returns 36 for i36 and 80 for x86_fp80. The type passed must
  /// have a size (Type::isSized() must return true).
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned long long getTypeSizeInBits(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getTypeSizeInBits, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned long long getTypeSizeInBits(ptrwrp<Y0> p0) const {
      return getTypeSizeInBits(p0.get());
  }), () )
  /// Returns the maximum number of bytes that may be overwritten by
  /// storing the specified type.
  ///
  /// For example, returns 5 for i36 and 10 for x86_fp80.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned long long getTypeStoreSize(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getTypeStoreSize, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned long long getTypeStoreSize(ptrwrp<Y0> p0) const {
      return getTypeStoreSize(p0.get());
  }), () )
  /// Returns the maximum number of bits that may be overwritten by
  /// storing the specified type; always a multiple of 8.
  ///
  /// For example, returns 40 for i36 and 80 for x86_fp80.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned long long getTypeStoreSizeInBits(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getTypeStoreSizeInBits, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned long long getTypeStoreSizeInBits(ptrwrp<Y0> p0) const {
      return getTypeStoreSizeInBits(p0.get());
  }), () )
  /// Returns the offset in bytes between successive objects of the
  /// specified type, including alignment padding.
  ///
  /// This is the amount that alloca reserves for this type. For example,
  /// returns 12 or 16 for x86_fp80, depending on alignment.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned long long getTypeAllocSize(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getTypeAllocSize, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned long long getTypeAllocSize(ptrwrp<Y0> p0) const {
      return getTypeAllocSize(p0.get());
  }), () )
  /// Returns the offset in bits between successive objects of the
  /// specified type, including alignment padding; always a multiple of 8.
  ///
  /// This is the amount that alloca reserves for this type. For example,
  /// returns 96 or 128 for x86_fp80, depending on alignment.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned long long getTypeAllocSizeInBits(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getTypeAllocSizeInBits, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned long long getTypeAllocSizeInBits(ptrwrp<Y0> p0) const {
      return getTypeAllocSizeInBits(p0.get());
  }), () )
  /// Returns the minimum ABI-required alignment for the specified type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getABITypeAlignment(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getABITypeAlignment, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int getABITypeAlignment(ptrwrp<Y0> p0) const {
      return getABITypeAlignment(p0.get());
  }), () )
  /// Returns the minimum ABI-required alignment for an integer type of
  /// the specified bitwidth.
  constexpr unsigned int getABIIntegerTypeAlignment(unsigned int BitWidth) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getABIIntegerTypeAlignment, Xs..., BitWidth); }) , (;) )
  /// Returns the preferred stack/global alignment for the specified
  /// type.
  ///
  /// This is always at least as good as the ABI alignment.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getPrefTypeAlignment(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getPrefTypeAlignment, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int getPrefTypeAlignment(ptrwrp<Y0> p0) const {
      return getPrefTypeAlignment(p0.get());
  }), () )
  /// Returns the preferred alignment for the specified type, returned as
  /// log2 of the value (a shift amount).
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getPreferredTypeAlignmentShift(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getPreferredTypeAlignmentShift, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int getPreferredTypeAlignmentShift(ptrwrp<Y0> p0) const {
      return getPreferredTypeAlignmentShift(p0.get());
  }), () )
  /// Returns an integer (vector of integer) type with size at least as
  /// big as that of a pointer of the given pointer (vector of pointer) type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getIntPtrType(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) p0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getIntPtrType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getIntPtrType(ptrwrp<Y0> p0) const {
      return getIntPtrType(p0.get());
  }), () )
  /// Returns the size of largest legal integer type size, or 0 if none
  /// are set.
  constexpr unsigned int getLargestLegalIntTypeSizeInBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getLargestLegalIntTypeSizeInBits, Xs...); }) , (;) )
  /// Returns the type of a GEP index.
  /// If it was not specified explicitly, it will be the integer type of the
  /// pointer width - IntPtrType.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getIndexType(IFMETA_ELSE((const llvm::Type::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::Type *)) PtrTy) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getIndexType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::Type *) )
  getIndexType(ptrwrp<Y0> p0) const {
      return getIndexType(p0.get());
  }), () )
  /// Returns a StructLayout object, indicating the alignment of the
  /// struct, its size, and the offsets of its fields.
  ///
  /// Note that this information is lazily cached.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::StructLayout *) )
  getStructLayout(IFMETA_ELSE((const llvm::StructType::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::llvm::StructType *)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__DataLayout, reflenums::llvm__DataLayout::getStructLayout, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::StructLayout *) )
  getStructLayout(ptrwrp<Y0> p0) const {
      return getStructLayout(p0.get());
  }), () )
};

/// Used to lazily calculate structure layout information for a target machine,
/// based on the DataLayout structure.
M_template_rtpack(Xs)
struct llvm::StructLayout::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_llvm__StructLayout;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::llvm::StructLayout::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr unsigned long long getSizeInBytes() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructLayout, reflenums::llvm__StructLayout::getSizeInBytes, Xs...); }) , (;) )
  constexpr unsigned long long getSizeInBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructLayout, reflenums::llvm__StructLayout::getSizeInBits, Xs...); }) , (;) )
  constexpr unsigned int getAlignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructLayout, reflenums::llvm__StructLayout::getAlignment, Xs...); }) , (;) )
  /// Returns whether the struct has padding or not between its fields.
  /// NB: Padding in nested element is not taken into account.
  constexpr bool hasPadding() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructLayout, reflenums::llvm__StructLayout::hasPadding, Xs...); }) , (;) )
  /// Given a valid byte offset into the structure, returns the structure
  /// index that contains it.
  constexpr unsigned int getElementContainingOffset(unsigned long long Offset) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructLayout, reflenums::llvm__StructLayout::getElementContainingOffset, Xs..., Offset); }) , (;) )
  constexpr unsigned long long getElementOffset(unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructLayout, reflenums::llvm__StructLayout::getElementOffset, Xs..., Idx); }) , (;) )
  constexpr unsigned long long getElementOffsetInBits(unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_llvm__StructLayout, reflenums::llvm__StructLayout::getElementOffsetInBits, Xs..., Idx); }) , (;) )
};

///===---- Target Data Type Query Methods -------------------------------===//
enum clang::TargetInfo::IntType : unsigned int {
  NoInt = 0,
  SignedChar,
  UnsignedChar,
  SignedShort,
  UnsignedShort,
  SignedInt,
  UnsignedInt,
  SignedLong,
  UnsignedLong,
  SignedLongLong,
  UnsignedLongLong,
};

enum clang::TargetInfo::RealType : unsigned int {
  NoFloat = 255,
  Float = 0,
  Double,
  LongDouble,
  Float128,
};

/// The different kinds of __builtin_va_list types defined by
/// the target implementation.
enum clang::TargetInfo::BuiltinVaListKind : unsigned int {
  /// typedef char* __builtin_va_list;
  CharPtrBuiltinVaList = 0,
  /// typedef void* __builtin_va_list;
  VoidPtrBuiltinVaList,
  /// __builtin_va_list as defined by the AArch64 ABI
  /// http://infocenter.arm.com/help/topic/com.arm.doc.ihi0055a/IHI0055A_aapcs64.pdf
  AArch64ABIBuiltinVaList,
  /// __builtin_va_list as defined by the PNaCl ABI:
  /// http://www.chromium.org/nativeclient/pnacl/bitcode-abi#TOC-Machine-Types
  PNaClABIBuiltinVaList,
  /// __builtin_va_list as defined by the Power ABI:
  /// https://www.power.org
  ///        /resources/downloads/Power-Arch-32-bit-ABI-supp-1.0-Embedded.pdf
  PowerABIBuiltinVaList,
  /// __builtin_va_list as defined by the x86-64 ABI:
  /// http://refspecs.linuxbase.org/elf/x86_64-abi-0.21.pdf
  X86_64ABIBuiltinVaList,
  /// __builtin_va_list as defined by ARM AAPCS ABI
  /// http://infocenter.arm.com
  AAPCSABIBuiltinVaList,
  SystemZBuiltinVaList,
};

enum clang::TargetInfo::CallingConvMethodType : unsigned int {
  CCMT_Unknown,
  CCMT_Member,
  CCMT_NonMember,
};

enum clang::TargetInfo::CallingConvCheckResult : unsigned int {
  CCCR_OK,
  CCCR_Warning,
  CCCR_Ignore,
};

enum clang::TargetInfo::CallingConvKind : unsigned int {
  CCK_Default,
  CCK_ClangABI4OrPS4,
  CCK_MicrosoftWin64,
};

enum clang::TargetInfo::OpenCLTypeKind : unsigned int {
  OCLTK_Default,
  OCLTK_ClkEvent,
  OCLTK_Event,
  OCLTK_Image,
  OCLTK_Pipe,
  OCLTK_Queue,
  OCLTK_ReserveID,
  OCLTK_Sampler,
};

/// Exposes information about the current target.
///
M_template_rtpack(Xs)
struct clang::TargetInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TargetInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TargetInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr void Retain() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::Retain, Xs...); }) , (;) )
  constexpr void Release() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::Release, Xs...); }) , (;) )
  /// Retrieve the target options.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TargetOptions &) )
  getTargetOpts() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getTargetOpts, Xs...); }) , (;) )
  using IntType = enum refldetail::clang::TargetInfo::IntType;
  using RealType = enum refldetail::clang::TargetInfo::RealType;
  using BuiltinVaListKind = enum refldetail::clang::TargetInfo::BuiltinVaListKind;
  constexpr enum clang::TargetInfo::IntType getSizeType() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getSizeType, Xs...); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getSignedSizeType() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getSignedSizeType, Xs...); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getIntMaxType() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getIntMaxType, Xs...); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getUIntMaxType() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUIntMaxType, Xs...); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getPtrDiffType(unsigned int AddrSpace) const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getPtrDiffType, Xs..., AddrSpace); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getUnsignedPtrDiffType(unsigned int AddrSpace) const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUnsignedPtrDiffType, Xs..., AddrSpace); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getIntPtrType() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getIntPtrType, Xs...); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getUIntPtrType() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUIntPtrType, Xs...); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getWCharType() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getWCharType, Xs...); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getWIntType() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getWIntType, Xs...); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getChar16Type() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getChar16Type, Xs...); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getChar32Type() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getChar32Type, Xs...); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getInt64Type() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getInt64Type, Xs...); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getUInt64Type() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUInt64Type, Xs...); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getSigAtomicType() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getSigAtomicType, Xs...); }) , (;) )
  constexpr enum clang::TargetInfo::IntType getProcessIDType() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getProcessIDType, Xs...); }) , (;) )
  static constexpr enum clang::TargetInfo::IntType getCorrespondingUnsignedType(enum clang::TargetInfo::IntType T) IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getCorrespondingUnsignedType, Xs..., T); }) , (;) )
  /// Return the width (in bits) of the specified integer type enum.
  ///
  /// For example, SignedInt -> getIntWidth().
  constexpr unsigned int getTypeWidth(enum clang::TargetInfo::IntType T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getTypeWidth, Xs..., T); }) , (;) )
  /// Return integer type with specified width.
  constexpr enum clang::TargetInfo::IntType getIntTypeByWidth(unsigned int BitWidth, bool IsSigned) const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getIntTypeByWidth, Xs..., BitWidth, IsSigned); }) , (;) )
  /// Return the smallest integer type with at least the specified width.
  constexpr enum clang::TargetInfo::IntType getLeastIntTypeByWidth(unsigned int BitWidth, bool IsSigned) const IFMETA_ELSE( ({    return (enum clang::TargetInfo::IntType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLeastIntTypeByWidth, Xs..., BitWidth, IsSigned); }) , (;) )
  /// Return floating point type with specified width.
  constexpr enum clang::TargetInfo::RealType getRealTypeByWidth(unsigned int BitWidth) const IFMETA_ELSE( ({    return (enum clang::TargetInfo::RealType)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getRealTypeByWidth, Xs..., BitWidth); }) , (;) )
  /// Return the alignment (in bits) of the specified integer type enum.
  ///
  /// For example, SignedInt -> getIntAlign().
  constexpr unsigned int getTypeAlign(enum clang::TargetInfo::IntType T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getTypeAlign, Xs..., T); }) , (;) )
  /// Returns true if the type is signed; false otherwise.
  static constexpr bool isTypeSigned(enum clang::TargetInfo::IntType T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isTypeSigned, Xs..., T); }) , (;) )
  /// Return the width of pointers on this target, for the
  /// specified address space.
  constexpr unsigned long long getPointerWidth(unsigned int AddrSpace) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getPointerWidth, Xs..., AddrSpace); }) , (;) )
  constexpr unsigned long long getPointerAlign(unsigned int AddrSpace) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getPointerAlign, Xs..., AddrSpace); }) , (;) )
  /// Return the maximum width of pointers on this target.
  constexpr unsigned long long getMaxPointerWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getMaxPointerWidth, Xs...); }) , (;) )
  /// Get integer value for null pointer.
  /// \param AddrSpace address space of pointee in source language.
  constexpr unsigned long long getNullPointerValue(enum clang::LangAS AddrSpace) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getNullPointerValue, Xs..., AddrSpace); }) , (;) )
  /// Return the size of '_Bool' and C++ 'bool' for this target, in bits.
  constexpr unsigned int getBoolWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getBoolWidth, Xs...); }) , (;) )
  /// Return the alignment of '_Bool' and C++ 'bool' for this target.
  constexpr unsigned int getBoolAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getBoolAlign, Xs...); }) , (;) )
  constexpr unsigned int getCharWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getCharWidth, Xs...); }) , (;) )
  constexpr unsigned int getCharAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getCharAlign, Xs...); }) , (;) )
  /// Return the size of 'signed short' and 'unsigned short' for this
  /// target, in bits.
  constexpr unsigned int getShortWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getShortWidth, Xs...); }) , (;) )
  /// Return the alignment of 'signed short' and 'unsigned short' for
  /// this target.
  constexpr unsigned int getShortAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getShortAlign, Xs...); }) , (;) )
  /// getIntWidth/Align - Return the size of 'signed int' and 'unsigned int' for
  /// this target, in bits.
  constexpr unsigned int getIntWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getIntWidth, Xs...); }) , (;) )
  constexpr unsigned int getIntAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getIntAlign, Xs...); }) , (;) )
  /// getLongWidth/Align - Return the size of 'signed long' and 'unsigned long'
  /// for this target, in bits.
  constexpr unsigned int getLongWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLongWidth, Xs...); }) , (;) )
  constexpr unsigned int getLongAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLongAlign, Xs...); }) , (;) )
  /// getLongLongWidth/Align - Return the size of 'signed long long' and
  /// 'unsigned long long' for this target, in bits.
  constexpr unsigned int getLongLongWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLongLongWidth, Xs...); }) , (;) )
  constexpr unsigned int getLongLongAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLongLongAlign, Xs...); }) , (;) )
  /// getShortAccumWidth/Align - Return the size of 'signed short _Accum' and
  /// 'unsigned short _Accum' for this target, in bits.
  constexpr unsigned int getShortAccumWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getShortAccumWidth, Xs...); }) , (;) )
  constexpr unsigned int getShortAccumAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getShortAccumAlign, Xs...); }) , (;) )
  /// getAccumWidth/Align - Return the size of 'signed _Accum' and
  /// 'unsigned _Accum' for this target, in bits.
  constexpr unsigned int getAccumWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getAccumWidth, Xs...); }) , (;) )
  constexpr unsigned int getAccumAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getAccumAlign, Xs...); }) , (;) )
  /// getLongAccumWidth/Align - Return the size of 'signed long _Accum' and
  /// 'unsigned long _Accum' for this target, in bits.
  constexpr unsigned int getLongAccumWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLongAccumWidth, Xs...); }) , (;) )
  constexpr unsigned int getLongAccumAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLongAccumAlign, Xs...); }) , (;) )
  /// getShortFractWidth/Align - Return the size of 'signed short _Fract' and
  /// 'unsigned short _Fract' for this target, in bits.
  constexpr unsigned int getShortFractWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getShortFractWidth, Xs...); }) , (;) )
  constexpr unsigned int getShortFractAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getShortFractAlign, Xs...); }) , (;) )
  /// getFractWidth/Align - Return the size of 'signed _Fract' and
  /// 'unsigned _Fract' for this target, in bits.
  constexpr unsigned int getFractWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getFractWidth, Xs...); }) , (;) )
  constexpr unsigned int getFractAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getFractAlign, Xs...); }) , (;) )
  /// getLongFractWidth/Align - Return the size of 'signed long _Fract' and
  /// 'unsigned long _Fract' for this target, in bits.
  constexpr unsigned int getLongFractWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLongFractWidth, Xs...); }) , (;) )
  constexpr unsigned int getLongFractAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLongFractAlign, Xs...); }) , (;) )
  /// getShortAccumScale/IBits - Return the number of fractional/integral bits
  /// in a 'signed short _Accum' type.
  constexpr unsigned int getShortAccumScale() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getShortAccumScale, Xs...); }) , (;) )
  constexpr unsigned int getShortAccumIBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getShortAccumIBits, Xs...); }) , (;) )
  /// getAccumScale/IBits - Return the number of fractional/integral bits
  /// in a 'signed _Accum' type.
  constexpr unsigned int getAccumScale() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getAccumScale, Xs...); }) , (;) )
  constexpr unsigned int getAccumIBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getAccumIBits, Xs...); }) , (;) )
  /// getLongAccumScale/IBits - Return the number of fractional/integral bits
  /// in a 'signed long _Accum' type.
  constexpr unsigned int getLongAccumScale() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLongAccumScale, Xs...); }) , (;) )
  constexpr unsigned int getLongAccumIBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLongAccumIBits, Xs...); }) , (;) )
  /// getUnsignedShortAccumScale/IBits - Return the number of
  /// fractional/integral bits in a 'unsigned short _Accum' type.
  constexpr unsigned int getUnsignedShortAccumScale() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUnsignedShortAccumScale, Xs...); }) , (;) )
  constexpr unsigned int getUnsignedShortAccumIBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUnsignedShortAccumIBits, Xs...); }) , (;) )
  /// getUnsignedAccumScale/IBits - Return the number of fractional/integral
  /// bits in a 'unsigned _Accum' type.
  constexpr unsigned int getUnsignedAccumScale() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUnsignedAccumScale, Xs...); }) , (;) )
  constexpr unsigned int getUnsignedAccumIBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUnsignedAccumIBits, Xs...); }) , (;) )
  /// getUnsignedLongAccumScale/IBits - Return the number of fractional/integral
  /// bits in a 'unsigned long _Accum' type.
  constexpr unsigned int getUnsignedLongAccumScale() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUnsignedLongAccumScale, Xs...); }) , (;) )
  constexpr unsigned int getUnsignedLongAccumIBits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUnsignedLongAccumIBits, Xs...); }) , (;) )
  /// getShortFractScale - Return the number of fractional bits
  /// in a 'signed short _Fract' type.
  constexpr unsigned int getShortFractScale() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getShortFractScale, Xs...); }) , (;) )
  /// getFractScale - Return the number of fractional bits
  /// in a 'signed _Fract' type.
  constexpr unsigned int getFractScale() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getFractScale, Xs...); }) , (;) )
  /// getLongFractScale - Return the number of fractional bits
  /// in a 'signed long _Fract' type.
  constexpr unsigned int getLongFractScale() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLongFractScale, Xs...); }) , (;) )
  /// getUnsignedShortFractScale - Return the number of fractional bits
  /// in a 'unsigned short _Fract' type.
  constexpr unsigned int getUnsignedShortFractScale() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUnsignedShortFractScale, Xs...); }) , (;) )
  /// getUnsignedFractScale - Return the number of fractional bits
  /// in a 'unsigned _Fract' type.
  constexpr unsigned int getUnsignedFractScale() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUnsignedFractScale, Xs...); }) , (;) )
  /// getUnsignedLongFractScale - Return the number of fractional bits
  /// in a 'unsigned long _Fract' type.
  constexpr unsigned int getUnsignedLongFractScale() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUnsignedLongFractScale, Xs...); }) , (;) )
  /// Determine whether the __int128 type is supported on this target.
  constexpr bool hasInt128Type() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::hasInt128Type, Xs...); }) , (;) )
  /// Determine whether _Float16 is supported on this target.
  constexpr bool hasLegalHalfType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::hasLegalHalfType, Xs...); }) , (;) )
  /// Determine whether the __float128 type is supported on this target.
  constexpr bool hasFloat128Type() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::hasFloat128Type, Xs...); }) , (;) )
  /// Return the alignment that is suitable for storing any
  /// object with a fundamental alignment requirement.
  constexpr unsigned int getSuitableAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getSuitableAlign, Xs...); }) , (;) )
  /// Return the default alignment for __attribute__((aligned)) on
  /// this target, to be used if no alignment value is specified.
  constexpr unsigned int getDefaultAlignForAttributeAligned() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getDefaultAlignForAttributeAligned, Xs...); }) , (;) )
  /// getMinGlobalAlign - Return the minimum alignment of a global variable,
  /// unless its alignment is explicitly reduced via attributes.
  constexpr unsigned int getMinGlobalAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getMinGlobalAlign, Xs...); }) , (;) )
  /// Return the largest alignment for which a suitably-sized allocation with
  /// '::operator new(size_t)' is guaranteed to produce a correctly-aligned
  /// pointer.
  constexpr unsigned int getNewAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getNewAlign, Xs...); }) , (;) )
  /// getWCharWidth/Align - Return the size of 'wchar_t' for this target, in
  /// bits.
  constexpr unsigned int getWCharWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getWCharWidth, Xs...); }) , (;) )
  constexpr unsigned int getWCharAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getWCharAlign, Xs...); }) , (;) )
  /// getChar16Width/Align - Return the size of 'char16_t' for this target, in
  /// bits.
  constexpr unsigned int getChar16Width() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getChar16Width, Xs...); }) , (;) )
  constexpr unsigned int getChar16Align() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getChar16Align, Xs...); }) , (;) )
  /// getChar32Width/Align - Return the size of 'char32_t' for this target, in
  /// bits.
  constexpr unsigned int getChar32Width() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getChar32Width, Xs...); }) , (;) )
  constexpr unsigned int getChar32Align() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getChar32Align, Xs...); }) , (;) )
  /// getHalfWidth/Align/Format - Return the size/align/format of 'half'.
  constexpr unsigned int getHalfWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getHalfWidth, Xs...); }) , (;) )
  constexpr unsigned int getHalfAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getHalfAlign, Xs...); }) , (;) )
  /// getFloatWidth/Align/Format - Return the size/align/format of 'float'.
  constexpr unsigned int getFloatWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getFloatWidth, Xs...); }) , (;) )
  constexpr unsigned int getFloatAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getFloatAlign, Xs...); }) , (;) )
  /// getDoubleWidth/Align/Format - Return the size/align/format of 'double'.
  constexpr unsigned int getDoubleWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getDoubleWidth, Xs...); }) , (;) )
  constexpr unsigned int getDoubleAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getDoubleAlign, Xs...); }) , (;) )
  /// getLongDoubleWidth/Align/Format - Return the size/align/format of 'long
  /// double'.
  constexpr unsigned int getLongDoubleWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLongDoubleWidth, Xs...); }) , (;) )
  constexpr unsigned int getLongDoubleAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLongDoubleAlign, Xs...); }) , (;) )
  /// getFloat128Width/Align/Format - Return the size/align/format of
  /// '__float128'.
  constexpr unsigned int getFloat128Width() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getFloat128Width, Xs...); }) , (;) )
  constexpr unsigned int getFloat128Align() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getFloat128Align, Xs...); }) , (;) )
  /// Return true if the 'long double' type should be mangled like
  /// __float128.
  constexpr bool useFloat128ManglingForLongDouble() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::useFloat128ManglingForLongDouble, Xs...); }) , (;) )
  /// Return the value for the C99 FLT_EVAL_METHOD macro.
  constexpr unsigned int getFloatEvalMethod() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getFloatEvalMethod, Xs...); }) , (;) )
  constexpr unsigned int getLargeArrayMinWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLargeArrayMinWidth, Xs...); }) , (;) )
  constexpr unsigned int getLargeArrayAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getLargeArrayAlign, Xs...); }) , (;) )
  /// Return the maximum width lock-free atomic operation which will
  /// ever be supported for the given target
  constexpr unsigned int getMaxAtomicPromoteWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getMaxAtomicPromoteWidth, Xs...); }) , (;) )
  /// Return the maximum width lock-free atomic operation which can be
  /// inlined given the supported features of the given target.
  constexpr unsigned int getMaxAtomicInlineWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getMaxAtomicInlineWidth, Xs...); }) , (;) )
  /// Returns true if the given target supports lock-free atomic
  /// operations at the specified width and alignment.
  constexpr bool hasBuiltinAtomic(unsigned long long AtomicSizeInBits, unsigned long long AlignmentInBits) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::hasBuiltinAtomic, Xs..., AtomicSizeInBits, AlignmentInBits); }) , (;) )
  /// Return the maximum vector alignment supported for the given target.
  constexpr unsigned int getMaxVectorAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getMaxVectorAlign, Xs...); }) , (;) )
  /// Return default simd alignment for the given target. Generally, this
  /// value is type-specific, but this alignment can be used for most of the
  /// types for the given target.
  constexpr unsigned int getSimdDefaultAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getSimdDefaultAlign, Xs...); }) , (;) )
  /// Return the size of intmax_t and uintmax_t for this target, in bits.
  constexpr unsigned int getIntMaxTWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getIntMaxTWidth, Xs...); }) , (;) )
  constexpr unsigned int getUnwindWordWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getUnwindWordWidth, Xs...); }) , (;) )
  /// Return the "preferred" register width on this target.
  constexpr unsigned int getRegisterWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getRegisterWidth, Xs...); }) , (;) )
  /// Returns the name of the mcount instrumentation function.
  constexpr const char * getMCountName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getMCountName, Xs...); }) , (;) )
  /// Check if the Objective-C built-in boolean type should be signed
  /// char.
  ///
  /// Otherwise, if this returns false, the normal built-in boolean type
  /// should also be used for Objective-C.
  constexpr bool useSignedCharForObjCBool() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::useSignedCharForObjCBool, Xs...); }) , (;) )
  /// Check whether the alignment of bit-field types is respected
  /// when laying out structures.
  constexpr bool useBitFieldTypeAlignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::useBitFieldTypeAlignment, Xs...); }) , (;) )
  /// Check whether zero length bitfields should force alignment of
  /// the next member.
  constexpr bool useZeroLengthBitfieldAlignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::useZeroLengthBitfieldAlignment, Xs...); }) , (;) )
  /// Get the fixed alignment value in bits for a member that follows
  /// a zero length bitfield.
  constexpr unsigned int getZeroLengthBitfieldBoundary() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getZeroLengthBitfieldBoundary, Xs...); }) , (;) )
  constexpr bool useExplicitBitFieldAlignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::useExplicitBitFieldAlignment, Xs...); }) , (;) )
  /// Check whether this target support '\#pragma options align=mac68k'.
  constexpr bool hasAlignMac68kSupport() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::hasAlignMac68kSupport, Xs...); }) , (;) )
  /// Return the user string for the specified integer type enum.
  ///
  /// For example, SignedShort -> "short".
  static constexpr const char * getTypeName(enum clang::TargetInfo::IntType T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getTypeName, Xs..., T); }) , (;) )
  /// Return the constant suffix for the specified integer type enum.
  ///
  /// For example, SignedLong -> "L".
  constexpr const char * getTypeConstantSuffix(enum clang::TargetInfo::IntType T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getTypeConstantSuffix, Xs..., T); }) , (;) )
  /// Return the printf format modifier for the specified
  /// integer type enum.
  ///
  /// For example, SignedLong -> "l".
  static constexpr const char * getTypeFormatModifier(enum clang::TargetInfo::IntType T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getTypeFormatModifier, Xs..., T); }) , (;) )
  /// Check whether the given real type should use the "fpret" flavor of
  /// Objective-C message passing on this target.
  constexpr bool useObjCFPRetForRealType(enum clang::TargetInfo::RealType T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::useObjCFPRetForRealType, Xs..., T); }) , (;) )
  /// Check whether _Complex long double should use the "fp2ret" flavor
  /// of Objective-C message passing on this target.
  constexpr bool useObjCFP2RetForComplexLongDouble() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::useObjCFP2RetForComplexLongDouble, Xs...); }) , (;) )
  /// Check whether llvm intrinsics such as llvm.convert.to.fp16 should be used
  /// to convert to and from __fp16.
  /// FIXME: This function should be removed once all targets stop using the
  /// conversion intrinsics.
  constexpr bool useFP16ConversionIntrinsics() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::useFP16ConversionIntrinsics, Xs...); }) , (;) )
  /// Specify if mangling based on address space map should be used or
  /// not for language specific address spaces
  constexpr bool useAddressSpaceMapMangling() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::useAddressSpaceMapMangling, Xs...); }) , (;) )
  /// The __builtin_clz* and __builtin_ctz* built-in
  /// functions are specified to have undefined results for zero inputs, but
  /// on targets that support these operations in a way that provides
  /// well-defined results for zero without loss of performance, it is a good
  /// idea to avoid optimizing based on that undef behavior.
  constexpr bool isCLZForZeroUndef() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isCLZForZeroUndef, Xs...); }) , (;) )
  /// Returns the kind of __builtin_va_list type that should be used
  /// with this target.
  constexpr enum clang::TargetInfo::BuiltinVaListKind getBuiltinVaListKind() const IFMETA_ELSE( ({    return (enum clang::TargetInfo::BuiltinVaListKind)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getBuiltinVaListKind, Xs...); }) , (;) )
  /// Returns whether or not type \c __builtin_ms_va_list type is
  /// available on this target.
  constexpr bool hasBuiltinMSVaList() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::hasBuiltinMSVaList, Xs...); }) , (;) )
  /// Returns true for RenderScript.
  constexpr bool isRenderScriptTarget() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isRenderScriptTarget, Xs...); }) , (;) )
  /// Returns whether the passed in string is a valid clobber in an
  /// inline asm statement.
  ///
  /// This is used by Sema.
  constexpr bool isValidClobber(const char * Name) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isValidClobber, Xs..., Name); }) , (;) )
  /// Returns whether the passed in string is a valid register name
  /// according to GCC.
  ///
  /// This is used by Sema for inline asm statements.
  constexpr bool isValidGCCRegisterName(const char * Name) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isValidGCCRegisterName, Xs..., Name); }) , (;) )
  /// Returns the "normalized" GCC register name.
  ///
  /// ReturnCannonical true will return the register name without any additions
  /// such as "{}" or "%" in it's canonical form, for example:
  /// ReturnCanonical = true and Name = "rax", will return "ax".
  constexpr const char * getNormalizedGCCRegisterName(const char * Name, bool ReturnCanonical = false) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getNormalizedGCCRegisterName, Xs..., Name, ReturnCanonical); }) , (;) )
  /// Extracts a register from the passed constraint (if it is a
  /// single-register constraint) and the asm label expression related to a
  /// variable in the input or output list of an inline asm statement.
  ///
  /// This function is used by Sema in order to diagnose conflicts between
  /// the clobber list and the input/output lists.
  constexpr const char * getConstraintRegister(const char * Constraint, const char * Expression) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getConstraintRegister, Xs..., Constraint, Expression); }) , (;) )
  M_template_rtpack(Zs) using ConstraintInfo = struct refldetail::clang::TargetInfo::ConstraintInfo::M_template impl M_targpack(Zs);
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool validateOutputConstraint(IFMETA_ELSE((const clang::TargetInfo::ConstraintInfo::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::TargetInfo::ConstraintInfo &)) Info) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::validateOutputConstraint, Xs..., Y0s...); }) , (;) )
  constexpr bool validateOutputSize(const char * p0, unsigned int p1) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::validateOutputSize, Xs..., p0, p1); }) , (;) )
  constexpr bool validateInputSize(const char * p0, unsigned int p1) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::validateInputSize, Xs..., p0, p1); }) , (;) )
  /// Returns a string of target-specific clobbers, in LLVM format.
  constexpr const char * getClobbers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getClobbers, Xs...); }) , (;) )
  /// Returns true if NaN encoding is IEEE 754-2008.
  /// Only MIPS allows a different encoding.
  constexpr bool isNan2008() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isNan2008, Xs...); }) , (;) )
  /// Returns the target triple of the primary target.
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::Triple &) )
  getTriple() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getTriple, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::llvm::DataLayout &) )
  getDataLayout() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getDataLayout, Xs...); }) , (;) )
  /// Does this target support "protected" visibility?
  ///
  /// Any target which dynamic libraries will naturally support
  /// something like "default" (meaning that the symbol is visible
  /// outside this shared object) and "hidden" (meaning that it isn't)
  /// visibilities, but "protected" is really an ELF-specific concept
  /// with weird semantics designed around the convenience of dynamic
  /// linker implementations.  Which is not to suggest that there's
  /// consistent target-independent semantics for "default" visibility
  /// either; the entire thing is pretty badly mangled.
  constexpr bool hasProtectedVisibility() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::hasProtectedVisibility, Xs...); }) , (;) )
  /// An optional hook that targets can implement to perform semantic
  /// checking on attribute((section("foo"))) specifiers.
  ///
  /// In this case, "foo" is passed in to be checked.  If the section
  /// specifier is invalid, the backend should return a non-empty string
  /// that indicates the problem.
  ///
  /// This hook is a simple quality of implementation feature to catch errors
  /// and give good diagnostics in cases when the assembler or code generator
  /// would otherwise reject the section specifier.
  ///
  constexpr const char * isValidSectionSpecifier(const char * SR) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isValidSectionSpecifier, Xs..., SR); }) , (;) )
  /// Get the ABI currently in use.
  constexpr const char * getABI() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getABI, Xs...); }) , (;) )
  /// Get the C++ ABI currently in use.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TargetCXXABI) )
  getCXXABI() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getCXXABI, Xs...); }) , (;) )
  /// brief Determine whether this TargetInfo supports the given CPU name.
  constexpr bool isValidCPUName(const char * Name) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isValidCPUName, Xs..., Name); }) , (;) )
  /// Determine whether this TargetInfo supports the given feature.
  constexpr bool isValidFeatureName(const char * Feature) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isValidFeatureName, Xs..., Feature); }) , (;) )
  /// Determine whether the given target has the given feature.
  constexpr bool hasFeature(const char * Feature) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::hasFeature, Xs..., Feature); }) , (;) )
  /// Identify whether this taret supports multiversioning of functions,
  /// which requires support for cpu_supports and cpu_is functionality.
  constexpr bool supportsMultiVersioning() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::supportsMultiVersioning, Xs...); }) , (;) )
  constexpr bool validateCpuSupports(const char * Name) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::validateCpuSupports, Xs..., Name); }) , (;) )
  constexpr unsigned int multiVersionSortPriority(const char * Name) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::multiVersionSortPriority, Xs..., Name); }) , (;) )
  constexpr bool validateCpuIs(const char * Name) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::validateCpuIs, Xs..., Name); }) , (;) )
  constexpr bool validateCPUSpecificCPUDispatch(const char * Name) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::validateCPUSpecificCPUDispatch, Xs..., Name); }) , (;) )
  constexpr char CPUSpecificManglingCharacter(const char * Name) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::CPUSpecificManglingCharacter, Xs..., Name); }) , (;) )
  constexpr unsigned int getRegParmMax() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getRegParmMax, Xs...); }) , (;) )
  /// Whether the target supports thread-local storage.
  constexpr bool isTLSSupported() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isTLSSupported, Xs...); }) , (;) )
  /// Return the maximum alignment (in bits) of a TLS variable
  ///
  /// Gets the maximum alignment (in bits) of a TLS variable on this target.
  /// Returns zero if there is no such constraint.
  constexpr unsigned short getMaxTLSAlign() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getMaxTLSAlign, Xs...); }) , (;) )
  /// Whether target supports variable-length arrays.
  constexpr bool isVLASupported() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isVLASupported, Xs...); }) , (;) )
  /// Whether the target supports SEH __try.
  constexpr bool isSEHTrySupported() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isSEHTrySupported, Xs...); }) , (;) )
  /// Return true if {|} are normal characters in the asm string.
  ///
  /// If this returns false (the default), then {abc|xyz} is syntax
  /// that says that when compiling for asm variant #0, "abc" should be
  /// generated, but when compiling for asm variant #1, "xyz" should be
  /// generated.
  constexpr bool hasNoAsmVariants() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::hasNoAsmVariants, Xs...); }) , (;) )
  /// Return the register number that __builtin_eh_return_regno would
  /// return with the specified argument.
  /// This corresponds with TargetLowering's getExceptionPointerRegister
  /// and getExceptionSelectorRegister in the backend.
  constexpr int getEHDataRegisterNumber(unsigned int RegNo) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getEHDataRegisterNumber, Xs..., RegNo); }) , (;) )
  /// Return the section to use for C++ static initialization functions.
  constexpr const char * getStaticInitSectionSpecifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getStaticInitSectionSpecifier, Xs...); }) , (;) )
  /// Retrieve the name of the platform as it is used in the
  /// availability attribute.
  constexpr const char * getPlatformName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getPlatformName, Xs...); }) , (;) )
  /// Retrieve the minimum desired version of the platform, to
  /// which the program should be compiled.
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::VersionTuple) )
  getPlatformMinVersion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getPlatformMinVersion, Xs...); }) , (;) )
  constexpr bool isBigEndian() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isBigEndian, Xs...); }) , (;) )
  constexpr bool isLittleEndian() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::isLittleEndian, Xs...); }) , (;) )
  using CallingConvMethodType = enum refldetail::clang::TargetInfo::CallingConvMethodType;
  /// Gets the default calling convention for the given target and
  /// declaration context.
  constexpr enum clang::CallingConv getDefaultCallingConv(enum clang::TargetInfo::CallingConvMethodType MT) const IFMETA_ELSE( ({    return (enum clang::CallingConv)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getDefaultCallingConv, Xs..., MT); }) , (;) )
  using CallingConvCheckResult = enum refldetail::clang::TargetInfo::CallingConvCheckResult;
  /// Determines whether a given calling convention is valid for the
  /// target. A calling convention can either be accepted, produce a warning
  /// and be substituted with the default calling convention, or (someday)
  /// produce an error (such as using thiscall on a non-instance function).
  constexpr enum clang::TargetInfo::CallingConvCheckResult checkCallingConvention(enum clang::CallingConv CC) const IFMETA_ELSE( ({    return (enum clang::TargetInfo::CallingConvCheckResult)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::checkCallingConvention, Xs..., CC); }) , (;) )
  using CallingConvKind = enum refldetail::clang::TargetInfo::CallingConvKind;
  constexpr enum clang::TargetInfo::CallingConvKind getCallingConvKind(bool ClangABICompat4) const IFMETA_ELSE( ({    return (enum clang::TargetInfo::CallingConvKind)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getCallingConvKind, Xs..., ClangABICompat4); }) , (;) )
  /// Controls if __builtin_longjmp / __builtin_setjmp can be lowered to
  /// llvm.eh.sjlj.longjmp / llvm.eh.sjlj.setjmp.
  constexpr bool hasSjLjLowering() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::hasSjLjLowering, Xs...); }) , (;) )
  /// Check if the target supports CFProtection branch.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool checkCFProtectionBranchSupported(IFMETA_ELSE((const clang::DiagnosticsEngine::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::DiagnosticsEngine &)) Diags) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::checkCFProtectionBranchSupported, Xs..., Y0s...); }) , (;) )
  /// Check if the target supports CFProtection branch.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool checkCFProtectionReturnSupported(IFMETA_ELSE((const clang::DiagnosticsEngine::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::DiagnosticsEngine &)) Diags) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::checkCFProtectionReturnSupported, Xs..., Y0s...); }) , (;) )
  /// Whether target allows to overalign ABI-specified preferred alignment
  constexpr bool allowsLargerPreferedTypeAlignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::allowsLargerPreferedTypeAlignment, Xs...); }) , (;) )
  /// Get const supported OpenCL extensions and optional core features.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::OpenCLOptions &) )
  getSupportedOpenCLOpts() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getSupportedOpenCLOpts, Xs...); }) , (;) )
  using OpenCLTypeKind = enum refldetail::clang::TargetInfo::OpenCLTypeKind;
  /// Get address space for OpenCL type.
  constexpr enum clang::LangAS getOpenCLTypeAddrSpace(enum clang::TargetInfo::OpenCLTypeKind TK) const IFMETA_ELSE( ({    return (enum clang::LangAS)__reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getOpenCLTypeAddrSpace, Xs..., TK); }) , (;) )
  /// \returns Target specific vtbl ptr address space.
  constexpr unsigned int getVtblPtrAddressSpace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::getVtblPtrAddressSpace, Xs...); }) , (;) )
  /// Check the target is valid after it is fully initialized.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool validateTarget(IFMETA_ELSE((const clang::DiagnosticsEngine::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::DiagnosticsEngine &)) Diags) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo, reflenums::clang__TargetInfo::validateTarget, Xs..., Y0s...); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::TargetInfo::ConstraintInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TargetInfo__ConstraintInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TargetInfo::ConstraintInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  unsigned int Flags
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__TargetInfo__ConstraintInfo, reflenums::clang__TargetInfo__ConstraintInfo::Flags, Xs...);), (;) )
  int TiedOperand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__TargetInfo__ConstraintInfo, reflenums::clang__TargetInfo__ConstraintInfo::TiedOperand, Xs...);), (;) )
  constexpr bool isReadWrite() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo__ConstraintInfo, reflenums::clang__TargetInfo__ConstraintInfo::isReadWrite, Xs...); }) , (;) )
  constexpr bool allowsRegister() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo__ConstraintInfo, reflenums::clang__TargetInfo__ConstraintInfo::allowsRegister, Xs...); }) , (;) )
  constexpr bool allowsMemory() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo__ConstraintInfo, reflenums::clang__TargetInfo__ConstraintInfo::allowsMemory, Xs...); }) , (;) )
  /// Return true if this output operand has a matching
    /// (tied) input operand.
  constexpr bool hasMatchingInput() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo__ConstraintInfo, reflenums::clang__TargetInfo__ConstraintInfo::hasMatchingInput, Xs...); }) , (;) )
  /// Return true if this input operand is a matching
    /// constraint that ties it to an output operand.
    ///
    /// If this returns true then getTiedOperand will indicate which output
    /// operand this is tied to.
  constexpr bool hasTiedOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo__ConstraintInfo, reflenums::clang__TargetInfo__ConstraintInfo::hasTiedOperand, Xs...); }) , (;) )
  constexpr unsigned int getTiedOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo__ConstraintInfo, reflenums::clang__TargetInfo__ConstraintInfo::getTiedOperand, Xs...); }) , (;) )
  constexpr bool requiresImmediateConstant() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo__ConstraintInfo, reflenums::clang__TargetInfo__ConstraintInfo::requiresImmediateConstant, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isValidAsmImmediate(IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::llvm::APInt &)) Value) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TargetInfo__ConstraintInfo, reflenums::clang__TargetInfo__ConstraintInfo::isValidAsmImmediate, Xs..., Y0s...); }) , (;) )
};

enum class clang::XRayFunctionFilter::ImbueAttribute : int {
  NONE,
  ALWAYS,
  NEVER,
  ALWAYS_ARG1,
};

M_template_rtpack(Xs)
struct clang::XRayFunctionFilter::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__XRayFunctionFilter;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::XRayFunctionFilter::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using ImbueAttribute = enum refldetail::clang::XRayFunctionFilter::ImbueAttribute;
  constexpr enum clang::XRayFunctionFilter::ImbueAttribute shouldImbueFunction(const char * FunctionName) const IFMETA_ELSE( ({    return (enum clang::XRayFunctionFilter::ImbueAttribute)__reflect_prop(reflenums::RK_clang__XRayFunctionFilter, reflenums::clang__XRayFunctionFilter::shouldImbueFunction, Xs..., FunctionName); }) , (;) )
  constexpr enum clang::XRayFunctionFilter::ImbueAttribute shouldImbueFunctionsInFile(const char * Filename, const char * Category = 0) const IFMETA_ELSE( ({    return (enum clang::XRayFunctionFilter::ImbueAttribute)__reflect_prop(reflenums::RK_clang__XRayFunctionFilter, reflenums::clang__XRayFunctionFilter::shouldImbueFunctionsInFile, Xs..., Filename, Category); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum clang::XRayFunctionFilter::ImbueAttribute shouldImbueLocation(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc, const char * Category = 0) const IFMETA_ELSE( ({    return (enum clang::XRayFunctionFilter::ImbueAttribute)__reflect_prop(reflenums::RK_clang__XRayFunctionFilter, reflenums::clang__XRayFunctionFilter::shouldImbueLocation, Xs..., Y0s..., Category); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::TypeInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypeInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypeInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  unsigned long long Width
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__TypeInfo, reflenums::clang__TypeInfo::Width, Xs...);), (;) )
  unsigned int Align
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__TypeInfo, reflenums::clang__TypeInfo::Align, Xs...);), (;) )
  bool AlignIsRequired
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__TypeInfo, reflenums::clang__TypeInfo::AlignIsRequired, Xs...);), (;) )
};

enum class clang::ASTContext::InlineVariableDefinitionKind : int {
  /// Not an inline variable.
  None,
  /// Weak definition of inline variable.
  Weak,
  /// Weak for now, might become strong later in this TU.
  WeakUnknown,
  /// Strong definition.
  Strong,
};

/// Holds long-lived AST nodes (such as types and decls) that can be
/// referred to throughout the semantic analysis of a file.
M_template_rtpack(Xs)
struct clang::ASTContext::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ASTContext;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ASTContext::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr void Retain() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::Retain, Xs...); }) , (;) )
  constexpr void Release() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::Release, Xs...); }) , (;) )
  M_REFLTYPED_FIELD(Idents, (typename meta::clang::IdentifierTable &), __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::Idents, Xs...))
  M_REFLTYPED_FIELD(Selectors, (typename meta::clang::SelectorTable &), __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::Selectors, Xs...))
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::PrintingPolicy &) )
  getPrintingPolicy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getPrintingPolicy, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::SourceManager &) )
  getSourceManager() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getSourceManager, Xs...); }) , (;) )
  constexpr void * Allocate(unsigned long Size, unsigned int Align = 8) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::Allocate, Xs..., Size, Align); }) , (;) )
  constexpr void Deallocate(void * Ptr) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::Deallocate, Xs..., Ptr); }) , (;) )
  /// Return the total amount of physical memory allocated for representing
  /// AST nodes and type information.
  constexpr unsigned long getASTAllocatedMemory() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getASTAllocatedMemory, Xs...); }) , (;) )
  /// Return the total memory used for various side tables.
  constexpr unsigned long getSideTableAllocatedMemory() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getSideTableAllocatedMemory, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TargetInfo &) )
  getTargetInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTargetInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TargetInfo *) )
  getAuxTargetInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAuxTargetInfo, Xs...); }) , (;) )
  /// getIntTypeForBitwidth -
  /// sets integer QualTy according to specified details:
  /// bitwidth, signed/unsigned.
  /// Returns empty type if there is no appropriate target types.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getIntTypeForBitwidth(unsigned int DestWidth, unsigned int Signed) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getIntTypeForBitwidth, Xs..., DestWidth, Signed); }) , (;) )
  /// getRealTypeForBitwidth -
  /// sets floating point QualTy according to specified bitwidth.
  /// Returns empty type if there is no appropriate target types.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getRealTypeForBitwidth(unsigned int DestWidth) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getRealTypeForBitwidth, Xs..., DestWidth); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool AtomicUsesUnsupportedLibcall(IFMETA_ELSE((const clang::AtomicExpr::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::AtomicExpr *)) E) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::AtomicUsesUnsupportedLibcall, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool AtomicUsesUnsupportedLibcall(ptrwrp<Y0> p0) const {
      return AtomicUsesUnsupportedLibcall(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::LangOptions &) )
  getLangOpts() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getLangOpts, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::SanitizerBlacklist &) )
  getSanitizerBlacklist() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getSanitizerBlacklist, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::XRayFunctionFilter &) )
  getXRayFilter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getXRayFilter, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DiagnosticsEngine &) )
  getDiagnostics() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDiagnostics, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FullSourceLoc) )
  getFullLoc(IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SourceLocation)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getFullLoc, Xs..., Y0s...); }) , (;) )
  /// True if comments are already loaded from ExternalASTSource.
  bool CommentsLoaded
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::CommentsLoaded, Xs...);), (;) )
  /// Return the documentation comment attached to a given declaration,
  /// without looking into cache.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::RawComment *) )
  getRawCommentForDeclNoCache(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getRawCommentForDeclNoCache, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::RawComment *) )
  getRawCommentForDeclNoCache(ptrwrp<Y0> p0) const {
      return getRawCommentForDeclNoCache(p0.get());
  }), () )
  /// Return the documentation comment attached to a given declaration.
  /// Returns nullptr if no comment is attached.
  ///
  /// \param OriginalDecl if not nullptr, is set to declaration AST node that
  /// had the comment, if the comment we found comes from a redeclaration.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::RawComment *) )
  getRawCommentForAnyRedecl(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D, IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y1s...> * *), (const typename meta::clang::Decl **)) OriginalDecl = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getRawCommentForAnyRedecl, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::RawComment *) )
  getRawCommentForAnyRedecl(ptrwrp<Y0> p0, ptrwrp<Y1> p1 = {}) const {
      return getRawCommentForAnyRedecl(p0.get(), p1.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::comments::CommandTraits &) )
  getCommentCommandTraits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getCommentCommandTraits, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int overridden_methods_size(IFMETA_ELSE((const clang::CXXMethodDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::CXXMethodDecl *)) Method) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::overridden_methods_size, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int overridden_methods_size(ptrwrp<Y0> p0) const {
      return overridden_methods_size(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImportDecl *) )
  getNextLocalImport(IFMETA_ELSE((const clang::ImportDecl::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::ImportDecl *)) Import) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getNextLocalImport, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImportDecl *) )
  getNextLocalImport(ptrwrp<Y0> p0) {
      return getNextLocalImport(p0.get());
  }), () )
  RANGE_REFLECTION(clang::ASTContext, local_imports,
      constexpr auto local_imports() const ,
      (typename meta::clang::ImportDecl *),
      (reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::local_imports, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TranslationUnitDecl *) )
  getTranslationUnitDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTranslationUnitDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ExternCContextDecl *) )
  getExternCContextDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getExternCContextDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::BuiltinTemplateDecl *) )
  getMakeIntegerSeqDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getMakeIntegerSeqDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::BuiltinTemplateDecl *) )
  getTypePackElementDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypePackElementDecl, Xs...); }) , (;) )
  M_REFLTYPED_FIELD(AutoDeductTy, (typename meta::clang::QualType), __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::AutoDeductTy, Xs...))
  M_REFLTYPED_FIELD(AutoRRefDeductTy, (typename meta::clang::QualType), __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::AutoRRefDeductTy, Xs...))
  M_REFLTYPED_FIELD(VaListTagDecl, (typename meta::clang::Decl *), __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::VaListTagDecl, Xs...))
  /// Retrieve a pointer to the external AST source associated
  /// with this AST context, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ExternalASTSource *) )
  getExternalSource() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getExternalSource, Xs...); }) , (;) )
  constexpr void PrintStats() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::PrintStats, Xs...); }) , (;) )
  /// Retrieve the declaration for the 128-bit signed integer type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefDecl *) )
  getInt128Decl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getInt128Decl, Xs...); }) , (;) )
  /// Retrieve the declaration for the 128-bit unsigned integer type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefDecl *) )
  getUInt128Decl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getUInt128Decl, Xs...); }) , (;) )
  /// Return the uniqued reference to the type for an address space
  /// qualified type with the specified type and address space.
  ///
  /// The resulting type has a union of the qualifiers from T and the address
  /// space. If T already has an address space specifier, it is silently
  /// replaced.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAddrSpaceQualType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T, enum clang::LangAS AddressSpace) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAddrSpaceQualType, Xs..., Y0s..., AddressSpace); }) , (;) )
  /// Remove any existing address space on the type and returns the type
  /// with qualifiers intact (or that's the idea anyway)
  ///
  /// The return type should be T with all prior qualifiers minus the address
  /// space.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  removeAddrSpaceQualType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::removeAddrSpaceQualType, Xs..., Y0s...); }) , (;) )
  /// Return the uniqued reference to the type for an Objective-C
  /// gc-qualified type.
  ///
  /// The resulting type has a union of the qualifiers from T and the gc
  /// attribute.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCGCQualType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T, enum clang::Qualifiers::GC gcAttr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCGCQualType, Xs..., Y0s..., gcAttr); }) , (;) )
  /// Return the uniqued reference to the type for a \c restrict
  /// qualified type.
  ///
  /// The resulting type has a union of the qualifiers from \p T and
  /// \c restrict.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getRestrictType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getRestrictType, Xs..., Y0s...); }) , (;) )
  /// Return the uniqued reference to the type for a \c volatile
  /// qualified type.
  ///
  /// The resulting type has a union of the qualifiers from \p T and
  /// \c volatile.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getVolatileType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getVolatileType, Xs..., Y0s...); }) , (;) )
  /// Return the uniqued reference to the type for a \c const
  /// qualified type.
  ///
  /// The resulting type has a union of the qualifiers from \p T and \c const.
  ///
  /// It can be reasonably expected that this will always be equivalent to
  /// calling T.withConst().
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getConstType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getConstType, Xs..., Y0s...); }) , (;) )
  /// Return the uniqued reference to the type for a complex
  /// number with the specified element type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getComplexType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getComplexType, Xs..., Y0s...); }) , (;) )
  /// Return the uniqued reference to the type for a pointer to
  /// the specified type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPointerType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getPointerType, Xs..., Y0s...); }) , (;) )
  /// Return the uniqued reference to a type adjusted from the original
  /// type to a new type.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAdjustedType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Orig, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) New) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAdjustedType, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Return the uniqued reference to the decayed version of the given
  /// type.  Can only be called on array and function types which decay to
  /// pointer types.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDecayedType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDecayedType, Xs..., Y0s...); }) , (;) )
  /// Return the uniqued reference to the atomic type for the specified
  /// type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAtomicType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAtomicType, Xs..., Y0s...); }) , (;) )
  /// Return the uniqued reference to the type for a block of the
  /// specified type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBlockPointerType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getBlockPointerType, Xs..., Y0s...); }) , (;) )
  /// Gets the struct used to keep track of the descriptor for pointer to
  /// blocks.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBlockDescriptorType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getBlockDescriptorType, Xs...); }) , (;) )
  /// Return a read_only pipe type for the specified type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getReadPipeType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getReadPipeType, Xs..., Y0s...); }) , (;) )
  /// Return a write_only pipe type for the specified type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getWritePipeType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getWritePipeType, Xs..., Y0s...); }) , (;) )
  /// Gets the struct used to keep track of the extended descriptor for
  /// pointer to blocks.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBlockDescriptorExtendedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getBlockDescriptorExtendedType, Xs...); }) , (;) )
  /// Map an AST Type to an OpenCLTypeKind enum value.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum clang::TargetInfo::OpenCLTypeKind getOpenCLTypeKind(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) const IFMETA_ELSE( ({    return (enum clang::TargetInfo::OpenCLTypeKind)__reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getOpenCLTypeKind, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr enum clang::TargetInfo::OpenCLTypeKind getOpenCLTypeKind(ptrwrp<Y0> p0) const {
      return getOpenCLTypeKind(p0.get());
  }), () )
  /// Get address space for OpenCL type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum clang::LangAS getOpenCLTypeAddrSpace(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) const IFMETA_ELSE( ({    return (enum clang::LangAS)__reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getOpenCLTypeAddrSpace, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr enum clang::LangAS getOpenCLTypeAddrSpace(ptrwrp<Y0> p0) const {
      return getOpenCLTypeAddrSpace(p0.get());
  }), () )
  /// Return the uniqued reference to the type for an lvalue reference
  /// to the specified type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getLValueReferenceType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T, bool SpelledAsLValue = true) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getLValueReferenceType, Xs..., Y0s..., SpelledAsLValue); }) , (;) )
  /// Return the uniqued reference to the type for an rvalue reference
  /// to the specified type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getRValueReferenceType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getRValueReferenceType, Xs..., Y0s...); }) , (;) )
  /// Return the uniqued reference to the type for a member pointer to
  /// the specified type in the specified class.
  ///
  /// The class \p Cls is a \c Type because it could be a dependent name.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getMemberPointerType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::Type *)) Cls) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getMemberPointerType, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getMemberPointerType(Y0 p0, ptrwrp<Y1> p1) const {
      return getMemberPointerType(p0, p1.get());
  }), () )
  /// Return a non-unique reference to the type for a variable array of
  /// the specified element type.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getVariableArrayType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) EltTy, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::Expr *)) NumElts, enum clang::ArrayType::ArraySizeModifier ASM, unsigned int IndexTypeQuals, IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceRange)) Brackets) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getVariableArrayType, Xs..., Y0s..., Y1s..., ASM, IndexTypeQuals, Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getVariableArrayType(Y0 p0, ptrwrp<Y1> p1, enum clang::ArrayType::ArraySizeModifier p2, unsigned int p3, Y2 p4) const {
      return getVariableArrayType(p0, p1.get(), p2, p3, p4);
  }), () )
  /// Return a non-unique reference to the type for a dependently-sized
  /// array of the specified element type.
  ///
  /// FIXME: We will need these to be uniqued, or at least comparable, at some
  /// point.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDependentSizedArrayType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) EltTy, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::Expr *)) NumElts, enum clang::ArrayType::ArraySizeModifier ASM, unsigned int IndexTypeQuals, IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceRange)) Brackets) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDependentSizedArrayType, Xs..., Y0s..., Y1s..., ASM, IndexTypeQuals, Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDependentSizedArrayType(Y0 p0, ptrwrp<Y1> p1, enum clang::ArrayType::ArraySizeModifier p2, unsigned int p3, Y2 p4) const {
      return getDependentSizedArrayType(p0, p1.get(), p2, p3, p4);
  }), () )
  /// Return a unique reference to the type for an incomplete array of
  /// the specified element type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getIncompleteArrayType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) EltTy, enum clang::ArrayType::ArraySizeModifier ASM, unsigned int IndexTypeQuals) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getIncompleteArrayType, Xs..., Y0s..., ASM, IndexTypeQuals); }) , (;) )
  /// Return the unique reference to the type for a constant array of
  /// the specified element type.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getConstantArrayType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) EltTy, IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::APInt &)) ArySize, enum clang::ArrayType::ArraySizeModifier ASM, unsigned int IndexTypeQuals) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getConstantArrayType, Xs..., Y0s..., Y1s..., ASM, IndexTypeQuals); }) , (;) )
  /// Returns a vla type where known sizes are replaced with [*].
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getVariableArrayDecayedType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getVariableArrayDecayedType, Xs..., Y0s...); }) , (;) )
  /// Return the unique reference to a vector type of the specified
  /// element type and size.
  ///
  /// \pre \p VectorType must be a built-in type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getVectorType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) VectorType, unsigned int NumElts, enum clang::VectorType::VectorKind VecKind) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getVectorType, Xs..., Y0s..., NumElts, VecKind); }) , (;) )
  /// Return the unique reference to the type for a dependently sized vector of
  /// the specified element type.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDependentVectorType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) VectorType, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::Expr *)) SizeExpr, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) AttrLoc, enum clang::VectorType::VectorKind VecKind) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDependentVectorType, Xs..., Y0s..., Y1s..., Y2s..., VecKind); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDependentVectorType(Y0 p0, ptrwrp<Y1> p1, Y2 p2, enum clang::VectorType::VectorKind p3) const {
      return getDependentVectorType(p0, p1.get(), p2, p3);
  }), () )
  /// Return the unique reference to an extended vector type
  /// of the specified element type and size.
  ///
  /// \pre \p VectorType must be a built-in type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getExtVectorType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) VectorType, unsigned int NumElts) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getExtVectorType, Xs..., Y0s..., NumElts); }) , (;) )
  /// \pre Return a non-unique reference to the type for a dependently-sized
  /// vector of the specified element type.
  ///
  /// FIXME: We will need these to be uniqued, or at least comparable, at some
  /// point.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDependentSizedExtVectorType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) VectorType, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::Expr *)) SizeExpr, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) AttrLoc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDependentSizedExtVectorType, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDependentSizedExtVectorType(Y0 p0, ptrwrp<Y1> p1, Y2 p2) const {
      return getDependentSizedExtVectorType(p0, p1.get(), p2);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDependentAddressSpaceType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) PointeeType, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::Expr *)) AddrSpaceExpr, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) AttrLoc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDependentAddressSpaceType, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDependentAddressSpaceType(Y0 p0, ptrwrp<Y1> p1, Y2 p2) const {
      return getDependentAddressSpaceType(p0, p1.get(), p2);
  }), () )
  /// Return a K&R style C function type like 'int()'.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getFunctionNoProtoType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) ResultTy, IFMETA_ELSE((const clang::FunctionType::ExtInfo::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::FunctionType::ExtInfo &)) Info) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getFunctionNoProtoType, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getFunctionNoProtoType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) ResultTy) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getFunctionNoProtoType1, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  adjustStringLiteralBaseType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) StrLTy) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::adjustStringLiteralBaseType, Xs..., Y0s...); }) , (;) )
  /// Return the unique reference to the type for the specified type
  /// declaration.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTypeDeclType(IFMETA_ELSE((const clang::TypeDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::TypeDecl *)) Decl, IFMETA_ELSE((const clang::TypeDecl::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::TypeDecl *)) PrevDecl = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeDeclType, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTypeDeclType(ptrwrp<Y0> p0, ptrwrp<Y1> p1 = {}) const {
      return getTypeDeclType(p0.get(), p1.get());
  }), () )
  /// Return the unique reference to the type for the specified
  /// typedef-name decl.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTypedefType(IFMETA_ELSE((const clang::TypedefNameDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::TypedefNameDecl *)) Decl, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) Canon = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypedefType, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTypedefType(ptrwrp<Y0> p0, Y1 p1 = {}) const {
      return getTypedefType(p0.get(), p1);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getRecordType(IFMETA_ELSE((const clang::RecordDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::RecordDecl *)) Decl) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getRecordType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getRecordType(ptrwrp<Y0> p0) const {
      return getRecordType(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getEnumType(IFMETA_ELSE((const clang::EnumDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::EnumDecl *)) Decl) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getEnumType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getEnumType(ptrwrp<Y0> p0) const {
      return getEnumType(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getInjectedClassNameType(IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::CXXRecordDecl *)) Decl, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) TST) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getInjectedClassNameType, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getInjectedClassNameType(ptrwrp<Y0> p0, Y1 p1) const {
      return getInjectedClassNameType(p0.get(), p1);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getSubstTemplateTypeParmType(IFMETA_ELSE((const clang::TemplateTypeParmType::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::TemplateTypeParmType *)) Replaced, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) Replacement) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getSubstTemplateTypeParmType, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getSubstTemplateTypeParmType(ptrwrp<Y0> p0, Y1 p1) const {
      return getSubstTemplateTypeParmType(p0.get(), p1);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTemplateTypeParmType(unsigned int Depth, unsigned int Index, bool ParameterPack, IFMETA_ELSE((const clang::TemplateTypeParmDecl::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::TemplateTypeParmDecl *)) ParmDecl = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTemplateTypeParmType, Xs..., Depth, Index, ParameterPack, Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTemplateTypeParmType(unsigned int p0, unsigned int p1, bool p2, ptrwrp<Y0> p3 = {}) const {
      return getTemplateTypeParmType(p0, p1, p2, p3.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTemplateSpecializationType(IFMETA_ELSE((const clang::TemplateName::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::TemplateName)) T, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::TemplateArgumentListInfo &)) Args, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) Canon = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTemplateSpecializationType, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTemplateSpecializationTypeInfo(IFMETA_ELSE((const clang::TemplateName::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::TemplateName)) T, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) TLoc, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y2s...>), (const typename meta::clang::TemplateArgumentListInfo &)) Args, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::QualType)) Canon = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTemplateSpecializationTypeInfo, Xs..., Y0s..., Y1s..., Y2s..., Y3s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getParenType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) NamedType) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getParenType, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getElaboratedType(enum clang::ElaboratedTypeKeyword Keyword, IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::NestedNameSpecifier *)) NNS, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) NamedType, IFMETA_ELSE((const clang::TagDecl::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::TagDecl *)) OwnedTagDecl = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getElaboratedType, Xs..., Keyword, Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getElaboratedType(enum clang::ElaboratedTypeKeyword p0, ptrwrp<Y0> p1, Y1 p2, ptrwrp<Y2> p3 = {}) const {
      return getElaboratedType(p0, p1.get(), p2, p3.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDependentNameType(enum clang::ElaboratedTypeKeyword Keyword, IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::NestedNameSpecifier *)) NNS, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::IdentifierInfo *)) Name, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) Canon = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDependentNameType, Xs..., Keyword, Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDependentNameType(enum clang::ElaboratedTypeKeyword p0, ptrwrp<Y0> p1, ptrwrp<Y1> p2, Y2 p3 = {}) const {
      return getDependentNameType(p0, p1.get(), p2.get(), p3);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDependentTemplateSpecializationType(enum clang::ElaboratedTypeKeyword Keyword, IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::NestedNameSpecifier *)) NNS, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::IdentifierInfo *)) Name, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y2s...>), (const typename meta::clang::TemplateArgumentListInfo &)) Args) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDependentTemplateSpecializationType, Xs..., Keyword, Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDependentTemplateSpecializationType(enum clang::ElaboratedTypeKeyword p0, ptrwrp<Y0> p1, ptrwrp<Y1> p2, Y2 p3) const {
      return getDependentTemplateSpecializationType(p0, p1.get(), p2.get(), p3);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCInterfaceType(IFMETA_ELSE((const clang::ObjCInterfaceDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ObjCInterfaceDecl *)) Decl, IFMETA_ELSE((const clang::ObjCInterfaceDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::ObjCInterfaceDecl *)) PrevDecl = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCInterfaceType, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCInterfaceType(ptrwrp<Y0> p0, ptrwrp<Y1> p1 = {}) const {
      return getObjCInterfaceType(p0.get(), p1.get());
  }), () )
  /// Legacy interface: cannot provide type arguments or __kindof.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCObjectType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Base, IFMETA_ELSE((const clang::ObjCProtocolDecl::template impl</*ptrorref=*/1, Y1s...> * * const), (typename meta::clang::ObjCProtocolDecl *const *)) Protocols, unsigned int NumProtocols) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCObjectType, Xs..., Y0s..., Y1s..., NumProtocols); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCObjectType(Y0 p0, ptrwrp<Y1> p1, unsigned int p2) const {
      return getObjCObjectType(p0, p1.get(), p2);
  }), () )
  /// Return a ObjCObjectPointerType type for the given ObjCObjectType.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCObjectPointerType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) OIT) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCObjectPointerType, Xs..., Y0s...); }) , (;) )
  /// GCC extension.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTypeOfExprType(IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::Expr *)) e) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeOfExprType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTypeOfExprType(ptrwrp<Y0> p0) const {
      return getTypeOfExprType(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTypeOfType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) t) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeOfType, Xs..., Y0s...); }) , (;) )
  /// C++11 decltype.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDecltypeType(IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::Expr *)) e, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) UnderlyingType) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDecltypeType, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDecltypeType(ptrwrp<Y0> p0, Y1 p1) const {
      return getDecltypeType(p0.get(), p1);
  }), () )
  /// \brief Reflected type.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getReflectedType(IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::Expr *)) e, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) UnderlyingType) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getReflectedType, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getReflectedType(ptrwrp<Y0> p0, Y1 p1) const {
      return getReflectedType(p0.get(), p1);
  }), () )
  /// Unary type transforms
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getUnaryTransformType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) BaseType, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) UnderlyingType, enum clang::UnaryTransformType::UTTKind UKind) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getUnaryTransformType, Xs..., Y0s..., Y1s..., UKind); }) , (;) )
  /// C++11 deduced auto type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAutoType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) DeducedType, enum clang::AutoTypeKeyword Keyword, bool IsDependent) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAutoType, Xs..., Y0s..., Keyword, IsDependent); }) , (;) )
  /// C++11 deduction pattern for 'auto' type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAutoDeductType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAutoDeductType, Xs...); }) , (;) )
  /// C++11 deduction pattern for 'auto &&' type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAutoRRefDeductType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAutoRRefDeductType, Xs...); }) , (;) )
  /// C++17 deduced class template specialization type.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDeducedTemplateSpecializationType(IFMETA_ELSE((const clang::TemplateName::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::TemplateName)) Template, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) DeducedType, bool IsDependent) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDeducedTemplateSpecializationType, Xs..., Y0s..., Y1s..., IsDependent); }) , (;) )
  /// Return the unique reference to the type for the specified TagDecl
  /// (struct/union/class/enum) decl.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTagDeclType(IFMETA_ELSE((const clang::TagDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::TagDecl *)) Decl) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTagDeclType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTagDeclType(ptrwrp<Y0> p0) const {
      return getTagDeclType(p0.get());
  }), () )
  /// Return the unique wchar_t type available in C++ (and available as
  /// __wchar_t as a Microsoft extension).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getWCharType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getWCharType, Xs...); }) , (;) )
  /// Return the type of wide characters. In C++, this returns the
  /// unique wchar_t type. In C99, this returns a type compatible with the type
  /// defined in <stddef.h> as defined by the target.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getWideCharType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getWideCharType, Xs...); }) , (;) )
  /// Return the type of "signed wchar_t".
  ///
  /// Used when in C++, as a GCC extension.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getSignedWCharType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getSignedWCharType, Xs...); }) , (;) )
  /// Return the type of "unsigned wchar_t".
  ///
  /// Used when in C++, as a GCC extension.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getUnsignedWCharType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getUnsignedWCharType, Xs...); }) , (;) )
  /// In C99, this returns a type compatible with the type
  /// defined in <stddef.h> as defined by the target.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getWIntType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getWIntType, Xs...); }) , (;) )
  /// Return a type compatible with "intptr_t" (C99 7.18.1.4),
  /// as defined by the target.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getIntPtrType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getIntPtrType, Xs...); }) , (;) )
  /// Return a type compatible with "uintptr_t" (C99 7.18.1.4),
  /// as defined by the target.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getUIntPtrType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getUIntPtrType, Xs...); }) , (;) )
  /// Return the unique type for "ptrdiff_t" (C99 7.17) defined in
  /// <stddef.h>. Pointer - pointer requires this (C99 6.5.6p9).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPointerDiffType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getPointerDiffType, Xs...); }) , (;) )
  /// Return the unique unsigned counterpart of "ptrdiff_t"
  /// integer type. The standard (C11 7.21.6.1p7) refers to this type
  /// in the definition of %tu format specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getUnsignedPointerDiffType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getUnsignedPointerDiffType, Xs...); }) , (;) )
  /// Return the unique type for "pid_t" defined in
  /// <sys/types.h>. We need this to compute the correct type for vfork().
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getProcessIDType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getProcessIDType, Xs...); }) , (;) )
  /// Return the C structure type used to represent constant CFStrings.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getCFConstantStringType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getCFConstantStringType, Xs...); }) , (;) )
  /// Returns the C struct type for objc_super
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCSuperType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCSuperType, Xs...); }) , (;) )
  /// Get the structure type used to representation CFStrings, or NULL
  /// if it hasn't yet been built.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getRawCFConstantStringType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getRawCFConstantStringType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefDecl *) )
  getCFConstantStringDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getCFConstantStringDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::RecordDecl *) )
  getCFConstantStringTagDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getCFConstantStringTagDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCConstantStringInterface() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCConstantStringInterface, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCNSStringType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCNSStringType, Xs...); }) , (;) )
  /// Retrieve the type that \c id has been defined to, which may be
  /// different from the built-in \c id if \c id has been typedef'd.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCIdRedefinitionType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCIdRedefinitionType, Xs...); }) , (;) )
  /// Retrieve the type that \c Class has been defined to, which may be
  /// different from the built-in \c Class if \c Class has been typedef'd.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCClassRedefinitionType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCClassRedefinitionType, Xs...); }) , (;) )
  /// Retrieve the type that 'SEL' has been defined to, which may be
  /// different from the built-in 'SEL' if 'SEL' has been typedef'd.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCSelRedefinitionType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCSelRedefinitionType, Xs...); }) , (;) )
  /// Retrieve the identifier 'bool'.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getBoolName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getBoolName, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getMakeIntegerSeqName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getMakeIntegerSeqName, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getTypePackElementName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypePackElementName, Xs...); }) , (;) )
  /// Retrieve the C FILE type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getFILEType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getFILEType, Xs...); }) , (;) )
  /// Retrieve the C jmp_buf type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getjmp_bufType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getjmp_bufType, Xs...); }) , (;) )
  /// Retrieve the C sigjmp_buf type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getsigjmp_bufType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getsigjmp_bufType, Xs...); }) , (;) )
  /// Retrieve the C ucontext_t type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getucontext_tType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getucontext_tType, Xs...); }) , (;) )
  /// The result type of logical operations, '<', '>', '!=', etc.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getLogicalOperationType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getLogicalOperationType, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void getLegacyIntegralTypeEncoding(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::QualType &)) t) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getLegacyIntegralTypeEncoding, Xs..., Y0s...); }) , (;) )
  /// Emit the encoded type for the function \p Decl into \p S.
  ///
  /// This is in the same format as Objective-C method encodings.
  ///
  /// \returns true if an error occurred (e.g., because one of the parameter
  /// types is incomplete), false otherwise.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * getObjCEncodingForFunctionDecl(IFMETA_ELSE((const clang::FunctionDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::FunctionDecl *)) Decl) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCEncodingForFunctionDecl, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr const char * getObjCEncodingForFunctionDecl(ptrwrp<Y0> p0) const {
      return getObjCEncodingForFunctionDecl(p0.get());
  }), () )
  /// Emit the encoded type for the method declaration \p Decl into
  /// \p S.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * getObjCEncodingForMethodDecl(IFMETA_ELSE((const clang::ObjCMethodDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ObjCMethodDecl *)) Decl, bool Extended = false) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCEncodingForMethodDecl, Xs..., Y0s..., Extended); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr const char * getObjCEncodingForMethodDecl(ptrwrp<Y0> p0, bool p1 = false) const {
      return getObjCEncodingForMethodDecl(p0.get(), p1);
  }), () )
  /// Return the encoded type for this block declaration.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr const char * getObjCEncodingForBlock(IFMETA_ELSE((const clang::BlockExpr::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::BlockExpr *)) blockExpr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCEncodingForBlock, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr const char * getObjCEncodingForBlock(ptrwrp<Y0> p0) const {
      return getObjCEncodingForBlock(p0.get());
  }), () )
  /// getObjCEncodingForPropertyDecl - Return the encoded type for
  /// this method declaration. If non-NULL, Container must be either
  /// an ObjCCategoryImplDecl or ObjCImplementationDecl; it should
  /// only be NULL when getting encodings for protocol properties.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr const char * getObjCEncodingForPropertyDecl(IFMETA_ELSE((const clang::ObjCPropertyDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ObjCPropertyDecl *)) PD, IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::Decl *)) Container) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCEncodingForPropertyDecl, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr const char * getObjCEncodingForPropertyDecl(ptrwrp<Y0> p0, ptrwrp<Y1> p1) const {
      return getObjCEncodingForPropertyDecl(p0.get(), p1.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool ProtocolCompatibleWithProtocol(IFMETA_ELSE((const clang::ObjCProtocolDecl::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::ObjCProtocolDecl *)) lProto, IFMETA_ELSE((const clang::ObjCProtocolDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::ObjCProtocolDecl *)) rProto) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::ProtocolCompatibleWithProtocol, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr bool ProtocolCompatibleWithProtocol(ptrwrp<Y0> p0, ptrwrp<Y1> p1) const {
      return ProtocolCompatibleWithProtocol(p0.get(), p1.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyImplDecl *) )
  getObjCPropertyImplDeclForPropertyDecl(IFMETA_ELSE((const clang::ObjCPropertyDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ObjCPropertyDecl *)) PD, IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::Decl *)) Container) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCPropertyImplDeclForPropertyDecl, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyImplDecl *) )
  getObjCPropertyImplDeclForPropertyDecl(ptrwrp<Y0> p0, ptrwrp<Y1> p1) const {
      return getObjCPropertyImplDeclForPropertyDecl(p0.get(), p1.get());
  }), () )
  /// Return the size of type \p T for Objective-C encoding purpose,
  /// in characters.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getObjCEncodingTypeSize(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCEncodingTypeSize, Xs..., Y0s...); }) , (;) )
  /// Retrieve the typedef corresponding to the predefined \c id type
  /// in Objective-C.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefDecl *) )
  getObjCIdDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCIdDecl, Xs...); }) , (;) )
  /// Represents the Objective-CC \c id type.
  ///
  /// This is set up lazily, by Sema.  \c id is always a (typedef for a)
  /// pointer type, a pointer to a struct.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCIdType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCIdType, Xs...); }) , (;) )
  /// Retrieve the typedef corresponding to the predefined 'SEL' type
  /// in Objective-C.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefDecl *) )
  getObjCSelDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCSelDecl, Xs...); }) , (;) )
  /// Retrieve the type that corresponds to the predefined Objective-C
  /// 'SEL' type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCSelType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCSelType, Xs...); }) , (;) )
  /// Retrieve the typedef declaration corresponding to the predefined
  /// Objective-C 'Class' type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefDecl *) )
  getObjCClassDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCClassDecl, Xs...); }) , (;) )
  /// Represents the Objective-C \c Class type.
  ///
  /// This is set up lazily, by Sema.  \c Class is always a (typedef for a)
  /// pointer type, a pointer to a struct.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCClassType, Xs...); }) , (;) )
  /// Retrieve the Objective-C class declaration corresponding to
  /// the predefined \c Protocol class.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCInterfaceDecl *) )
  getObjCProtocolDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCProtocolDecl, Xs...); }) , (;) )
  /// Retrieve declaration of 'BOOL' typedef
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefDecl *) )
  getBOOLDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getBOOLDecl, Xs...); }) , (;) )
  /// type of 'BOOL' type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBOOLType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getBOOLType, Xs...); }) , (;) )
  /// Retrieve the type of the Objective-C \c Protocol class.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getObjCProtoType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCProtoType, Xs...); }) , (;) )
  /// Retrieve the C type declaration corresponding to the predefined
  /// \c __builtin_va_list type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefDecl *) )
  getBuiltinVaListDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getBuiltinVaListDecl, Xs...); }) , (;) )
  /// Retrieve the type of the \c __builtin_va_list type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBuiltinVaListType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getBuiltinVaListType, Xs...); }) , (;) )
  /// Retrieve the C type declaration corresponding to the predefined
  /// \c __va_list_tag type used to help define the \c __builtin_va_list type
  /// for some targets.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Decl *) )
  getVaListTagDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getVaListTagDecl, Xs...); }) , (;) )
  /// Retrieve the C type declaration corresponding to the predefined
  /// \c __builtin_ms_va_list type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypedefDecl *) )
  getBuiltinMSVaListDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getBuiltinMSVaListDecl, Xs...); }) , (;) )
  /// Retrieve the type of the \c __builtin_ms_va_list type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBuiltinMSVaListType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getBuiltinMSVaListType, Xs...); }) , (;) )
  /// Return whether a declaration to a builtin is allowed to be
  /// overloaded/redeclared.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool canBuiltinBeRedeclared(IFMETA_ELSE((const clang::FunctionDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::FunctionDecl *)) p0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::canBuiltinBeRedeclared, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool canBuiltinBeRedeclared(ptrwrp<Y0> p0) const {
      return canBuiltinBeRedeclared(p0.get());
  }), () )
  /// Return a type with additional \c const, \c volatile, or
  /// \c restrict qualifiers.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getCVRQualifiedType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T, unsigned int CVR) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getCVRQualifiedType, Xs..., Y0s..., CVR); }) , (;) )
  /// Un-split a SplitQualType.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getQualifiedType(IFMETA_ELSE((const clang::SplitQualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::SplitQualType)) split) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getQualifiedType, Xs..., Y0s...); }) , (;) )
  /// Return a type with additional qualifiers.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getQualifiedType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Qualifiers)) Qs) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getQualifiedType1, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Return a type with additional qualifiers.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getQualifiedType(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T, IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Qualifiers)) Qs) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getQualifiedType2, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getQualifiedType(ptrwrp<Y0> p0, Y1 p1) const {
      return getQualifiedType(p0.get(), p1);
  }), () )
  /// getUnqualifiedObjCPointerType - Returns version of
  /// Objective-C pointer type with lifetime qualifier removed.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getUnqualifiedObjCPointerType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) type) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getUnqualifiedObjCPointerType, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned char getFixedPointScale(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getFixedPointScale, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned char getFixedPointIBits(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getFixedPointIBits, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationNameInfo) )
  getNameForTemplate(IFMETA_ELSE((const clang::TemplateName::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::TemplateName)) Name, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) NameLoc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getNameForTemplate, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getOverloadedTemplateName(IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::UnresolvedSetIterator)) Begin, IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::UnresolvedSetIterator)) End) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getOverloadedTemplateName, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getQualifiedTemplateName(IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::NestedNameSpecifier *)) NNS, bool TemplateKeyword, IFMETA_ELSE((const clang::TemplateDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::TemplateDecl *)) Template) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getQualifiedTemplateName, Xs..., Y0s..., TemplateKeyword, Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getQualifiedTemplateName(ptrwrp<Y0> p0, bool p1, ptrwrp<Y1> p2) const {
      return getQualifiedTemplateName(p0.get(), p1, p2.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getDependentTemplateName(IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::NestedNameSpecifier *)) NNS, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::IdentifierInfo *)) Name) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDependentTemplateName, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getDependentTemplateName(ptrwrp<Y0> p0, ptrwrp<Y1> p1) const {
      return getDependentTemplateName(p0.get(), p1.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getDependentTemplateName(IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::NestedNameSpecifier *)) NNS, enum clang::OverloadedOperatorKind Operator) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDependentTemplateName1, Xs..., Y0s..., Operator); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getDependentTemplateName(ptrwrp<Y0> p0, enum clang::OverloadedOperatorKind p1) const {
      return getDependentTemplateName(p0.get(), p1);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getSubstTemplateTemplateParm(IFMETA_ELSE((const clang::TemplateTemplateParmDecl::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::TemplateTemplateParmDecl *)) param, IFMETA_ELSE((const clang::TemplateName::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::TemplateName)) replacement) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getSubstTemplateTemplateParm, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getSubstTemplateTemplateParm(ptrwrp<Y0> p0, Y1 p1) const {
      return getSubstTemplateTemplateParm(p0.get(), p1);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getSubstTemplateTemplateParmPack(IFMETA_ELSE((const clang::TemplateTemplateParmDecl::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::TemplateTemplateParmDecl *)) Param, IFMETA_ELSE((const clang::TemplateArgument::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::TemplateArgument &)) ArgPack) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getSubstTemplateTemplateParmPack, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getSubstTemplateTemplateParmPack(ptrwrp<Y0> p0, Y1 p1) const {
      return getSubstTemplateTemplateParmPack(p0.get(), p1);
  }), () )
  /// Return one of the GCNone, Weak or Strong Objective-C garbage
  /// collection attributes.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum clang::Qualifiers::GC getObjCGCAttrKind(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Ty) const IFMETA_ELSE( ({    return (enum clang::Qualifiers::GC)__reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCGCAttrKind, Xs..., Y0s...); }) , (;) )
  /// Return true if this is an \c NSObject object with its \c NSObject
  /// attribute set.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool isObjCNSObjectType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Ty) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::isObjCNSObjectType, Xs..., Y0s...); }) , (;) )
  /// Get the size and alignment of the specified complete type in bits.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeInfo) )
  getTypeInfo(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeInfo, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeInfo) )
  getTypeInfo(ptrwrp<Y0> p0) const {
      return getTypeInfo(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeInfo) )
  getTypeInfo(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeInfo1, Xs..., Y0s...); }) , (;) )
  /// Get default simd alignment of the specified complete type in bits.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getOpenMPDefaultSimdAlign(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getOpenMPDefaultSimdAlign, Xs..., Y0s...); }) , (;) )
  /// Return the size of the specified (complete) type \p T, in bits.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned long long getTypeSize(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeSize, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned long long getTypeSize(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeSize1, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned long long getTypeSize(ptrwrp<Y0> p0) const {
      return getTypeSize(p0.get());
  }), () )
  /// Return the size of the character type, in bits.
  constexpr unsigned long long getCharWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getCharWidth, Xs...); }) , (;) )
  /// Convert a size in bits to a size in characters.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  toCharUnitsFromBits(long long BitSize) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::toCharUnitsFromBits, Xs..., BitSize); }) , (;) )
  /// Convert a size in characters to a size in bits.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr long long toBits(IFMETA_ELSE((const clang::CharUnits::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::CharUnits)) CharSize) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::toBits, Xs..., Y0s...); }) , (;) )
  /// Return the size of the specified (complete) type \p T, in
  /// characters.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getTypeSizeInChars(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeSizeInChars, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getTypeSizeInChars(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeSizeInChars1, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getTypeSizeInChars(ptrwrp<Y0> p0) const {
      return getTypeSizeInChars(p0.get());
  }), () )
  /// Return the ABI-specified alignment of a (complete) type \p T, in
  /// bits.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getTypeAlign(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeAlign, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getTypeAlign(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeAlign1, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int getTypeAlign(ptrwrp<Y0> p0) const {
      return getTypeAlign(p0.get());
  }), () )
  /// Return the ABI-specified natural alignment of a (complete) type \p T,
  /// before alignment adjustments, in bits.
  ///
  /// This alignment is curently used only by ARM and AArch64 when passing
  /// arguments of a composite type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getTypeUnadjustedAlign(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeUnadjustedAlign, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getTypeUnadjustedAlign(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeUnadjustedAlign1, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int getTypeUnadjustedAlign(ptrwrp<Y0> p0) const {
      return getTypeUnadjustedAlign(p0.get());
  }), () )
  /// Return the ABI-specified alignment of a type, in bits, or 0 if
  /// the type is incomplete and we cannot determine the alignment (for
  /// example, from alignment attributes).
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getTypeAlignIfKnown(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeAlignIfKnown, Xs..., Y0s...); }) , (;) )
  /// Return the ABI-specified alignment of a (complete) type \p T, in
  /// characters.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getTypeAlignInChars(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeAlignInChars, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getTypeAlignInChars(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeAlignInChars1, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getTypeAlignInChars(ptrwrp<Y0> p0) const {
      return getTypeAlignInChars(p0.get());
  }), () )
  /// getTypeUnadjustedAlignInChars - Return the ABI-specified alignment of a type,
  /// in characters, before alignment adjustments. This method does not work on
  /// incomplete types.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getTypeUnadjustedAlignInChars(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeUnadjustedAlignInChars, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getTypeUnadjustedAlignInChars(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTypeUnadjustedAlignInChars1, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getTypeUnadjustedAlignInChars(ptrwrp<Y0> p0) const {
      return getTypeUnadjustedAlignInChars(p0.get());
  }), () )
  /// Determine if the alignment the type has was required using an
  /// alignment attribute.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isAlignmentRequired(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::isAlignmentRequired, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isAlignmentRequired(ptrwrp<Y0> p0) const {
      return isAlignmentRequired(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isAlignmentRequired(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::isAlignmentRequired1, Xs..., Y0s...); }) , (;) )
  /// Return the "preferred" alignment of the specified type \p T for
  /// the current target, in bits.
  ///
  /// This can be different than the ABI alignment in cases where it is
  /// beneficial for performance to overalign a data type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getPreferredTypeAlign(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getPreferredTypeAlign, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int getPreferredTypeAlign(ptrwrp<Y0> p0) const {
      return getPreferredTypeAlign(p0.get());
  }), () )
  /// Return the default alignment for __attribute__((aligned)) on
  /// this target, to be used if no alignment value is specified.
  constexpr unsigned int getTargetDefaultAlignForAttributeAligned() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTargetDefaultAlignForAttributeAligned, Xs...); }) , (;) )
  /// Return the alignment in bits that should be given to a
  /// global variable with type \p T.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getAlignOfGlobalVar(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAlignOfGlobalVar, Xs..., Y0s...); }) , (;) )
  /// Return the alignment in characters that should be given to a
  /// global variable with type \p T.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getAlignOfGlobalVarInChars(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAlignOfGlobalVarInChars, Xs..., Y0s...); }) , (;) )
  /// Return a conservative estimate of the alignment of the specified
  /// decl \p D.
  ///
  /// \pre \p D must not be a bitfield type, as bitfields do not have a valid
  /// alignment.
  ///
  /// If \p ForAlignof, references are treated like their underlying type
  /// and  large arrays don't get any special treatment. If not \p ForAlignof
  /// it computes the value expected by CodeGen: references are treated like
  /// pointers and large arrays get extra alignment.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getDeclAlign(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D, bool ForAlignof = false) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDeclAlign, Xs..., Y0s..., ForAlignof); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getDeclAlign(ptrwrp<Y0> p0, bool p1 = false) const {
      return getDeclAlign(p0.get(), p1);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void DumpRecordLayout(IFMETA_ELSE((const clang::RecordDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::RecordDecl *)) RD, IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y1s...>), (typename meta::llvm::raw_ostream &)) OS, bool Simple = false) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::DumpRecordLayout, Xs..., Y0s..., Y1s..., Simple); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr void DumpRecordLayout(ptrwrp<Y0> p0, Y1 p1, bool p2 = false) const {
      return DumpRecordLayout(p0.get(), p1, p2);
  }), () )
  /// Loading virtual member pointers using the virtual inheritance model
  /// always results in an adjustment using the vbtable even if the index is
  /// zero.
  ///
  /// This is usually OK because the first slot in the vbtable points
  /// backwards to the top of the MDC.  However, the MDC might be reusing a
  /// vbptr from an nv-base.  In this case, the first slot in the vbtable
  /// points to the start of the nv-base which introduced the vbptr and *not*
  /// the MDC.  Modify the NonVirtualBaseAdjustment to account for this.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getOffsetOfBaseWithVBPtr(IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::CXXRecordDecl *)) RD) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getOffsetOfBaseWithVBPtr, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CharUnits) )
  getOffsetOfBaseWithVBPtr(ptrwrp<Y0> p0) const {
      return getOffsetOfBaseWithVBPtr(p0.get());
  }), () )
  /// Get the offset of a FieldDecl or IndirectFieldDecl, in bits.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned long long getFieldOffset(IFMETA_ELSE((const clang::ValueDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ValueDecl *)) FD) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getFieldOffset, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned long long getFieldOffset(ptrwrp<Y0> p0) const {
      return getFieldOffset(p0.get());
  }), () )
  /// Get the offset of an ObjCIvarDecl in bits.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr unsigned long long lookupFieldBitOffset(IFMETA_ELSE((const clang::ObjCInterfaceDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ObjCInterfaceDecl *)) OID, IFMETA_ELSE((const clang::ObjCImplementationDecl::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::ObjCImplementationDecl *)) ID, IFMETA_ELSE((const clang::ObjCIvarDecl::template impl</*ptrorref=*/1, Y2s...> *), (const typename meta::clang::ObjCIvarDecl *)) Ivar) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::lookupFieldBitOffset, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  constexpr unsigned long long lookupFieldBitOffset(ptrwrp<Y0> p0, ptrwrp<Y1> p1, ptrwrp<Y2> p2) const {
      return lookupFieldBitOffset(p0.get(), p1.get(), p2.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isNearlyEmpty(IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::CXXRecordDecl *)) RD) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::isNearlyEmpty, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isNearlyEmpty(ptrwrp<Y0> p0) const {
      return isNearlyEmpty(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int CountNonClassIvars(IFMETA_ELSE((const clang::ObjCInterfaceDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ObjCInterfaceDecl *)) OI) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::CountNonClassIvars, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int CountNonClassIvars(ptrwrp<Y0> p0) const {
      return CountNonClassIvars(p0.get());
  }), () )
  /// Return true if the specified type has unique object representations
  /// according to (C++17 [meta.unary.prop]p9)
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool hasUniqueObjectRepresentations(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::hasUniqueObjectRepresentations, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getCanonicalType(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getCanonicalType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getCanonicalType(ptrwrp<Y0> p0) const {
      return getCanonicalType(p0.get());
  }), () )
  /// Determine whether the given types \p T1 and \p T2 are equivalent.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool hasSameType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T1, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) T2) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::hasSameType, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool hasSameType(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) T1, IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::Type *)) T2) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::hasSameType1, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr bool hasSameType(ptrwrp<Y0> p0, ptrwrp<Y1> p1) const {
      return hasSameType(p0.get(), p1.get());
  }), () )
  /// Determine whether the given types are equivalent after
  /// cvr-qualifiers have been removed.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool hasSameUnqualifiedType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T1, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) T2) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::hasSameUnqualifiedType, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool hasSameNullabilityTypeQualifier(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) SubT, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) SuperT, bool IsParam) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::hasSameNullabilityTypeQualifier, Xs..., Y0s..., Y1s..., IsParam); }) , (;) )
  /// Retrieves the "canonical" nested name specifier for a
  /// given nested name specifier.
  ///
  /// The canonical nested name specifier is a nested name specifier
  /// that uniquely identifies a type or namespace within the type
  /// system. For example, given:
  ///
  /// \code
  /// namespace N {
  ///   struct S {
  ///     template<typename T> struct X { typename T* type; };
  ///   };
  /// }
  ///
  /// template<typename T> struct Y {
  ///   typename N::S::X<T>::type member;
  /// };
  /// \endcode
  ///
  /// Here, the nested-name-specifier for N::S::X<T>:: will be
  /// S::X<template-param-0-0>, since 'S' and 'X' are uniquely defined
  /// by declarations in the type system and the canonical type for
  /// the template type parameter 'T' is template-param-0-0.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getCanonicalNestedNameSpecifier(IFMETA_ELSE((const clang::NestedNameSpecifier::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::NestedNameSpecifier *)) NNS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getCanonicalNestedNameSpecifier, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getCanonicalNestedNameSpecifier(ptrwrp<Y0> p0) const {
      return getCanonicalNestedNameSpecifier(p0.get());
  }), () )
  /// Retrieves the default calling convention for the current target.
  constexpr enum clang::CallingConv getDefaultCallingConvention(bool IsVariadic, bool IsCXXMethod) const IFMETA_ELSE( ({    return (enum clang::CallingConv)__reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getDefaultCallingConvention, Xs..., IsVariadic, IsCXXMethod); }) , (;) )
  /// Retrieves the "canonical" template name that refers to a
  /// given template.
  ///
  /// The canonical template name is the simplest expression that can
  /// be used to refer to a given template. For most templates, this
  /// expression is just the template declaration itself. For example,
  /// the template std::vector can be referred to via a variety of
  /// names---std::vector, \::std::vector, vector (if vector is in
  /// scope), etc.---but all of these names map down to the same
  /// TemplateDecl, which is used to form the canonical template name.
  ///
  /// Dependent template names are more interesting. Here, the
  /// template name could be something like T::template apply or
  /// std::allocator<T>::template rebind, where the nested name
  /// specifier itself is dependent. In this case, the canonical
  /// template name uses the shortest form of the dependent
  /// nested-name-specifier, which itself contains all canonical
  /// types, values, and templates.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateName) )
  getCanonicalTemplateName(IFMETA_ELSE((const clang::TemplateName::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::TemplateName)) Name) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getCanonicalTemplateName, Xs..., Y0s...); }) , (;) )
  /// Retrieve the "canonical" template argument.
  ///
  /// The canonical template argument is the simplest template argument
  /// (which may be a type, value, expression, or declaration) that
  /// expresses the value of the argument.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateArgument) )
  getCanonicalTemplateArgument(IFMETA_ELSE((const clang::TemplateArgument::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::TemplateArgument &)) Arg) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getCanonicalTemplateArgument, Xs..., Y0s...); }) , (;) )
  /// Type Query functions.  If the type is an instance of the specified class,
  /// return the Type pointer for the underlying maximally pretty type.  This
  /// is a member of ASTContext because this may need to do some amount of
  /// canonicalization, e.g. to move type qualifiers into the element type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ArrayType *) )
  getAsArrayType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAsArrayType, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ConstantArrayType *) )
  getAsConstantArrayType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAsConstantArrayType, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VariableArrayType *) )
  getAsVariableArrayType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAsVariableArrayType, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::IncompleteArrayType *) )
  getAsIncompleteArrayType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAsIncompleteArrayType, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DependentSizedArrayType *) )
  getAsDependentSizedArrayType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAsDependentSizedArrayType, Xs..., Y0s...); }) , (;) )
  /// Return the innermost element type of an array type.
  ///
  /// For example, will return "int" for int[m][n]
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBaseElementType(IFMETA_ELSE((const clang::ArrayType::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ArrayType *)) VAT) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getBaseElementType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBaseElementType(ptrwrp<Y0> p0) const {
      return getBaseElementType(p0.get());
  }), () )
  /// Return the innermost element type of a type (which needn't
  /// actually be an array type).
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBaseElementType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) QT) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getBaseElementType1, Xs..., Y0s...); }) , (;) )
  /// Return number of constant array elements.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned long long getConstantArrayElementCount(IFMETA_ELSE((const clang::ConstantArrayType::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ConstantArrayType *)) CA) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getConstantArrayElementCount, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned long long getConstantArrayElementCount(ptrwrp<Y0> p0) const {
      return getConstantArrayElementCount(p0.get());
  }), () )
  /// Perform adjustment on the parameter type of a function.
  ///
  /// This routine adjusts the given parameter type @p T to the actual
  /// parameter type used by semantic analysis (C99 6.7.5.3p[7,8],
  /// C++ [dcl.fct]p3). The adjusted parameter type is returned.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAdjustedParameterType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getAdjustedParameterType, Xs..., Y0s...); }) , (;) )
  /// Retrieve the parameter type as adjusted for use in the signature
  /// of a function, decaying array and function types and removing top-level
  /// cv-qualifiers.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getSignatureParameterType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getSignatureParameterType, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getExceptionObjectType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getExceptionObjectType, Xs..., Y0s...); }) , (;) )
  /// Return the properly qualified result of decaying the specified
  /// array type to a pointer.
  ///
  /// This operation is non-trivial when handling typedefs etc.  The canonical
  /// type of \p T must be an array type, this returns a pointer to a properly
  /// qualified element of the array.
  ///
  /// See C99 6.7.5.3p7 and C99 6.3.2.1p3.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getArrayDecayedType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getArrayDecayedType, Xs..., Y0s...); }) , (;) )
  /// Return the type that \p PromotableType will promote to: C99
  /// 6.3.1.1p2, assuming that \p PromotableType is a promotable integer type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getPromotedIntegerType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) PromotableType) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getPromotedIntegerType, Xs..., Y0s...); }) , (;) )
  /// Recurses in pointer/array types until it finds an Objective-C
  /// retainable type and returns its ownership.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum clang::Qualifiers::ObjCLifetime getInnerObjCOwnership(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return (enum clang::Qualifiers::ObjCLifetime)__reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getInnerObjCOwnership, Xs..., Y0s...); }) , (;) )
  /// Whether this is a promotable bitfield reference according
  /// to C99 6.3.1.1p2, bullet 2 (and GCC extensions).
  ///
  /// \returns the type this bit-field will promote to, or NULL if no
  /// promotion occurs.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  isPromotableBitField(IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::Expr *)) E) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::isPromotableBitField, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  isPromotableBitField(ptrwrp<Y0> p0) const {
      return isPromotableBitField(p0.get());
  }), () )
  /// Return the highest ranked integer type, see C99 6.3.1.8p1.
  ///
  /// If \p LHS > \p RHS, returns 1.  If \p LHS == \p RHS, returns 0.  If
  /// \p LHS < \p RHS, return -1.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr int getIntegerTypeOrder(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) LHS, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getIntegerTypeOrder, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Compare the rank of the two specified floating point types,
  /// ignoring the domain of the type (i.e. 'double' == '_Complex double').
  ///
  /// If \p LHS > \p RHS, returns 1.  If \p LHS == \p RHS, returns 0.  If
  /// \p LHS < \p RHS, return -1.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr int getFloatingTypeOrder(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) LHS, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getFloatingTypeOrder, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Return a real floating point or a complex type (based on
  /// \p typeDomain/\p typeSize).
  ///
  /// \param typeDomain a real floating point or complex type.
  /// \param typeSize a real floating point or complex type.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getFloatingTypeOfSizeWithinDomain(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) typeSize, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) typeDomain) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getFloatingTypeOfSizeWithinDomain, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getTargetAddressSpace(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTargetAddressSpace, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getTargetAddressSpace(IFMETA_ELSE((const clang::Qualifiers::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Qualifiers)) Q) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTargetAddressSpace1, Xs..., Y0s...); }) , (;) )
  constexpr unsigned int getTargetAddressSpace(enum clang::LangAS AS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTargetAddressSpace2, Xs..., AS); }) , (;) )
  /// Get target-dependent integer value for null pointer which is used for
  /// constant folding.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned long long getTargetNullPointerValue(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) QT) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTargetNullPointerValue, Xs..., Y0s...); }) , (;) )
  constexpr bool addressSpaceMapManglingFor(enum clang::LangAS AS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::addressSpaceMapManglingFor, Xs..., AS); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isObjCIdType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::isObjCIdType, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isObjCClassType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::isObjCClassType, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isObjCSelType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::isObjCSelType, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getIntWidth(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getIntWidth, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getCorrespondingUnsignedType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getCorrespondingUnsignedType, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getCorrespondingSaturatedType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Ty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getCorrespondingSaturatedType, Xs..., Y0s...); }) , (;) )
  /// Make an APSInt of the appropriate width and signedness for the
  /// given \p Value and integer \p Type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  MakeIntValue(unsigned long long Value, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) Type) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::MakeIntValue, Xs..., Value, Y0s...); }) , (;) )
  /// Get the duplicate declaration of a ObjCMethod in the same
  /// interface, or null if none exists.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCMethodDecl *) )
  getObjCMethodRedeclaration(IFMETA_ELSE((const clang::ObjCMethodDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ObjCMethodDecl *)) MD) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjCMethodRedeclaration, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCMethodDecl *) )
  getObjCMethodRedeclaration(ptrwrp<Y0> p0) const {
      return getObjCMethodRedeclaration(p0.get());
  }), () )
  /// Returns the Objective-C interface that \p ND belongs to if it is
  /// an Objective-C method/property/ivar etc. that is part of an interface,
  /// otherwise returns null.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  getObjContainingInterface(IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::NamedDecl *)) ND) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getObjContainingInterface, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  getObjContainingInterface(ptrwrp<Y0> p0) const {
      return getObjContainingInterface(p0.get());
  }), () )
  /// Allocate an uninitialized TypeSourceInfo.
  ///
  /// The caller should initialize the memory held by TypeSourceInfo using
  /// the TypeLoc wrappers.
  ///
  /// \param T the type that will be the basis for type source info. This type
  /// should refer to how the declarator was written in source code, not to
  /// what type semantic analysis resolved the declarator to.
  ///
  /// \param Size the size of the type info to create, or 0 if the size
  /// should be calculated based on the type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  CreateTypeSourceInfo(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T, unsigned int Size = 0) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::CreateTypeSourceInfo, Xs..., Y0s..., Size); }) , (;) )
  /// Allocate a TypeSourceInfo where all locations have been
  /// initialized to a given location, which defaults to the empty
  /// location.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTrivialTypeSourceInfo(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) Loc = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getTrivialTypeSourceInfo, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum clang::GVALinkage GetGVALinkageForFunction(IFMETA_ELSE((const clang::FunctionDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::FunctionDecl *)) FD) const IFMETA_ELSE( ({    return (enum clang::GVALinkage)__reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::GetGVALinkageForFunction, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr enum clang::GVALinkage GetGVALinkageForFunction(ptrwrp<Y0> p0) const {
      return GetGVALinkageForFunction(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getManglingNumber(IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::NamedDecl *)) ND) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getManglingNumber, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int getManglingNumber(ptrwrp<Y0> p0) const {
      return getManglingNumber(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getStaticLocalNumber(IFMETA_ELSE((const clang::VarDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::VarDecl *)) VD) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getStaticLocalNumber, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int getStaticLocalNumber(ptrwrp<Y0> p0) const {
      return getStaticLocalNumber(p0.get());
  }), () )
  /// Used by ParmVarDecl to retrieve on the side the
  /// index of the parameter when it exceeds the size of the normal bitfield.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int getParameterIndex(IFMETA_ELSE((const clang::ParmVarDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ParmVarDecl *)) D) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getParameterIndex, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr unsigned int getParameterIndex(ptrwrp<Y0> p0) const {
      return getParameterIndex(p0.get());
  }), () )
  /// Returns true if this is an inline-initialized static data member
  /// which is treated as a definition for MSVC compatibility.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isMSStaticDataMemberInlineDefinition(IFMETA_ELSE((const clang::VarDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::VarDecl *)) VD) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::isMSStaticDataMemberInlineDefinition, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isMSStaticDataMemberInlineDefinition(ptrwrp<Y0> p0) const {
      return isMSStaticDataMemberInlineDefinition(p0.get());
  }), () )
  using InlineVariableDefinitionKind = enum refldetail::clang::ASTContext::InlineVariableDefinitionKind;
  /// Determine whether a definition of this inline variable should
  /// be treated as a weak or strong definition. For compatibility with
  /// C++14 and before, for a constexpr static data member, if there is an
  /// out-of-line declaration of the member, we may promote it from weak to
  /// strong.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum clang::ASTContext::InlineVariableDefinitionKind getInlineVariableDefinitionKind(IFMETA_ELSE((const clang::VarDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::VarDecl *)) VD) const IFMETA_ELSE( ({    return (enum clang::ASTContext::InlineVariableDefinitionKind)__reflect_prop(reflenums::RK_clang__ASTContext, reflenums::clang__ASTContext::getInlineVariableDefinitionKind, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr enum clang::ASTContext::InlineVariableDefinitionKind getInlineVariableDefinitionKind(ptrwrp<Y0> p0) const {
      return getInlineVariableDefinitionKind(p0.get());
  }), () )
};

/// A POD class for pairing a NamedDecl* with an access specifier.
/// Can be put into unions.
M_template_rtpack(Xs)
struct clang::DeclAccessPair::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DeclAccessPair;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DeclAccessPair::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclAccessPair) )
  make(IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::NamedDecl *)) D, enum clang::AccessSpecifier AS) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclAccessPair, reflenums::clang__DeclAccessPair::make, Xs..., Y0s..., AS); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclAccessPair) )
  make(ptrwrp<Y0> p0, enum clang::AccessSpecifier p1) {
      return make(p0.get(), p1);
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclAccessPair, reflenums::clang__DeclAccessPair::getDecl, Xs...); }) , (;) )
  constexpr enum clang::AccessSpecifier getAccess() const IFMETA_ELSE( ({    return (enum clang::AccessSpecifier)__reflect_prop(reflenums::RK_clang__DeclAccessPair, reflenums::clang__DeclAccessPair::getAccess, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  operator->() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclAccessPair, reflenums::clang__DeclAccessPair::operator_arrow, Xs...); }) , (;) )
};

/// The iterator over UnresolvedSets.  Serves as both the const and
/// non-const iterator.
M_template_rtpack(Xs)
struct clang::UnresolvedSetIterator::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UnresolvedSetIterator;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UnresolvedSetIterator::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedSetIterator) )
  operator+(long n) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::operator_plus, Xs..., n); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedSetIterator) )
  operator-(long n) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::operator_minus, Xs..., n); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator!=(IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::UnresolvedSetIterator &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::operator_not_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator>(IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::UnresolvedSetIterator &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::operator_gr, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<=(IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::UnresolvedSetIterator &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::operator_less_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator>=(IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::UnresolvedSetIterator &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::operator_gr_eq, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  operator->() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::operator_arrow, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr long operator-(IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::UnresolvedSetIterator &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::operator_minus1, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator==(IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::UnresolvedSetIterator &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::operator_eq_eq, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool operator<(IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::UnresolvedSetIterator &)) RHS) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::operator_less, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  operator*() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::operator_star, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::getDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void setDecl(IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::NamedDecl *)) ND) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::setDecl, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr void setDecl(ptrwrp<Y0> p0) const {
      return setDecl(p0.get());
  }), () )
  constexpr enum clang::AccessSpecifier getAccess() const IFMETA_ELSE( ({    return (enum clang::AccessSpecifier)__reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::getAccess, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclAccessPair &) )
  getPair() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetIterator, reflenums::clang__UnresolvedSetIterator::getPair, Xs...); }) , (;) )
};

/// A set of unresolved declarations.
M_template_rtpack(Xs)
struct clang::UnresolvedSetImpl::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UnresolvedSetImpl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UnresolvedSetImpl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetImpl, reflenums::clang__UnresolvedSetImpl::empty, Xs...); }) , (;) )
  constexpr unsigned int size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetImpl, reflenums::clang__UnresolvedSetImpl::size, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclAccessPair &) )
  operator[](unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedSetImpl, reflenums::clang__UnresolvedSetImpl::operator_sub, Xs..., I); }) , (;) )
  RANGECLASS_SIZE_AND_GET(clang__UnresolvedSetImpl, typename meta::clang::NamedDecl *);
};

/// CastKind - The kind of operation required for a conversion.
enum clang::CastKind : unsigned int {
  /// CK_Dependent - A conversion which cannot yet be analyzed because
/// either the expression or target type is dependent.  These are
/// created only for explicit casts; dependent ASTs aren't required
/// to even approximately type-check.
///   (T*) malloc(sizeof(T))
///   reinterpret_cast<intptr_t>(A<T>::alloc());
  CK_Dependent,
  /// CK_BitCast - A conversion which causes a bit pattern of one type
/// to be reinterpreted as a bit pattern of another type.  Generally
/// the operands must have equivalent size and unrelated types.
///
/// The pointer conversion char* -> int* is a bitcast.  A conversion
/// from any pointer type to a C pointer type is a bitcast unless
/// it's actually BaseToDerived or DerivedToBase.  A conversion to a
/// block pointer or ObjC pointer type is a bitcast only if the
/// operand has the same type kind; otherwise, it's one of the
/// specialized casts below.
///
/// Vector coercions are bitcasts.
  CK_BitCast,
  /// CK_LValueBitCast - A conversion which reinterprets the address of
/// an l-value as an l-value of a different kind.  Used for
/// reinterpret_casts of l-value expressions to reference types.
///    bool b; reinterpret_cast<char&>(b) = 'a';
  CK_LValueBitCast,
  /// CK_LValueToRValue - A conversion which causes the extraction of
/// an r-value from the operand gl-value.  The result of an r-value
/// conversion is always unqualified.
  CK_LValueToRValue,
  /// CK_NoOp - A conversion which does not affect the type other than
/// (possibly) adding qualifiers.
///   int    -> int
///   char** -> const char * const *
  CK_NoOp,
  /// CK_BaseToDerived - A conversion from a C++ class pointer/reference
/// to a derived class pointer/reference.
///   B *b = static_cast<B*>(a);
  CK_BaseToDerived,
  /// CK_DerivedToBase - A conversion from a C++ class pointer
/// to a base class pointer.
///   A *a = new B();
  CK_DerivedToBase,
  /// CK_UncheckedDerivedToBase - A conversion from a C++ class
/// pointer/reference to a base class that can assume that the
/// derived pointer is not null.
///   const A &a = B();
///   b->method_from_a();
  CK_UncheckedDerivedToBase,
  /// CK_Dynamic - A C++ dynamic_cast.
  CK_Dynamic,
  /// CK_ToUnion - The GCC cast-to-union extension.
///   int   -> union { int x; float y; }
///   float -> union { int x; float y; }
  CK_ToUnion,
  /// CK_ArrayToPointerDecay - Array to pointer decay.
///   int[10] -> int*
///   char[5][6] -> char(*)[6]
  CK_ArrayToPointerDecay,
  /// CK_FunctionToPointerDecay - Function to pointer decay.
///   void(int) -> void(*)(int)
  CK_FunctionToPointerDecay,
  /// CK_NullToPointer - Null pointer constant to pointer, ObjC
/// pointer, or block pointer.
///   (void*) 0
///   void (^block)() = 0;
  CK_NullToPointer,
  /// CK_NullToMemberPointer - Null pointer constant to member pointer.
///   int A::*mptr = 0;
///   int (A::*fptr)(int) = nullptr;
  CK_NullToMemberPointer,
  /// CK_BaseToDerivedMemberPointer - Member pointer in base class to
/// member pointer in derived class.
///   int B::*mptr = &A::member;
  CK_BaseToDerivedMemberPointer,
  /// CK_DerivedToBaseMemberPointer - Member pointer in derived class to
/// member pointer in base class.
///   int A::*mptr = static_cast<int A::*>(&B::member);
  CK_DerivedToBaseMemberPointer,
  /// CK_MemberPointerToBoolean - Member pointer to boolean.  A check
/// against the null member pointer.
  CK_MemberPointerToBoolean,
  /// CK_ReinterpretMemberPointer - Reinterpret a member pointer as a
/// different kind of member pointer.  C++ forbids this from
/// crossing between function and object types, but otherwise does
/// not restrict it.  However, the only operation that is permitted
/// on a "punned" member pointer is casting it back to the original
/// type, which is required to be a lossless operation (although
/// many ABIs do not guarantee this on all possible intermediate types).
  CK_ReinterpretMemberPointer,
  /// CK_UserDefinedConversion - Conversion using a user defined type
/// conversion function.
///    struct A { operator int(); }; int i = int(A());
  CK_UserDefinedConversion,
  /// CK_ConstructorConversion - Conversion by constructor.
///    struct A { A(int); }; A a = A(10);
  CK_ConstructorConversion,
  /// CK_IntegralToPointer - Integral to pointer.  A special kind of
/// reinterpreting conversion.  Applies to normal, ObjC, and block
/// pointers.
///    (char*) 0x1001aab0
///    reinterpret_cast<int*>(0)
  CK_IntegralToPointer,
  /// CK_PointerToIntegral - Pointer to integral.  A special kind of
/// reinterpreting conversion.  Applies to normal, ObjC, and block
/// pointers.
///    (intptr_t) "help!"
  CK_PointerToIntegral,
  /// CK_PointerToBoolean - Pointer to boolean conversion.  A check
/// against null.  Applies to normal, ObjC, and block pointers.
  CK_PointerToBoolean,
  /// CK_ToVoid - Cast to void, discarding the computed value.
///    (void) malloc(2048)
  CK_ToVoid,
  /// CK_VectorSplat - A conversion from an arithmetic type to a
/// vector of that element type.  Fills all elements ("splats") with
/// the source value.
///    __attribute__((ext_vector_type(4))) int v = 5;
  CK_VectorSplat,
  /// CK_IntegralCast - A cast between integral types (other than to
/// boolean).  Variously a bitcast, a truncation, a sign-extension,
/// or a zero-extension.
///    long l = 5;
///    (unsigned) i
  CK_IntegralCast,
  /// CK_IntegralToBoolean - Integral to boolean.  A check against zero.
///    (bool) i
  CK_IntegralToBoolean,
  /// CK_IntegralToFloating - Integral to floating point.
///    float f = i;
  CK_IntegralToFloating,
  /// CK_FloatingToIntegral - Floating point to integral.  Rounds
/// towards zero, discarding any fractional component.
///    (int) f
  CK_FloatingToIntegral,
  /// CK_FloatingToBoolean - Floating point to boolean.
///    (bool) f
  CK_FloatingToBoolean,
  /// CK_FloatingToBoolean - Floating point to boolean.
///    (bool) f
  CK_BooleanToSignedIntegral,
  /// CK_FloatingCast - Casting between floating types of different size.
///    (double) f
///    (float) ld
  CK_FloatingCast,
  /// CK_CPointerToObjCPointerCast - Casting a C pointer kind to an
/// Objective-C pointer.
  CK_CPointerToObjCPointerCast,
  /// CK_BlockPointerToObjCPointerCast - Casting a block pointer to an
/// ObjC pointer.
  CK_BlockPointerToObjCPointerCast,
  /// CK_AnyPointerToBlockPointerCast - Casting any non-block pointer
/// to a block pointer.  Block-to-block casts are bitcasts.
  CK_AnyPointerToBlockPointerCast,
  /// Converting between two Objective-C object types, which
/// can occur when performing reference binding to an Objective-C
/// object.
  CK_ObjCObjectLValueCast,
  /// A conversion of a floating point real to a floating point
/// complex of the original type.  Injects the value as the real
/// component with a zero imaginary component.
///   float -> _Complex float
  CK_FloatingRealToComplex,
  /// Converts a floating point complex to floating point real
/// of the source's element type.  Just discards the imaginary
/// component.
///   _Complex long double -> long double
  CK_FloatingComplexToReal,
  /// Converts a floating point complex to bool by comparing
/// against 0+0i.
  CK_FloatingComplexToBoolean,
  /// Converts between different floating point complex types.
///   _Complex float -> _Complex double
  CK_FloatingComplexCast,
  /// Converts from a floating complex to an integral complex.
///   _Complex float -> _Complex int
  CK_FloatingComplexToIntegralComplex,
  /// Converts from an integral real to an integral complex
/// whose element type matches the source.  Injects the value as
/// the real component with a zero imaginary component.
///   long -> _Complex long
  CK_IntegralRealToComplex,
  /// Converts an integral complex to an integral real of the
/// source's element type by discarding the imaginary component.
///   _Complex short -> short
  CK_IntegralComplexToReal,
  /// Converts an integral complex to bool by comparing against
/// 0+0i.
  CK_IntegralComplexToBoolean,
  /// Converts between different integral complex types.
///   _Complex char -> _Complex long long
///   _Complex unsigned int -> _Complex signed int
  CK_IntegralComplexCast,
  /// Converts from an integral complex to a floating complex.
///   _Complex unsigned -> _Complex float
  CK_IntegralComplexToFloatingComplex,
  /// [ARC] Produces a retainable object pointer so that it may
/// be consumed, e.g. by being passed to a consuming parameter.
/// Calls objc_retain.
  CK_ARCProduceObject,
  /// [ARC] Consumes a retainable object pointer that has just
/// been produced, e.g. as the return value of a retaining call.
/// Enters a cleanup to call objc_release at some indefinite time.
  CK_ARCConsumeObject,
  /// [ARC] Reclaim a retainable object pointer object that may
/// have been produced and autoreleased as part of a function return
/// sequence.
  CK_ARCReclaimReturnedObject,
  /// [ARC] Causes a value of block type to be copied to the
/// heap, if it is not already there.  A number of other operations
/// in ARC cause blocks to be copied; this is for cases where that
/// would not otherwise be guaranteed, such as when casting to a
/// non-block pointer type.
  CK_ARCExtendBlockObject,
  /// Converts from _Atomic(T) to T.
  CK_AtomicToNonAtomic,
  /// Converts from T to _Atomic(T).
  CK_NonAtomicToAtomic,
  /// Causes a block literal to by copied to the heap and then
/// autoreleased.
///
/// This particular cast kind is used for the conversion from a C++11
/// lambda expression to a block pointer.
  CK_CopyAndAutoreleaseBlockObject,
  CK_BuiltinFnToFnPtr,
  CK_ZeroToOCLEvent,
  CK_ZeroToOCLQueue,
  CK_AddressSpaceConversion,
  CK_IntToOCLSampler,
};

enum clang::BinaryOperatorKind : unsigned int {
  BO_PtrMemD,
  BO_PtrMemI,
  BO_Mul,
  BO_Div,
  BO_Rem,
  BO_Add,
  BO_Sub,
  BO_Shl,
  BO_Shr,
  BO_Cmp,
  BO_LT,
  BO_GT,
  BO_LE,
  BO_GE,
  BO_EQ,
  BO_NE,
  BO_And,
  BO_Xor,
  BO_Or,
  BO_LAnd,
  BO_LOr,
  BO_Assign,
  BO_MulAssign,
  BO_DivAssign,
  BO_RemAssign,
  BO_AddAssign,
  BO_SubAssign,
  BO_ShlAssign,
  BO_ShrAssign,
  BO_AndAssign,
  BO_XorAssign,
  BO_OrAssign,
  BO_Comma,
};

enum clang::UnaryOperatorKind : unsigned int {
  UO_PostInc,
  UO_PostDec,
  UO_PreInc,
  UO_PreDec,
  UO_AddrOf,
  UO_Deref,
  UO_Plus,
  UO_Minus,
  UO_Not,
  UO_LNot,
  UO_Real,
  UO_Imag,
  UO_Extension,
  UO_Coawait,
};

/// The kind of bridging performed by the Objective-C bridge cast.
enum clang::ObjCBridgeCastKind : unsigned int {
  /// Bridging via __bridge, which does nothing but reinterpret
  /// the bits.
  OBC_Bridge,
  /// Bridging via __bridge_transfer, which transfers ownership of an
  /// Objective-C pointer into ARC.
  OBC_BridgeTransfer,
  /// Bridging via __bridge_retain, which makes an ARC object available
  /// as a +1 C pointer.
  OBC_BridgeRetained,
};

/// Names for traits that operate specifically on types.
enum clang::TypeTrait : unsigned int {
  UTT_HasNothrowAssign,
  UTT_HasNothrowMoveAssign,
  UTT_HasNothrowCopy,
  UTT_HasNothrowConstructor,
  UTT_HasTrivialAssign,
  UTT_HasTrivialMoveAssign,
  UTT_HasTrivialCopy,
  UTT_HasTrivialDefaultConstructor,
  UTT_HasTrivialMoveConstructor,
  UTT_HasTrivialDestructor,
  UTT_HasVirtualDestructor,
  UTT_IsAbstract,
  UTT_IsAggregate,
  UTT_IsArithmetic,
  UTT_IsArray,
  UTT_IsClass,
  UTT_IsCompleteType,
  UTT_IsCompound,
  UTT_IsConst,
  UTT_IsDestructible,
  UTT_IsEmpty,
  UTT_IsEnum,
  UTT_IsFinal,
  UTT_IsFloatingPoint,
  UTT_IsFunction,
  UTT_IsFundamental,
  UTT_IsIntegral,
  UTT_IsInterfaceClass,
  UTT_IsLiteral,
  UTT_IsLvalueReference,
  UTT_IsMemberFunctionPointer,
  UTT_IsMemberObjectPointer,
  UTT_IsMemberPointer,
  UTT_IsNothrowDestructible,
  UTT_IsObject,
  UTT_IsPOD,
  UTT_IsPointer,
  UTT_IsPolymorphic,
  UTT_IsReference,
  UTT_IsRvalueReference,
  UTT_IsScalar,
  UTT_IsSealed,
  UTT_IsSigned,
  UTT_IsStandardLayout,
  UTT_IsTrivial,
  UTT_IsTriviallyCopyable,
  UTT_IsTriviallyDestructible,
  UTT_IsUnion,
  UTT_IsUnsigned,
  UTT_IsVoid,
  UTT_IsVolatile,
  UTT_HasUniqueObjectRepresentations,
  UTT_Last = 51,
  BTT_IsBaseOf,
  BTT_IsConvertible,
  BTT_IsConvertibleTo,
  BTT_IsSame,
  BTT_TypeCompatible,
  BTT_IsAssignable,
  BTT_IsNothrowAssignable,
  BTT_IsTriviallyAssignable,
  BTT_ReferenceBindsToTemporary,
  BTT_Last = 60,
  TT_IsConstructible,
  TT_IsNothrowConstructible,
  TT_IsTriviallyConstructible,
};

/// Names for the array type traits.
enum clang::ArrayTypeTrait : unsigned int {
  ATT_ArrayRank,
  ATT_ArrayExtent,
};

/// Names for the "expression or type" traits.
enum clang::UnaryExprOrTypeTrait : unsigned int {
  UETT_SizeOf,
  UETT_AlignOf,
  UETT_VecStep,
  UETT_OpenMPRequiredSimdAlign,
};

enum clang::Expr::LValueClassification : unsigned int {
  LV_Valid,
  LV_NotObjectType,
  LV_IncompleteVoidType,
  LV_DuplicateVectorComponents,
  LV_InvalidExpression,
  LV_InvalidMessageExpression,
  LV_MemberFunction,
  LV_SubObjCPropertySetting,
  LV_ClassTemporary,
  LV_ArrayTemporary,
};

enum clang::Expr::isModifiableLvalueResult : unsigned int {
  MLV_Valid,
  MLV_NotObjectType,
  MLV_IncompleteVoidType,
  MLV_DuplicateVectorComponents,
  MLV_InvalidExpression,
  MLV_LValueCast,
  MLV_IncompleteType,
  MLV_ConstQualified,
  MLV_ConstQualifiedField,
  MLV_ConstAddrSpace,
  MLV_ArrayType,
  MLV_NoSetterProperty,
  MLV_MemberFunction,
  MLV_SubObjCPropertySetting,
  MLV_InvalidMessageExpression,
  MLV_ClassTemporary,
  MLV_ArrayTemporary,
};

enum clang::Expr::SideEffectsKind : unsigned int {
  ///< Strictly evaluate the expression.
  SE_NoSideEffects,
  ///< Allow UB that we can give a value, but not
                             ///< arbitrary unmodeled side effects.
  SE_AllowUndefinedBehavior,
  ///< Allow any unmodeled side effect.
  SE_AllowSideEffects,
};

/// Indicates how the constant expression will be used.
enum clang::Expr::ConstExprUsage : unsigned int {
  EvaluateForCodeGen,
  EvaluateForMangling,
};

/// Enumeration used to describe the kind of Null pointer constant
/// returned from \c isNullPointerConstant().
enum clang::Expr::NullPointerConstantKind : unsigned int {
  /// Expression is not a Null pointer constant.
  NPCK_NotNull = 0,
  /// Expression is a Null pointer constant built from a zero integer
  /// expression that is not a simple, possibly parenthesized, zero literal.
  /// C++ Core Issue 903 will classify these expressions as "not pointers"
  /// once it is adopted.
  /// http://www.open-std.org/jtc1/sc22/wg21/docs/cwg_active.html#903
  NPCK_ZeroExpression,
  /// Expression is a Null pointer constant built from a literal zero.
  NPCK_ZeroLiteral,
  /// Expression is a C++11 nullptr.
  NPCK_CXX11_nullptr,
  /// Expression is a GNU-style __null constant.
  NPCK_GNUNull,
};

/// Enumeration used to describe how \c isNullPointerConstant()
/// should cope with value-dependent expressions.
enum clang::Expr::NullPointerConstantValueDependence : unsigned int {
  /// Specifies that the expression should never be value-dependent.
  NPC_NeverValueDependent = 0,
  /// Specifies that a value-dependent expression of integral or
  /// dependent type should be considered a null pointer constant.
  NPC_ValueDependentIsNull,
  /// Specifies that a value-dependent expression should be considered
  /// to never be a null pointer constant.
  NPC_ValueDependentIsNotNull,
};

/// Expr - This represents one expression.  Note that Expr's are subclasses of
/// Stmt.  This allows an expression to be transparently used any place a Stmt
/// is required.
///
M_template_rtpack(Xs)
struct clang::Expr::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Expr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Expr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::getType, Xs...); }) , (;) )
  /// isValueDependent - Determines whether this expression is
  /// value-dependent (C++ [temp.dep.constexpr]). For example, the
  /// array bound of "Chars" in the following example is
  /// value-dependent.
  /// @code
  /// template<int Size, char (&Chars)[Size]> struct meta_string;
  /// @endcode
  constexpr bool isValueDependent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isValueDependent, Xs...); }) , (;) )
  /// isTypeDependent - Determines whether this expression is
  /// type-dependent (C++ [temp.dep.expr]), which means that its type
  /// could change from one template instantiation to the next. For
  /// example, the expressions "x" and "x + y" are type-dependent in
  /// the following code, but "y" is not type-dependent:
  /// @code
  /// template<typename T>
  /// void add(T x, int y) {
  ///   x + y;
  /// }
  /// @endcode
  constexpr bool isTypeDependent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isTypeDependent, Xs...); }) , (;) )
  /// Whether this expression is instantiation-dependent, meaning that
  /// it depends in some way on a template parameter, even if neither its type
  /// nor (constant) value can change due to the template instantiation.
  ///
  /// In the following example, the expression \c sizeof(sizeof(T() + T())) is
  /// instantiation-dependent (since it involves a template parameter \c T), but
  /// is neither type- nor value-dependent, since the type of the inner
  /// \c sizeof is known (\c std::size_t) and therefore the size of the outer
  /// \c sizeof is known.
  ///
  /// \code
  /// template<typename T>
  /// void f(T x, T y) {
  ///   sizeof(sizeof(T() + T());
  /// }
  /// \endcode
  ///
  constexpr bool isInstantiationDependent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isInstantiationDependent, Xs...); }) , (;) )
  /// Whether this expression contains an unexpanded parameter
  /// pack (for C++11 variadic templates).
  ///
  /// Given the following function template:
  ///
  /// \code
  /// template<typename F, typename ...Types>
  /// void forward(const F &f, Types &&...args) {
  ///   f(static_cast<Types&&>(args)...);
  /// }
  /// \endcode
  ///
  /// The expressions \c args and \c static_cast<Types&&>(args) both
  /// contain parameter packs.
  constexpr bool containsUnexpandedParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::containsUnexpandedParameterPack, Xs...); }) , (;) )
  /// getExprLoc - Return the preferred location for the arrow when diagnosing
  /// a problem with a generic expression.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::getExprLoc, Xs...); }) , (;) )
  /// isUnusedResultAWarning - Return true if this immediate expression should
  /// be warned about if the result is unused.  If so, fill in expr, location,
  /// and ranges with expr to warn on and source locations/ranges appropriate
  /// for a warning.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  constexpr bool isUnusedResultAWarning(IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::Expr *&)) WarnExpr, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/1, Y1s...>), (typename meta::clang::SourceLocation &)) Loc, IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/1, Y2s...>), (typename meta::clang::SourceRange &)) R1, IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/1, Y3s...>), (typename meta::clang::SourceRange &)) R2, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y4s...>), (typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isUnusedResultAWarning, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s...); }) , (;) )
  /// isLValue - True if this expression is an "l-value" according to
  /// the rules of the current language.  C and C++ give somewhat
  /// different rules for this concept, but in general, the result of
  /// an l-value expression identifies a specific object whereas the
  /// result of an r-value expression is a value detached from any
  /// specific storage.
  ///
  /// C++11 divides the concept of "r-value" into pure r-values
  /// ("pr-values") and so-called expiring values ("x-values"), which
  /// identify specific objects that can be safely cannibalized for
  /// their resources.  This is an unfortunate abuse of terminology on
  /// the part of the C++ committee.  In Clang, when we say "r-value",
  /// we generally mean a pr-value.
  constexpr bool isLValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isLValue, Xs...); }) , (;) )
  constexpr bool isRValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isRValue, Xs...); }) , (;) )
  constexpr bool isXValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isXValue, Xs...); }) , (;) )
  constexpr bool isGLValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isGLValue, Xs...); }) , (;) )
  using LValueClassification = enum refldetail::clang::Expr::LValueClassification;
  /// Reasons why an expression might not be an l-value.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum clang::Expr::LValueClassification ClassifyLValue(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return (enum clang::Expr::LValueClassification)__reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::ClassifyLValue, Xs..., Y0s...); }) , (;) )
  using isModifiableLvalueResult = enum refldetail::clang::Expr::isModifiableLvalueResult;
  /// isModifiableLvalue - C99 6.3.2.1: an lvalue that does not have array type,
  /// does not have an incomplete type, does not have a const-qualified type,
  /// and if it is a structure or union, does not have any member (including,
  /// recursively, any member or element of all contained aggregates or unions)
  /// with a const-qualified type.
  ///
  /// \param Loc [in,out] - A source location which *may* be filled
  /// in with the location of the expression making this a
  /// non-modifiable lvalue, if specified.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr enum clang::Expr::isModifiableLvalueResult isModifiableLvalue(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::SourceLocation *)) Loc = {}) const IFMETA_ELSE( ({    return (enum clang::Expr::isModifiableLvalueResult)__reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isModifiableLvalue, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr enum clang::Expr::isModifiableLvalueResult isModifiableLvalue(Y0 p0, ptrwrp<Y1> p1 = {}) const {
      return isModifiableLvalue(p0, p1.get());
  }), () )
  M_template_rtpack(Zs) using Classification = struct refldetail::clang::Expr::Classification::M_template impl M_targpack(Zs);
  /// Classify - Classify this expression according to the C++11
  ///        expression taxonomy.
  ///
  /// C++11 defines ([basic.lval]) a new taxonomy of expressions to replace the
  /// old lvalue vs rvalue. This function determines the type of expression this
  /// is. There are three expression types:
  /// - lvalues are classical lvalues as in C++03.
  /// - prvalues are equivalent to rvalues in C++03.
  /// - xvalues are expressions yielding unnamed rvalue references, e.g. a
  ///   function returning an rvalue reference.
  /// lvalues and xvalues are collectively referred to as glvalues, while
  /// prvalues and xvalues together form rvalues.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr::Classification) )
  Classify(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::Classify, Xs..., Y0s...); }) , (;) )
  /// ClassifyModifiable - Classify this expression according to the
  ///        C++11 expression taxonomy, and see if it is valid on the left side
  ///        of an assignment.
  ///
  /// This function extends classify in that it also tests whether the
  /// expression is modifiable (C99 6.3.2.1p1).
  /// \param Loc A source location that might be filled with a relevant location
  ///            if the expression is not modifiable.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr::Classification) )
  ClassifyModifiable(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/1, Y1s...>), (typename meta::clang::SourceLocation &)) Loc) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::ClassifyModifiable, Xs..., Y0s..., Y1s...); }) , (;) )
  /// getValueKindForType - Given a formal return or parameter type,
  /// give its value kind.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr enum clang::ExprValueKind getValueKindForType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) T) IFMETA_ELSE( ({    return (enum clang::ExprValueKind)__reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::getValueKindForType, Xs..., Y0s...); }) , (;) )
  /// getValueKind - The value kind that this expression produces.
  constexpr enum clang::ExprValueKind getValueKind() const IFMETA_ELSE( ({    return (enum clang::ExprValueKind)__reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::getValueKind, Xs...); }) , (;) )
  /// getObjectKind - The object kind that this expression produces.
  /// Object kinds are meaningful only for expressions that yield an
  /// l-value or x-value.
  constexpr enum clang::ExprObjectKind getObjectKind() const IFMETA_ELSE( ({    return (enum clang::ExprObjectKind)__reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::getObjectKind, Xs...); }) , (;) )
  constexpr bool isOrdinaryOrBitFieldObject() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isOrdinaryOrBitFieldObject, Xs...); }) , (;) )
  /// Returns true if this expression is a gl-value that
  /// potentially refers to a bit-field.
  ///
  /// In C++, whether a gl-value refers to a bitfield is essentially
  /// an aspect of the value-kind type system.
  constexpr bool refersToBitField() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::refersToBitField, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FieldDecl *) )
  getSourceBitField() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::getSourceBitField, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Decl *) )
  getReferencedDeclOfCallee() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::getReferencedDeclOfCallee, Xs...); }) , (;) )
  /// If this expression is an l-value for an Objective C
  /// property, find the underlying property reference expression.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCPropertyRefExpr *) )
  getObjCProperty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::getObjCProperty, Xs...); }) , (;) )
  /// Check if this expression is the ObjC 'self' implicit parameter.
  constexpr bool isObjCSelfExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isObjCSelfExpr, Xs...); }) , (;) )
  /// Returns whether this expression refers to a vector element.
  constexpr bool refersToVectorElement() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::refersToVectorElement, Xs...); }) , (;) )
  /// Returns whether this expression refers to a global register
  /// variable.
  constexpr bool refersToGlobalRegisterVar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::refersToGlobalRegisterVar, Xs...); }) , (;) )
  /// Returns whether this expression has a placeholder type.
  constexpr bool hasPlaceholderType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::hasPlaceholderType, Xs...); }) , (;) )
  /// Returns whether this expression has a specific placeholder type.
  constexpr bool hasPlaceholderType(enum clang::BuiltinType::Kind K) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::hasPlaceholderType1, Xs..., K); }) , (;) )
  /// isKnownToHaveBooleanValue - Return true if this is an integer expression
  /// that is known to return 0 or 1.  This happens for _Bool/bool expressions
  /// but also int expressions which are produced by things like comparisons in
  /// C.
  constexpr bool isKnownToHaveBooleanValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isKnownToHaveBooleanValue, Xs...); }) , (;) )
  /// isIntegerConstantExpr - Return true if this expression is a valid integer
  /// constant expression, and, if so, return its value in Result.  If not a
  /// valid i-c-e, return false and fill in Loc (if specified) with the location
  /// of the invalid expression.
  ///
  /// Note: This does not perform the implicit conversions required by C++11
  /// [expr.const]p5.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr bool isIntegerConstantExpr(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::APSInt &)) Result, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Ctx, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::SourceLocation *)) Loc = {}, bool isEvaluated = true) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isIntegerConstantExpr, Xs..., Y0s..., Y1s..., Y2s..., isEvaluated); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  constexpr bool isIntegerConstantExpr(Y0 p0, Y1 p1, ptrwrp<Y2> p2 = {}, bool p3 = true) const {
      return isIntegerConstantExpr(p0, p1, p2.get(), p3);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isIntegerConstantExpr(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::SourceLocation *)) Loc = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isIntegerConstantExpr1, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr bool isIntegerConstantExpr(Y0 p0, ptrwrp<Y1> p1 = {}) const {
      return isIntegerConstantExpr(p0, p1.get());
  }), () )
  /// isCXX98IntegralConstantExpr - Return true if this expression is an
  /// integral constant expression in C++98. Can only be used in C++.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isCXX98IntegralConstantExpr(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isCXX98IntegralConstantExpr, Xs..., Y0s...); }) , (;) )
  /// isCXX11ConstantExpr - Return true if this expression is a constant
  /// expression in C++11. Can only be used in C++.
  ///
  /// Note: This does not perform the implicit conversions required by C++11
  /// [expr.const]p5.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr bool isCXX11ConstantExpr(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx, IFMETA_ELSE((const clang::APValue::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::APValue *)) Result = {}, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::SourceLocation *)) Loc = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isCXX11ConstantExpr, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  constexpr bool isCXX11ConstantExpr(Y0 p0, ptrwrp<Y1> p1 = {}, ptrwrp<Y2> p2 = {}) const {
      return isCXX11ConstantExpr(p0, p1.get(), p2.get());
  }), () )
  /// isConstantInitializer - Returns true if this expression can be emitted to
  /// IR as a constant, and thus can be used as a constant initializer in C.
  /// If this expression is not constant and Culprit is non-null,
  /// it is used to store the address of first non constant expr.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isConstantInitializer(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx, bool ForRef, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y1s...> * *), (const typename meta::clang::Expr **)) Culprit = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isConstantInitializer, Xs..., Y0s..., ForRef, Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr bool isConstantInitializer(Y0 p0, bool p1, ptrwrp<Y1> p2 = {}) const {
      return isConstantInitializer(p0, p1, p2.get());
  }), () )
  M_template_rtpack(Zs) using EvalStatus = struct refldetail::clang::Expr::EvalStatus::M_template impl M_targpack(Zs);
  M_template_rtpack(Zs) using EvalResult = struct refldetail::clang::Expr::EvalResult::M_template impl M_targpack(Zs);
  /// EvaluateAsRValue - Return true if this is a constant which we can fold to
  /// an rvalue using any crazy technique (that has nothing to do with language
  /// standards) that we want to, even if the expression has side-effects. If
  /// this function returns true, it returns the folded constant in Result. If
  /// the expression is a glvalue, an lvalue-to-rvalue conversion will be
  /// applied.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool EvaluateAsRValue(IFMETA_ELSE((const clang::Expr::EvalResult::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::Expr::EvalResult &)) Result, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::EvaluateAsRValue, Xs..., Y0s..., Y1s...); }) , (;) )
  using SideEffectsKind = enum refldetail::clang::Expr::SideEffectsKind;
  /// EvaluateAsInt - Return true if this is a constant which we can fold and
  /// convert to an integer, using any crazy technique that we want to.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool EvaluateAsInt(IFMETA_ELSE((const llvm::APSInt::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::APSInt &)) Result, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Ctx, enum clang::Expr::SideEffectsKind AllowSideEffects = SE_NoSideEffects) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::EvaluateAsInt, Xs..., Y0s..., Y1s..., AllowSideEffects); }) , (;) )
  /// EvaluateAsString - Return true if this is a constant which we can fold and
  /// convert to a string literal.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool EvaluateAsString(IFMETA_ELSE((const clang::StringLiteral::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::StringLiteral *&)) StrLitResult, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Ctx, enum clang::Expr::SideEffectsKind AllowSideEffects = SE_NoSideEffects) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::EvaluateAsString, Xs..., Y0s..., Y1s..., AllowSideEffects); }) , (;) )
  /// Returns whether the expression was completely folded.
  /// We use this in EvaluateConstexprDecl.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool EvaluateAsVoid(IFMETA_ELSE((const clang::Expr::EvalResult::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::Expr::EvalResult &)) Result, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::EvaluateAsVoid, Xs..., Y0s..., Y1s...); }) , (;) )
  /// EvaluateAsFloat - Return true if this is a constant which we can fold and
  /// convert to a floating point value, using any crazy technique that we
  /// want to.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool EvaluateAsFloat(IFMETA_ELSE((const llvm::APFloat::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::APFloat &)) Result, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Ctx, enum clang::Expr::SideEffectsKind AllowSideEffects = SE_NoSideEffects) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::EvaluateAsFloat, Xs..., Y0s..., Y1s..., AllowSideEffects); }) , (;) )
  /// isEvaluatable - Call EvaluateAsRValue to see if this expression can be
  /// constant folded without side-effects, but discard the result.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isEvaluatable(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx, enum clang::Expr::SideEffectsKind AllowSideEffects = SE_NoSideEffects) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isEvaluatable, Xs..., Y0s..., AllowSideEffects); }) , (;) )
  /// HasSideEffects - This routine returns true for all those expressions
  /// which have any effect other than producing a value. Example is a function
  /// call, volatile variable read, or throwing an exception. If
  /// IncludePossibleEffects is false, this call treats certain expressions with
  /// potential side effects (such as function call-like expressions,
  /// instantiation-dependent expressions, or invocations from a macro) as not
  /// having side effects.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool HasSideEffects(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx, bool IncludePossibleEffects = true) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::HasSideEffects, Xs..., Y0s..., IncludePossibleEffects); }) , (;) )
  /// Determine whether this expression involves a call to any function
  /// that is not trivial.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool hasNonTrivialCall(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::hasNonTrivialCall, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void EvaluateForOverflow(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::EvaluateForOverflow, Xs..., Y0s...); }) , (;) )
  /// EvaluateAsLValue - Evaluate an expression to see if we can fold it to an
  /// lvalue with link time known address, with no side-effects.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool EvaluateAsLValue(IFMETA_ELSE((const clang::Expr::EvalResult::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::Expr::EvalResult &)) Result, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::EvaluateAsLValue, Xs..., Y0s..., Y1s...); }) , (;) )
  using ConstExprUsage = enum refldetail::clang::Expr::ConstExprUsage;
  /// Evaluate an expression that is required to be a constant expression.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool EvaluateAsConstantExpr(IFMETA_ELSE((const clang::Expr::EvalResult::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::Expr::EvalResult &)) Result, enum clang::Expr::ConstExprUsage Usage, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::EvaluateAsConstantExpr, Xs..., Y0s..., Usage, Y1s...); }) , (;) )
  using NullPointerConstantKind = enum refldetail::clang::Expr::NullPointerConstantKind;
  using NullPointerConstantValueDependence = enum refldetail::clang::Expr::NullPointerConstantValueDependence;
  /// isNullPointerConstant - C99 6.3.2.3p3 - Test if this reduces down to
  /// a Null pointer constant. The return value can further distinguish the
  /// kind of NULL pointer constant that was detected.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr enum clang::Expr::NullPointerConstantKind isNullPointerConstant(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx, enum clang::Expr::NullPointerConstantValueDependence NPC) const IFMETA_ELSE( ({    return (enum clang::Expr::NullPointerConstantKind)__reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isNullPointerConstant, Xs..., Y0s..., NPC); }) , (;) )
  /// isOBJCGCCandidate - Return true if this expression may be used in a read/
  /// write barrier.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isOBJCGCCandidate(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isOBJCGCCandidate, Xs..., Y0s...); }) , (;) )
  /// Returns true if this expression is a bound member function.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isBoundMemberFunction(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isBoundMemberFunction, Xs..., Y0s...); }) , (;) )
  /// Given an expression of bound-member type, find the type
  /// of the member.  Returns null if this is an *overloaded* bound
  /// member expression.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  findBoundMemberType(IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Expr *)) expr) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::findBoundMemberType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  findBoundMemberType(ptrwrp<Y0> p0) {
      return findBoundMemberType(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  IgnoreImplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::IgnoreImplicit, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  IgnoreConversionOperator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::IgnoreConversionOperator, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  IgnoreParenImpCasts() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::IgnoreParenImpCasts, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  IgnoreParenLValueCasts() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::IgnoreParenLValueCasts, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  ignoreParenBaseCasts() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::ignoreParenBaseCasts, Xs...); }) , (;) )
  /// Determine whether this expression is a default function argument.
  ///
  /// Default arguments are implicitly generated in the abstract syntax tree
  /// by semantic analysis for function calls, object constructions, etc. in
  /// C++. Default arguments are represented by \c CXXDefaultArgExpr nodes;
  /// this routine also looks through any implicit casts to determine whether
  /// the expression is a default argument.
  constexpr bool isDefaultArgument() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isDefaultArgument, Xs...); }) , (;) )
  /// Determine whether the result of this expression is a
  /// temporary object of the given class type.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isTemporaryObject(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx, IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::CXXRecordDecl *)) TempTy) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isTemporaryObject, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr bool isTemporaryObject(Y0 p0, ptrwrp<Y1> p1) const {
      return isTemporaryObject(p0, p1.get());
  }), () )
  /// Whether this expression is an implicit reference to 'this' in C++.
  constexpr bool isImplicitCXXThis() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::isImplicitCXXThis, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  IgnoreImpCasts() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::IgnoreImpCasts, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  IgnoreParens() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::IgnoreParens, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  IgnoreParenCasts() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::IgnoreParenCasts, Xs...); }) , (;) )
  /// Strip off casts, but keep parentheses.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  IgnoreCasts() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::IgnoreCasts, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  IgnoreParenNoopCasts(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::IgnoreParenNoopCasts, Xs..., Y0s...); }) , (;) )
  /// For an expression of class type or pointer to class type,
  /// return the most derived class decl the expression is known to refer to.
  ///
  /// If this expression is a cast, this method looks through it to find the
  /// most derived decl that can be inferred from the expression.
  /// This is valid because derived-to-base conversions have undefined
  /// behavior if the object isn't dynamically of the derived type.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXRecordDecl *) )
  getBestDynamicClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::getBestDynamicClassType, Xs...); }) , (;) )
  /// Get the inner expression that determines the best dynamic class.
  /// If this is a prvalue, we guarantee that it is of the most-derived type
  /// for the object itself.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getBestDynamicClassTypeExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::getBestDynamicClassTypeExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  skipRValueSubobjectAdjustments() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::skipRValueSubobjectAdjustments, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr, reflenums::clang__Expr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// The various classification results. Most of these mean prvalue.
enum clang::Expr::Classification::Kinds : unsigned int {
  CL_LValue,
  CL_XValue,
  CL_Function,
  CL_Void,
  CL_AddressableVoid,
  CL_DuplicateVectorComponents,
  CL_MemberFunction,
  CL_SubObjCPropertySetting,
  CL_ClassTemporary,
  CL_ArrayTemporary,
  CL_ObjCMessageRValue,
  CL_PRValue,
};

/// The results of modification testing.
enum clang::Expr::Classification::ModifiableType : unsigned int {
  CM_Untested,
  CM_Modifiable,
  CM_RValue,
  CM_Function,
  CM_LValueCast,
  CM_NoSetterProperty,
  CM_ConstQualified,
  CM_ConstQualifiedField,
  CM_ConstAddrSpace,
  CM_ArrayType,
  CM_IncompleteType,
};

/// The return type of classify(). Represents the C++11 expression
  ///        taxonomy.
M_template_rtpack(Xs)
struct clang::Expr::Classification::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Expr__Classification;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Expr::Classification::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using Kinds = enum refldetail::clang::Expr::Classification::Kinds;
  using ModifiableType = enum refldetail::clang::Expr::Classification::ModifiableType;
  constexpr enum clang::Expr::Classification::Kinds getKind() const IFMETA_ELSE( ({    return (enum clang::Expr::Classification::Kinds)__reflect_prop(reflenums::RK_clang__Expr__Classification, reflenums::clang__Expr__Classification::getKind, Xs...); }) , (;) )
  constexpr enum clang::Expr::Classification::ModifiableType getModifiable() const IFMETA_ELSE( ({    return (enum clang::Expr::Classification::ModifiableType)__reflect_prop(reflenums::RK_clang__Expr__Classification, reflenums::clang__Expr__Classification::getModifiable, Xs...); }) , (;) )
  constexpr bool isLValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr__Classification, reflenums::clang__Expr__Classification::isLValue, Xs...); }) , (;) )
  constexpr bool isXValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr__Classification, reflenums::clang__Expr__Classification::isXValue, Xs...); }) , (;) )
  constexpr bool isGLValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr__Classification, reflenums::clang__Expr__Classification::isGLValue, Xs...); }) , (;) )
  constexpr bool isPRValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr__Classification, reflenums::clang__Expr__Classification::isPRValue, Xs...); }) , (;) )
  constexpr bool isRValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr__Classification, reflenums::clang__Expr__Classification::isRValue, Xs...); }) , (;) )
  constexpr bool isModifiable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr__Classification, reflenums::clang__Expr__Classification::isModifiable, Xs...); }) , (;) )
  /// Create a simple, modifiably lvalue
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr::Classification) )
  makeSimpleLValue() IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr__Classification, reflenums::clang__Expr__Classification::makeSimpleLValue, Xs...); }) , (;) )
};

/// EvalStatus is a struct with detailed info about an evaluation in progress.
M_template_rtpack(Xs)
struct clang::Expr::EvalStatus::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Expr__EvalStatus;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Expr::EvalStatus::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Whether the evaluated expression has side effects.
    /// For example, (f() && 0) can be folded, but it still has side effects.
  bool HasSideEffects
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Expr__EvalStatus, reflenums::clang__Expr__EvalStatus::HasSideEffects, Xs...);), (;) )
  /// Whether the evaluation hit undefined behavior.
    /// For example, 1.0 / 0.0 can be folded to Inf, but has undefined behavior.
    /// Likewise, INT_MAX + 1 can be folded to INT_MIN, but has UB.
  bool HasUndefinedBehavior
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__Expr__EvalStatus, reflenums::clang__Expr__EvalStatus::HasUndefinedBehavior, Xs...);), (;) )
  constexpr bool hasSideEffects() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr__EvalStatus, reflenums::clang__Expr__EvalStatus::hasSideEffects, Xs...); }) , (;) )
};

/// EvalResult is a struct with detailed info about an evaluated expression.
M_template_rtpack(Xs)
struct clang::Expr::EvalResult::impl : impl_offset_t<clang::Expr::EvalStatus, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Expr__EvalResult;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Expr::EvalResult::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isGlobalLValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Expr__EvalResult, reflenums::clang__Expr__EvalResult::isGlobalLValue, Xs...); }) , (;) )
};

/// OpaqueValueExpr - An expression referring to an opaque object of a
/// fixed type and value class.  These don't correspond to concrete
/// syntax; instead they're used to express operations (usually copy
/// operations) on values whose source is generally obvious from
/// context.
M_template_rtpack(Xs)
struct clang::OpaqueValueExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OpaqueValueExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OpaqueValueExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Given an expression which invokes a copy constructor --- i.e.  a
  /// CXXConstructExpr, possibly wrapped in an ExprWithCleanups ---
  /// find the OpaqueValueExpr that's the source of the construction.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (const typename meta::clang::OpaqueValueExpr *) )
  findInCopyConstruct(IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Expr *)) expr) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpaqueValueExpr, reflenums::clang__OpaqueValueExpr::findInCopyConstruct, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr IFMETA_ELSE( (auto), (const typename meta::clang::OpaqueValueExpr *) )
  findInCopyConstruct(ptrwrp<Y0> p0) {
      return findInCopyConstruct(p0.get());
  }), () )
  /// Retrieve the location of this expression.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpaqueValueExpr, reflenums::clang__OpaqueValueExpr::getLocation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpaqueValueExpr, reflenums::clang__OpaqueValueExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpaqueValueExpr, reflenums::clang__OpaqueValueExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpaqueValueExpr, reflenums::clang__OpaqueValueExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpaqueValueExpr, reflenums::clang__OpaqueValueExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpaqueValueExpr, reflenums::clang__OpaqueValueExpr::getExprLoc, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::OpaqueValueExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__OpaqueValueExpr, reflenums::clang__OpaqueValueExpr::children, Xs...), () )
  /// The source expression of an opaque value expression is the
  /// expression which originally generated the value.  This is
  /// provided as a convenience for analyses that don't wish to
  /// precisely model the execution behavior of the program.
  ///
  /// The source expression is typically set when building the
  /// expression which binds the opaque value expression in the first
  /// place.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSourceExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpaqueValueExpr, reflenums::clang__OpaqueValueExpr::getSourceExpr, Xs...); }) , (;) )
  constexpr bool isUnique() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpaqueValueExpr, reflenums::clang__OpaqueValueExpr::isUnique, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OpaqueValueExpr, reflenums::clang__OpaqueValueExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A reference to a declared variable, function, enum, etc.
/// [C99 6.5.1p2]
///
/// This encodes all the information about how a declaration is referenced
/// within an expression.
///
/// There are several optional constructs attached to DeclRefExprs only when
/// they apply in order to conserve memory. These are laid out past the end of
/// the object, and flags in the DeclRefExprBitfield track whether they exist:
///
///   DeclRefExprBits.HasQualifier:
///       Specifies when this declaration reference expression has a C++
///       nested-name-specifier.
///   DeclRefExprBits.HasFoundDecl:
///       Specifies when this declaration reference expression has a record of
///       a NamedDecl (different from the referenced ValueDecl) which was found
///       during name lookup and/or overload resolution.
///   DeclRefExprBits.HasTemplateKWAndArgsInfo:
///       Specifies when this declaration reference expression has an explicit
///       C++ template keyword and/or template argument list.
///   DeclRefExprBits.RefersToEnclosingVariableOrCapture
///       Specifies when this declaration reference expression (validly)
///       refers to an enclosed local or a captured variable.
M_template_rtpack(Xs)
struct clang::DeclRefExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DeclRefExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DeclRefExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclRefExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::NestedNameSpecifierLoc)) QualifierLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) TemplateKWLoc, IFMETA_ELSE((const clang::ValueDecl::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::ValueDecl *)) D, bool RefersToEnclosingVariableOrCapture, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::SourceLocation)) NameLoc, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::QualType)) T, enum clang::ExprValueKind VK, IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::NamedDecl *)) FoundD = {}, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y7s...> *), (const typename meta::clang::TemplateArgumentListInfo *)) TemplateArgs = {}) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., RefersToEnclosingVariableOrCapture, Y4s..., Y5s..., VK, Y6s..., Y7s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclRefExpr *) )
  Create(Y0 p0, Y1 p1, Y2 p2, ptrwrp<Y3> p3, bool p4, Y4 p5, Y5 p6, enum clang::ExprValueKind p7, ptrwrp<Y6> p8 = {}, ptrwrp<Y7> p9 = {}) {
      return Create(p0, p1, p2, p3.get(), p4, p5, p6, p7, p8.get(), p9.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclRefExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::NestedNameSpecifierLoc)) QualifierLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) TemplateKWLoc, IFMETA_ELSE((const clang::ValueDecl::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::ValueDecl *)) D, bool RefersToEnclosingVariableOrCapture, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/1, Y4s...>), (const typename meta::clang::DeclarationNameInfo &)) NameInfo, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::QualType)) T, enum clang::ExprValueKind VK, IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::NamedDecl *)) FoundD = {}, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y7s...> *), (const typename meta::clang::TemplateArgumentListInfo *)) TemplateArgs = {}) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::Create1, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., RefersToEnclosingVariableOrCapture, Y4s..., Y5s..., VK, Y6s..., Y7s...); }) , (;) )
  /// Construct an empty declaration reference expression.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclRefExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, bool HasQualifier, bool HasFoundDecl, bool HasTemplateKWAndArgsInfo, unsigned int NumTemplateArgs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::CreateEmpty, Xs..., Y0s..., HasQualifier, HasFoundDecl, HasTemplateKWAndArgsInfo, NumTemplateArgs); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ValueDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationNameInfo) )
  getNameInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getNameInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getLocation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getEndLoc, Xs...); }) , (;) )
  /// Determine whether this declaration reference was preceded by a
  /// C++ nested-name-specifier, e.g., \c N::foo.
  constexpr bool hasQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::hasQualifier, Xs...); }) , (;) )
  /// If the name was qualified, retrieves the nested-name-specifier
  /// that precedes the name, with source-location information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getQualifierLoc, Xs...); }) , (;) )
  /// If the name was qualified, retrieves the nested-name-specifier
  /// that precedes the name. Otherwise, returns NULL.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getQualifier, Xs...); }) , (;) )
  /// Get the NamedDecl through which this reference occurred.
  /// See non-const variant.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamedDecl *) )
  getFoundDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getFoundDecl, Xs...); }) , (;) )
  constexpr bool hasTemplateKWAndArgsInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::hasTemplateKWAndArgsInfo, Xs...); }) , (;) )
  /// Retrieve the location of the template keyword preceding
  /// this name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTemplateKeywordLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getTemplateKeywordLoc, Xs...); }) , (;) )
  /// Retrieve the location of the left angle bracket starting the
  /// explicit template argument list following the name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getLAngleLoc, Xs...); }) , (;) )
  /// Retrieve the location of the right angle bracket ending the
  /// explicit template argument list following the name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getRAngleLoc, Xs...); }) , (;) )
  /// Determines whether the name in this declaration reference
  /// was preceded by the template keyword.
  constexpr bool hasTemplateKeyword() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::hasTemplateKeyword, Xs...); }) , (;) )
  /// Determines whether this declaration reference was followed by an
  /// explicit template argument list.
  constexpr bool hasExplicitTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::hasExplicitTemplateArgs, Xs...); }) , (;) )
  /// Copies the template arguments (if present) into the given
  /// structure.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void copyTemplateArgumentsInto(IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::TemplateArgumentListInfo &)) List) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::copyTemplateArgumentsInto, Xs..., Y0s...); }) , (;) )
  /// Retrieve the template arguments provided as part of this
  /// template-id.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentLoc *) )
  getTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getTemplateArgs, Xs...); }) , (;) )
  /// Retrieve the number of template arguments provided as part of this
  /// template-id.
  constexpr unsigned int getNumTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::getNumTemplateArgs, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::DeclRefExpr, template_arguments,
      constexpr auto template_arguments() const ,
      (typename meta::clang::TemplateArgumentLoc),
      (reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::template_arguments, Xs...), () )
  /// Returns true if this expression refers to a function that
  /// was resolved from an overloaded set having size greater than 1.
  constexpr bool hadMultipleCandidates() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::hadMultipleCandidates, Xs...); }) , (;) )
  /// Does this DeclRefExpr refer to an enclosing local or a captured
  /// variable?
  constexpr bool refersToEnclosingVariableOrCapture() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::refersToEnclosingVariableOrCapture, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::DeclRefExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__DeclRefExpr, reflenums::clang__DeclRefExpr::children, Xs...), () )
};

enum clang::PredefinedExpr::IdentType : unsigned int {
  Func,
  Function,
  LFunction,
  FuncDName,
  FuncSig,
  LFuncSig,
  PrettyFunction,
  /// The same as PrettyFunction, except that the
  /// 'virtual' keyword is omitted for virtual member functions.
  PrettyFunctionNoVirtual,
};

/// [C99 6.4.2.2] - A predefined identifier such as __func__.
M_template_rtpack(Xs)
struct clang::PredefinedExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__PredefinedExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::PredefinedExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using IdentType = enum refldetail::clang::PredefinedExpr::IdentType;
  constexpr enum clang::PredefinedExpr::IdentType getIdentType() const IFMETA_ELSE( ({    return (enum clang::PredefinedExpr::IdentType)__reflect_prop(reflenums::RK_clang__PredefinedExpr, reflenums::clang__PredefinedExpr::getIdentType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PredefinedExpr, reflenums::clang__PredefinedExpr::getLocation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::StringLiteral *) )
  getFunctionName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PredefinedExpr, reflenums::clang__PredefinedExpr::getFunctionName, Xs...); }) , (;) )
  static constexpr const char * getIdentTypeName(enum clang::PredefinedExpr::IdentType IT) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PredefinedExpr, reflenums::clang__PredefinedExpr::getIdentTypeName, Xs..., IT); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr const char * ComputeName(enum clang::PredefinedExpr::IdentType IT, IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) CurrentDecl) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PredefinedExpr, reflenums::clang__PredefinedExpr::ComputeName, Xs..., IT, Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr const char * ComputeName(enum clang::PredefinedExpr::IdentType p0, ptrwrp<Y0> p1) {
      return ComputeName(p0, p1.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PredefinedExpr, reflenums::clang__PredefinedExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PredefinedExpr, reflenums::clang__PredefinedExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PredefinedExpr, reflenums::clang__PredefinedExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PredefinedExpr, reflenums::clang__PredefinedExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PredefinedExpr, reflenums::clang__PredefinedExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::PredefinedExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__PredefinedExpr, reflenums::clang__PredefinedExpr::children, Xs...), () )
};

M_template_rtpack(Xs)
struct clang::APIntStorage::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__APIntStorage;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::APIntStorage::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
};

M_template_rtpack(Xs)
struct clang::IntegerLiteral::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)>, impl_offset_t<clang::APIntStorage, 16 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__IntegerLiteral;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::IntegerLiteral::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Returns a new integer literal with value 'V' and type 'type'.
  /// \param type - either IntTy, LongTy, LongLongTy, UnsignedIntTy,
  /// UnsignedLongTy, or UnsignedLongLongTy which should match the size of V
  /// \param V - the value that the returned integer literal contains.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::IntegerLiteral *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::APInt &)) V, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) type, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) l) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IntegerLiteral, reflenums::clang__IntegerLiteral::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s...); }) , (;) )
  /// Returns a new empty integer literal.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::IntegerLiteral *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) Empty) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IntegerLiteral, reflenums::clang__IntegerLiteral::Create1, Xs..., Y0s..., Y1s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IntegerLiteral, reflenums::clang__IntegerLiteral::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IntegerLiteral, reflenums::clang__IntegerLiteral::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IntegerLiteral, reflenums::clang__IntegerLiteral::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IntegerLiteral, reflenums::clang__IntegerLiteral::getEndLoc, Xs...); }) , (;) )
  /// Retrieve the location of the literal.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IntegerLiteral, reflenums::clang__IntegerLiteral::getLocation, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__IntegerLiteral, reflenums::clang__IntegerLiteral::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::IntegerLiteral, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__IntegerLiteral, reflenums::clang__IntegerLiteral::children, Xs...), () )
};

M_template_rtpack(Xs)
struct clang::FixedPointLiteral::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)>, impl_offset_t<clang::APIntStorage, 16 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FixedPointLiteral;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FixedPointLiteral::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FixedPointLiteral *) )
  CreateFromRawInt(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const llvm::APInt::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::APInt &)) V, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) type, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) l, unsigned int Scale) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FixedPointLiteral, reflenums::clang__FixedPointLiteral::CreateFromRawInt, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Scale); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FixedPointLiteral, reflenums::clang__FixedPointLiteral::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FixedPointLiteral, reflenums::clang__FixedPointLiteral::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FixedPointLiteral, reflenums::clang__FixedPointLiteral::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FixedPointLiteral, reflenums::clang__FixedPointLiteral::getEndLoc, Xs...); }) , (;) )
  /// \brief Retrieve the location of the literal.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FixedPointLiteral, reflenums::clang__FixedPointLiteral::getLocation, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FixedPointLiteral, reflenums::clang__FixedPointLiteral::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  constexpr const char * getValueAsString(unsigned int Radix) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FixedPointLiteral, reflenums::clang__FixedPointLiteral::getValueAsString, Xs..., Radix); }) , (;) )
  RANGE_REFLECTION(clang::FixedPointLiteral, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__FixedPointLiteral, reflenums::clang__FixedPointLiteral::children, Xs...), () )
};

enum clang::CharacterLiteral::CharacterKind : unsigned int {
  Ascii,
  Wide,
  UTF8,
  UTF16,
  UTF32,
};

M_template_rtpack(Xs)
struct clang::CharacterLiteral::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CharacterLiteral;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CharacterLiteral::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using CharacterKind = enum refldetail::clang::CharacterLiteral::CharacterKind;
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharacterLiteral, reflenums::clang__CharacterLiteral::getLocation, Xs...); }) , (;) )
  constexpr enum clang::CharacterLiteral::CharacterKind getKind() const IFMETA_ELSE( ({    return (enum clang::CharacterLiteral::CharacterKind)__reflect_prop(reflenums::RK_clang__CharacterLiteral, reflenums::clang__CharacterLiteral::getKind, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharacterLiteral, reflenums::clang__CharacterLiteral::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharacterLiteral, reflenums::clang__CharacterLiteral::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharacterLiteral, reflenums::clang__CharacterLiteral::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharacterLiteral, reflenums::clang__CharacterLiteral::getEndLoc, Xs...); }) , (;) )
  constexpr unsigned int getValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharacterLiteral, reflenums::clang__CharacterLiteral::getValue, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CharacterLiteral, reflenums::clang__CharacterLiteral::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::CharacterLiteral, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__CharacterLiteral, reflenums::clang__CharacterLiteral::children, Xs...), () )
};

M_template_rtpack(Xs)
struct clang::FloatingLiteral::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FloatingLiteral;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FloatingLiteral::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FloatingLiteral *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const llvm::APFloat::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::llvm::APFloat &)) V, bool isexact, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) Type, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) L) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FloatingLiteral, reflenums::clang__FloatingLiteral::Create, Xs..., Y0s..., Y1s..., isexact, Y2s..., Y3s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FloatingLiteral *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) Empty) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FloatingLiteral, reflenums::clang__FloatingLiteral::Create1, Xs..., Y0s..., Y1s...); }) , (;) )
  constexpr bool isExact() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FloatingLiteral, reflenums::clang__FloatingLiteral::isExact, Xs...); }) , (;) )
  /// getValueAsApproximateDouble - This returns the value as an inaccurate
  /// double.  Note that this may cause loss of precision, but is useful for
  /// debugging dumps, etc.
  constexpr double getValueAsApproximateDouble() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FloatingLiteral, reflenums::clang__FloatingLiteral::getValueAsApproximateDouble, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FloatingLiteral, reflenums::clang__FloatingLiteral::getLocation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FloatingLiteral, reflenums::clang__FloatingLiteral::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FloatingLiteral, reflenums::clang__FloatingLiteral::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FloatingLiteral, reflenums::clang__FloatingLiteral::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FloatingLiteral, reflenums::clang__FloatingLiteral::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FloatingLiteral, reflenums::clang__FloatingLiteral::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::FloatingLiteral, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__FloatingLiteral, reflenums::clang__FloatingLiteral::children, Xs...), () )
};

/// ImaginaryLiteral - We support imaginary integer and floating point literals,
/// like "1.0i".  We represent these as a wrapper around FloatingLiteral and
/// IntegerLiteral classes.  Instances of this class always have a Complex type
/// whose element type matches the subexpression.
///
M_template_rtpack(Xs)
struct clang::ImaginaryLiteral::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ImaginaryLiteral;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ImaginaryLiteral::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSubExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImaginaryLiteral, reflenums::clang__ImaginaryLiteral::getSubExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImaginaryLiteral, reflenums::clang__ImaginaryLiteral::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImaginaryLiteral, reflenums::clang__ImaginaryLiteral::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImaginaryLiteral, reflenums::clang__ImaginaryLiteral::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImaginaryLiteral, reflenums::clang__ImaginaryLiteral::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImaginaryLiteral, reflenums::clang__ImaginaryLiteral::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::ImaginaryLiteral, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__ImaginaryLiteral, reflenums::clang__ImaginaryLiteral::children, Xs...), () )
};

enum clang::StringLiteral::StringKind : unsigned int {
  Ascii,
  Wide,
  UTF8,
  UTF16,
  UTF32,
};

/// StringLiteral - This represents a string literal expression, e.g. "foo"
/// or L"bar" (wide strings).  The actual string is returned by getBytes()
/// is NOT null-terminated, and the length of the string is determined by
/// calling getByteLength().  The C type for a string is always a
/// ConstantArrayType.  In C++, the char type is const qualified, in C it is
/// not.
///
/// Note that strings in C can be formed by concatenation of multiple string
/// literal pptokens in translation phase #6.  This keeps track of the locations
/// of each of these pieces.
///
/// Strings in C can also be truncated and extended by assigning into arrays,
/// e.g. with constructs like:
///   char X[2] = "foobar";
/// In this case, getByteLength() will return 6, but the string literal will
/// have type "char[2]".
M_template_rtpack(Xs)
struct clang::StringLiteral::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__StringLiteral;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::StringLiteral::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using StringKind = enum refldetail::clang::StringLiteral::StringKind;
  /// Construct an empty string literal.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::StringLiteral *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumStrs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::CreateEmpty, Xs..., Y0s..., NumStrs); }) , (;) )
  constexpr const char * getString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getString, Xs...); }) , (;) )
  /// Allow access to clients that need the byte representation, such as
  /// ASTWriterStmt::VisitStringLiteral().
  constexpr const char * getBytes() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getBytes, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void outputString(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::outputString, Xs..., Y0s...); }) , (;) )
  constexpr unsigned int getCodeUnit(unsigned long i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getCodeUnit, Xs..., i); }) , (;) )
  constexpr unsigned int getByteLength() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getByteLength, Xs...); }) , (;) )
  constexpr unsigned int getLength() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getLength, Xs...); }) , (;) )
  constexpr unsigned int getCharByteWidth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getCharByteWidth, Xs...); }) , (;) )
  constexpr enum clang::StringLiteral::StringKind getKind() const IFMETA_ELSE( ({    return (enum clang::StringLiteral::StringKind)__reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getKind, Xs...); }) , (;) )
  constexpr bool isAscii() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::isAscii, Xs...); }) , (;) )
  constexpr bool isWide() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::isWide, Xs...); }) , (;) )
  constexpr bool isUTF8() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::isUTF8, Xs...); }) , (;) )
  constexpr bool isUTF16() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::isUTF16, Xs...); }) , (;) )
  constexpr bool isUTF32() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::isUTF32, Xs...); }) , (;) )
  constexpr bool isPascal() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::isPascal, Xs...); }) , (;) )
  constexpr bool containsNonAscii() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::containsNonAscii, Xs...); }) , (;) )
  constexpr bool containsNonAsciiOrNull() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::containsNonAsciiOrNull, Xs...); }) , (;) )
  /// getNumConcatenated - Get the number of string literal tokens that were
  /// concatenated in translation phase #6 to form this string literal.
  constexpr unsigned int getNumConcatenated() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getNumConcatenated, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getStrTokenLoc(unsigned int TokNum) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getStrTokenLoc, Xs..., TokNum); }) , (;) )
  /// getLocationOfByte - Return a source location that points to the specified
  /// byte of this string literal.
  ///
  /// Strings are amazingly complex.  They can be formed from multiple tokens
  /// and can have escape sequences in them in addition to the usual trigraph
  /// and escaped newline business.  This routine handles this complexity.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocationOfByte(unsigned int ByteNo, IFMETA_ELSE((const clang::SourceManager::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::SourceManager &)) SM, IFMETA_ELSE((const clang::LangOptions::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::LangOptions &)) Features, IFMETA_ELSE((const clang::TargetInfo::template impl</*ptrorref=*/1, Y2s...>), (const typename meta::clang::TargetInfo &)) Target, unsigned int * StartToken = nullptr, unsigned int * StartTokenByteOffset = nullptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getLocationOfByte, Xs..., ByteNo, Y0s..., Y1s..., Y2s..., StartToken, StartTokenByteOffset); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::StringLiteral, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__StringLiteral, reflenums::clang__StringLiteral::children, Xs...), () )
};

/// ParenExpr - This represents a parethesized expression, e.g. "(1)".  This
/// AST node is only formed if full location information is requested.
M_template_rtpack(Xs)
struct clang::ParenExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ParenExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ParenExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSubExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenExpr, reflenums::clang__ParenExpr::getSubExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenExpr, reflenums::clang__ParenExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenExpr, reflenums::clang__ParenExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenExpr, reflenums::clang__ParenExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenExpr, reflenums::clang__ParenExpr::getEndLoc, Xs...); }) , (;) )
  /// Get the location of the left parentheses '('.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLParen() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenExpr, reflenums::clang__ParenExpr::getLParen, Xs...); }) , (;) )
  /// Get the location of the right parentheses ')'.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParen() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenExpr, reflenums::clang__ParenExpr::getRParen, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenExpr, reflenums::clang__ParenExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::ParenExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__ParenExpr, reflenums::clang__ParenExpr::children, Xs...), () )
};

/// UnaryOperator - This represents the unary-expression's (except sizeof and
/// alignof), the postinc/postdec operators from postfix-expression, and various
/// extensions.
///
/// Notes on various nodes:
///
/// Real/Imag - These return the real/imag part of a complex operand.  If
///   applied to a non-complex value, the former returns its operand and the
///   later returns zero in the type of the operand.
///
M_template_rtpack(Xs)
struct clang::UnaryOperator::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UnaryOperator;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UnaryOperator::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr enum clang::UnaryOperatorKind getOpcode() const IFMETA_ELSE( ({    return (enum clang::UnaryOperatorKind)__reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::getOpcode, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSubExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::getSubExpr, Xs...); }) , (;) )
  /// getOperatorLoc - Return the location of the operator.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOperatorLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::getOperatorLoc, Xs...); }) , (;) )
  /// Returns true if the unary operator can cause an overflow. For instance,
  ///   signed int i = INT_MAX; i++;
  ///   signed char c = CHAR_MAX; c++;
  /// Due to integer promotions, c++ is promoted to an int before the postfix
  /// increment, and the result is an int that cannot overflow. However, i++
  /// can overflow.
  constexpr bool canOverflow() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::canOverflow, Xs...); }) , (;) )
  /// isPostfix - Return true if this is a postfix operation, like x++.
  static constexpr bool isPostfix(enum clang::UnaryOperatorKind Op) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::isPostfix, Xs..., Op); }) , (;) )
  /// isPrefix - Return true if this is a prefix operation, like --x.
  static constexpr bool isPrefix(enum clang::UnaryOperatorKind Op) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::isPrefix, Xs..., Op); }) , (;) )
  constexpr bool isPrefix() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::isPrefix1, Xs...); }) , (;) )
  constexpr bool isPostfix() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::isPostfix1, Xs...); }) , (;) )
  static constexpr bool isIncrementOp(enum clang::UnaryOperatorKind Op) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::isIncrementOp, Xs..., Op); }) , (;) )
  constexpr bool isIncrementOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::isIncrementOp1, Xs...); }) , (;) )
  static constexpr bool isDecrementOp(enum clang::UnaryOperatorKind Op) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::isDecrementOp, Xs..., Op); }) , (;) )
  constexpr bool isDecrementOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::isDecrementOp1, Xs...); }) , (;) )
  static constexpr bool isIncrementDecrementOp(enum clang::UnaryOperatorKind Op) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::isIncrementDecrementOp, Xs..., Op); }) , (;) )
  constexpr bool isIncrementDecrementOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::isIncrementDecrementOp1, Xs...); }) , (;) )
  static constexpr bool isArithmeticOp(enum clang::UnaryOperatorKind Op) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::isArithmeticOp, Xs..., Op); }) , (;) )
  constexpr bool isArithmeticOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::isArithmeticOp1, Xs...); }) , (;) )
  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it
  /// corresponds to, e.g. "sizeof" or "[pre]++"
  static constexpr const char * getOpcodeStr(enum clang::UnaryOperatorKind Op) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::getOpcodeStr, Xs..., Op); }) , (;) )
  /// Retrieve the unary opcode that corresponds to the given
  /// overloaded operator.
  static constexpr enum clang::UnaryOperatorKind getOverloadedOpcode(enum clang::OverloadedOperatorKind OO, bool Postfix) IFMETA_ELSE( ({    return (enum clang::UnaryOperatorKind)__reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::getOverloadedOpcode, Xs..., OO, Postfix); }) , (;) )
  /// Retrieve the overloaded operator kind that corresponds to
  /// the given unary opcode.
  static constexpr enum clang::OverloadedOperatorKind getOverloadedOperator(enum clang::UnaryOperatorKind Opc) IFMETA_ELSE( ({    return (enum clang::OverloadedOperatorKind)__reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::getOverloadedOperator, Xs..., Opc); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::getExprLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::UnaryOperator, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__UnaryOperator, reflenums::clang__UnaryOperator::children, Xs...), () )
};

/// The kind of offsetof node we have.
enum clang::OffsetOfNode::Kind : unsigned int {
  /// An index into an array.
  Array = 0,
  /// A field.
  Field = 1,
  /// A field in a dependent type, known only by its name.
  Identifier = 2,
  /// An implicit indirection through a C++ base class, when the
  /// field found is in a base class.
  Base = 3,
};

/// Helper class for OffsetOfExpr.
M_template_rtpack(Xs)
struct clang::OffsetOfNode::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OffsetOfNode;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OffsetOfNode::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using Kind = enum refldetail::clang::OffsetOfNode::Kind;
  /// Determine what kind of offsetof node this is.
  constexpr enum clang::OffsetOfNode::Kind getKind() const IFMETA_ELSE( ({    return (enum clang::OffsetOfNode::Kind)__reflect_prop(reflenums::RK_clang__OffsetOfNode, reflenums::clang__OffsetOfNode::getKind, Xs...); }) , (;) )
  /// For an array element node, returns the index into the array
  /// of expressions.
  constexpr unsigned int getArrayExprIndex() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfNode, reflenums::clang__OffsetOfNode::getArrayExprIndex, Xs...); }) , (;) )
  /// For a field offsetof node, returns the field.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FieldDecl *) )
  getField() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfNode, reflenums::clang__OffsetOfNode::getField, Xs...); }) , (;) )
  /// For a field or identifier offsetof node, returns the name of
  /// the field.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getFieldName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfNode, reflenums::clang__OffsetOfNode::getFieldName, Xs...); }) , (;) )
  /// For a base class node, returns the base specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXBaseSpecifier *) )
  getBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfNode, reflenums::clang__OffsetOfNode::getBase, Xs...); }) , (;) )
  /// Retrieve the source range that covers this offsetof node.
  ///
  /// For an array element node, the source range contains the locations of
  /// the square brackets. For a field or identifier node, the source range
  /// contains the location of the period (if there is one) and the
  /// identifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfNode, reflenums::clang__OffsetOfNode::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfNode, reflenums::clang__OffsetOfNode::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfNode, reflenums::clang__OffsetOfNode::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfNode, reflenums::clang__OffsetOfNode::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfNode, reflenums::clang__OffsetOfNode::getEndLoc, Xs...); }) , (;) )
};

/// OffsetOfExpr - [C99 7.17] - This represents an expression of the form
/// offsetof(record-type, member-designator). For example, given:
/// @code
/// struct S {
///   float f;
///   double d;
/// };
/// struct T {
///   int i;
///   struct S s[10];
/// };
/// @endcode
/// we can represent and evaluate the expression @c offsetof(struct T, s[2].d).
M_template_rtpack(Xs)
struct clang::OffsetOfExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OffsetOfExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OffsetOfExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OffsetOfExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumComps, unsigned int NumExprs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::CreateEmpty, Xs..., Y0s..., NumComps, NumExprs); }) , (;) )
  /// getOperatorLoc - Return the location of the operator.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOperatorLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::getOperatorLoc, Xs...); }) , (;) )
  /// Return the location of the right parentheses.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::getTypeSourceInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::OffsetOfNode &) )
  getComponent(unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::getComponent, Xs..., Idx); }) , (;) )
  constexpr unsigned int getNumComponents() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::getNumComponents, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getIndexExpr(unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::getIndexExpr, Xs..., Idx); }) , (;) )
  constexpr unsigned int getNumExpressions() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::getNumExpressions, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::OffsetOfExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__OffsetOfExpr, reflenums::clang__OffsetOfExpr::children, Xs...), () )
};

/// UnaryExprOrTypeTraitExpr - expression with either a type or (unevaluated)
/// expression operand.  Used for sizeof/alignof (C99 6.5.3.4) and
/// vec_step (OpenCL 1.1 6.11.12).
M_template_rtpack(Xs)
struct clang::UnaryExprOrTypeTraitExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UnaryExprOrTypeTraitExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UnaryExprOrTypeTraitExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr enum clang::UnaryExprOrTypeTrait getKind() const IFMETA_ELSE( ({    return (enum clang::UnaryExprOrTypeTrait)__reflect_prop(reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::getKind, Xs...); }) , (;) )
  constexpr bool isArgumentType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::isArgumentType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getArgumentType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::getArgumentType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getArgumentTypeInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::getArgumentTypeInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getArgumentExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::getArgumentExpr, Xs...); }) , (;) )
  /// Gets the argument type, or the type of the argument expression, whichever
  /// is appropriate.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTypeOfArgument() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::getTypeOfArgument, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOperatorLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::getOperatorLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::UnaryExprOrTypeTraitExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__UnaryExprOrTypeTraitExpr, reflenums::clang__UnaryExprOrTypeTraitExpr::children, Xs...), () )
};

/// ArraySubscriptExpr - [C99 6.5.2.1] Array Subscripting.
M_template_rtpack(Xs)
struct clang::ArraySubscriptExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ArraySubscriptExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ArraySubscriptExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getLHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArraySubscriptExpr, reflenums::clang__ArraySubscriptExpr::getLHS, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getRHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArraySubscriptExpr, reflenums::clang__ArraySubscriptExpr::getRHS, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArraySubscriptExpr, reflenums::clang__ArraySubscriptExpr::getBase, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getIdx() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArraySubscriptExpr, reflenums::clang__ArraySubscriptExpr::getIdx, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArraySubscriptExpr, reflenums::clang__ArraySubscriptExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArraySubscriptExpr, reflenums::clang__ArraySubscriptExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArraySubscriptExpr, reflenums::clang__ArraySubscriptExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArraySubscriptExpr, reflenums::clang__ArraySubscriptExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRBracketLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArraySubscriptExpr, reflenums::clang__ArraySubscriptExpr::getRBracketLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArraySubscriptExpr, reflenums::clang__ArraySubscriptExpr::getExprLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArraySubscriptExpr, reflenums::clang__ArraySubscriptExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::ArraySubscriptExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__ArraySubscriptExpr, reflenums::clang__ArraySubscriptExpr::children, Xs...), () )
};

/// CallExpr - Represents a function call (C99 6.5.2.2, C++ [expr.call]).
/// CallExpr itself represents a normal function call, e.g., "f(x, 2)",
/// while its subclasses may represent alternative syntax that (semantically)
/// results in a function call. For example, CXXOperatorCallExpr is
/// a subclass for overloaded operator calls that use operator syntax, e.g.,
/// "str1 + str2" to resolve to a function call.
M_template_rtpack(Xs)
struct clang::CallExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CallExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CallExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getCallee() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getCallee, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Decl *) )
  getCalleeDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getCalleeDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionDecl *) )
  getDirectCallee() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getDirectCallee, Xs...); }) , (;) )
  /// getNumArgs - Return the number of actual arguments to this call.
  ///
  constexpr unsigned int getNumArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getNumArgs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *const *) )
  getArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getArgs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getArg(unsigned int Arg) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getArg, Xs..., Arg); }) , (;) )
  RANGE_REFLECTION(clang::CallExpr, arguments,
      constexpr auto arguments() const ,
      (const typename meta::clang::Expr *const),
      (reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::arguments, Xs...), () )
  /// getNumCommas - Return the number of commas that must have been present in
  /// this function call.
  constexpr unsigned int getNumCommas() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getNumCommas, Xs...); }) , (;) )
  /// getBuiltinCallee - If this is a call to a builtin, return the builtin ID
  /// of the callee. If not, return 0.
  constexpr unsigned int getBuiltinCallee() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getBuiltinCallee, Xs...); }) , (;) )
  /// Returns \c true if this is a call to a builtin which does not
  /// evaluate side-effects within its arguments.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isUnevaluatedBuiltinCall(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::isUnevaluatedBuiltinCall, Xs..., Y0s...); }) , (;) )
  /// getCallReturnType - Get the return type of the call expr. This is not
  /// always the type of the expr itself, if the return type is a reference
  /// type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getCallReturnType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getCallReturnType, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::getEndLoc, Xs...); }) , (;) )
  /// Return true if this is a call to __assume() or __builtin_assume() with
  /// a non-value-dependent constant parameter evaluating as false.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isBuiltinAssumeFalse(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::isBuiltinAssumeFalse, Xs..., Y0s...); }) , (;) )
  constexpr bool isCallToStdMove() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::isCallToStdMove, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::CallExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__CallExpr, reflenums::clang__CallExpr::children, Xs...), () )
};

/// MemberExpr - [C99 6.5.2.3] Structure and Union Members.  X->F and X.F.
///
M_template_rtpack(Xs)
struct clang::MemberExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__MemberExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::MemberExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_c M_rtpack(Y8s) M_c M_rtpack(Y9s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::MemberExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::Expr *)) base, bool isarrow, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) OperatorLoc, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::NestedNameSpecifierLoc)) QualifierLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::SourceLocation)) TemplateKWLoc, IFMETA_ELSE((const clang::ValueDecl::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::ValueDecl *)) memberdecl, IFMETA_ELSE((const clang::DeclAccessPair::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::DeclAccessPair)) founddecl, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/0, Y7s...>), (typename meta::clang::DeclarationNameInfo)) MemberNameInfo, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y8s...> *), (const typename meta::clang::TemplateArgumentListInfo *)) targs, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y9s...>), (typename meta::clang::QualType)) ty, enum clang::ExprValueKind VK, enum clang::ExprObjectKind OK) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::Create, Xs..., Y0s..., Y1s..., isarrow, Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., Y7s..., Y8s..., Y9s..., VK, OK); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7, typename Y8, typename Y9>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::MemberExpr *) )
  Create(Y0 p0, ptrwrp<Y1> p1, bool p2, Y2 p3, Y3 p4, Y4 p5, ptrwrp<Y5> p6, Y6 p7, Y7 p8, ptrwrp<Y8> p9, Y9 p10, enum clang::ExprValueKind p11, enum clang::ExprObjectKind p12) {
      return Create(p0, p1.get(), p2, p3, p4, p5, p6.get(), p7, p8, p9.get(), p10, p11, p12);
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getBase, Xs...); }) , (;) )
  /// Retrieve the member declaration to which this expression refers.
  ///
  /// The returned declaration will be a FieldDecl or (in C++) a VarDecl (for
  /// static data members), a CXXMethodDecl, or an EnumConstantDecl.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ValueDecl *) )
  getMemberDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getMemberDecl, Xs...); }) , (;) )
  /// Retrieves the declaration found by lookup.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclAccessPair) )
  getFoundDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getFoundDecl, Xs...); }) , (;) )
  /// Determines whether this member expression actually had
  /// a C++ nested-name-specifier prior to the name of the member, e.g.,
  /// x->Base::foo.
  constexpr bool hasQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::hasQualifier, Xs...); }) , (;) )
  /// If the member name was qualified, retrieves the
  /// nested-name-specifier that precedes the member name, with source-location
  /// information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getQualifierLoc, Xs...); }) , (;) )
  /// If the member name was qualified, retrieves the
  /// nested-name-specifier that precedes the member name. Otherwise, returns
  /// NULL.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getQualifier, Xs...); }) , (;) )
  /// Retrieve the location of the template keyword preceding
  /// the member name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTemplateKeywordLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getTemplateKeywordLoc, Xs...); }) , (;) )
  /// Retrieve the location of the left angle bracket starting the
  /// explicit template argument list following the member name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getLAngleLoc, Xs...); }) , (;) )
  /// Retrieve the location of the right angle bracket ending the
  /// explicit template argument list following the member name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getRAngleLoc, Xs...); }) , (;) )
  /// Determines whether the member name was preceded by the template keyword.
  constexpr bool hasTemplateKeyword() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::hasTemplateKeyword, Xs...); }) , (;) )
  /// Determines whether the member name was followed by an
  /// explicit template argument list.
  constexpr bool hasExplicitTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::hasExplicitTemplateArgs, Xs...); }) , (;) )
  /// Copies the template arguments (if present) into the given
  /// structure.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void copyTemplateArgumentsInto(IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::TemplateArgumentListInfo &)) List) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::copyTemplateArgumentsInto, Xs..., Y0s...); }) , (;) )
  /// Retrieve the template arguments provided as part of this
  /// template-id.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentLoc *) )
  getTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getTemplateArgs, Xs...); }) , (;) )
  /// Retrieve the number of template arguments provided as part of this
  /// template-id.
  constexpr unsigned int getNumTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getNumTemplateArgs, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::MemberExpr, template_arguments,
      constexpr auto template_arguments() const ,
      (typename meta::clang::TemplateArgumentLoc),
      (reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::template_arguments, Xs...), () )
  /// Retrieve the member declaration name info.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationNameInfo) )
  getMemberNameInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getMemberNameInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOperatorLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getOperatorLoc, Xs...); }) , (;) )
  constexpr bool isArrow() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::isArrow, Xs...); }) , (;) )
  /// getMemberLoc - Return the location of the "member", in X->F, it is the
  /// location of 'F'.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getMemberLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getMemberLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::getExprLoc, Xs...); }) , (;) )
  /// Determine whether the base of this explicit is implicit.
  constexpr bool isImplicitAccess() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::isImplicitAccess, Xs...); }) , (;) )
  /// Returns true if this member expression refers to a method that
  /// was resolved from an overloaded set having size greater than 1.
  constexpr bool hadMultipleCandidates() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::hadMultipleCandidates, Xs...); }) , (;) )
  /// Returns true if virtual dispatch is performed.
  /// If the member access is fully qualified, (i.e. X::f()), virtual
  /// dispatching is not performed. In -fapple-kext mode qualified
  /// calls to virtual method will still go through the vtable.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool performsVirtualDispatch(IFMETA_ELSE((const clang::LangOptions::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::LangOptions &)) LO) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::performsVirtualDispatch, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::MemberExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__MemberExpr, reflenums::clang__MemberExpr::children, Xs...), () )
};

/// CompoundLiteralExpr - [C99 6.5.2.5]
///
M_template_rtpack(Xs)
struct clang::CompoundLiteralExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CompoundLiteralExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CompoundLiteralExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundLiteralExpr, reflenums::clang__CompoundLiteralExpr::getInitializer, Xs...); }) , (;) )
  constexpr bool isFileScope() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundLiteralExpr, reflenums::clang__CompoundLiteralExpr::isFileScope, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundLiteralExpr, reflenums::clang__CompoundLiteralExpr::getLParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundLiteralExpr, reflenums::clang__CompoundLiteralExpr::getTypeSourceInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundLiteralExpr, reflenums::clang__CompoundLiteralExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundLiteralExpr, reflenums::clang__CompoundLiteralExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundLiteralExpr, reflenums::clang__CompoundLiteralExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundLiteralExpr, reflenums::clang__CompoundLiteralExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundLiteralExpr, reflenums::clang__CompoundLiteralExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::CompoundLiteralExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__CompoundLiteralExpr, reflenums::clang__CompoundLiteralExpr::children, Xs...), () )
};

/// CastExpr - Base class for type casts, including both implicit
/// casts (ImplicitCastExpr) and explicit casts that have some
/// representation in the source code (ExplicitCastExpr's derived
/// classes).
M_template_rtpack(Xs)
struct clang::CastExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CastExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CastExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr enum clang::CastKind getCastKind() const IFMETA_ELSE( ({    return (enum clang::CastKind)__reflect_prop(reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::getCastKind, Xs...); }) , (;) )
  static constexpr const char * getCastKindName(enum clang::CastKind CK) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::getCastKindName, Xs..., CK); }) , (;) )
  constexpr const char * getCastKindName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::getCastKindName1, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSubExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::getSubExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSubExprAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::getSubExprAsWritten, Xs...); }) , (;) )
  /// If this cast applies a user-defined conversion, retrieve the conversion
  /// function that it invokes.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getConversionFunction() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::getConversionFunction, Xs...); }) , (;) )
  constexpr bool path_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::path_empty, Xs...); }) , (;) )
  constexpr unsigned int path_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::path_size, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FieldDecl *) )
  getTargetUnionField() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::getTargetUnionField, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FieldDecl *) )
  getTargetFieldForToUnionCast(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) unionType, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) opType) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::getTargetFieldForToUnionCast, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FieldDecl *) )
  getTargetFieldForToUnionCast(IFMETA_ELSE((const clang::RecordDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::RecordDecl *)) RD, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) opType) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::getTargetFieldForToUnionCast1, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  static constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FieldDecl *) )
  getTargetFieldForToUnionCast(ptrwrp<Y0> p0, Y1 p1) {
      return getTargetFieldForToUnionCast(p0.get(), p1);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::CastExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__CastExpr, reflenums::clang__CastExpr::children, Xs...), () )
};

/// ImplicitCastExpr - Allows us to explicitly represent implicit type
/// conversions, which have no direct representation in the original
/// source code. For example: converting T[]->T*, void f()->void
/// (*f)(), float->double, short->int, etc.
///
/// In C, implicit casts always produce rvalues. However, in C++, an
/// implicit cast whose result is being bound to a reference will be
/// an lvalue or xvalue. For example:
///
/// @code
/// class Base { };
/// class Derived : public Base { };
/// Derived &&ref();
/// void f(Derived d) {
///   Base& b = d; // initializer is an ImplicitCastExpr
///                // to an lvalue of type Base
///   Base&& r = ref(); // initializer is an ImplicitCastExpr
///                     // to an xvalue of type Base
/// }
/// @endcode
M_template_rtpack(Xs)
struct clang::ImplicitCastExpr::impl : impl_offset_t<clang::CastExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ImplicitCastExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ImplicitCastExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isPartOfExplicitCast() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitCastExpr, reflenums::clang__ImplicitCastExpr::isPartOfExplicitCast, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImplicitCastExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, unsigned int PathSize) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitCastExpr, reflenums::clang__ImplicitCastExpr::CreateEmpty, Xs..., Y0s..., PathSize); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitCastExpr, reflenums::clang__ImplicitCastExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitCastExpr, reflenums::clang__ImplicitCastExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitCastExpr, reflenums::clang__ImplicitCastExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitCastExpr, reflenums::clang__ImplicitCastExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitCastExpr, reflenums::clang__ImplicitCastExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ExplicitCastExpr - An explicit cast written in the source
/// code.
///
/// This class is effectively an abstract class, because it provides
/// the basic representation of an explicitly-written cast without
/// specifying which kind of cast (C cast, functional cast, static
/// cast, etc.) was written; specific derived classes represent the
/// particular style of cast and its location information.
///
/// Unlike implicit casts, explicit cast nodes have two different
/// types: the type that was written into the source code, and the
/// actual type of the expression as determined by semantic
/// analysis. These types may differ slightly. For example, in C++ one
/// can cast to a reference type, which indicates that the resulting
/// expression will be an lvalue or xvalue. The reference type, however,
/// will not be used as the type of the expression.
M_template_rtpack(Xs)
struct clang::ExplicitCastExpr::impl : impl_offset_t<clang::CastExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ExplicitCastExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ExplicitCastExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// getTypeInfoAsWritten - Returns the type source info for the type
  /// that this expression is casting to.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeInfoAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExplicitCastExpr, reflenums::clang__ExplicitCastExpr::getTypeInfoAsWritten, Xs...); }) , (;) )
  /// getTypeAsWritten - Returns the type that this expression is
  /// casting to, as written in the source code.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTypeAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExplicitCastExpr, reflenums::clang__ExplicitCastExpr::getTypeAsWritten, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExplicitCastExpr, reflenums::clang__ExplicitCastExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// CStyleCastExpr - An explicit cast in C (C99 6.5.4) or a C-style
/// cast in C++ (C++ [expr.cast]), which uses the syntax
/// (Type)expr. For example: @c (int)f.
M_template_rtpack(Xs)
struct clang::CStyleCastExpr::impl : impl_offset_t<clang::ExplicitCastExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CStyleCastExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CStyleCastExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CStyleCastExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, unsigned int PathSize) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CStyleCastExpr, reflenums::clang__CStyleCastExpr::CreateEmpty, Xs..., Y0s..., PathSize); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CStyleCastExpr, reflenums::clang__CStyleCastExpr::getLParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CStyleCastExpr, reflenums::clang__CStyleCastExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CStyleCastExpr, reflenums::clang__CStyleCastExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CStyleCastExpr, reflenums::clang__CStyleCastExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CStyleCastExpr, reflenums::clang__CStyleCastExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CStyleCastExpr, reflenums::clang__CStyleCastExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CStyleCastExpr, reflenums::clang__CStyleCastExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A builtin binary operation expression such as "x + y" or "x <= y".
///
/// This expression node kind describes a builtin binary operation,
/// such as "x + y" for integer values "x" and "y". The operands will
/// already have been converted to appropriate types (e.g., by
/// performing promotions or conversions).
///
/// In C++, where operators may be overloaded, a different kind of
/// expression node (CXXOperatorCallExpr) is used to express the
/// invocation of an overloaded operator with operator syntax. Within
/// a C++ template, whether BinaryOperator or CXXOperatorCallExpr is
/// used to store an expression "x + y" depends on the subexpressions
/// for x and y. If neither x or y is type-dependent, and the "+"
/// operator resolves to a built-in operation, BinaryOperator will be
/// used to express the computation (x and y may still be
/// value-dependent). If either x or y is type-dependent, or if the
/// "+" resolves to an overloaded operator, CXXOperatorCallExpr will
/// be used to express the computation.
M_template_rtpack(Xs)
struct clang::BinaryOperator::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__BinaryOperator;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::BinaryOperator::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getExprLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOperatorLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getOperatorLoc, Xs...); }) , (;) )
  constexpr enum clang::BinaryOperatorKind getOpcode() const IFMETA_ELSE( ({    return (enum clang::BinaryOperatorKind)__reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getOpcode, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getLHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getLHS, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getRHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getRHS, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getEndLoc, Xs...); }) , (;) )
  /// getOpcodeStr - Turn an Opcode enum value into the punctuation char it
  /// corresponds to, e.g. "<<=".
  static constexpr const char * getOpcodeStr(enum clang::BinaryOperatorKind Op) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getOpcodeStr, Xs..., Op); }) , (;) )
  constexpr const char * getOpcodeStr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getOpcodeStr1, Xs...); }) , (;) )
  /// Retrieve the binary opcode that corresponds to the given
  /// overloaded operator.
  static constexpr enum clang::BinaryOperatorKind getOverloadedOpcode(enum clang::OverloadedOperatorKind OO) IFMETA_ELSE( ({    return (enum clang::BinaryOperatorKind)__reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getOverloadedOpcode, Xs..., OO); }) , (;) )
  /// Retrieve the overloaded operator kind that corresponds to
  /// the given binary opcode.
  static constexpr enum clang::OverloadedOperatorKind getOverloadedOperator(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return (enum clang::OverloadedOperatorKind)__reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getOverloadedOperator, Xs..., Opc); }) , (;) )
  /// predicates to categorize the respective opcodes.
  constexpr bool isPtrMemOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isPtrMemOp, Xs...); }) , (;) )
  static constexpr bool isMultiplicativeOp(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isMultiplicativeOp, Xs..., Opc); }) , (;) )
  constexpr bool isMultiplicativeOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isMultiplicativeOp1, Xs...); }) , (;) )
  static constexpr bool isAdditiveOp(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isAdditiveOp, Xs..., Opc); }) , (;) )
  constexpr bool isAdditiveOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isAdditiveOp1, Xs...); }) , (;) )
  static constexpr bool isShiftOp(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isShiftOp, Xs..., Opc); }) , (;) )
  constexpr bool isShiftOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isShiftOp1, Xs...); }) , (;) )
  static constexpr bool isBitwiseOp(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isBitwiseOp, Xs..., Opc); }) , (;) )
  constexpr bool isBitwiseOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isBitwiseOp1, Xs...); }) , (;) )
  static constexpr bool isRelationalOp(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isRelationalOp, Xs..., Opc); }) , (;) )
  constexpr bool isRelationalOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isRelationalOp1, Xs...); }) , (;) )
  static constexpr bool isEqualityOp(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isEqualityOp, Xs..., Opc); }) , (;) )
  constexpr bool isEqualityOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isEqualityOp1, Xs...); }) , (;) )
  static constexpr bool isComparisonOp(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isComparisonOp, Xs..., Opc); }) , (;) )
  constexpr bool isComparisonOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isComparisonOp1, Xs...); }) , (;) )
  static constexpr enum clang::BinaryOperatorKind negateComparisonOp(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return (enum clang::BinaryOperatorKind)__reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::negateComparisonOp, Xs..., Opc); }) , (;) )
  static constexpr enum clang::BinaryOperatorKind reverseComparisonOp(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return (enum clang::BinaryOperatorKind)__reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::reverseComparisonOp, Xs..., Opc); }) , (;) )
  static constexpr bool isLogicalOp(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isLogicalOp, Xs..., Opc); }) , (;) )
  constexpr bool isLogicalOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isLogicalOp1, Xs...); }) , (;) )
  static constexpr bool isAssignmentOp(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isAssignmentOp, Xs..., Opc); }) , (;) )
  constexpr bool isAssignmentOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isAssignmentOp1, Xs...); }) , (;) )
  static constexpr bool isCompoundAssignmentOp(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isCompoundAssignmentOp, Xs..., Opc); }) , (;) )
  constexpr bool isCompoundAssignmentOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isCompoundAssignmentOp1, Xs...); }) , (;) )
  static constexpr enum clang::BinaryOperatorKind getOpForCompoundAssignment(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return (enum clang::BinaryOperatorKind)__reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getOpForCompoundAssignment, Xs..., Opc); }) , (;) )
  static constexpr bool isShiftAssignOp(enum clang::BinaryOperatorKind Opc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isShiftAssignOp, Xs..., Opc); }) , (;) )
  constexpr bool isShiftAssignOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isShiftAssignOp1, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr bool isNullPointerArithmeticExtension(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx, enum clang::BinaryOperatorKind Opc, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::Expr *)) LHS, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::Expr *)) RHS) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isNullPointerArithmeticExtension, Xs..., Y0s..., Opc, Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr bool isNullPointerArithmeticExtension(Y0 p0, enum clang::BinaryOperatorKind p1, ptrwrp<Y1> p2, ptrwrp<Y2> p3) {
      return isNullPointerArithmeticExtension(p0, p1, p2.get(), p3.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) S) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::BinaryOperator, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::children, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FPOptions) )
  getFPFeatures() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::getFPFeatures, Xs...); }) , (;) )
  constexpr bool isFPContractableWithinStatement() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryOperator, reflenums::clang__BinaryOperator::isFPContractableWithinStatement, Xs...); }) , (;) )
};

/// CompoundAssignOperator - For compound assignments (e.g. +=), we keep
/// track of the type the operation is performed in.  Due to the semantics of
/// these operators, the operands are promoted, the arithmetic performed, an
/// implicit conversion back to the result type done, then the assignment takes
/// place.  This captures the intermediate type which the computation is done
/// in.
M_template_rtpack(Xs)
struct clang::CompoundAssignOperator::impl : impl_offset_t<clang::BinaryOperator, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CompoundAssignOperator;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CompoundAssignOperator::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getComputationLHSType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundAssignOperator, reflenums::clang__CompoundAssignOperator::getComputationLHSType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getComputationResultType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundAssignOperator, reflenums::clang__CompoundAssignOperator::getComputationResultType, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) S) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompoundAssignOperator, reflenums::clang__CompoundAssignOperator::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// AbstractConditionalOperator - An abstract base class for
/// ConditionalOperator and BinaryConditionalOperator.
M_template_rtpack(Xs)
struct clang::AbstractConditionalOperator::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__AbstractConditionalOperator;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::AbstractConditionalOperator::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCond() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AbstractConditionalOperator, reflenums::clang__AbstractConditionalOperator::getCond, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getTrueExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AbstractConditionalOperator, reflenums::clang__AbstractConditionalOperator::getTrueExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getFalseExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AbstractConditionalOperator, reflenums::clang__AbstractConditionalOperator::getFalseExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getQuestionLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AbstractConditionalOperator, reflenums::clang__AbstractConditionalOperator::getQuestionLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getColonLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AbstractConditionalOperator, reflenums::clang__AbstractConditionalOperator::getColonLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AbstractConditionalOperator, reflenums::clang__AbstractConditionalOperator::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ConditionalOperator - The ?: ternary operator.  The GNU "missing
/// middle" extension is a BinaryConditionalOperator.
M_template_rtpack(Xs)
struct clang::ConditionalOperator::impl : impl_offset_t<clang::AbstractConditionalOperator, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ConditionalOperator;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ConditionalOperator::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCond() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConditionalOperator, reflenums::clang__ConditionalOperator::getCond, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getTrueExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConditionalOperator, reflenums::clang__ConditionalOperator::getTrueExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getFalseExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConditionalOperator, reflenums::clang__ConditionalOperator::getFalseExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getLHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConditionalOperator, reflenums::clang__ConditionalOperator::getLHS, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getRHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConditionalOperator, reflenums::clang__ConditionalOperator::getRHS, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConditionalOperator, reflenums::clang__ConditionalOperator::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConditionalOperator, reflenums::clang__ConditionalOperator::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConditionalOperator, reflenums::clang__ConditionalOperator::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConditionalOperator, reflenums::clang__ConditionalOperator::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConditionalOperator, reflenums::clang__ConditionalOperator::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::ConditionalOperator, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__ConditionalOperator, reflenums::clang__ConditionalOperator::children, Xs...), () )
};

/// BinaryConditionalOperator - The GNU extension to the conditional
/// operator which allows the middle operand to be omitted.
///
/// This is a different expression kind on the assumption that almost
/// every client ends up needing to know that these are different.
M_template_rtpack(Xs)
struct clang::BinaryConditionalOperator::impl : impl_offset_t<clang::AbstractConditionalOperator, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__BinaryConditionalOperator;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::BinaryConditionalOperator::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// getCommon - Return the common expression, written to the
  ///   left of the condition.  The opaque value will be bound to the
  ///   result of this expression.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCommon() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryConditionalOperator, reflenums::clang__BinaryConditionalOperator::getCommon, Xs...); }) , (;) )
  /// getOpaqueValue - Return the opaque value placeholder.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::OpaqueValueExpr *) )
  getOpaqueValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryConditionalOperator, reflenums::clang__BinaryConditionalOperator::getOpaqueValue, Xs...); }) , (;) )
  /// getCond - Return the condition expression; this is defined
  ///   in terms of the opaque value.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCond() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryConditionalOperator, reflenums::clang__BinaryConditionalOperator::getCond, Xs...); }) , (;) )
  /// getTrueExpr - Return the subexpression which will be
  ///   evaluated if the condition evaluates to true;  this is defined
  ///   in terms of the opaque value.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getTrueExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryConditionalOperator, reflenums::clang__BinaryConditionalOperator::getTrueExpr, Xs...); }) , (;) )
  /// getFalseExpr - Return the subexpression which will be
  ///   evaluated if the condnition evaluates to false; this is
  ///   defined in terms of the opaque value.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getFalseExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryConditionalOperator, reflenums::clang__BinaryConditionalOperator::getFalseExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryConditionalOperator, reflenums::clang__BinaryConditionalOperator::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryConditionalOperator, reflenums::clang__BinaryConditionalOperator::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryConditionalOperator, reflenums::clang__BinaryConditionalOperator::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryConditionalOperator, reflenums::clang__BinaryConditionalOperator::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BinaryConditionalOperator, reflenums::clang__BinaryConditionalOperator::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::BinaryConditionalOperator, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__BinaryConditionalOperator, reflenums::clang__BinaryConditionalOperator::children, Xs...), () )
};

/// AddrLabelExpr - The GNU address of label extension, representing &&label.
M_template_rtpack(Xs)
struct clang::AddrLabelExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__AddrLabelExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::AddrLabelExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAmpAmpLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AddrLabelExpr, reflenums::clang__AddrLabelExpr::getAmpAmpLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLabelLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AddrLabelExpr, reflenums::clang__AddrLabelExpr::getLabelLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AddrLabelExpr, reflenums::clang__AddrLabelExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AddrLabelExpr, reflenums::clang__AddrLabelExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AddrLabelExpr, reflenums::clang__AddrLabelExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AddrLabelExpr, reflenums::clang__AddrLabelExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::LabelDecl *) )
  getLabel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AddrLabelExpr, reflenums::clang__AddrLabelExpr::getLabel, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AddrLabelExpr, reflenums::clang__AddrLabelExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::AddrLabelExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__AddrLabelExpr, reflenums::clang__AddrLabelExpr::children, Xs...), () )
};

/// StmtExpr - This is the GNU Statement Expression extension: ({int X=4; X;}).
/// The StmtExpr contains a single CompoundStmt node, which it evaluates and
/// takes the value of the last subexpression.
///
/// A StmtExpr is always an r-value; values "returned" out of a
/// StmtExpr will be copied.
M_template_rtpack(Xs)
struct clang::StmtExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__StmtExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::StmtExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CompoundStmt *) )
  getSubStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StmtExpr, reflenums::clang__StmtExpr::getSubStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StmtExpr, reflenums::clang__StmtExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StmtExpr, reflenums::clang__StmtExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StmtExpr, reflenums::clang__StmtExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StmtExpr, reflenums::clang__StmtExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StmtExpr, reflenums::clang__StmtExpr::getLParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StmtExpr, reflenums::clang__StmtExpr::getRParenLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StmtExpr, reflenums::clang__StmtExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::StmtExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__StmtExpr, reflenums::clang__StmtExpr::children, Xs...), () )
};

/// ShuffleVectorExpr - clang-specific builtin-in function
/// __builtin_shufflevector.
/// This AST node represents a operator that does a constant
/// shuffle, similar to LLVM's shufflevector instruction. It takes
/// two vectors and a variable number of constant indices,
/// and returns the appropriately shuffled vector.
M_template_rtpack(Xs)
struct clang::ShuffleVectorExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ShuffleVectorExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ShuffleVectorExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBuiltinLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ShuffleVectorExpr, reflenums::clang__ShuffleVectorExpr::getBuiltinLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ShuffleVectorExpr, reflenums::clang__ShuffleVectorExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ShuffleVectorExpr, reflenums::clang__ShuffleVectorExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ShuffleVectorExpr, reflenums::clang__ShuffleVectorExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ShuffleVectorExpr, reflenums::clang__ShuffleVectorExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ShuffleVectorExpr, reflenums::clang__ShuffleVectorExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ShuffleVectorExpr, reflenums::clang__ShuffleVectorExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  /// getNumSubExprs - Return the size of the SubExprs array.  This includes the
  /// constant expression, the actual arguments passed in, and the function
  /// pointers.
  constexpr unsigned int getNumSubExprs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ShuffleVectorExpr, reflenums::clang__ShuffleVectorExpr::getNumSubExprs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getExpr(unsigned int Index) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ShuffleVectorExpr, reflenums::clang__ShuffleVectorExpr::getExpr, Xs..., Index); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::llvm::APSInt) )
  getShuffleMaskIdx(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx, unsigned int N) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ShuffleVectorExpr, reflenums::clang__ShuffleVectorExpr::getShuffleMaskIdx, Xs..., Y0s..., N); }) , (;) )
  RANGE_REFLECTION(clang::ShuffleVectorExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__ShuffleVectorExpr, reflenums::clang__ShuffleVectorExpr::children, Xs...), () )
};

/// ConvertVectorExpr - Clang builtin function __builtin_convertvector
/// This AST node provides support for converting a vector type to another
/// vector type of the same arity.
M_template_rtpack(Xs)
struct clang::ConvertVectorExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ConvertVectorExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ConvertVectorExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// getSrcExpr - Return the Expr to be converted.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSrcExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConvertVectorExpr, reflenums::clang__ConvertVectorExpr::getSrcExpr, Xs...); }) , (;) )
  /// getTypeSourceInfo - Return the destination type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConvertVectorExpr, reflenums::clang__ConvertVectorExpr::getTypeSourceInfo, Xs...); }) , (;) )
  /// getBuiltinLoc - Return the location of the __builtin_convertvector token.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBuiltinLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConvertVectorExpr, reflenums::clang__ConvertVectorExpr::getBuiltinLoc, Xs...); }) , (;) )
  /// getRParenLoc - Return the location of final right parenthesis.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConvertVectorExpr, reflenums::clang__ConvertVectorExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConvertVectorExpr, reflenums::clang__ConvertVectorExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConvertVectorExpr, reflenums::clang__ConvertVectorExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConvertVectorExpr, reflenums::clang__ConvertVectorExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConvertVectorExpr, reflenums::clang__ConvertVectorExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConvertVectorExpr, reflenums::clang__ConvertVectorExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::ConvertVectorExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__ConvertVectorExpr, reflenums::clang__ConvertVectorExpr::children, Xs...), () )
};

/// ChooseExpr - GNU builtin-in function __builtin_choose_expr.
/// This AST node is similar to the conditional operator (?:) in C, with
/// the following exceptions:
/// - the test expression must be a integer constant expression.
/// - the expression returned acts like the chosen subexpression in every
///   visible way: the type is the same as that of the chosen subexpression,
///   and all predicates (whether it's an l-value, whether it's an integer
///   constant expression, etc.) return the same result as for the chosen
///   sub-expression.
M_template_rtpack(Xs)
struct clang::ChooseExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ChooseExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ChooseExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// isConditionTrue - Return whether the condition is true (i.e. not
  /// equal to zero).
  constexpr bool isConditionTrue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::isConditionTrue, Xs...); }) , (;) )
  constexpr bool isConditionDependent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::isConditionDependent, Xs...); }) , (;) )
  /// getChosenSubExpr - Return the subexpression chosen according to the
  /// condition.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getChosenSubExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::getChosenSubExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCond() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::getCond, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getLHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::getLHS, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getRHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::getRHS, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBuiltinLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::getBuiltinLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::ChooseExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__ChooseExpr, reflenums::clang__ChooseExpr::children, Xs...), () )
};

/// GNUNullExpr - Implements the GNU __null extension, which is a name
/// for a null pointer constant that has integral type (e.g., int or
/// long) and is the same size and alignment as a pointer. The __null
/// extension is typically only used by system headers, which define
/// NULL as __null in C++ rather than using 0 (which is an integer
/// that may not match the size of a pointer).
M_template_rtpack(Xs)
struct clang::GNUNullExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__GNUNullExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::GNUNullExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// getTokenLocation - The location of the __null token.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTokenLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GNUNullExpr, reflenums::clang__GNUNullExpr::getTokenLocation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GNUNullExpr, reflenums::clang__GNUNullExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GNUNullExpr, reflenums::clang__GNUNullExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GNUNullExpr, reflenums::clang__GNUNullExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GNUNullExpr, reflenums::clang__GNUNullExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GNUNullExpr, reflenums::clang__GNUNullExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::GNUNullExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__GNUNullExpr, reflenums::clang__GNUNullExpr::children, Xs...), () )
};

/// Represents a call to the builtin function \c __builtin_va_arg.
M_template_rtpack(Xs)
struct clang::VAArgExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__VAArgExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::VAArgExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSubExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VAArgExpr, reflenums::clang__VAArgExpr::getSubExpr, Xs...); }) , (;) )
  /// Returns whether this is really a Win64 ABI va_arg expression.
  constexpr bool isMicrosoftABI() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VAArgExpr, reflenums::clang__VAArgExpr::isMicrosoftABI, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getWrittenTypeInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VAArgExpr, reflenums::clang__VAArgExpr::getWrittenTypeInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBuiltinLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VAArgExpr, reflenums::clang__VAArgExpr::getBuiltinLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VAArgExpr, reflenums::clang__VAArgExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VAArgExpr, reflenums::clang__VAArgExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VAArgExpr, reflenums::clang__VAArgExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VAArgExpr, reflenums::clang__VAArgExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VAArgExpr, reflenums::clang__VAArgExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VAArgExpr, reflenums::clang__VAArgExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::VAArgExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__VAArgExpr, reflenums::clang__VAArgExpr::children, Xs...), () )
};

/// Describes an C or C++ initializer list.
///
/// InitListExpr describes an initializer list, which can be used to
/// initialize objects of different types, including
/// struct/class/union types, arrays, and vectors. For example:
///
/// @code
/// struct foo x = { 1, { 2, 3 } };
/// @endcode
///
/// Prior to semantic analysis, an initializer list will represent the
/// initializer list as written by the user, but will have the
/// placeholder type "void". This initializer list is called the
/// syntactic form of the initializer, and may contain C99 designated
/// initializers (represented as DesignatedInitExprs), initializations
/// of subobject members without explicit braces, and so on. Clients
/// interested in the original syntax of the initializer list should
/// use the syntactic form of the initializer list.
///
/// After semantic analysis, the initializer list will represent the
/// semantic form of the initializer, where the initializations of all
/// subobjects are made explicit with nested InitListExpr nodes and
/// C99 designators have been eliminated by placing the designated
/// initializations into the subobject they initialize. Additionally,
/// any "holes" in the initialization, where no initializer has been
/// specified for a particular subobject, will be replaced with
/// implicitly-generated ImplicitValueInitExpr expressions that
/// value-initialize the subobjects. Note, however, that the
/// initializer lists may still have fewer initializers than there are
/// elements to initialize within the object.
///
/// After semantic analysis has completed, given an initializer list,
/// method isSemanticForm() returns true if and only if this is the
/// semantic form of the initializer list (note: the same AST node
/// may at the same time be the syntactic form).
/// Given the semantic form of the initializer list, one can retrieve
/// the syntactic form of that initializer list (when different)
/// using method getSyntacticForm(); the method returns null if applied
/// to a initializer list which is already in syntactic form.
/// Similarly, given the syntactic form (i.e., an initializer list such
/// that isSemanticForm() returns false), one can retrieve the semantic
/// form using method getSemanticForm().
/// Since many initializer lists have the same syntactic and semantic forms,
/// getSyntacticForm() may return NULL, indicating that the current
/// semantic initializer list also serves as its syntactic form.
M_template_rtpack(Xs)
struct clang::InitListExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__InitListExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::InitListExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr unsigned int getNumInits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::getNumInits, Xs...); }) , (;) )
  /// Retrieve the set of initializers.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *const *) )
  getInits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::getInits, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::InitListExpr, inits,
      constexpr auto inits() const ,
      (typename meta::clang::Expr *),
      (reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::inits, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getInit(unsigned int Init) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::getInit, Xs..., Init); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getArrayFiller() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::getArrayFiller, Xs...); }) , (;) )
  /// Return true if this is an array initializer and its array "filler"
  /// has been set.
  constexpr bool hasArrayFiller() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::hasArrayFiller, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FieldDecl *) )
  getInitializedFieldInUnion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::getInitializedFieldInUnion, Xs...); }) , (;) )
  constexpr bool isExplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::isExplicit, Xs...); }) , (;) )
  constexpr bool isStringLiteralInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::isStringLiteralInit, Xs...); }) , (;) )
  /// Is this a transparent initializer list (that is, an InitListExpr that is
  /// purely syntactic, and whose semantics are that of the sole contained
  /// initializer)?
  constexpr bool isTransparent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::isTransparent, Xs...); }) , (;) )
  /// Is this the zero initializer {0} in a language which considers it
  /// idiomatic?
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isIdiomaticZeroInitializer(IFMETA_ELSE((const clang::LangOptions::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::LangOptions &)) LangOpts) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::isIdiomaticZeroInitializer, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLBraceLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::getLBraceLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRBraceLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::getRBraceLoc, Xs...); }) , (;) )
  constexpr bool isSemanticForm() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::isSemanticForm, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::InitListExpr *) )
  getSemanticForm() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::getSemanticForm, Xs...); }) , (;) )
  constexpr bool isSyntacticForm() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::isSyntacticForm, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::InitListExpr *) )
  getSyntacticForm() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::getSyntacticForm, Xs...); }) , (;) )
  constexpr bool hadArrayRangeDesignator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::hadArrayRangeDesignator, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::InitListExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__InitListExpr, reflenums::clang__InitListExpr::children, Xs...), () )
  RANGECLASS_SIZE_AND_GET(clang__InitListExpr, typename meta::clang::Stmt *const);
};

/// Represents a C99 designated initializer expression.
///
/// A designated initializer expression (C99 6.7.8) contains one or
/// more designators (which can be field designators, array
/// designators, or GNU array-range designators) followed by an
/// expression that initializes the field or element(s) that the
/// designators refer to. For example, given:
///
/// @code
/// struct point {
///   double x;
///   double y;
/// };
/// struct point ptarray[10] = { [2].y = 1.0, [2].x = 2.0, [0].x = 1.0 };
/// @endcode
///
/// The InitListExpr contains three DesignatedInitExprs, the first of
/// which covers @c [2].y=1.0. This DesignatedInitExpr will have two
/// designators, one array designator for @c [2] followed by one field
/// designator for @c .y. The initialization expression will be 1.0.
M_template_rtpack(Xs)
struct clang::DesignatedInitExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DesignatedInitExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DesignatedInitExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template_rtpack(Zs) using Designator = struct refldetail::clang::DesignatedInitExpr::Designator::M_template impl M_targpack(Zs);
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DesignatedInitExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumIndexExprs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::CreateEmpty, Xs..., Y0s..., NumIndexExprs); }) , (;) )
  /// Returns the number of designators in this initializer.
  constexpr unsigned int size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::size, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::DesignatedInitExpr, designators,
      constexpr auto designators() const ,
      (typename meta::clang::DesignatedInitExpr::Designator),
      (reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::designators, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DesignatedInitExpr::Designator *) )
  getDesignator(unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::getDesignator, Xs..., Idx); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getArrayIndex(IFMETA_ELSE((const clang::DesignatedInitExpr::Designator::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::DesignatedInitExpr::Designator &)) D) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::getArrayIndex, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getArrayRangeStart(IFMETA_ELSE((const clang::DesignatedInitExpr::Designator::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::DesignatedInitExpr::Designator &)) D) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::getArrayRangeStart, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getArrayRangeEnd(IFMETA_ELSE((const clang::DesignatedInitExpr::Designator::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::DesignatedInitExpr::Designator &)) D) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::getArrayRangeEnd, Xs..., Y0s...); }) , (;) )
  /// Retrieve the location of the '=' that precedes the
  /// initializer value itself, if present.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEqualOrColonLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::getEqualOrColonLoc, Xs...); }) , (;) )
  /// Determines whether this designated initializer used the
  /// deprecated GNU syntax for designated initializers.
  constexpr bool usesGNUSyntax() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::usesGNUSyntax, Xs...); }) , (;) )
  /// Retrieve the initializer value.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::getInit, Xs...); }) , (;) )
  /// Retrieve the total number of subexpressions in this
  /// designated initializer expression, including the actual
  /// initialized value and any expressions that occur within array
  /// and array-range designators.
  constexpr unsigned int getNumSubExprs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::getNumSubExprs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSubExpr(unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::getSubExpr, Xs..., Idx); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getDesignatorsSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::getDesignatorsSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::DesignatedInitExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__DesignatedInitExpr, reflenums::clang__DesignatedInitExpr::children, Xs...), () )
};

/// Represents a single C99 designator.
  ///
  /// @todo This class is infuriatingly similar to clang::Designator,
  /// but minor differences (storing indices vs. storing pointers)
  /// keep us from reusing it. Try harder, later, to rectify these
  /// differences.
M_template_rtpack(Xs)
struct clang::DesignatedInitExpr::Designator::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DesignatedInitExpr__Designator;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DesignatedInitExpr::Designator::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isFieldDesignator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::isFieldDesignator, Xs...); }) , (;) )
  constexpr bool isArrayDesignator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::isArrayDesignator, Xs...); }) , (;) )
  constexpr bool isArrayRangeDesignator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::isArrayRangeDesignator, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getFieldName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::getFieldName, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FieldDecl *) )
  getField() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::getField, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getDotLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::getDotLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getFieldLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::getFieldLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLBracketLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::getLBracketLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRBracketLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::getRBracketLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEllipsisLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::getEllipsisLoc, Xs...); }) , (;) )
  constexpr unsigned int getFirstExprIndex() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::getFirstExprIndex, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitExpr__Designator, reflenums::clang__DesignatedInitExpr__Designator::getSourceRange, Xs...); }) , (;) )
};

/// Represents a place-holder for an object not to be initialized by
/// anything.
///
/// This only makes sense when it appears as part of an updater of a
/// DesignatedInitUpdateExpr (see below). The base expression of a DIUE
/// initializes a big object, and the NoInitExpr's mark the spots within the
/// big object not to be overwritten by the updater.
///
/// \see DesignatedInitUpdateExpr
M_template_rtpack(Xs)
struct clang::NoInitExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__NoInitExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::NoInitExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NoInitExpr, reflenums::clang__NoInitExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NoInitExpr, reflenums::clang__NoInitExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NoInitExpr, reflenums::clang__NoInitExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NoInitExpr, reflenums::clang__NoInitExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NoInitExpr, reflenums::clang__NoInitExpr::getEndLoc, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::NoInitExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__NoInitExpr, reflenums::clang__NoInitExpr::children, Xs...), () )
};

M_template_rtpack(Xs)
struct clang::DesignatedInitUpdateExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DesignatedInitUpdateExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DesignatedInitUpdateExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitUpdateExpr, reflenums::clang__DesignatedInitUpdateExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitUpdateExpr, reflenums::clang__DesignatedInitUpdateExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitUpdateExpr, reflenums::clang__DesignatedInitUpdateExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitUpdateExpr, reflenums::clang__DesignatedInitUpdateExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitUpdateExpr, reflenums::clang__DesignatedInitUpdateExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitUpdateExpr, reflenums::clang__DesignatedInitUpdateExpr::getBase, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::InitListExpr *) )
  getUpdater() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DesignatedInitUpdateExpr, reflenums::clang__DesignatedInitUpdateExpr::getUpdater, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::DesignatedInitUpdateExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__DesignatedInitUpdateExpr, reflenums::clang__DesignatedInitUpdateExpr::children, Xs...), () )
};

/// Represents a loop initializing the elements of an array.
///
/// The need to initialize the elements of an array occurs in a number of
/// contexts:
///
///  * in the implicit copy/move constructor for a class with an array member
///  * when a lambda-expression captures an array by value
///  * when a decomposition declaration decomposes an array
///
/// There are two subexpressions: a common expression (the source array)
/// that is evaluated once up-front, and a per-element initializer that
/// runs once for each array element.
///
/// Within the per-element initializer, the common expression may be referenced
/// via an OpaqueValueExpr, and the current index may be obtained via an
/// ArrayInitIndexExpr.
M_template_rtpack(Xs)
struct clang::ArrayInitLoopExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ArrayInitLoopExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ArrayInitLoopExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Get the common subexpression shared by all initializations (the source
  /// array).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::OpaqueValueExpr *) )
  getCommonExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayInitLoopExpr, reflenums::clang__ArrayInitLoopExpr::getCommonExpr, Xs...); }) , (;) )
  /// Get the initializer to use for each array element.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSubExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayInitLoopExpr, reflenums::clang__ArrayInitLoopExpr::getSubExpr, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) S) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayInitLoopExpr, reflenums::clang__ArrayInitLoopExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayInitLoopExpr, reflenums::clang__ArrayInitLoopExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayInitLoopExpr, reflenums::clang__ArrayInitLoopExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayInitLoopExpr, reflenums::clang__ArrayInitLoopExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayInitLoopExpr, reflenums::clang__ArrayInitLoopExpr::getEndLoc, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ArrayInitLoopExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__ArrayInitLoopExpr, reflenums::clang__ArrayInitLoopExpr::children, Xs...), () )
};

/// Represents the index of the current element of an array being
/// initialized by an ArrayInitLoopExpr. This can only appear within the
/// subexpression of an ArrayInitLoopExpr.
M_template_rtpack(Xs)
struct clang::ArrayInitIndexExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ArrayInitIndexExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ArrayInitIndexExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) S) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayInitIndexExpr, reflenums::clang__ArrayInitIndexExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayInitIndexExpr, reflenums::clang__ArrayInitIndexExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayInitIndexExpr, reflenums::clang__ArrayInitIndexExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayInitIndexExpr, reflenums::clang__ArrayInitIndexExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayInitIndexExpr, reflenums::clang__ArrayInitIndexExpr::getEndLoc, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ArrayInitIndexExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__ArrayInitIndexExpr, reflenums::clang__ArrayInitIndexExpr::children, Xs...), () )
};

/// Represents an implicitly-generated value initialization of
/// an object of a given type.
///
/// Implicit value initializations occur within semantic initializer
/// list expressions (InitListExpr) as placeholders for subobject
/// initializations not explicitly specified by the user.
///
/// \see InitListExpr
M_template_rtpack(Xs)
struct clang::ImplicitValueInitExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ImplicitValueInitExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ImplicitValueInitExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitValueInitExpr, reflenums::clang__ImplicitValueInitExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitValueInitExpr, reflenums::clang__ImplicitValueInitExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitValueInitExpr, reflenums::clang__ImplicitValueInitExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitValueInitExpr, reflenums::clang__ImplicitValueInitExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ImplicitValueInitExpr, reflenums::clang__ImplicitValueInitExpr::getEndLoc, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ImplicitValueInitExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__ImplicitValueInitExpr, reflenums::clang__ImplicitValueInitExpr::children, Xs...), () )
};

M_template_rtpack(Xs)
struct clang::ParenListExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ParenListExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ParenListExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr unsigned int getNumExprs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenListExpr, reflenums::clang__ParenListExpr::getNumExprs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getExpr(unsigned int Init) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenListExpr, reflenums::clang__ParenListExpr::getExpr, Xs..., Init); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenListExpr, reflenums::clang__ParenListExpr::getLParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenListExpr, reflenums::clang__ParenListExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenListExpr, reflenums::clang__ParenListExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenListExpr, reflenums::clang__ParenListExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenListExpr, reflenums::clang__ParenListExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenListExpr, reflenums::clang__ParenListExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ParenListExpr, reflenums::clang__ParenListExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::ParenListExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__ParenListExpr, reflenums::clang__ParenListExpr::children, Xs...), () )
};

/// Represents a C11 generic selection.
///
/// A generic selection (C11 6.5.1.1) contains an unevaluated controlling
/// expression, followed by one or more generic associations.  Each generic
/// association specifies a type name and an expression, or "default" and an
/// expression (in which case it is known as a default generic association).
/// The type and value of the generic selection are identical to those of its
/// result expression, which is defined as the expression in the generic
/// association with a type name that is compatible with the type of the
/// controlling expression, or the expression in the default generic association
/// if no types are compatible.  For example:
///
/// @code
/// _Generic(X, double: 1, float: 2, default: 3)
/// @endcode
///
/// The above expression evaluates to 1 if 1.0 is substituted for X, 2 if 1.0f
/// or 3 if "hello".
///
/// As an extension, generic selections are allowed in C++, where the following
/// additional semantics apply:
///
/// Any generic selection whose controlling expression is type-dependent or
/// which names a dependent type in its association list is result-dependent,
/// which means that the choice of result expression is dependent.
/// Result-dependent generic associations are both type- and value-dependent.
M_template_rtpack(Xs)
struct clang::GenericSelectionExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__GenericSelectionExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::GenericSelectionExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr unsigned int getNumAssocs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getNumAssocs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getGenericLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getGenericLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getDefaultLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getDefaultLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getAssocExpr(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getAssocExpr, Xs..., i); }) , (;) )
  RANGE_REFLECTION(clang::GenericSelectionExpr, getAssocExprs,
      constexpr auto getAssocExprs() const ,
      (typename meta::clang::Expr *),
      (reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getAssocExprs, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TypeSourceInfo *) )
  getAssocTypeSourceInfo(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getAssocTypeSourceInfo, Xs..., i); }) , (;) )
  RANGE_REFLECTION(clang::GenericSelectionExpr, getAssocTypeSourceInfos,
      constexpr auto getAssocTypeSourceInfos() const ,
      (typename meta::clang::TypeSourceInfo *),
      (reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getAssocTypeSourceInfos, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAssocType(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getAssocType, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getControllingExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getControllingExpr, Xs...); }) , (;) )
  /// Whether this generic selection is result-dependent.
  constexpr bool isResultDependent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::isResultDependent, Xs...); }) , (;) )
  /// The zero-based index of the result expression's generic association in
  /// the generic selection's association list.  Defined only if the
  /// generic selection is not result-dependent.
  constexpr unsigned int getResultIndex() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getResultIndex, Xs...); }) , (;) )
  /// The generic selection's result expression.  Defined only if the
  /// generic selection is not result-dependent.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getResultExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getResultExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::GenericSelectionExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__GenericSelectionExpr, reflenums::clang__GenericSelectionExpr::children, Xs...), () )
};

/// ExtVectorElementExpr - This represents access to specific elements of a
/// vector, and may occur on the left hand side or right hand side.  For example
/// the following is legal:  "V.xy = V.zw" if V is a 4 element extended vector.
///
/// Note that the base may have either vector or pointer to vector type, just
/// like a struct field reference.
///
M_template_rtpack(Xs)
struct clang::ExtVectorElementExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ExtVectorElementExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ExtVectorElementExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorElementExpr, reflenums::clang__ExtVectorElementExpr::getBase, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo &) )
  getAccessor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorElementExpr, reflenums::clang__ExtVectorElementExpr::getAccessor, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAccessorLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorElementExpr, reflenums::clang__ExtVectorElementExpr::getAccessorLoc, Xs...); }) , (;) )
  /// getNumElements - Get the number of components being selected.
  constexpr unsigned int getNumElements() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorElementExpr, reflenums::clang__ExtVectorElementExpr::getNumElements, Xs...); }) , (;) )
  /// containsDuplicateElements - Return true if any element access is
  /// repeated.
  constexpr bool containsDuplicateElements() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorElementExpr, reflenums::clang__ExtVectorElementExpr::containsDuplicateElements, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorElementExpr, reflenums::clang__ExtVectorElementExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorElementExpr, reflenums::clang__ExtVectorElementExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorElementExpr, reflenums::clang__ExtVectorElementExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorElementExpr, reflenums::clang__ExtVectorElementExpr::getEndLoc, Xs...); }) , (;) )
  /// isArrow - Return true if the base expression is a pointer to vector,
  /// return false if the base expression is a vector.
  constexpr bool isArrow() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorElementExpr, reflenums::clang__ExtVectorElementExpr::isArrow, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExtVectorElementExpr, reflenums::clang__ExtVectorElementExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::ExtVectorElementExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__ExtVectorElementExpr, reflenums::clang__ExtVectorElementExpr::children, Xs...), () )
};

/// BlockExpr - Adaptor class for mixing a BlockDecl with expressions.
/// ^{ statement-body }   or   ^(int arg1, float arg2){ statement-body }
M_template_rtpack(Xs)
struct clang::BlockExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__BlockExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::BlockExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::BlockDecl *) )
  getBlockDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockExpr, reflenums::clang__BlockExpr::getBlockDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getCaretLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockExpr, reflenums::clang__BlockExpr::getCaretLocation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockExpr, reflenums::clang__BlockExpr::getBody, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockExpr, reflenums::clang__BlockExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockExpr, reflenums::clang__BlockExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockExpr, reflenums::clang__BlockExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockExpr, reflenums::clang__BlockExpr::getEndLoc, Xs...); }) , (;) )
  /// getFunctionType - Return the underlying function type for this block.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionProtoType *) )
  getFunctionType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockExpr, reflenums::clang__BlockExpr::getFunctionType, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BlockExpr, reflenums::clang__BlockExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::BlockExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__BlockExpr, reflenums::clang__BlockExpr::children, Xs...), () )
};

/// AsTypeExpr - Clang builtin function __builtin_astype [OpenCL 6.2.4.2]
/// This AST node provides support for reinterpreting a type to another
/// type of the same size.
M_template_rtpack(Xs)
struct clang::AsTypeExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__AsTypeExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::AsTypeExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// getSrcExpr - Return the Expr to be converted.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSrcExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsTypeExpr, reflenums::clang__AsTypeExpr::getSrcExpr, Xs...); }) , (;) )
  /// getBuiltinLoc - Return the location of the __builtin_astype token.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBuiltinLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsTypeExpr, reflenums::clang__AsTypeExpr::getBuiltinLoc, Xs...); }) , (;) )
  /// getRParenLoc - Return the location of final right parenthesis.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsTypeExpr, reflenums::clang__AsTypeExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsTypeExpr, reflenums::clang__AsTypeExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsTypeExpr, reflenums::clang__AsTypeExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsTypeExpr, reflenums::clang__AsTypeExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsTypeExpr, reflenums::clang__AsTypeExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AsTypeExpr, reflenums::clang__AsTypeExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::AsTypeExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__AsTypeExpr, reflenums::clang__AsTypeExpr::children, Xs...), () )
};

/// PseudoObjectExpr - An expression which accesses a pseudo-object
/// l-value.  A pseudo-object is an abstract object, accesses to which
/// are translated to calls.  The pseudo-object expression has a
/// syntactic form, which shows how the expression was actually
/// written in the source code, and a semantic form, which is a series
/// of expressions to be executed in order which detail how the
/// operation is actually evaluated.  Optionally, one of the semantic
/// forms may also provide a result value for the expression.
///
/// If any of the semantic-form expressions is an OpaqueValueExpr,
/// that OVE is required to have a source expression, and it is bound
/// to the result of that source expression.  Such OVEs may appear
/// only in subsequent semantic-form expressions and as
/// sub-expressions of the syntactic form.
///
/// PseudoObjectExpr should be used only when an operation can be
/// usefully described in terms of fairly simple rewrite rules on
/// objects and functions that are meant to be used by end-developers.
/// For example, under the Itanium ABI, dynamic casts are implemented
/// as a call to a runtime function called __dynamic_cast; using this
/// class to describe that would be inappropriate because that call is
/// not really part of the user-visible semantics, and instead the
/// cast is properly reflected in the AST and IR-generation has been
/// taught to generate the call as necessary.  In contrast, an
/// Objective-C property access is semantically defined to be
/// equivalent to a particular message send, and this is very much
/// part of the user model.  The name of this class encourages this
/// modelling design.
M_template_rtpack(Xs)
struct clang::PseudoObjectExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__PseudoObjectExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::PseudoObjectExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::PseudoObjectExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) shell, unsigned int numSemanticExprs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::Create, Xs..., Y0s..., Y1s..., numSemanticExprs); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSyntacticForm() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::getSyntacticForm, Xs...); }) , (;) )
  /// Return the index of the result-bearing expression into the semantics
  /// expressions, or PseudoObjectExpr::NoResult if there is none.
  constexpr unsigned int getResultExprIndex() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::getResultExprIndex, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getResultExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::getResultExpr, Xs...); }) , (;) )
  constexpr unsigned int getNumSemanticExprs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::getNumSemanticExprs, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::PseudoObjectExpr, semantics,
      constexpr auto semantics() const ,
      (const typename meta::clang::Expr *const),
      (reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::semantics, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSemanticExpr(unsigned int index) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::getSemanticExpr, Xs..., index); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::getExprLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::getEndLoc, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::PseudoObjectExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::children, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PseudoObjectExpr, reflenums::clang__PseudoObjectExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

enum clang::AtomicExpr::AtomicOp : unsigned int {
  AO__c11_atomic_init,
  AO__c11_atomic_load,
  AO__c11_atomic_store,
  AO__c11_atomic_exchange,
  AO__c11_atomic_compare_exchange_strong,
  AO__c11_atomic_compare_exchange_weak,
  AO__c11_atomic_fetch_add,
  AO__c11_atomic_fetch_sub,
  AO__c11_atomic_fetch_and,
  AO__c11_atomic_fetch_or,
  AO__c11_atomic_fetch_xor,
  AO__atomic_load,
  AO__atomic_load_n,
  AO__atomic_store,
  AO__atomic_store_n,
  AO__atomic_exchange,
  AO__atomic_exchange_n,
  AO__atomic_compare_exchange,
  AO__atomic_compare_exchange_n,
  AO__atomic_fetch_add,
  AO__atomic_fetch_sub,
  AO__atomic_fetch_and,
  AO__atomic_fetch_or,
  AO__atomic_fetch_xor,
  AO__atomic_fetch_nand,
  AO__atomic_add_fetch,
  AO__atomic_sub_fetch,
  AO__atomic_and_fetch,
  AO__atomic_or_fetch,
  AO__atomic_xor_fetch,
  AO__atomic_nand_fetch,
  AO__opencl_atomic_init,
  AO__opencl_atomic_load,
  AO__opencl_atomic_store,
  AO__opencl_atomic_exchange,
  AO__opencl_atomic_compare_exchange_strong,
  AO__opencl_atomic_compare_exchange_weak,
  AO__opencl_atomic_fetch_add,
  AO__opencl_atomic_fetch_sub,
  AO__opencl_atomic_fetch_and,
  AO__opencl_atomic_fetch_or,
  AO__opencl_atomic_fetch_xor,
  AO__opencl_atomic_fetch_min,
  AO__opencl_atomic_fetch_max,
  AO__atomic_fetch_min,
  AO__atomic_fetch_max,
  BI_First = 0,
};

/// AtomicExpr - Variadic atomic builtins: __atomic_exchange, __atomic_fetch_*,
/// __atomic_load, __atomic_store, and __atomic_compare_exchange_*, for the
/// similarly-named C++11 instructions, and __c11 variants for <stdatomic.h>,
/// and corresponding __opencl_atomic_* for OpenCL 2.0.
/// All of these instructions take one primary pointer, at least one memory
/// order. The instructions for which getScopeModel returns non-null value
/// take one synch scope.
M_template_rtpack(Xs)
struct clang::AtomicExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__AtomicExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::AtomicExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using AtomicOp = enum refldetail::clang::AtomicExpr::AtomicOp;
  /// Determine the number of arguments the specified atomic builtin
  /// should have.
  static constexpr unsigned int getNumSubExprs(enum clang::AtomicExpr::AtomicOp Op) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getNumSubExprs, Xs..., Op); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getPtr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getPtr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getOrder() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getOrder, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getScope() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getScope, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getVal1() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getVal1, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getOrderFail() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getOrderFail, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getVal2() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getVal2, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getWeak() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getWeak, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getValueType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getValueType, Xs...); }) , (;) )
  constexpr enum clang::AtomicExpr::AtomicOp getOp() const IFMETA_ELSE( ({    return (enum clang::AtomicExpr::AtomicOp)__reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getOp, Xs...); }) , (;) )
  constexpr unsigned int getNumSubExprs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getNumSubExprs1, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *const *) )
  getSubExprs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getSubExprs, Xs...); }) , (;) )
  constexpr bool isVolatile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::isVolatile, Xs...); }) , (;) )
  constexpr bool isCmpXChg() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::isCmpXChg, Xs...); }) , (;) )
  constexpr bool isOpenCL() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::isOpenCL, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBuiltinLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getBuiltinLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::AtomicExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__AtomicExpr, reflenums::clang__AtomicExpr::children, Xs...), () )
};

/// TypoExpr - Internal placeholder for expressions where typo correction
/// still needs to be performed and/or an error diagnostic emitted.
M_template_rtpack(Xs)
struct clang::TypoExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypoExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypoExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  RANGE_REFLECTION(clang::TypoExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__TypoExpr, reflenums::clang__TypoExpr::children, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypoExpr, reflenums::clang__TypoExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypoExpr, reflenums::clang__TypoExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypoExpr, reflenums::clang__TypoExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypoExpr, reflenums::clang__TypoExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypoExpr, reflenums::clang__TypoExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

enum clang::attr::Kind : unsigned int {
  FallThrough,
  Suppress,
  SwiftContext,
  SwiftErrorResult,
  SwiftIndirectResult,
  Annotate,
  CFConsumed,
  CarriesDependency,
  NSConsumed,
  NonNull,
  PassObjectSize,
  AMDGPUFlatWorkGroupSize,
  AMDGPUNumSGPR,
  AMDGPUNumVGPR,
  AMDGPUWavesPerEU,
  ARMInterrupt,
  AVRInterrupt,
  AVRSignal,
  AcquireCapability,
  AcquiredAfter,
  AcquiredBefore,
  AlignMac68k,
  Aligned,
  AllocAlign,
  AllocSize,
  AlwaysInline,
  AnalyzerNoReturn,
  AnyX86Interrupt,
  AnyX86NoCallerSavedRegisters,
  AnyX86NoCfCheck,
  ArcWeakrefUnavailable,
  ArgumentWithTypeTag,
  Artificial,
  AsmLabel,
  AssertCapability,
  AssertExclusiveLock,
  AssertSharedLock,
  AssumeAligned,
  Availability,
  Blocks,
  C11NoReturn,
  CDecl,
  CFAuditedTransfer,
  CFReturnsNotRetained,
  CFReturnsRetained,
  CFUnknownTransfer,
  CPUDispatch,
  CPUSpecific,
  CUDAConstant,
  CUDADevice,
  CUDAGlobal,
  CUDAHost,
  CUDAInvalidTarget,
  CUDALaunchBounds,
  CUDAShared,
  CXX11NoReturn,
  CallableWhen,
  Capability,
  CapturedRecord,
  Cleanup,
  CodeSeg,
  Cold,
  Common,
  Const,
  Constructor,
  Consumable,
  ConsumableAutoCast,
  ConsumableSetOnRead,
  Convergent,
  DLLExport,
  DLLImport,
  Deprecated,
  Destructor,
  DiagnoseIf,
  DisableTailCalls,
  EmptyBases,
  EnableIf,
  EnumExtensibility,
  ExclusiveTrylockFunction,
  ExternalSourceSymbol,
  FastCall,
  Final,
  FlagEnum,
  Flatten,
  Format,
  FormatArg,
  GNUInline,
  GuardedBy,
  GuardedVar,
  Hot,
  IBAction,
  IBOutlet,
  IBOutletCollection,
  InitPriority,
  IntelOclBicc,
  InternalLinkage,
  LTOVisibilityPublic,
  LayoutVersion,
  LifetimeBound,
  LockReturned,
  LocksExcluded,
  MSABI,
  MSInheritance,
  MSNoVTable,
  MSP430Interrupt,
  MSStruct,
  MSVtorDisp,
  MaxFieldAlignment,
  MayAlias,
  MicroMips,
  MinSize,
  MinVectorWidth,
  Mips16,
  MipsInterrupt,
  MipsLongCall,
  MipsShortCall,
  NSConsumesSelf,
  NSReturnsAutoreleased,
  NSReturnsNotRetained,
  NSReturnsRetained,
  Naked,
  NoAlias,
  NoCommon,
  NoDebug,
  NoDuplicate,
  NoInline,
  NoInstrumentFunction,
  NoMicroMips,
  NoMips16,
  NoReturn,
  NoSanitize,
  NoSplitStack,
  NoStackProtector,
  NoThreadSafetyAnalysis,
  NoThrow,
  NotTailCalled,
  OMPCaptureNoInit,
  OMPDeclareTargetDecl,
  OMPThreadPrivateDecl,
  ObjCBridge,
  ObjCBridgeMutable,
  ObjCBridgeRelated,
  ObjCException,
  ObjCExplicitProtocolImpl,
  ObjCIndependentClass,
  ObjCMethodFamily,
  ObjCNSObject,
  ObjCPreciseLifetime,
  ObjCRequiresPropertyDefs,
  ObjCRequiresSuper,
  ObjCReturnsInnerPointer,
  ObjCRootClass,
  ObjCSubclassingRestricted,
  OpenCLIntelReqdSubGroupSize,
  OpenCLKernel,
  OpenCLUnrollHint,
  OptimizeNone,
  Override,
  Ownership,
  Packed,
  ParamTypestate,
  Pascal,
  Pcs,
  PragmaClangBSSSection,
  PragmaClangDataSection,
  PragmaClangRodataSection,
  PragmaClangTextSection,
  PreserveAll,
  PreserveMost,
  PtGuardedBy,
  PtGuardedVar,
  Pure,
  RISCVInterrupt,
  RegCall,
  ReleaseCapability,
  ReqdWorkGroupSize,
  RequireConstantInit,
  RequiresCapability,
  Restrict,
  ReturnTypestate,
  ReturnsNonNull,
  ReturnsTwice,
  ScopedLockable,
  Section,
  SelectAny,
  Sentinel,
  SetTypestate,
  SharedTrylockFunction,
  StdCall,
  SwiftCall,
  SysVABI,
  TLSModel,
  Target,
  TestTypestate,
  ThisCall,
  TransparentUnion,
  TrivialABI,
  TryAcquireCapability,
  TypeTagForDatatype,
  TypeVisibility,
  Unavailable,
  Unused,
  Used,
  Uuid,
  VecReturn,
  VecTypeHint,
  VectorCall,
  Visibility,
  WarnUnused,
  WarnUnusedResult,
  Weak,
  WeakImport,
  WeakRef,
  WorkGroupSizeHint,
  X86ForceAlignArgPointer,
  XRayInstrument,
  XRayLogArgs,
  AbiTag,
  Alias,
  AlignValue,
  IFunc,
  InitSeg,
  LoopHint,
  Mode,
  NoEscape,
  OMPCaptureKind,
  OMPDeclareSimdDecl,
  OMPReferencedVar,
  ObjCBoxable,
  ObjCDesignatedInitializer,
  ObjCRuntimeName,
  ObjCRuntimeVisible,
  OpenCLAccess,
  Overloadable,
  RenderScriptKernel,
  Thread,
  FirstAttr = 0,
  LastAttr = 235,
  FirstStmtAttr = 0,
  LastStmtAttr = 1,
  FirstInheritableAttr = 2,
  LastInheritableAttr = 216,
  FirstInheritableParamAttr = 2,
  LastInheritableParamAttr = 10,
  FirstParameterABIAttr = 2,
  LastParameterABIAttr = 4,
};

/// OpenMP directives.
enum clang::OpenMPDirectiveKind : unsigned int {
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_threadprivate,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_parallel,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_task,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_for,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_sections,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_section,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_single,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_master,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_critical,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_taskyield,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_barrier,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_taskwait,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_taskgroup,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_flush,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_ordered,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_atomic,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_teams,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_cancel,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target_data,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target_enter_data,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target_exit_data,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target_parallel,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target_parallel_for,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target_update,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_parallel_for,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_parallel_for_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_parallel_sections,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_for_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_cancellation_point,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_declare_reduction,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_declare_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_taskloop,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_taskloop_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_distribute,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_declare_target,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_end_declare_target,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_distribute_parallel_for,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_distribute_parallel_for_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_distribute_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target_parallel_for_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_teams_distribute,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_teams_distribute_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_teams_distribute_parallel_for_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_teams_distribute_parallel_for,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target_teams,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target_teams_distribute,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target_teams_distribute_parallel_for,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target_teams_distribute_parallel_for_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_target_teams_distribute_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPD_unknown,
};

/// OpenMP clauses.
enum clang::OpenMPClauseKind : unsigned int {
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_if,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_final,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_num_threads,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_safelen,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_simdlen,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_collapse,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_default,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_private,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_firstprivate,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_lastprivate,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_shared,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_reduction,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_linear,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_aligned,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_copyin,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_copyprivate,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_proc_bind,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_schedule,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_ordered,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_nowait,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_untied,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_mergeable,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_flush,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_read,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_write,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_update,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_capture,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_seq_cst,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_depend,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_device,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_threads,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_simd,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_map,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_num_teams,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_thread_limit,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_priority,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_grainsize,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_nogroup,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_num_tasks,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_hint,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_dist_schedule,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_defaultmap,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_to,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_from,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_use_device_ptr,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_is_device_ptr,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_task_reduction,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_in_reduction,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_threadprivate,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_uniform,
  /// \file
/// This file defines the list of supported OpenMP directives and
/// clauses.
///
  OMPC_unknown,
};

/// Attr - This represents one attribute.
M_template_rtpack(Xs)
struct clang::Attr::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__Attr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::Attr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr void * operator new(unsigned long Bytes, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned long Alignment = 8) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Attr, reflenums::clang__Attr::operator_new, Xs..., Bytes, Y0s..., Alignment); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr void operator delete(void * Ptr, IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned long Alignment) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Attr, reflenums::clang__Attr::operator_delete, Xs..., Ptr, Y0s..., Alignment); }) , (;) )
  constexpr enum clang::attr::Kind getKind() const IFMETA_ELSE( ({    return (enum clang::attr::Kind)__reflect_prop(reflenums::RK_clang__Attr, reflenums::clang__Attr::getKind, Xs...); }) , (;) )
  constexpr unsigned int getSpellingListIndex() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Attr, reflenums::clang__Attr::getSpellingListIndex, Xs...); }) , (;) )
  constexpr const char * getSpelling() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Attr, reflenums::clang__Attr::getSpelling, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Attr, reflenums::clang__Attr::getLocation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Attr, reflenums::clang__Attr::getRange, Xs...); }) , (;) )
  constexpr bool isInherited() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Attr, reflenums::clang__Attr::isInherited, Xs...); }) , (;) )
  /// Returns true if the attribute has been implicitly created instead
  /// of explicitly written by the user.
  constexpr bool isImplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Attr, reflenums::clang__Attr::isImplicit, Xs...); }) , (;) )
  constexpr bool isPackExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Attr, reflenums::clang__Attr::isPackExpansion, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Attr *) )
  clone(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Attr, reflenums::clang__Attr::clone, Xs..., Y0s...); }) , (;) )
  constexpr bool isLateParsed() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__Attr, reflenums::clang__Attr::isLateParsed, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void printPretty(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__Attr, reflenums::clang__Attr::printPretty, Xs..., Y0s..., Y1s...); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::InheritableAttr::impl : impl_offset_t<clang::Attr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__InheritableAttr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::InheritableAttr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Should this attribute be inherited from a prior declaration even if it's
  /// explicitly provided in the current declaration?
  constexpr bool shouldInheritEvenIfAlreadyPresent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InheritableAttr, reflenums::clang__InheritableAttr::shouldInheritEvenIfAlreadyPresent, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Attr::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Attr *)) A) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InheritableAttr, reflenums::clang__InheritableAttr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::ExternalSourceSymbolAttr::impl : impl_offset_t<clang::InheritableAttr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ExternalSourceSymbolAttr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ExternalSourceSymbolAttr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ExternalSourceSymbolAttr *) )
  clone(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExternalSourceSymbolAttr, reflenums::clang__ExternalSourceSymbolAttr::clone, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void printPretty(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ExternalSourceSymbolAttr, reflenums::clang__ExternalSourceSymbolAttr::printPretty, Xs..., Y0s..., Y1s...); }) , (;) )
  constexpr const char * getSpelling() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExternalSourceSymbolAttr, reflenums::clang__ExternalSourceSymbolAttr::getSpelling, Xs...); }) , (;) )
  constexpr const char * getLanguage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExternalSourceSymbolAttr, reflenums::clang__ExternalSourceSymbolAttr::getLanguage, Xs...); }) , (;) )
  constexpr unsigned int getLanguageLength() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExternalSourceSymbolAttr, reflenums::clang__ExternalSourceSymbolAttr::getLanguageLength, Xs...); }) , (;) )
  constexpr const char * getDefinedIn() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExternalSourceSymbolAttr, reflenums::clang__ExternalSourceSymbolAttr::getDefinedIn, Xs...); }) , (;) )
  constexpr unsigned int getDefinedInLength() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExternalSourceSymbolAttr, reflenums::clang__ExternalSourceSymbolAttr::getDefinedInLength, Xs...); }) , (;) )
  constexpr bool getGeneratedDeclaration() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExternalSourceSymbolAttr, reflenums::clang__ExternalSourceSymbolAttr::getGeneratedDeclaration, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Attr::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Attr *)) A) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExternalSourceSymbolAttr, reflenums::clang__ExternalSourceSymbolAttr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

enum clang::MSInheritanceAttr::Spelling : unsigned int {
  Keyword_single_inheritance = 0,
  Keyword_multiple_inheritance = 1,
  Keyword_virtual_inheritance = 2,
  Keyword_unspecified_inheritance = 3,
};

M_template_rtpack(Xs)
struct clang::MSInheritanceAttr::impl : impl_offset_t<clang::InheritableAttr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__MSInheritanceAttr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::MSInheritanceAttr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using Spelling = enum refldetail::clang::MSInheritanceAttr::Spelling;
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::MSInheritanceAttr *) )
  CreateImplicit(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx, enum clang::MSInheritanceAttr::Spelling S, bool BestCase, IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceRange)) Loc = {}) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSInheritanceAttr, reflenums::clang__MSInheritanceAttr::CreateImplicit, Xs..., Y0s..., S, BestCase, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::MSInheritanceAttr *) )
  CreateImplicit(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx, enum clang::MSInheritanceAttr::Spelling S, IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceRange)) Loc = {}) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSInheritanceAttr, reflenums::clang__MSInheritanceAttr::CreateImplicit1, Xs..., Y0s..., S, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::MSInheritanceAttr *) )
  clone(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSInheritanceAttr, reflenums::clang__MSInheritanceAttr::clone, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void printPretty(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__MSInheritanceAttr, reflenums::clang__MSInheritanceAttr::printPretty, Xs..., Y0s..., Y1s...); }) , (;) )
  constexpr const char * getSpelling() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSInheritanceAttr, reflenums::clang__MSInheritanceAttr::getSpelling, Xs...); }) , (;) )
  constexpr enum clang::MSInheritanceAttr::Spelling getSemanticSpelling() const IFMETA_ELSE( ({    return (enum clang::MSInheritanceAttr::Spelling)__reflect_prop(reflenums::RK_clang__MSInheritanceAttr, reflenums::clang__MSInheritanceAttr::getSemanticSpelling, Xs...); }) , (;) )
  constexpr bool getBestCase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSInheritanceAttr, reflenums::clang__MSInheritanceAttr::getBestCase, Xs...); }) , (;) )
  static const bool DefaultBestCase = true;
  static constexpr bool hasVBPtrOffsetField(enum clang::MSInheritanceAttr::Spelling Inheritance) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSInheritanceAttr, reflenums::clang__MSInheritanceAttr::hasVBPtrOffsetField, Xs..., Inheritance); }) , (;) )
  static constexpr bool hasNVOffsetField(bool IsMemberFunction, enum clang::MSInheritanceAttr::Spelling Inheritance) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSInheritanceAttr, reflenums::clang__MSInheritanceAttr::hasNVOffsetField, Xs..., IsMemberFunction, Inheritance); }) , (;) )
  static constexpr bool hasVBTableOffsetField(enum clang::MSInheritanceAttr::Spelling Inheritance) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSInheritanceAttr, reflenums::clang__MSInheritanceAttr::hasVBTableOffsetField, Xs..., Inheritance); }) , (;) )
  static constexpr bool hasOnlyOneField(bool IsMemberFunction, enum clang::MSInheritanceAttr::Spelling Inheritance) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSInheritanceAttr, reflenums::clang__MSInheritanceAttr::hasOnlyOneField, Xs..., IsMemberFunction, Inheritance); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Attr::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Attr *)) A) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSInheritanceAttr, reflenums::clang__MSInheritanceAttr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

enum clang::MSVtorDispAttr::Mode : unsigned int {
  Never,
  ForVBaseOverride,
  ForVFTable,
};

M_template_rtpack(Xs)
struct clang::MSVtorDispAttr::impl : impl_offset_t<clang::InheritableAttr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__MSVtorDispAttr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::MSVtorDispAttr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::MSVtorDispAttr *) )
  CreateImplicit(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx, unsigned int Vdm, IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceRange)) Loc = {}) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSVtorDispAttr, reflenums::clang__MSVtorDispAttr::CreateImplicit, Xs..., Y0s..., Vdm, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::MSVtorDispAttr *) )
  clone(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSVtorDispAttr, reflenums::clang__MSVtorDispAttr::clone, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void printPretty(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__MSVtorDispAttr, reflenums::clang__MSVtorDispAttr::printPretty, Xs..., Y0s..., Y1s...); }) , (;) )
  constexpr const char * getSpelling() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSVtorDispAttr, reflenums::clang__MSVtorDispAttr::getSpelling, Xs...); }) , (;) )
  constexpr unsigned int getVdm() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSVtorDispAttr, reflenums::clang__MSVtorDispAttr::getVdm, Xs...); }) , (;) )
  using Mode = enum refldetail::clang::MSVtorDispAttr::Mode;
  constexpr enum clang::MSVtorDispAttr::Mode getVtorDispMode() const IFMETA_ELSE( ({    return (enum clang::MSVtorDispAttr::Mode)__reflect_prop(reflenums::RK_clang__MSVtorDispAttr, reflenums::clang__MSVtorDispAttr::getVtorDispMode, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Attr::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Attr *)) A) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSVtorDispAttr, reflenums::clang__MSVtorDispAttr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// The default, if any, capture method for a lambda expression.
enum clang::LambdaCaptureDefault : unsigned int {
  LCD_None,
  LCD_ByCopy,
  LCD_ByRef,
};

/// The different capture forms in a lambda introducer
///
/// C++11 allows capture of \c this, or of local variables by copy or
/// by reference.  C++1y also allows "init-capture", where the initializer
/// is an expression.
enum clang::LambdaCaptureKind : unsigned int {
  ///< Capturing the \c *this object by reference
  LCK_This,
  LCK_StarThis,
  ///< Capturing by copy (a.k.a., by value)
  LCK_ByCopy,
  ///< Capturing by reference
  LCK_ByRef,
  ///< Capturing variable-length array type
  LCK_VLAType,
};

/// Describes the capture of a variable or of \c this, or of a
/// C++1y init-capture.
M_template_rtpack(Xs)
struct clang::LambdaCapture::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__LambdaCapture;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::LambdaCapture::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Determine the kind of capture.
  constexpr enum clang::LambdaCaptureKind getCaptureKind() const IFMETA_ELSE( ({    return (enum clang::LambdaCaptureKind)__reflect_prop(reflenums::RK_clang__LambdaCapture, reflenums::clang__LambdaCapture::getCaptureKind, Xs...); }) , (;) )
  /// Determine whether this capture handles the C++ \c this
  /// pointer.
  constexpr bool capturesThis() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaCapture, reflenums::clang__LambdaCapture::capturesThis, Xs...); }) , (;) )
  /// Determine whether this capture handles a variable.
  constexpr bool capturesVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaCapture, reflenums::clang__LambdaCapture::capturesVariable, Xs...); }) , (;) )
  /// Determine whether this captures a variable length array bound
  /// expression.
  constexpr bool capturesVLAType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaCapture, reflenums::clang__LambdaCapture::capturesVLAType, Xs...); }) , (;) )
  /// Retrieve the declaration of the local variable being
  /// captured.
  ///
  /// This operation is only valid if this capture is a variable capture
  /// (other than a capture of \c this).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getCapturedVar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaCapture, reflenums::clang__LambdaCapture::getCapturedVar, Xs...); }) , (;) )
  /// Determine whether this was an implicit capture (not
  /// written between the square brackets introducing the lambda).
  constexpr bool isImplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaCapture, reflenums::clang__LambdaCapture::isImplicit, Xs...); }) , (;) )
  /// Determine whether this was an explicit capture (written
  /// between the square brackets introducing the lambda).
  constexpr bool isExplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaCapture, reflenums::clang__LambdaCapture::isExplicit, Xs...); }) , (;) )
  /// Retrieve the source location of the capture.
  ///
  /// For an explicit capture, this returns the location of the
  /// explicit capture in the source. For an implicit capture, this
  /// returns the location at which the variable or \c this was first
  /// used.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaCapture, reflenums::clang__LambdaCapture::getLocation, Xs...); }) , (;) )
  /// Determine whether this capture is a pack expansion,
  /// which captures a function parameter pack.
  constexpr bool isPackExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaCapture, reflenums::clang__LambdaCapture::isPackExpansion, Xs...); }) , (;) )
  /// Retrieve the location of the ellipsis for a capture
  /// that is a pack expansion.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEllipsisLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaCapture, reflenums::clang__LambdaCapture::getEllipsisLoc, Xs...); }) , (;) )
};

/// Represents an access specifier followed by colon ':'.
///
/// An objects of this class represents sugar for the syntactic occurrence
/// of an access specifier followed by a colon in the list of member
/// specifiers of a C++ class definition.
///
/// Note that they do not represent other uses of access specifiers,
/// such as those occurring in a list of base specifiers.
/// Also note that this class has nothing to do with so-called
/// "access declarations" (C++98 11.3 [class.access.dcl]).
M_template_rtpack(Xs)
struct clang::AccessSpecDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__AccessSpecDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::AccessSpecDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// The location of the access specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAccessSpecifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AccessSpecDecl, reflenums::clang__AccessSpecDecl::getAccessSpecifierLoc, Xs...); }) , (;) )
  /// The location of the colon following the access specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getColonLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AccessSpecDecl, reflenums::clang__AccessSpecDecl::getColonLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AccessSpecDecl, reflenums::clang__AccessSpecDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::AccessSpecDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, enum clang::AccessSpecifier AS, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) ASLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) ColonLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AccessSpecDecl, reflenums::clang__AccessSpecDecl::Create, Xs..., Y0s..., AS, Y1s..., Y2s..., Y3s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::AccessSpecDecl *) )
  Create(Y0 p0, enum clang::AccessSpecifier p1, ptrwrp<Y1> p2, Y2 p3, Y3 p4) {
      return Create(p0, p1, p2.get(), p3, p4);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::AccessSpecDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AccessSpecDecl, reflenums::clang__AccessSpecDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AccessSpecDecl, reflenums::clang__AccessSpecDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__AccessSpecDecl, reflenums::clang__AccessSpecDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a base class of a C++ class.
///
/// Each CXXBaseSpecifier represents a single, direct base class (or
/// struct) of a C++ class (or struct). It specifies the type of that
/// base class, whether it is a virtual or non-virtual base, and what
/// level of access (public, protected, private) is used for the
/// derivation. For example:
///
/// \code
///   class A { };
///   class B { };
///   class C : public virtual A, protected B { };
/// \endcode
///
/// In this code, C will have two CXXBaseSpecifiers, one for "public
/// virtual A" and the other for "protected B".
M_template_rtpack(Xs)
struct clang::CXXBaseSpecifier::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXBaseSpecifier;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXBaseSpecifier::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieves the source range that contains the entire base specifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::getEndLoc, Xs...); }) , (;) )
  /// Get the location at which the base class type was written.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBaseTypeLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::getBaseTypeLoc, Xs...); }) , (;) )
  /// Determines whether the base class is a virtual base class (or not).
  constexpr bool isVirtual() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::isVirtual, Xs...); }) , (;) )
  /// Determine whether this base class is a base of a class declared
  /// with the 'class' keyword (vs. one declared with the 'struct' keyword).
  constexpr bool isBaseOfClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::isBaseOfClass, Xs...); }) , (;) )
  /// Determine whether this base specifier is a pack expansion.
  constexpr bool isPackExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::isPackExpansion, Xs...); }) , (;) )
  /// Determine whether this base class's constructors get inherited.
  constexpr bool getInheritConstructors() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::getInheritConstructors, Xs...); }) , (;) )
  /// For a pack expansion, determine the location of the ellipsis.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEllipsisLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::getEllipsisLoc, Xs...); }) , (;) )
  /// Returns the access specifier for this base specifier.
  ///
  /// This is the actual base specifier as used for semantic analysis, so
  /// the result can never be AS_none. To retrieve the access specifier as
  /// written in the source code, use getAccessSpecifierAsWritten().
  constexpr enum clang::AccessSpecifier getAccessSpecifier() const IFMETA_ELSE( ({    return (enum clang::AccessSpecifier)__reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::getAccessSpecifier, Xs...); }) , (;) )
  /// Retrieves the access specifier as written in the source code
  /// (which may mean that no access specifier was explicitly written).
  ///
  /// Use getAccessSpecifier() to retrieve the access specifier for use in
  /// semantic analysis.
  constexpr enum clang::AccessSpecifier getAccessSpecifierAsWritten() const IFMETA_ELSE( ({    return (enum clang::AccessSpecifier)__reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::getAccessSpecifierAsWritten, Xs...); }) , (;) )
  /// Retrieves the type of the base class.
  ///
  /// This type will always be an unqualified class type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::getType, Xs...); }) , (;) )
  /// Retrieves the type and source location of the base class.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBaseSpecifier, reflenums::clang__CXXBaseSpecifier::getTypeSourceInfo, Xs...); }) , (;) )
};

/// Represents a C++ struct/union/class.
M_template_rtpack(Xs)
struct clang::CXXRecordDecl::impl : impl_offset_t<clang::RecordDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXRecordDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXRecordDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXRecordDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getCanonicalDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXRecordDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXRecordDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getMostRecentDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXRecordDecl *) )
  getMostRecentNonInjectedDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getMostRecentNonInjectedDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getDefinition, Xs...); }) , (;) )
  constexpr bool hasDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasDefinition, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, enum clang::TagTypeKind TK, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) IdLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::CXXRecordDecl *)) PrevDecl = {}, bool DelayTypeCreation = false) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::Create, Xs..., Y0s..., TK, Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., DelayTypeCreation); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  Create(Y0 p0, enum clang::TagTypeKind p1, ptrwrp<Y1> p2, Y2 p3, Y3 p4, ptrwrp<Y4> p5, ptrwrp<Y5> p6 = {}, bool p7 = false) {
      return Create(p0, p1, p2.get(), p3, p4, p5.get(), p6.get(), p7);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  CreateLambda(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::TypeSourceInfo *)) Info, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) Loc, bool DependentLambda, bool IsGeneric, enum clang::LambdaCaptureDefault CaptureDefault) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::CreateLambda, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., DependentLambda, IsGeneric, CaptureDefault); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  CreateLambda(Y0 p0, ptrwrp<Y1> p1, ptrwrp<Y2> p2, Y3 p3, bool p4, bool p5, enum clang::LambdaCaptureDefault p6) {
      return CreateLambda(p0, p1.get(), p2.get(), p3, p4, p5, p6);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr bool isDynamicClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isDynamicClass, Xs...); }) , (;) )
  /// @returns true if class is dynamic or might be dynamic because the
  /// definition is incomplete of dependent.
  constexpr bool mayBeDynamicClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::mayBeDynamicClass, Xs...); }) , (;) )
  /// @returns true if class is non dynamic or might be non dynamic because the
  /// definition is incomplete of dependent.
  constexpr bool mayBeNonDynamicClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::mayBeNonDynamicClass, Xs...); }) , (;) )
  constexpr bool isParsingBaseSpecifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isParsingBaseSpecifiers, Xs...); }) , (;) )
  constexpr bool isInstantiation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isInstantiation, Xs...); }) , (;) )
  constexpr unsigned int getODRHash() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getODRHash, Xs...); }) , (;) )
  /// Retrieves the number of base classes of this class.
  constexpr unsigned int getNumBases() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getNumBases, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CXXRecordDecl, bases,
      constexpr auto bases() const ,
      (const typename meta::clang::CXXBaseSpecifier),
      (reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::bases, Xs...), () )
  /// Retrieves the number of virtual base classes of this class.
  constexpr unsigned int getNumVBases() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getNumVBases, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CXXRecordDecl, vbases,
      constexpr auto vbases() const ,
      (const typename meta::clang::CXXBaseSpecifier),
      (reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::vbases, Xs...), () )
  /// Determine whether this class has any dependent base classes which
  /// are not the current instantiation.
  constexpr bool hasAnyDependentBases() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasAnyDependentBases, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CXXRecordDecl, methods,
      constexpr auto methods() const ,
      (typename meta::clang::CXXMethodDecl *),
      (reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::methods, Xs...), () )
  RANGE_REFLECTION(clang::CXXRecordDecl, ctors,
      constexpr auto ctors() const ,
      (typename meta::clang::CXXConstructorDecl *),
      (reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::ctors, Xs...), () )
  RANGE_REFLECTION(clang::CXXRecordDecl, friends,
      constexpr auto friends() const ,
      (typename meta::clang::FriendDecl *),
      (reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::friends, Xs...), () )
  /// Determines whether this record has any friends.
  constexpr bool hasFriends() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasFriends, Xs...); }) , (;) )
  /// \c true if a defaulted copy constructor for this class would be
  /// deleted.
  constexpr bool defaultedCopyConstructorIsDeleted() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::defaultedCopyConstructorIsDeleted, Xs...); }) , (;) )
  /// \c true if a defaulted move constructor for this class would be
  /// deleted.
  constexpr bool defaultedMoveConstructorIsDeleted() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::defaultedMoveConstructorIsDeleted, Xs...); }) , (;) )
  /// \c true if a defaulted destructor for this class would be deleted.
  constexpr bool defaultedDestructorIsDeleted() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::defaultedDestructorIsDeleted, Xs...); }) , (;) )
  /// \c true if we know for sure that this class has a single,
  /// accessible, unambiguous copy constructor that is not deleted.
  constexpr bool hasSimpleCopyConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasSimpleCopyConstructor, Xs...); }) , (;) )
  /// \c true if we know for sure that this class has a single,
  /// accessible, unambiguous move constructor that is not deleted.
  constexpr bool hasSimpleMoveConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasSimpleMoveConstructor, Xs...); }) , (;) )
  /// \c true if we know for sure that this class has a single,
  /// accessible, unambiguous move assignment operator that is not deleted.
  constexpr bool hasSimpleMoveAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasSimpleMoveAssignment, Xs...); }) , (;) )
  /// \c true if we know for sure that this class has an accessible
  /// destructor that is not deleted.
  constexpr bool hasSimpleDestructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasSimpleDestructor, Xs...); }) , (;) )
  /// Determine whether this class has any default constructors.
  constexpr bool hasDefaultConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasDefaultConstructor, Xs...); }) , (;) )
  /// Determine if we need to declare a default constructor for
  /// this class.
  ///
  /// This value is used for lazy creation of default constructors.
  constexpr bool needsImplicitDefaultConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::needsImplicitDefaultConstructor, Xs...); }) , (;) )
  /// Determine whether this class has any user-declared constructors.
  ///
  /// When true, a default constructor will not be implicitly declared.
  constexpr bool hasUserDeclaredConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasUserDeclaredConstructor, Xs...); }) , (;) )
  /// Whether this class has a user-provided default constructor
  /// per C++11.
  constexpr bool hasUserProvidedDefaultConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasUserProvidedDefaultConstructor, Xs...); }) , (;) )
  /// Determine whether this class has a user-declared copy constructor.
  ///
  /// When false, a copy constructor will be implicitly declared.
  constexpr bool hasUserDeclaredCopyConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasUserDeclaredCopyConstructor, Xs...); }) , (;) )
  /// Determine whether this class needs an implicit copy
  /// constructor to be lazily declared.
  constexpr bool needsImplicitCopyConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::needsImplicitCopyConstructor, Xs...); }) , (;) )
  /// Determine whether we need to eagerly declare a defaulted copy
  /// constructor for this class.
  constexpr bool needsOverloadResolutionForCopyConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::needsOverloadResolutionForCopyConstructor, Xs...); }) , (;) )
  /// Determine whether an implicit copy constructor for this type
  /// would have a parameter with a const-qualified reference type.
  constexpr bool implicitCopyConstructorHasConstParam() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::implicitCopyConstructorHasConstParam, Xs...); }) , (;) )
  /// Determine whether this class has a copy constructor with
  /// a parameter type which is a reference to a const-qualified type.
  constexpr bool hasCopyConstructorWithConstParam() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasCopyConstructorWithConstParam, Xs...); }) , (;) )
  /// Whether this class has a user-declared move constructor or
  /// assignment operator.
  ///
  /// When false, a move constructor and assignment operator may be
  /// implicitly declared.
  constexpr bool hasUserDeclaredMoveOperation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasUserDeclaredMoveOperation, Xs...); }) , (;) )
  /// Determine whether this class has had a move constructor
  /// declared by the user.
  constexpr bool hasUserDeclaredMoveConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasUserDeclaredMoveConstructor, Xs...); }) , (;) )
  /// Determine whether this class has a move constructor.
  constexpr bool hasMoveConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasMoveConstructor, Xs...); }) , (;) )
  /// Determine whether this class should get an implicit move
  /// constructor or if any existing special member function inhibits this.
  constexpr bool needsImplicitMoveConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::needsImplicitMoveConstructor, Xs...); }) , (;) )
  /// Determine whether we need to eagerly declare a defaulted move
  /// constructor for this class.
  constexpr bool needsOverloadResolutionForMoveConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::needsOverloadResolutionForMoveConstructor, Xs...); }) , (;) )
  /// Determine whether this class has a user-declared copy assignment
  /// operator.
  ///
  /// When false, a copy assignment operator will be implicitly declared.
  constexpr bool hasUserDeclaredCopyAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasUserDeclaredCopyAssignment, Xs...); }) , (;) )
  /// Determine whether this class needs an implicit copy
  /// assignment operator to be lazily declared.
  constexpr bool needsImplicitCopyAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::needsImplicitCopyAssignment, Xs...); }) , (;) )
  /// Determine whether we need to eagerly declare a defaulted copy
  /// assignment operator for this class.
  constexpr bool needsOverloadResolutionForCopyAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::needsOverloadResolutionForCopyAssignment, Xs...); }) , (;) )
  /// Determine whether an implicit copy assignment operator for this
  /// type would have a parameter with a const-qualified reference type.
  constexpr bool implicitCopyAssignmentHasConstParam() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::implicitCopyAssignmentHasConstParam, Xs...); }) , (;) )
  /// Determine whether this class has a copy assignment operator with
  /// a parameter type which is a reference to a const-qualified type or is not
  /// a reference.
  constexpr bool hasCopyAssignmentWithConstParam() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasCopyAssignmentWithConstParam, Xs...); }) , (;) )
  /// Determine whether this class has had a move assignment
  /// declared by the user.
  constexpr bool hasUserDeclaredMoveAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasUserDeclaredMoveAssignment, Xs...); }) , (;) )
  /// Determine whether this class has a move assignment operator.
  constexpr bool hasMoveAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasMoveAssignment, Xs...); }) , (;) )
  /// Determine whether this class should get an implicit move
  /// assignment operator or if any existing special member function inhibits
  /// this.
  constexpr bool needsImplicitMoveAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::needsImplicitMoveAssignment, Xs...); }) , (;) )
  /// Determine whether we need to eagerly declare a move assignment
  /// operator for this class.
  constexpr bool needsOverloadResolutionForMoveAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::needsOverloadResolutionForMoveAssignment, Xs...); }) , (;) )
  /// Determine whether this class has a user-declared destructor.
  ///
  /// When false, a destructor will be implicitly declared.
  constexpr bool hasUserDeclaredDestructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasUserDeclaredDestructor, Xs...); }) , (;) )
  /// Determine whether this class needs an implicit destructor to
  /// be lazily declared.
  constexpr bool needsImplicitDestructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::needsImplicitDestructor, Xs...); }) , (;) )
  /// Determine whether we need to eagerly declare a destructor for this
  /// class.
  constexpr bool needsOverloadResolutionForDestructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::needsOverloadResolutionForDestructor, Xs...); }) , (;) )
  /// Determine whether this class describes a lambda function object.
  constexpr bool isLambda() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isLambda, Xs...); }) , (;) )
  /// Determine whether this class describes a generic
  /// lambda function object (i.e. function call operator is
  /// a template).
  constexpr bool isGenericLambda() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isGenericLambda, Xs...); }) , (;) )
  /// Retrieve the lambda call operator of the closure type
  /// if this is a closure type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXMethodDecl *) )
  getLambdaCallOperator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getLambdaCallOperator, Xs...); }) , (;) )
  /// Retrieve the lambda static invoker, the address of which
  /// is returned by the conversion operator, and the body of which
  /// is forwarded to the lambda call operator.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXMethodDecl *) )
  getLambdaStaticInvoker() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getLambdaStaticInvoker, Xs...); }) , (;) )
  /// Retrieve the generic lambda's template parameter list.
  /// Returns null if the class does not represent a lambda or a generic
  /// lambda.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateParameterList *) )
  getGenericLambdaTemplateParameterList() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getGenericLambdaTemplateParameterList, Xs...); }) , (;) )
  constexpr enum clang::LambdaCaptureDefault getLambdaCaptureDefault() const IFMETA_ELSE( ({    return (enum clang::LambdaCaptureDefault)__reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getLambdaCaptureDefault, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CXXRecordDecl, captures,
      constexpr auto captures() const ,
      (const typename meta::clang::LambdaCapture),
      (reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::captures, Xs...), () )
  /// Determine whether this class is an aggregate (C++ [dcl.init.aggr]),
  /// which is a class with no user-declared constructors, no private
  /// or protected non-static data members, no base classes, and no virtual
  /// functions (C++ [dcl.init.aggr]p1).
  constexpr bool isAggregate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isAggregate, Xs...); }) , (;) )
  /// Whether this class has any in-class initializers
  /// for non-static data members (including those in anonymous unions or
  /// structs).
  constexpr bool hasInClassInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasInClassInitializer, Xs...); }) , (;) )
  /// Whether this class or any of its subobjects has any members of
  /// reference type which would make value-initialization ill-formed.
  ///
  /// Per C++03 [dcl.init]p5:
  ///  - if T is a non-union class type without a user-declared constructor,
  ///    then every non-static data member and base-class component of T is
  ///    value-initialized [...] A program that calls for [...]
  ///    value-initialization of an entity of reference type is ill-formed.
  constexpr bool hasUninitializedReferenceMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasUninitializedReferenceMember, Xs...); }) , (;) )
  /// Whether this class is a POD-type (C++ [class]p4)
  ///
  /// For purposes of this function a class is POD if it is an aggregate
  /// that has no non-static non-POD data members, no reference data
  /// members, no user-defined copy assignment operator and no
  /// user-defined destructor.
  ///
  /// Note that this is the C++ TR1 definition of POD.
  constexpr bool isPOD() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isPOD, Xs...); }) , (;) )
  /// True if this class is C-like, without C++-specific features, e.g.
  /// it contains only public fields, no bases, tag kind is not 'class', etc.
  constexpr bool isCLike() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isCLike, Xs...); }) , (;) )
  /// Determine whether this is an empty class in the sense of
  /// (C++11 [meta.unary.prop]).
  ///
  /// The CXXRecordDecl is a class type, but not a union type,
  /// with no non-static data members other than bit-fields of length 0,
  /// no virtual member functions, no virtual base classes,
  /// and no base class B for which is_empty<B>::value is false.
  ///
  /// \note This does NOT include a check for union-ness.
  constexpr bool isEmpty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isEmpty, Xs...); }) , (;) )
  /// Determine whether this class has direct non-static data members.
  constexpr bool hasDirectFields() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasDirectFields, Xs...); }) , (;) )
  /// Whether this class is polymorphic (C++ [class.virtual]),
  /// which means that the class contains or inherits a virtual function.
  constexpr bool isPolymorphic() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isPolymorphic, Xs...); }) , (;) )
  /// Determine whether this class has a pure virtual function.
  ///
  /// The class is is abstract per (C++ [class.abstract]p2) if it declares
  /// a pure virtual function or inherits a pure virtual function that is
  /// not overridden.
  constexpr bool isAbstract() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isAbstract, Xs...); }) , (;) )
  /// Determine whether this class is standard-layout per
  /// C++ [class]p7.
  constexpr bool isStandardLayout() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isStandardLayout, Xs...); }) , (;) )
  /// Determine whether this class was standard-layout per
  /// C++11 [class]p7, specifically using the C++11 rules without any DRs.
  constexpr bool isCXX11StandardLayout() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isCXX11StandardLayout, Xs...); }) , (;) )
  /// Determine whether this class, or any of its class subobjects,
  /// contains a mutable field.
  constexpr bool hasMutableFields() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasMutableFields, Xs...); }) , (;) )
  /// Determine whether this class has any variant members.
  constexpr bool hasVariantMembers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasVariantMembers, Xs...); }) , (;) )
  /// Determine whether this class has a trivial default constructor
  /// (C++11 [class.ctor]p5).
  constexpr bool hasTrivialDefaultConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasTrivialDefaultConstructor, Xs...); }) , (;) )
  /// Determine whether this class has a non-trivial default constructor
  /// (C++11 [class.ctor]p5).
  constexpr bool hasNonTrivialDefaultConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasNonTrivialDefaultConstructor, Xs...); }) , (;) )
  /// Determine whether this class has at least one constexpr constructor
  /// other than the copy or move constructors.
  constexpr bool hasConstexprNonCopyMoveConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasConstexprNonCopyMoveConstructor, Xs...); }) , (;) )
  /// Determine whether a defaulted default constructor for this class
  /// would be constexpr.
  constexpr bool defaultedDefaultConstructorIsConstexpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::defaultedDefaultConstructorIsConstexpr, Xs...); }) , (;) )
  /// Determine whether this class has a constexpr default constructor.
  constexpr bool hasConstexprDefaultConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasConstexprDefaultConstructor, Xs...); }) , (;) )
  /// Determine whether this class has a trivial copy constructor
  /// (C++ [class.copy]p6, C++11 [class.copy]p12)
  constexpr bool hasTrivialCopyConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasTrivialCopyConstructor, Xs...); }) , (;) )
  constexpr bool hasTrivialCopyConstructorForCall() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasTrivialCopyConstructorForCall, Xs...); }) , (;) )
  /// Determine whether this class has a non-trivial copy constructor
  /// (C++ [class.copy]p6, C++11 [class.copy]p12)
  constexpr bool hasNonTrivialCopyConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasNonTrivialCopyConstructor, Xs...); }) , (;) )
  constexpr bool hasNonTrivialCopyConstructorForCall() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasNonTrivialCopyConstructorForCall, Xs...); }) , (;) )
  /// Determine whether this class has a trivial move constructor
  /// (C++11 [class.copy]p12)
  constexpr bool hasTrivialMoveConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasTrivialMoveConstructor, Xs...); }) , (;) )
  constexpr bool hasTrivialMoveConstructorForCall() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasTrivialMoveConstructorForCall, Xs...); }) , (;) )
  /// Determine whether this class has a non-trivial move constructor
  /// (C++11 [class.copy]p12)
  constexpr bool hasNonTrivialMoveConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasNonTrivialMoveConstructor, Xs...); }) , (;) )
  constexpr bool hasNonTrivialMoveConstructorForCall() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasNonTrivialMoveConstructorForCall, Xs...); }) , (;) )
  /// Determine whether this class has a trivial copy assignment operator
  /// (C++ [class.copy]p11, C++11 [class.copy]p25)
  constexpr bool hasTrivialCopyAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasTrivialCopyAssignment, Xs...); }) , (;) )
  /// Determine whether this class has a non-trivial copy assignment
  /// operator (C++ [class.copy]p11, C++11 [class.copy]p25)
  constexpr bool hasNonTrivialCopyAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasNonTrivialCopyAssignment, Xs...); }) , (;) )
  /// Determine whether this class has a trivial move assignment operator
  /// (C++11 [class.copy]p25)
  constexpr bool hasTrivialMoveAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasTrivialMoveAssignment, Xs...); }) , (;) )
  /// Determine whether this class has a non-trivial move assignment
  /// operator (C++11 [class.copy]p25)
  constexpr bool hasNonTrivialMoveAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasNonTrivialMoveAssignment, Xs...); }) , (;) )
  /// Determine whether this class has a trivial destructor
  /// (C++ [class.dtor]p3)
  constexpr bool hasTrivialDestructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasTrivialDestructor, Xs...); }) , (;) )
  constexpr bool hasTrivialDestructorForCall() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasTrivialDestructorForCall, Xs...); }) , (;) )
  /// Determine whether this class has a non-trivial destructor
  /// (C++ [class.dtor]p3)
  constexpr bool hasNonTrivialDestructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasNonTrivialDestructor, Xs...); }) , (;) )
  constexpr bool hasNonTrivialDestructorForCall() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasNonTrivialDestructorForCall, Xs...); }) , (;) )
  /// Determine whether declaring a const variable with this type is ok
  /// per core issue 253.
  constexpr bool allowConstDefaultInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::allowConstDefaultInit, Xs...); }) , (;) )
  /// Determine whether this class has a destructor which has no
  /// semantic effect.
  ///
  /// Any such destructor will be trivial, public, defaulted and not deleted,
  /// and will call only irrelevant destructors.
  constexpr bool hasIrrelevantDestructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasIrrelevantDestructor, Xs...); }) , (;) )
  /// Determine whether this class has a non-literal or/ volatile type
  /// non-static data member or base class.
  constexpr bool hasNonLiteralTypeFieldsOrBases() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasNonLiteralTypeFieldsOrBases, Xs...); }) , (;) )
  /// Determine whether this class has a using-declaration that names
  /// a user-declared base class constructor.
  constexpr bool hasInheritedConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasInheritedConstructor, Xs...); }) , (;) )
  /// Determine whether this class has a using-declaration that names
  /// a base class assignment operator.
  constexpr bool hasInheritedAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::hasInheritedAssignment, Xs...); }) , (;) )
  /// Determine whether this class is considered trivially copyable per
  /// (C++11 [class]p6).
  constexpr bool isTriviallyCopyable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isTriviallyCopyable, Xs...); }) , (;) )
  /// Determine whether this class is considered trivial.
  ///
  /// C++11 [class]p6:
  ///    "A trivial class is a class that has a trivial default constructor and
  ///    is trivially copiable."
  constexpr bool isTrivial() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isTrivial, Xs...); }) , (;) )
  /// Determine whether this class is a literal type.
  ///
  /// C++11 [basic.types]p10:
  ///   A class type that has all the following properties:
  ///     - it has a trivial destructor
  ///     - every constructor call and full-expression in the
  ///       brace-or-equal-intializers for non-static data members (if any) is
  ///       a constant expression.
  ///     - it is an aggregate type or has at least one constexpr constructor
  ///       or constructor template that is not a copy or move constructor, and
  ///     - all of its non-static data members and base classes are of literal
  ///       types
  ///
  /// We resolve DR1361 by ignoring the second bullet. We resolve DR1452 by
  /// treating types with trivial default constructors as literal types.
  ///
  /// Only in C++17 and beyond, are lambdas literal types.
  constexpr bool isLiteral() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isLiteral, Xs...); }) , (;) )
  /// If this record is an instantiation of a member class,
  /// retrieves the member class from which it was instantiated.
  ///
  /// This routine will return non-null for (non-templated) member
  /// classes of class templates. For example, given:
  ///
  /// \code
  /// template<typename T>
  /// struct X {
  ///   struct A { };
  /// };
  /// \endcode
  ///
  /// The declaration for X<int>::A is a (non-templated) CXXRecordDecl
  /// whose parent is the class template specialization X<int>. For
  /// this declaration, getInstantiatedFromMemberClass() will return
  /// the CXXRecordDecl X<T>::A. When a complete definition of
  /// X<int>::A is required, it will be instantiated from the
  /// declaration returned by getInstantiatedFromMemberClass().
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getInstantiatedFromMemberClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getInstantiatedFromMemberClass, Xs...); }) , (;) )
  /// If this class is an instantiation of a member class of a
  /// class template specialization, retrieves the member specialization
  /// information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::MemberSpecializationInfo *) )
  getMemberSpecializationInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getMemberSpecializationInfo, Xs...); }) , (;) )
  /// Retrieves the class template that is described by this
  /// class declaration.
  ///
  /// Every class template is represented as a ClassTemplateDecl and a
  /// CXXRecordDecl. The former contains template properties (such as
  /// the template parameter lists) while the latter contains the
  /// actual description of the template's
  /// contents. ClassTemplateDecl::getTemplatedDecl() retrieves the
  /// CXXRecordDecl that from a ClassTemplateDecl, while
  /// getDescribedClassTemplate() retrieves the ClassTemplateDecl from
  /// a CXXRecordDecl.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ClassTemplateDecl *) )
  getDescribedClassTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getDescribedClassTemplate, Xs...); }) , (;) )
  /// Determine whether this particular class is a specialization or
  /// instantiation of a class template or member class of a class template,
  /// and how it was instantiated or specialized.
  constexpr enum clang::TemplateSpecializationKind getTemplateSpecializationKind() const IFMETA_ELSE( ({    return (enum clang::TemplateSpecializationKind)__reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getTemplateSpecializationKind, Xs...); }) , (;) )
  /// Retrieve the record declaration from which this record could be
  /// instantiated. Returns null if this class is not a template instantiation.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXRecordDecl *) )
  getTemplateInstantiationPattern() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getTemplateInstantiationPattern, Xs...); }) , (;) )
  /// Returns the destructor decl for this class.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDestructorDecl *) )
  getDestructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getDestructor, Xs...); }) , (;) )
  /// Returns true if the class destructor, or any implicitly invoked
  /// destructors are marked noreturn.
  constexpr bool isAnyDestructorNoReturn() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isAnyDestructorNoReturn, Xs...); }) , (;) )
  /// If the class is a local class [class.local], returns
  /// the enclosing function declaration.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionDecl *) )
  isLocalClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isLocalClass, Xs...); }) , (;) )
  /// Determine whether this dependent class is a current instantiation,
  /// when viewed from within the given context.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isCurrentInstantiation(IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::DeclContext *)) CurContext) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isCurrentInstantiation, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isCurrentInstantiation(ptrwrp<Y0> p0) const {
      return isCurrentInstantiation(p0.get());
  }), () )
  /// Determine whether this class is derived from the class \p Base.
  ///
  /// This routine only determines whether this class is derived from \p Base,
  /// but does not account for factors that may make a Derived -> Base class
  /// ill-formed, such as private/protected inheritance or multiple, ambiguous
  /// base class subobjects.
  ///
  /// \param Base the base class we are searching for.
  ///
  /// \returns true if this class is derived from Base, false otherwise.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isDerivedFrom(IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::CXXRecordDecl *)) Base) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isDerivedFrom, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isDerivedFrom(ptrwrp<Y0> p0) const {
      return isDerivedFrom(p0.get());
  }), () )
  /// Determine whether this class is virtually derived from
  /// the class \p Base.
  ///
  /// This routine only determines whether this class is virtually
  /// derived from \p Base, but does not account for factors that may
  /// make a Derived -> Base class ill-formed, such as
  /// private/protected inheritance or multiple, ambiguous base class
  /// subobjects.
  ///
  /// \param Base the base class we are searching for.
  ///
  /// \returns true if this class is virtually derived from Base,
  /// false otherwise.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isVirtuallyDerivedFrom(IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::CXXRecordDecl *)) Base) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isVirtuallyDerivedFrom, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isVirtuallyDerivedFrom(ptrwrp<Y0> p0) const {
      return isVirtuallyDerivedFrom(p0.get());
  }), () )
  /// Determine whether this class is provably not derived from
  /// the type \p Base.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isProvablyNotDerivedFrom(IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::CXXRecordDecl *)) Base) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isProvablyNotDerivedFrom, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isProvablyNotDerivedFrom(ptrwrp<Y0> p0) const {
      return isProvablyNotDerivedFrom(p0.get());
  }), () )
  /// Renders and displays an inheritance diagram
  /// for this C++ class and all of its base classes (transitively) using
  /// GraphViz.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void viewInheritance(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::viewInheritance, Xs..., Y0s...); }) , (;) )
  /// Calculates the access of a decl that is reached
  /// along a path.
  static constexpr enum clang::AccessSpecifier MergeAccess(enum clang::AccessSpecifier PathAccess, enum clang::AccessSpecifier DeclAccess) IFMETA_ELSE( ({    return (enum clang::AccessSpecifier)__reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::MergeAccess, Xs..., PathAccess, DeclAccess); }) , (;) )
  /// Determine whether this class may end up being abstract, even though
  /// it is not yet known to be abstract.
  ///
  /// \returns true if this class is not known to be abstract but has any
  /// base classes that are abstract. In this case, \c completeDefinition()
  /// will need to compute final overriders to determine whether the class is
  /// actually abstract.
  constexpr bool mayBeAbstract() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::mayBeAbstract, Xs...); }) , (;) )
  /// If this is the closure type of a lambda expression, retrieve the
  /// number to be used for name mangling in the Itanium C++ ABI.
  ///
  /// Zero indicates that this closure type has internal linkage, so the
  /// mangling number does not matter, while a non-zero value indicates which
  /// lambda expression this is in this particular context.
  constexpr unsigned int getLambdaManglingNumber() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getLambdaManglingNumber, Xs...); }) , (;) )
  /// Retrieve the declaration that provides additional context for a
  /// lambda, when the normal declaration context is not specific enough.
  ///
  /// Certain contexts (default arguments of in-class function parameters and
  /// the initializers of data members) have separate name mangling rules for
  /// lambdas within the Itanium C++ ABI. For these cases, this routine provides
  /// the declaration in which the lambda occurs, e.g., the function parameter
  /// or the non-static data member. Otherwise, it returns NULL to imply that
  /// the declaration context suffices.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Decl *) )
  getLambdaContextDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getLambdaContextDecl, Xs...); }) , (;) )
  /// Returns the inheritance model used for this record.
  constexpr enum clang::MSInheritanceAttr::Spelling getMSInheritanceModel() const IFMETA_ELSE( ({    return (enum clang::MSInheritanceAttr::Spelling)__reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getMSInheritanceModel, Xs...); }) , (;) )
  /// Calculate what the inheritance model would be for this class.
  constexpr enum clang::MSInheritanceAttr::Spelling calculateInheritanceModel() const IFMETA_ELSE( ({    return (enum clang::MSInheritanceAttr::Spelling)__reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::calculateInheritanceModel, Xs...); }) , (;) )
  /// In the Microsoft C++ ABI, use zero for the field offset of a null data
  /// member pointer if we can guarantee that zero is not a valid field offset,
  /// or if the member pointer has multiple fields.  Polymorphic classes have a
  /// vfptr at offset zero, so we can use zero for null.  If there are multiple
  /// fields, we can use zero even if it is a valid field offset because
  /// null-ness testing will check the other fields.
  constexpr bool nullFieldOffsetIsZero() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::nullFieldOffsetIsZero, Xs...); }) , (;) )
  /// Controls when vtordisps will be emitted if this record is used as a
  /// virtual base.
  constexpr enum clang::MSVtorDispAttr::Mode getMSVtorDispMode() const IFMETA_ELSE( ({    return (enum clang::MSVtorDispAttr::Mode)__reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getMSVtorDispMode, Xs...); }) , (;) )
  /// Determine whether this lambda expression was known to be dependent
  /// at the time it was created, even if its context does not appear to be
  /// dependent.
  ///
  /// This flag is a workaround for an issue with parsing, where default
  /// arguments are parsed before their enclosing function declarations have
  /// been created. This means that any lambda expressions within those
  /// default arguments will have as their DeclContext the context enclosing
  /// the function declaration, which may be non-dependent even when the
  /// function declaration itself is dependent. This flag indicates when we
  /// know that the lambda is dependent despite that.
  constexpr bool isDependentLambda() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isDependentLambda, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getLambdaTypeInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::getLambdaTypeInfo, Xs...); }) , (;) )
  ////END
  constexpr bool isInterfaceLike() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::isInterfaceLike, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXRecordDecl, reflenums::clang__CXXRecordDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a C++ deduction guide declaration.
///
/// \code
/// template<typename T> struct A { A(); A(T); };
/// A() -> A<int>;
/// \endcode
///
/// In this example, there will be an explicit deduction guide from the
/// second line, and implicit deduction guide templates synthesized from
/// the constructors of \c A.
M_template_rtpack(Xs)
struct clang::CXXDeductionGuideDecl::impl : impl_offset_t<clang::FunctionDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXDeductionGuideDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXDeductionGuideDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDeductionGuideDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, bool IsExplicit, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/1, Y3s...>), (const typename meta::clang::DeclarationNameInfo &)) NameInfo, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::SourceLocation)) EndLocation) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeductionGuideDecl, reflenums::clang__CXXDeductionGuideDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., IsExplicit, Y3s..., Y4s..., Y5s..., Y6s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDeductionGuideDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, bool p3, Y3 p4, Y4 p5, ptrwrp<Y5> p6, Y6 p7) {
      return Create(p0, p1.get(), p2, p3, p4, p5, p6.get(), p7);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDeductionGuideDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeductionGuideDecl, reflenums::clang__CXXDeductionGuideDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// Whether this deduction guide is explicit.
  constexpr bool isExplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeductionGuideDecl, reflenums::clang__CXXDeductionGuideDecl::isExplicit, Xs...); }) , (;) )
  /// Whether this deduction guide was declared with the 'explicit' specifier.
  constexpr bool isExplicitSpecified() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeductionGuideDecl, reflenums::clang__CXXDeductionGuideDecl::isExplicitSpecified, Xs...); }) , (;) )
  /// Get the template for which this guide performs deduction.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateDecl *) )
  getDeducedTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeductionGuideDecl, reflenums::clang__CXXDeductionGuideDecl::getDeducedTemplate, Xs...); }) , (;) )
  constexpr bool isCopyDeductionCandidate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeductionGuideDecl, reflenums::clang__CXXDeductionGuideDecl::isCopyDeductionCandidate, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeductionGuideDecl, reflenums::clang__CXXDeductionGuideDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeductionGuideDecl, reflenums::clang__CXXDeductionGuideDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a static or instance method of a struct/union/class.
///
/// In the terminology of the C++ Standard, these are the (static and
/// non-static) member functions, whether virtual or not.
M_template_rtpack(Xs)
struct clang::CXXMethodDecl::impl : impl_offset_t<clang::FunctionDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXMethodDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXMethodDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXMethodDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::CXXRecordDecl *)) RD, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/1, Y3s...>), (const typename meta::clang::DeclarationNameInfo &)) NameInfo, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, enum clang::StorageClass SC, bool isInline, bool isConstexpr, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::SourceLocation)) EndLocation) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., SC, isInline, isConstexpr, Y6s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXMethodDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, ptrwrp<Y5> p5, enum clang::StorageClass p6, bool p7, bool p8, Y6 p9) {
      return Create(p0, p1.get(), p2, p3, p4, p5.get(), p6, p7, p8, p9);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXMethodDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr bool isStatic() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::isStatic, Xs...); }) , (;) )
  constexpr bool isInstance() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::isInstance, Xs...); }) , (;) )
  /// Returns true if the given operator is implicitly static in a record
  /// context.
  static constexpr bool isStaticOverloadedOperator(enum clang::OverloadedOperatorKind OOK) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::isStaticOverloadedOperator, Xs..., OOK); }) , (;) )
  constexpr bool isConst() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::isConst, Xs...); }) , (;) )
  constexpr bool isVolatile() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::isVolatile, Xs...); }) , (;) )
  constexpr bool isVirtual() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::isVirtual, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXMethodDecl *) )
  getDevirtualizedMethod(IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Expr *)) Base, bool IsAppleKext) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::getDevirtualizedMethod, Xs..., Y0s..., IsAppleKext); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXMethodDecl *) )
  getDevirtualizedMethod(ptrwrp<Y0> p0, bool p1) const {
      return getDevirtualizedMethod(p0.get(), p1);
  }), () )
  /// Determine whether this is a usual deallocation function
  /// (C++ [basic.stc.dynamic.deallocation]p2), which is an overloaded
  /// delete or delete[] operator with a particular signature.
  constexpr bool isUsualDeallocationFunction() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::isUsualDeallocationFunction, Xs...); }) , (;) )
  /// Determine whether this is a copy-assignment operator, regardless
  /// of whether it was declared implicitly or explicitly.
  constexpr bool isCopyAssignmentOperator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::isCopyAssignmentOperator, Xs...); }) , (;) )
  /// Determine whether this is a move assignment operator.
  constexpr bool isMoveAssignmentOperator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::isMoveAssignmentOperator, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXMethodDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::getCanonicalDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXMethodDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::getMostRecentDecl, Xs...); }) , (;) )
  /// True if this method is user-declared and was not
  /// deleted or defaulted on its first declaration.
  constexpr bool isUserProvided() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::isUserProvided, Xs...); }) , (;) )
  constexpr unsigned int size_overridden_methods() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::size_overridden_methods, Xs...); }) , (;) )
  /// Returns the parent of this method declaration, which
  /// is the class in which this method is defined.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXRecordDecl *) )
  getParent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::getParent, Xs...); }) , (;) )
  /// Returns the type of the \c this pointer.
  ///
  /// Should only be called for instance (i.e., non-static) methods. Note
  /// that for the call operator of a lambda closure type, this returns the
  /// desugared 'this' type (a pointer to the closure type), not the captured
  /// 'this' type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getThisType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::getThisType, Xs..., Y0s...); }) , (;) )
  constexpr unsigned int getTypeQualifiers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::getTypeQualifiers, Xs...); }) , (;) )
  /// Retrieve the ref-qualifier associated with this method.
  ///
  /// In the following example, \c f() has an lvalue ref-qualifier, \c g()
  /// has an rvalue ref-qualifier, and \c h() has no ref-qualifier.
  /// @code
  /// struct X {
  ///   void f() &;
  ///   void g() &&;
  ///   void h();
  /// };
  /// @endcode
  constexpr enum clang::RefQualifierKind getRefQualifier() const IFMETA_ELSE( ({    return (enum clang::RefQualifierKind)__reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::getRefQualifier, Xs...); }) , (;) )
  constexpr bool hasInlineBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::hasInlineBody, Xs...); }) , (;) )
  /// Determine whether this is a lambda closure type's static member
  /// function that is used for the result of the lambda's conversion to
  /// function pointer (for a lambda with no captures).
  ///
  /// The function itself, if used, will have a placeholder body that will be
  /// supplied by IR generation to either forward to the function call operator
  /// or clone the function call operator.
  constexpr bool isLambdaStaticInvoker() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::isLambdaStaticInvoker, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXMethodDecl *) )
  getCorrespondingMethodInClass(IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::CXXRecordDecl *)) RD, bool MayBeBase = false) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::getCorrespondingMethodInClass, Xs..., Y0s..., MayBeBase); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXMethodDecl *) )
  getCorrespondingMethodInClass(ptrwrp<Y0> p0, bool p1 = false) const {
      return getCorrespondingMethodInClass(p0.get(), p1);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMethodDecl, reflenums::clang__CXXMethodDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a C++ base or member initializer.
///
/// This is part of a constructor initializer that
/// initializes one non-static member variable or one base class. For
/// example, in the following, both 'A(a)' and 'f(3.14159)' are member
/// initializers:
///
/// \code
/// class A { };
/// class B : public A {
///   float f;
/// public:
///   B(A& a) : A(a), f(3.14159) { }
/// };
/// \endcode
M_template_rtpack(Xs)
struct clang::CXXCtorInitializer::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXCtorInitializer;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXCtorInitializer::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Determine whether this initializer is initializing a base class.
  constexpr bool isBaseInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::isBaseInitializer, Xs...); }) , (;) )
  /// Determine whether this initializer is initializing a non-static
  /// data member.
  constexpr bool isMemberInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::isMemberInitializer, Xs...); }) , (;) )
  constexpr bool isAnyMemberInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::isAnyMemberInitializer, Xs...); }) , (;) )
  constexpr bool isIndirectMemberInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::isIndirectMemberInitializer, Xs...); }) , (;) )
  /// Determine whether this initializer is an implicit initializer
  /// generated for a field with an initializer defined on the member
  /// declaration.
  ///
  /// In-class member initializers (also known as "non-static data member
  /// initializations", NSDMIs) were introduced in C++11.
  constexpr bool isInClassMemberInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::isInClassMemberInitializer, Xs...); }) , (;) )
  /// Determine whether this initializer is creating a delegating
  /// constructor.
  constexpr bool isDelegatingInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::isDelegatingInitializer, Xs...); }) , (;) )
  /// Determine whether this initializer is a pack expansion.
  constexpr bool isPackExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::isPackExpansion, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEllipsisLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getEllipsisLoc, Xs...); }) , (;) )
  /// If this is a base class initializer, returns the type of the
  /// base class with location information. Otherwise, returns an NULL
  /// type location.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeLoc) )
  getBaseClassLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getBaseClassLoc, Xs...); }) , (;) )
  /// If this is a base class initializer, returns the type of the base class.
  /// Otherwise, returns null.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getBaseClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getBaseClass, Xs...); }) , (;) )
  /// Returns whether the base is virtual or not.
  constexpr bool isBaseVirtual() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::isBaseVirtual, Xs...); }) , (;) )
  /// Returns the declarator information for a base class or delegating
  /// initializer.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getTypeSourceInfo, Xs...); }) , (;) )
  /// If this is a member initializer, returns the declaration of the
  /// non-static data member being initialized. Otherwise, returns null.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FieldDecl *) )
  getMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getMember, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FieldDecl *) )
  getAnyMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getAnyMember, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IndirectFieldDecl *) )
  getIndirectMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getIndirectMember, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getMemberLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getMemberLocation, Xs...); }) , (;) )
  /// Determine the source location of the initializer.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getSourceLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getSourceLocation, Xs...); }) , (;) )
  /// Determine the source range covering the entire initializer.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getSourceRange, Xs...); }) , (;) )
  /// Determine whether this initializer is explicitly written
  /// in the source code.
  constexpr bool isWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::isWritten, Xs...); }) , (;) )
  /// Return the source position of the initializer, counting from 0.
  /// If the initializer was implicit, -1 is returned.
  constexpr int getSourceOrder() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getSourceOrder, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getLParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getRParenLoc, Xs...); }) , (;) )
  /// Get the initializer.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCtorInitializer, reflenums::clang__CXXCtorInitializer::getInit, Xs...); }) , (;) )
};

/// Description of a constructor that was inherited from a base class.
M_template_rtpack(Xs)
struct clang::InheritedConstructor::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__InheritedConstructor;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::InheritedConstructor::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr explicit operator bool() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InheritedConstructor, reflenums::clang__InheritedConstructor::operator_bool, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ConstructorUsingShadowDecl *) )
  getShadowDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InheritedConstructor, reflenums::clang__InheritedConstructor::getShadowDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConstructorDecl *) )
  getConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__InheritedConstructor, reflenums::clang__InheritedConstructor::getConstructor, Xs...); }) , (;) )
};

/// Represents a C++ constructor within a class.
///
/// For example:
///
/// \code
/// class X {
/// public:
///   explicit X(int); // represented by a CXXConstructorDecl.
/// };
/// \endcode
M_template_rtpack(Xs)
struct clang::CXXConstructorDecl::impl : impl_offset_t<clang::CXXMethodDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXConstructorDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXConstructorDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConstructorDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID, bool InheritsConstructor) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::CreateDeserialized, Xs..., Y0s..., ID, InheritsConstructor); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConstructorDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::CXXRecordDecl *)) RD, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/1, Y3s...>), (const typename meta::clang::DeclarationNameInfo &)) NameInfo, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, bool isExplicit, bool isInline, bool isImplicitlyDeclared, bool isConstexpr, IFMETA_ELSE((const clang::InheritedConstructor::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::InheritedConstructor)) Inherited = {}) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., isExplicit, isInline, isImplicitlyDeclared, isConstexpr, Y6s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConstructorDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, ptrwrp<Y5> p5, bool p6, bool p7, bool p8, bool p9, Y6 p10 = {}) {
      return Create(p0, p1.get(), p2, p3, p4, p5.get(), p6, p7, p8, p9, p10);
  }), () )
  RANGE_REFLECTION(clang::CXXConstructorDecl, inits,
      constexpr auto inits() const ,
      (typename meta::clang::CXXCtorInitializer *const),
      (reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::inits, Xs...), () )
  /// Determine the number of arguments used to initialize the member
  /// or base.
  constexpr unsigned int getNumCtorInitializers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::getNumCtorInitializers, Xs...); }) , (;) )
  /// Whether this function is marked as explicit explicitly.
  constexpr bool isExplicitSpecified() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::isExplicitSpecified, Xs...); }) , (;) )
  /// Whether this function is explicit.
  constexpr bool isExplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::isExplicit, Xs...); }) , (;) )
  /// Determine whether this constructor is a delegating constructor.
  constexpr bool isDelegatingConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::isDelegatingConstructor, Xs...); }) , (;) )
  /// When this constructor delegates to another, retrieve the target.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConstructorDecl *) )
  getTargetConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::getTargetConstructor, Xs...); }) , (;) )
  /// Whether this constructor is a default
  /// constructor (C++ [class.ctor]p5), which can be used to
  /// default-initialize a class of this type.
  constexpr bool isDefaultConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::isDefaultConstructor, Xs...); }) , (;) )
  /// Whether this constructor is a copy
  /// constructor (C++ [class.copy]p2, which can be used to copy the
  /// class.
  constexpr bool isCopyConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::isCopyConstructor, Xs...); }) , (;) )
  /// Determine whether this constructor is a move constructor
  /// (C++11 [class.copy]p3), which can be used to move values of the class.
  constexpr bool isMoveConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::isMoveConstructor, Xs...); }) , (;) )
  /// Determine whether this a copy or move constructor.
  constexpr bool isCopyOrMoveConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::isCopyOrMoveConstructor, Xs...); }) , (;) )
  /// Whether this constructor is a
  /// converting constructor (C++ [class.conv.ctor]), which can be
  /// used for user-defined conversions.
  constexpr bool isConvertingConstructor(bool AllowExplicit) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::isConvertingConstructor, Xs..., AllowExplicit); }) , (;) )
  /// Determine whether this is a member template specialization that
  /// would copy the object to itself. Such constructors are never used to copy
  /// an object.
  constexpr bool isSpecializationCopyingObject() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::isSpecializationCopyingObject, Xs...); }) , (;) )
  /// Determine whether this is an implicit constructor synthesized to
  /// model a call to a constructor inherited from a base class.
  constexpr bool isInheritingConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::isInheritingConstructor, Xs...); }) , (;) )
  /// Get the constructor that this inheriting constructor is based on.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::InheritedConstructor) )
  getInheritedConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::getInheritedConstructor, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXConstructorDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::getCanonicalDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructorDecl, reflenums::clang__CXXConstructorDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a C++ destructor within a class.
///
/// For example:
///
/// \code
/// class X {
/// public:
///   ~X(); // represented by a CXXDestructorDecl.
/// };
/// \endcode
M_template_rtpack(Xs)
struct clang::CXXDestructorDecl::impl : impl_offset_t<clang::CXXMethodDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXDestructorDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXDestructorDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDestructorDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::CXXRecordDecl *)) RD, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/1, Y3s...>), (const typename meta::clang::DeclarationNameInfo &)) NameInfo, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, bool isInline, bool isImplicitlyDeclared) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDestructorDecl, reflenums::clang__CXXDestructorDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., isInline, isImplicitlyDeclared); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDestructorDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, ptrwrp<Y5> p5, bool p6, bool p7) {
      return Create(p0, p1.get(), p2, p3, p4, p5.get(), p6, p7);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDestructorDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDestructorDecl, reflenums::clang__CXXDestructorDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionDecl *) )
  getOperatorDelete() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDestructorDecl, reflenums::clang__CXXDestructorDecl::getOperatorDelete, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getOperatorDeleteThisArg() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDestructorDecl, reflenums::clang__CXXDestructorDecl::getOperatorDeleteThisArg, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXDestructorDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDestructorDecl, reflenums::clang__CXXDestructorDecl::getCanonicalDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDestructorDecl, reflenums::clang__CXXDestructorDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDestructorDecl, reflenums::clang__CXXDestructorDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a C++ conversion function within a class.
///
/// For example:
///
/// \code
/// class X {
/// public:
///   operator bool();
/// };
/// \endcode
M_template_rtpack(Xs)
struct clang::CXXConversionDecl::impl : impl_offset_t<clang::CXXMethodDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXConversionDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXConversionDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConversionDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::CXXRecordDecl *)) RD, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/1, Y3s...>), (const typename meta::clang::DeclarationNameInfo &)) NameInfo, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, bool isInline, bool isExplicit, bool isConstexpr, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::SourceLocation)) EndLocation) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConversionDecl, reflenums::clang__CXXConversionDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., isInline, isExplicit, isConstexpr, Y6s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConversionDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, ptrwrp<Y5> p5, bool p6, bool p7, bool p8, Y6 p9) {
      return Create(p0, p1.get(), p2, p3, p4, p5.get(), p6, p7, p8, p9);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConversionDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConversionDecl, reflenums::clang__CXXConversionDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// Whether this function is marked as explicit explicitly.
  constexpr bool isExplicitSpecified() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConversionDecl, reflenums::clang__CXXConversionDecl::isExplicitSpecified, Xs...); }) , (;) )
  /// Whether this function is explicit.
  constexpr bool isExplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConversionDecl, reflenums::clang__CXXConversionDecl::isExplicit, Xs...); }) , (;) )
  /// Returns the type that this conversion function is converting to.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getConversionType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConversionDecl, reflenums::clang__CXXConversionDecl::getConversionType, Xs...); }) , (;) )
  /// Determine whether this conversion function is a conversion from
  /// a lambda closure type to a block pointer.
  constexpr bool isLambdaToBlockPointerConversion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConversionDecl, reflenums::clang__CXXConversionDecl::isLambdaToBlockPointerConversion, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXConversionDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConversionDecl, reflenums::clang__CXXConversionDecl::getCanonicalDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConversionDecl, reflenums::clang__CXXConversionDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConversionDecl, reflenums::clang__CXXConversionDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents the language in a linkage specification.
///
/// The values are part of the serialization ABI for
/// ASTs and cannot be changed without altering that ABI.  To help
/// ensure a stable ABI for this, we choose the DW_LANG_ encodings
/// from the dwarf standard.
enum clang::LinkageSpecDecl::LanguageIDs : unsigned int {
  lang_c = 2,
  lang_cxx = 4,
};

/// Represents a linkage specification.
///
/// For example:
/// \code
///   extern "C" void foo();
/// \endcode
M_template_rtpack(Xs)
struct clang::LinkageSpecDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)>, impl_offset_t<clang::DeclContext, 40 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__LinkageSpecDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::LinkageSpecDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using LanguageIDs = enum refldetail::clang::LinkageSpecDecl::LanguageIDs;
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LinkageSpecDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) ExternLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) LangLoc, enum clang::LinkageSpecDecl::LanguageIDs Lang, bool HasBraces) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageSpecDecl, reflenums::clang__LinkageSpecDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Lang, HasBraces); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LinkageSpecDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, enum clang::LinkageSpecDecl::LanguageIDs p4, bool p5) {
      return Create(p0, p1.get(), p2, p3, p4, p5);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LinkageSpecDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageSpecDecl, reflenums::clang__LinkageSpecDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// Return the language specified by this linkage specification.
  constexpr enum clang::LinkageSpecDecl::LanguageIDs getLanguage() const IFMETA_ELSE( ({    return (enum clang::LinkageSpecDecl::LanguageIDs)__reflect_prop(reflenums::RK_clang__LinkageSpecDecl, reflenums::clang__LinkageSpecDecl::getLanguage, Xs...); }) , (;) )
  /// Determines whether this linkage specification had braces in
  /// its syntactic form.
  constexpr bool hasBraces() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageSpecDecl, reflenums::clang__LinkageSpecDecl::hasBraces, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExternLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageSpecDecl, reflenums::clang__LinkageSpecDecl::getExternLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRBraceLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageSpecDecl, reflenums::clang__LinkageSpecDecl::getRBraceLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageSpecDecl, reflenums::clang__LinkageSpecDecl::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageSpecDecl, reflenums::clang__LinkageSpecDecl::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageSpecDecl, reflenums::clang__LinkageSpecDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageSpecDecl, reflenums::clang__LinkageSpecDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LinkageSpecDecl, reflenums::clang__LinkageSpecDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents C++ using-directive.
///
/// For example:
/// \code
///    using namespace std;
/// \endcode
///
/// \note UsingDirectiveDecl should be Decl not NamedDecl, but we provide
/// artificial names for all using-directives in order to store
/// them in DeclContext effectively.
M_template_rtpack(Xs)
struct clang::UsingDirectiveDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UsingDirectiveDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UsingDirectiveDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the nested-name-specifier that qualifies the
  /// name of the namespace, with source-location information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDirectiveDecl, reflenums::clang__UsingDirectiveDecl::getQualifierLoc, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the
  /// name of the namespace.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDirectiveDecl, reflenums::clang__UsingDirectiveDecl::getQualifier, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamedDecl *) )
  getNominatedNamespaceAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDirectiveDecl, reflenums::clang__UsingDirectiveDecl::getNominatedNamespaceAsWritten, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamespaceDecl *) )
  getNominatedNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDirectiveDecl, reflenums::clang__UsingDirectiveDecl::getNominatedNamespace, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclContext *) )
  getCommonAncestor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDirectiveDecl, reflenums::clang__UsingDirectiveDecl::getCommonAncestor, Xs...); }) , (;) )
  /// Return the location of the \c using keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getUsingLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDirectiveDecl, reflenums::clang__UsingDirectiveDecl::getUsingLoc, Xs...); }) , (;) )
  /// Returns the location of the \c namespace keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getNamespaceKeyLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDirectiveDecl, reflenums::clang__UsingDirectiveDecl::getNamespaceKeyLocation, Xs...); }) , (;) )
  /// Returns the location of this using declaration's identifier.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getIdentLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDirectiveDecl, reflenums::clang__UsingDirectiveDecl::getIdentLocation, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UsingDirectiveDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) UsingLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) NamespaceLoc, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::NestedNameSpecifierLoc)) QualifierLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::SourceLocation)) IdentLoc, IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::NamedDecl *)) Nominated, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y7s...> *), (typename meta::clang::DeclContext *)) CommonAncestor) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDirectiveDecl, reflenums::clang__UsingDirectiveDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., Y7s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UsingDirectiveDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, Y5 p5, ptrwrp<Y6> p6, ptrwrp<Y7> p7) {
      return Create(p0, p1.get(), p2, p3, p4, p5, p6.get(), p7.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UsingDirectiveDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDirectiveDecl, reflenums::clang__UsingDirectiveDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDirectiveDecl, reflenums::clang__UsingDirectiveDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDirectiveDecl, reflenums::clang__UsingDirectiveDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDirectiveDecl, reflenums::clang__UsingDirectiveDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a C++ namespace alias.
///
/// For example:
///
/// \code
/// namespace Foo = Bar;
/// \endcode
M_template_rtpack(Xs)
struct clang::NamespaceAliasDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__NamespaceAliasDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::NamespaceAliasDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamespaceAliasDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamespaceAliasDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::getFirstDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamespaceAliasDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::getMostRecentDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamespaceAliasDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) NamespaceLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) AliasLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Alias, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::NestedNameSpecifierLoc)) QualifierLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::SourceLocation)) IdentLoc, IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y7s...> *), (typename meta::clang::NamedDecl *)) Namespace) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., Y7s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamespaceAliasDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, Y5 p5, Y6 p6, ptrwrp<Y7> p7) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5, p6, p7.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamespaceAliasDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamespaceAliasDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::getCanonicalDecl, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the
  /// name of the namespace, with source-location information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::getQualifierLoc, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the
  /// name of the namespace.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::getQualifier, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamespaceDecl *) )
  getNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::getNamespace, Xs...); }) , (;) )
  /// Returns the location of the alias name, i.e. 'foo' in
  /// "namespace foo = ns::bar;".
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAliasLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::getAliasLoc, Xs...); }) , (;) )
  /// Returns the location of the \c namespace keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getNamespaceLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::getNamespaceLoc, Xs...); }) , (;) )
  /// Returns the location of the identifier in the named namespace.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTargetNameLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::getTargetNameLoc, Xs...); }) , (;) )
  /// Retrieve the namespace that this alias refers to, which
  /// may either be a NamespaceDecl or a NamespaceAliasDecl.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getAliasedNamespace() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::getAliasedNamespace, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NamespaceAliasDecl, reflenums::clang__NamespaceAliasDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a shadow declaration introduced into a scope by a
/// (resolved) using declaration.
///
/// For example,
/// \code
/// namespace A {
///   void foo();
/// }
/// namespace B {
///   using A::foo; // <- a UsingDecl
///                 // Also creates a UsingShadowDecl for A::foo() in B
/// }
/// \endcode
M_template_rtpack(Xs)
struct clang::UsingShadowDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UsingShadowDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UsingShadowDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::UsingShadowDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingShadowDecl, reflenums::clang__UsingShadowDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::UsingShadowDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingShadowDecl, reflenums::clang__UsingShadowDecl::getFirstDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::UsingShadowDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingShadowDecl, reflenums::clang__UsingShadowDecl::getMostRecentDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UsingShadowDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) Loc, IFMETA_ELSE((const clang::UsingDecl::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::UsingDecl *)) Using, IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::NamedDecl *)) Target) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingShadowDecl, reflenums::clang__UsingShadowDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UsingShadowDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, ptrwrp<Y3> p3, ptrwrp<Y4> p4) {
      return Create(p0, p1.get(), p2, p3.get(), p4.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UsingShadowDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingShadowDecl, reflenums::clang__UsingShadowDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::UsingShadowDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingShadowDecl, reflenums::clang__UsingShadowDecl::getCanonicalDecl, Xs...); }) , (;) )
  /// Gets the underlying declaration which has been brought into the
  /// local scope.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getTargetDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingShadowDecl, reflenums::clang__UsingShadowDecl::getTargetDecl, Xs...); }) , (;) )
  /// Gets the using declaration to which this declaration is tied.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::UsingDecl *) )
  getUsingDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingShadowDecl, reflenums::clang__UsingShadowDecl::getUsingDecl, Xs...); }) , (;) )
  /// The next using shadow declaration contained in the shadow decl
  /// chain of the using declaration which introduced this decl.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::UsingShadowDecl *) )
  getNextUsingShadowDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingShadowDecl, reflenums::clang__UsingShadowDecl::getNextUsingShadowDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingShadowDecl, reflenums::clang__UsingShadowDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingShadowDecl, reflenums::clang__UsingShadowDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a shadow constructor declaration introduced into a
/// class by a C++11 using-declaration that names a constructor.
///
/// For example:
/// \code
/// struct Base { Base(int); };
/// struct Derived {
///    using Base::Base; // creates a UsingDecl and a ConstructorUsingShadowDecl
/// };
/// \endcode
M_template_rtpack(Xs)
struct clang::ConstructorUsingShadowDecl::impl : impl_offset_t<clang::UsingShadowDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ConstructorUsingShadowDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ConstructorUsingShadowDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ConstructorUsingShadowDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) Loc, IFMETA_ELSE((const clang::UsingDecl::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::UsingDecl *)) Using, IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::NamedDecl *)) Target, bool IsVirtual) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstructorUsingShadowDecl, reflenums::clang__ConstructorUsingShadowDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., IsVirtual); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ConstructorUsingShadowDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, ptrwrp<Y3> p3, ptrwrp<Y4> p4, bool p5) {
      return Create(p0, p1.get(), p2, p3.get(), p4.get(), p5);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ConstructorUsingShadowDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstructorUsingShadowDecl, reflenums::clang__ConstructorUsingShadowDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXRecordDecl *) )
  getParent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstructorUsingShadowDecl, reflenums::clang__ConstructorUsingShadowDecl::getParent, Xs...); }) , (;) )
  /// Get the inheriting constructor declaration for the direct base
  /// class from which this using shadow declaration was inherited, if there is
  /// one. This can be different for each redeclaration of the same shadow decl.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ConstructorUsingShadowDecl *) )
  getNominatedBaseClassShadowDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstructorUsingShadowDecl, reflenums::clang__ConstructorUsingShadowDecl::getNominatedBaseClassShadowDecl, Xs...); }) , (;) )
  /// Get the inheriting constructor declaration for the base class
  /// for which we don't have an explicit initializer, if there is one.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ConstructorUsingShadowDecl *) )
  getConstructedBaseClassShadowDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstructorUsingShadowDecl, reflenums::clang__ConstructorUsingShadowDecl::getConstructedBaseClassShadowDecl, Xs...); }) , (;) )
  /// Get the base class that was named in the using declaration. This
  /// can be different for each redeclaration of this same shadow decl.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getNominatedBaseClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstructorUsingShadowDecl, reflenums::clang__ConstructorUsingShadowDecl::getNominatedBaseClass, Xs...); }) , (;) )
  /// Get the base class whose constructor or constructor shadow
  /// declaration is passed the constructor arguments.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getConstructedBaseClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstructorUsingShadowDecl, reflenums::clang__ConstructorUsingShadowDecl::getConstructedBaseClass, Xs...); }) , (;) )
  /// Returns \c true if the constructed base class is a virtual base
  /// class subobject of this declaration's class.
  constexpr bool constructsVirtualBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstructorUsingShadowDecl, reflenums::clang__ConstructorUsingShadowDecl::constructsVirtualBase, Xs...); }) , (;) )
  /// Get the constructor or constructor template in the derived class
  /// corresponding to this using shadow declaration, if it has been implicitly
  /// declared already.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConstructorDecl *) )
  getConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstructorUsingShadowDecl, reflenums::clang__ConstructorUsingShadowDecl::getConstructor, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstructorUsingShadowDecl, reflenums::clang__ConstructorUsingShadowDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstructorUsingShadowDecl, reflenums::clang__ConstructorUsingShadowDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a C++ using-declaration.
///
/// For example:
/// \code
///    using someNameSpace::someIdentifier;
/// \endcode
M_template_rtpack(Xs)
struct clang::UsingDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UsingDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UsingDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::UsingDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::getFirstDecl, Xs...); }) , (;) )
  /// Return the source location of the 'using' keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getUsingLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::getUsingLoc, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the name,
  /// with source-location information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::getQualifierLoc, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::getQualifier, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationNameInfo) )
  getNameInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::getNameInfo, Xs...); }) , (;) )
  /// Return true if it is a C++03 access declaration (no 'using').
  constexpr bool isAccessDeclaration() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::isAccessDeclaration, Xs...); }) , (;) )
  /// Return true if the using declaration has 'typename'.
  constexpr bool hasTypename() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::hasTypename, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::UsingDecl, shadows,
      constexpr auto shadows() const ,
      (typename meta::clang::UsingShadowDecl *),
      (reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::shadows, Xs...), () )
  /// Return the number of shadowed declarations associated with this
  /// using declaration.
  constexpr unsigned int shadow_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::shadow_size, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UsingDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) UsingL, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::NestedNameSpecifierLoc)) QualifierLoc, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/1, Y4s...>), (const typename meta::clang::DeclarationNameInfo &)) NameInfo, bool HasTypenameKeyword) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., HasTypenameKeyword); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UsingDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, bool p5) {
      return Create(p0, p1.get(), p2, p3, p4, p5);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UsingDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::UsingDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::getCanonicalDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingDecl, reflenums::clang__UsingDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a pack of using declarations that a single
/// using-declarator pack-expanded into.
///
/// \code
/// template<typename ...T> struct X : T... {
///   using T::operator()...;
///   using T::operator T...;
/// };
/// \endcode
///
/// In the second case above, the UsingPackDecl will have the name
/// 'operator T' (which contains an unexpanded pack), but the individual
/// UsingDecls and UsingShadowDecls will have more reasonable names.
M_template_rtpack(Xs)
struct clang::UsingPackDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UsingPackDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UsingPackDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::UsingPackDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingPackDecl, reflenums::clang__UsingPackDecl::getFirstDecl, Xs...); }) , (;) )
  /// Get the using declaration from which this was instantiated. This will
  /// always be an UnresolvedUsingValueDecl or an UnresolvedUsingTypenameDecl
  /// that is a pack expansion.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getInstantiatedFromUsingDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingPackDecl, reflenums::clang__UsingPackDecl::getInstantiatedFromUsingDecl, Xs...); }) , (;) )
  /// Get the set of using declarations that this pack expanded into. Note that
  /// some of these may still be unresolved.
  RANGE_REFLECTION(clang::UsingPackDecl, expansions,
      constexpr auto expansions() const ,
      (typename meta::clang::NamedDecl *),
      (reflenums::RK_clang__UsingPackDecl, reflenums::clang__UsingPackDecl::expansions, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UsingPackDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID, unsigned int NumExpansions) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingPackDecl, reflenums::clang__UsingPackDecl::CreateDeserialized, Xs..., Y0s..., ID, NumExpansions); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingPackDecl, reflenums::clang__UsingPackDecl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::UsingPackDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingPackDecl, reflenums::clang__UsingPackDecl::getCanonicalDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingPackDecl, reflenums::clang__UsingPackDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UsingPackDecl, reflenums::clang__UsingPackDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a dependent using declaration which was not marked with
/// \c typename.
///
/// Unlike non-dependent using declarations, these *only* bring through
/// non-types; otherwise they would break two-phase lookup.
///
/// \code
/// template \<class T> class A : public Base<T> {
///   using Base<T>::foo;
/// };
/// \endcode
M_template_rtpack(Xs)
struct clang::UnresolvedUsingValueDecl::impl : impl_offset_t<clang::ValueDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UnresolvedUsingValueDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UnresolvedUsingValueDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::UnresolvedUsingValueDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::getFirstDecl, Xs...); }) , (;) )
  /// Returns the source location of the 'using' keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getUsingLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::getUsingLoc, Xs...); }) , (;) )
  /// Return true if it is a C++03 access declaration (no 'using').
  constexpr bool isAccessDeclaration() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::isAccessDeclaration, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the name,
  /// with source-location information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::getQualifierLoc, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::getQualifier, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationNameInfo) )
  getNameInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::getNameInfo, Xs...); }) , (;) )
  /// Determine whether this is a pack expansion.
  constexpr bool isPackExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::isPackExpansion, Xs...); }) , (;) )
  /// Get the location of the ellipsis if this is a pack expansion.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEllipsisLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::getEllipsisLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedUsingValueDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) UsingLoc, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::NestedNameSpecifierLoc)) QualifierLoc, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/1, Y4s...>), (const typename meta::clang::DeclarationNameInfo &)) NameInfo, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::SourceLocation)) EllipsisLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedUsingValueDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, Y5 p5) {
      return Create(p0, p1.get(), p2, p3, p4, p5);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedUsingValueDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::UnresolvedUsingValueDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::getCanonicalDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingValueDecl, reflenums::clang__UnresolvedUsingValueDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a dependent using declaration which was marked with
/// \c typename.
///
/// \code
/// template \<class T> class A : public Base<T> {
///   using typename Base<T>::foo;
/// };
/// \endcode
///
/// The type associated with an unresolved using typename decl is
/// currently always a typename type.
M_template_rtpack(Xs)
struct clang::UnresolvedUsingTypenameDecl::impl : impl_offset_t<clang::TypeDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UnresolvedUsingTypenameDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UnresolvedUsingTypenameDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::UnresolvedUsingTypenameDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingTypenameDecl, reflenums::clang__UnresolvedUsingTypenameDecl::getFirstDecl, Xs...); }) , (;) )
  /// Returns the source location of the 'using' keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getUsingLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingTypenameDecl, reflenums::clang__UnresolvedUsingTypenameDecl::getUsingLoc, Xs...); }) , (;) )
  /// Returns the source location of the 'typename' keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTypenameLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingTypenameDecl, reflenums::clang__UnresolvedUsingTypenameDecl::getTypenameLoc, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the name,
  /// with source-location information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingTypenameDecl, reflenums::clang__UnresolvedUsingTypenameDecl::getQualifierLoc, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingTypenameDecl, reflenums::clang__UnresolvedUsingTypenameDecl::getQualifier, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationNameInfo) )
  getNameInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingTypenameDecl, reflenums::clang__UnresolvedUsingTypenameDecl::getNameInfo, Xs...); }) , (;) )
  /// Determine whether this is a pack expansion.
  constexpr bool isPackExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingTypenameDecl, reflenums::clang__UnresolvedUsingTypenameDecl::isPackExpansion, Xs...); }) , (;) )
  /// Get the location of the ellipsis if this is a pack expansion.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEllipsisLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingTypenameDecl, reflenums::clang__UnresolvedUsingTypenameDecl::getEllipsisLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedUsingTypenameDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) UsingLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) TypenameLoc, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::NestedNameSpecifierLoc)) QualifierLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::SourceLocation)) TargetNameLoc, IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::DeclarationName)) TargetName, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y7s...>), (typename meta::clang::SourceLocation)) EllipsisLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingTypenameDecl, reflenums::clang__UnresolvedUsingTypenameDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., Y7s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedUsingTypenameDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, Y5 p5, Y6 p6, Y7 p7) {
      return Create(p0, p1.get(), p2, p3, p4, p5, p6, p7);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedUsingTypenameDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingTypenameDecl, reflenums::clang__UnresolvedUsingTypenameDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::UnresolvedUsingTypenameDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingTypenameDecl, reflenums::clang__UnresolvedUsingTypenameDecl::getCanonicalDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingTypenameDecl, reflenums::clang__UnresolvedUsingTypenameDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedUsingTypenameDecl, reflenums::clang__UnresolvedUsingTypenameDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a C++11 static_assert declaration.
M_template_rtpack(Xs)
struct clang::StaticAssertDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__StaticAssertDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::StaticAssertDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::StaticAssertDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StaticAssertLoc, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::Expr *)) AssertExpr, IFMETA_ELSE((const clang::StringLiteral::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::StringLiteral *)) Message, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::SourceLocation)) RParenLoc, bool Failed) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StaticAssertDecl, reflenums::clang__StaticAssertDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Failed); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::StaticAssertDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, ptrwrp<Y3> p3, ptrwrp<Y4> p4, Y5 p5, bool p6) {
      return Create(p0, p1.get(), p2, p3.get(), p4.get(), p5, p6);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::StaticAssertDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StaticAssertDecl, reflenums::clang__StaticAssertDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getAssertExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StaticAssertDecl, reflenums::clang__StaticAssertDecl::getAssertExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::StringLiteral *) )
  getMessage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StaticAssertDecl, reflenums::clang__StaticAssertDecl::getMessage, Xs...); }) , (;) )
  constexpr bool isFailed() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StaticAssertDecl, reflenums::clang__StaticAssertDecl::isFailed, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StaticAssertDecl, reflenums::clang__StaticAssertDecl::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StaticAssertDecl, reflenums::clang__StaticAssertDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StaticAssertDecl, reflenums::clang__StaticAssertDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StaticAssertDecl, reflenums::clang__StaticAssertDecl::classofKind, Xs..., K); }) , (;) )
};

/// A binding in a decomposition declaration. For instance, given:
///
///   int n[3];
///   auto &[a, b, c] = n;
///
/// a, b, and c are BindingDecls, whose bindings are the expressions
/// x[0], x[1], and x[2] respectively, where x is the implicit
/// DecompositionDecl of type 'int (&)[3]'.
M_template_rtpack(Xs)
struct clang::BindingDecl::impl : impl_offset_t<clang::ValueDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__BindingDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::BindingDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::BindingDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) IdLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::IdentifierInfo *)) Id) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BindingDecl, reflenums::clang__BindingDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::BindingDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, ptrwrp<Y3> p3) {
      return Create(p0, p1.get(), p2, p3.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::BindingDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BindingDecl, reflenums::clang__BindingDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// Get the expression to which this declaration is bound. This may be null
  /// in two different cases: while parsing the initializer for the
  /// decomposition declaration, and when the initializer is type-dependent.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getBinding() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BindingDecl, reflenums::clang__BindingDecl::getBinding, Xs...); }) , (;) )
  /// Get the variable (if any) that holds the value of evaluating the binding.
  /// Only present for user-defined bindings for tuple-like types.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getHoldingVar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BindingDecl, reflenums::clang__BindingDecl::getHoldingVar, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BindingDecl, reflenums::clang__BindingDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BindingDecl, reflenums::clang__BindingDecl::classofKind, Xs..., K); }) , (;) )
};

/// A decomposition declaration. For instance, given:
///
///   int n[3];
///   auto &[a, b, c] = n;
///
/// the second line declares a DecompositionDecl of type 'int (&)[3]', and
/// three BindingDecls (named a, b, and c). An instance of this class is always
/// unnamed, but behaves in almost all other respects like a VarDecl.
M_template_rtpack(Xs)
struct clang::DecompositionDecl::impl : impl_offset_t<clang::VarDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DecompositionDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DecompositionDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DecompositionDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID, unsigned int NumBindings) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DecompositionDecl, reflenums::clang__DecompositionDecl::CreateDeserialized, Xs..., Y0s..., ID, NumBindings); }) , (;) )
  RANGE_REFLECTION(clang::DecompositionDecl, bindings,
      constexpr auto bindings() const ,
      (typename meta::clang::BindingDecl *),
      (reflenums::RK_clang__DecompositionDecl, reflenums::clang__DecompositionDecl::bindings, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void printName(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) os) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DecompositionDecl, reflenums::clang__DecompositionDecl::printName, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DecompositionDecl, reflenums::clang__DecompositionDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DecompositionDecl, reflenums::clang__DecompositionDecl::classofKind, Xs..., K); }) , (;) )
};

/// An instance of this class represents the declaration of a property
/// member.  This is a Microsoft extension to C++, first introduced in
/// Visual Studio .NET 2003 as a parallel to similar features in C#
/// and Managed C++.
///
/// A property must always be a non-static class member.
///
/// A property member superficially resembles a non-static data
/// member, except preceded by a property attribute:
///   __declspec(property(get=GetX, put=PutX)) int x;
/// Either (but not both) of the 'get' and 'put' names may be omitted.
///
/// A reference to a property is always an lvalue.  If the lvalue
/// undergoes lvalue-to-rvalue conversion, then a getter name is
/// required, and that member is called with no arguments.
/// If the lvalue is assigned into, then a setter name is required,
/// and that member is called with one argument, the value assigned.
/// Both operations are potentially overloaded.  Compound assignments
/// are permitted, as are the increment and decrement operators.
///
/// The getter and putter methods are permitted to be overloaded,
/// although their return and parameter types are subject to certain
/// restrictions according to the type of the property.
///
/// A property declared using an incomplete array type may
/// additionally be subscripted, adding extra parameters to the getter
/// and putter methods.
M_template_rtpack(Xs)
struct clang::MSPropertyDecl::impl : impl_offset_t<clang::DeclaratorDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__MSPropertyDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::MSPropertyDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_c M_rtpack(Y8s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::MSPropertyDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) L, IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::DeclarationName)) N, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::SourceLocation)) StartL, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y7s...> *), (typename meta::clang::IdentifierInfo *)) Getter, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y8s...> *), (typename meta::clang::IdentifierInfo *)) Setter) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyDecl, reflenums::clang__MSPropertyDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., Y7s..., Y8s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7, typename Y8>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::MSPropertyDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, ptrwrp<Y5> p5, Y6 p6, ptrwrp<Y7> p7, ptrwrp<Y8> p8) {
      return Create(p0, p1.get(), p2, p3, p4, p5.get(), p6, p7.get(), p8.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::MSPropertyDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyDecl, reflenums::clang__MSPropertyDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyDecl, reflenums::clang__MSPropertyDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  constexpr bool hasGetter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyDecl, reflenums::clang__MSPropertyDecl::hasGetter, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getGetterId() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyDecl, reflenums::clang__MSPropertyDecl::getGetterId, Xs...); }) , (;) )
  constexpr bool hasSetter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyDecl, reflenums::clang__MSPropertyDecl::hasSetter, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getSetterId() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyDecl, reflenums::clang__MSPropertyDecl::getSetterId, Xs...); }) , (;) )
};

/// \brief Represents a C++ constexpr-declaration.
///
/// A constexpr-declaration contains a sequence of statements that are evaluated
/// at compile-time. For example:
///
/// \code
/// constexpr {
///   // statements
/// }
/// \endcode
///
/// When the constexpr-declaration appears in namespace or class scope, this
/// class contains a \c constexpr \c void function that contains the parsed body
/// of the declaration.
M_template_rtpack(Xs)
struct clang::ConstexprDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ConstexprDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ConstexprDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getLambdaExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::getLambdaExpr, Xs...); }) , (;) )
  constexpr bool isDependent() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::isDependent, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ConstexprDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// \brief Returns \c true if this is represented as a function.
  constexpr bool hasFunctionRepresentation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::hasFunctionRepresentation, Xs...); }) , (;) )
  /// \brief Returns \c true if this is represented as a lambda expression.
  constexpr bool hasLambdaRepresentation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::hasLambdaRepresentation, Xs...); }) , (;) )
  /// \brief Returns the function representation of the declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  getFunctionDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::getFunctionDecl, Xs...); }) , (;) )
  /// \brief Returns the closure declaration for the lambda expression.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getClosureDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::getClosureDecl, Xs...); }) , (;) )
  /// \brief Returns the call operator of the closure.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXMethodDecl *) )
  getClosureCallOperator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::getClosureCallOperator, Xs...); }) , (;) )
  /// \brief Returns \c true if the constexpr-declaration has a body.
  constexpr bool hasBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::hasBody, Xs...); }) , (;) )
  /// \brief Returns the body of the constexpr-declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::getBody, Xs...); }) , (;) )
  /// Returns the expression that evaluates the constexpr-declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CallExpr *) )
  getCallExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::getCallExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ConstexprDecl, reflenums::clang__ConstexprDecl::classofKind, Xs..., K); }) , (;) )
};

/// Stores a list of template parameters for a TemplateDecl and its
/// derived classes.
M_template_rtpack(Xs)
struct clang::TemplateParameterList::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TemplateParameterList;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TemplateParameterList::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr unsigned int size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateParameterList, reflenums::clang__TemplateParameterList::size, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::TemplateParameterList, asArray,
      constexpr auto asArray() const ,
      (const typename meta::clang::NamedDecl *),
      (reflenums::RK_clang__TemplateParameterList, reflenums::clang__TemplateParameterList::asArray, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::NamedDecl *) )
  getParam(unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateParameterList, reflenums::clang__TemplateParameterList::getParam, Xs..., Idx); }) , (;) )
  /// Returns the minimum number of arguments needed to form a
  /// template specialization.
  ///
  /// This may be fewer than the number of template parameters, if some of
  /// the parameters have default arguments or if there is a parameter pack.
  constexpr unsigned int getMinRequiredArguments() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateParameterList, reflenums::clang__TemplateParameterList::getMinRequiredArguments, Xs...); }) , (;) )
  /// Get the depth of this template parameter list in the set of
  /// template parameter lists.
  ///
  /// The first template parameter list in a declaration will have depth 0,
  /// the second template parameter list will have depth 1, etc.
  constexpr unsigned int getDepth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateParameterList, reflenums::clang__TemplateParameterList::getDepth, Xs...); }) , (;) )
  /// Determine whether this template parameter list contains an
  /// unexpanded parameter pack.
  constexpr bool containsUnexpandedParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateParameterList, reflenums::clang__TemplateParameterList::containsUnexpandedParameterPack, Xs...); }) , (;) )
  /// The constraint-expression of the associated requires-clause.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getRequiresClause() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateParameterList, reflenums::clang__TemplateParameterList::getRequiresClause, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTemplateLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateParameterList, reflenums::clang__TemplateParameterList::getTemplateLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateParameterList, reflenums::clang__TemplateParameterList::getLAngleLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateParameterList, reflenums::clang__TemplateParameterList::getRAngleLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateParameterList, reflenums::clang__TemplateParameterList::getSourceRange, Xs...); }) , (;) )
  RANGECLASS_SIZE_AND_GET(clang__TemplateParameterList, typename meta::clang::NamedDecl *const);
};

/// A template argument list.
M_template_rtpack(Xs)
struct clang::TemplateArgumentList::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TemplateArgumentList;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TemplateArgumentList::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the template argument at a given index.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgument &) )
  get(unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentList, reflenums::clang__TemplateArgumentList::get, Xs..., Idx); }) , (;) )
  /// Retrieve the template argument at a given index.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgument &) )
  operator[](unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentList, reflenums::clang__TemplateArgumentList::operator_sub, Xs..., Idx); }) , (;) )
  /// Produce this as an array ref.
  RANGE_REFLECTION(clang::TemplateArgumentList, asArray,
      constexpr auto asArray() const ,
      (typename meta::clang::TemplateArgument),
      (reflenums::RK_clang__TemplateArgumentList, reflenums::clang__TemplateArgumentList::asArray, Xs...), () )
  /// Retrieve the number of template arguments in this
  /// template argument list.
  constexpr unsigned int size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentList, reflenums::clang__TemplateArgumentList::size, Xs...); }) , (;) )
  /// Retrieve a pointer to the template argument list.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgument *) )
  data() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateArgumentList, reflenums::clang__TemplateArgumentList::data, Xs...); }) , (;) )
};

/// The base class of all kinds of template declarations (e.g.,
/// class, function, etc.).
///
/// The TemplateDecl class stores the list of template parameters and a
/// reference to the templated scoped declaration: the underlying AST node.
M_template_rtpack(Xs)
struct clang::TemplateDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TemplateDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TemplateDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Get the list of template parameters
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateParameterList *) )
  getTemplateParameters() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateDecl, reflenums::clang__TemplateDecl::getTemplateParameters, Xs...); }) , (;) )
  /// Get the constraint-expression from the associated requires-clause (if any)
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getRequiresClause() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateDecl, reflenums::clang__TemplateDecl::getRequiresClause, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getAssociatedConstraints() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateDecl, reflenums::clang__TemplateDecl::getAssociatedConstraints, Xs...); }) , (;) )
  /// Get the underlying, templated declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getTemplatedDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateDecl, reflenums::clang__TemplateDecl::getTemplatedDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateDecl, reflenums::clang__TemplateDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateDecl, reflenums::clang__TemplateDecl::classofKind, Xs..., K); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateDecl, reflenums::clang__TemplateDecl::getSourceRange, Xs...); }) , (;) )
};

/// Provides information about a function template specialization,
/// which is a FunctionDecl that has been explicitly specialization or
/// instantiated from a function template.
M_template_rtpack(Xs)
struct clang::FunctionTemplateSpecializationInfo::impl : impl_offset_t<llvm::FoldingSetBase::Node, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FunctionTemplateSpecializationInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FunctionTemplateSpecializationInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionTemplateSpecializationInfo *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::FunctionDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::FunctionDecl *)) FD, IFMETA_ELSE((const clang::FunctionTemplateDecl::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::FunctionTemplateDecl *)) Template, enum clang::TemplateSpecializationKind TSK, IFMETA_ELSE((const clang::TemplateArgumentList::template impl</*ptrorref=*/1, Y3s...> *), (const typename meta::clang::TemplateArgumentList *)) TemplateArgs, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y4s...> *), (const typename meta::clang::TemplateArgumentListInfo *)) TemplateArgsAsWritten, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::SourceLocation)) POI) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateSpecializationInfo, reflenums::clang__FunctionTemplateSpecializationInfo::Create, Xs..., Y0s..., Y1s..., Y2s..., TSK, Y3s..., Y4s..., Y5s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionTemplateSpecializationInfo *) )
  Create(Y0 p0, ptrwrp<Y1> p1, ptrwrp<Y2> p2, enum clang::TemplateSpecializationKind p3, ptrwrp<Y3> p4, ptrwrp<Y4> p5, Y5 p6) {
      return Create(p0, p1.get(), p2.get(), p3, p4.get(), p5.get(), p6);
  }), () )
  /// The function template specialization that this structure
  /// describes.
  M_REFLTYPED_FIELD(Function, (typename meta::clang::FunctionDecl *), __reflect_prop(reflenums::RK_clang__FunctionTemplateSpecializationInfo, reflenums::clang__FunctionTemplateSpecializationInfo::Function, Xs...))
  /// The template arguments used to produce the function template
  /// specialization from the function template.
  M_REFLTYPED_FIELD(TemplateArguments, (const typename meta::clang::TemplateArgumentList *), __reflect_prop(reflenums::RK_clang__FunctionTemplateSpecializationInfo, reflenums::clang__FunctionTemplateSpecializationInfo::TemplateArguments, Xs...))
  /// The template arguments as written in the sources, if provided.
  M_REFLTYPED_FIELD(TemplateArgumentsAsWritten, (const typename meta::clang::ASTTemplateArgumentListInfo *), __reflect_prop(reflenums::RK_clang__FunctionTemplateSpecializationInfo, reflenums::clang__FunctionTemplateSpecializationInfo::TemplateArgumentsAsWritten, Xs...))
  /// The point at which this function template specialization was
  /// first instantiated.
  M_REFLTYPED_FIELD(PointOfInstantiation, (typename meta::clang::SourceLocation), __reflect_prop(reflenums::RK_clang__FunctionTemplateSpecializationInfo, reflenums::clang__FunctionTemplateSpecializationInfo::PointOfInstantiation, Xs...))
  /// Retrieve the template from which this function was specialized.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionTemplateDecl *) )
  getTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateSpecializationInfo, reflenums::clang__FunctionTemplateSpecializationInfo::getTemplate, Xs...); }) , (;) )
  /// Determine what kind of template specialization this is.
  constexpr enum clang::TemplateSpecializationKind getTemplateSpecializationKind() const IFMETA_ELSE( ({    return (enum clang::TemplateSpecializationKind)__reflect_prop(reflenums::RK_clang__FunctionTemplateSpecializationInfo, reflenums::clang__FunctionTemplateSpecializationInfo::getTemplateSpecializationKind, Xs...); }) , (;) )
  constexpr bool isExplicitSpecialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateSpecializationInfo, reflenums::clang__FunctionTemplateSpecializationInfo::isExplicitSpecialization, Xs...); }) , (;) )
  /// True if this declaration is an explicit specialization,
  /// explicit instantiation declaration, or explicit instantiation
  /// definition.
  constexpr bool isExplicitInstantiationOrSpecialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateSpecializationInfo, reflenums::clang__FunctionTemplateSpecializationInfo::isExplicitInstantiationOrSpecialization, Xs...); }) , (;) )
  /// Retrieve the first point of instantiation of this function
  /// template specialization.
  ///
  /// The point of instantiation may be an invalid source location if this
  /// function has yet to be instantiated.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getPointOfInstantiation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateSpecializationInfo, reflenums::clang__FunctionTemplateSpecializationInfo::getPointOfInstantiation, Xs...); }) , (;) )
};

/// Provides information a specialization of a member of a class
/// template, which may be a member function, static data member,
/// member class or member enumeration.
M_template_rtpack(Xs)
struct clang::MemberSpecializationInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__MemberSpecializationInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::MemberSpecializationInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the member declaration from which this member was
  /// instantiated.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getInstantiatedFrom() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberSpecializationInfo, reflenums::clang__MemberSpecializationInfo::getInstantiatedFrom, Xs...); }) , (;) )
  /// Determine what kind of template specialization this is.
  constexpr enum clang::TemplateSpecializationKind getTemplateSpecializationKind() const IFMETA_ELSE( ({    return (enum clang::TemplateSpecializationKind)__reflect_prop(reflenums::RK_clang__MemberSpecializationInfo, reflenums::clang__MemberSpecializationInfo::getTemplateSpecializationKind, Xs...); }) , (;) )
  constexpr bool isExplicitSpecialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberSpecializationInfo, reflenums::clang__MemberSpecializationInfo::isExplicitSpecialization, Xs...); }) , (;) )
  /// Retrieve the first point of instantiation of this member.
  /// If the point of instantiation is an invalid location, then this member
  /// has not yet been instantiated.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getPointOfInstantiation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MemberSpecializationInfo, reflenums::clang__MemberSpecializationInfo::getPointOfInstantiation, Xs...); }) , (;) )
};

/// Provides information about a dependent function-template
/// specialization declaration.
///
/// Since explicit function template specialization and instantiation
/// declarations can only appear in namespace scope, and you can only
/// specialize a member of a fully-specialized class, the only way to
/// get one of these is in a friend declaration like the following:
///
/// \code
///   template \<class T> void foo(T);
///   template \<class T> class A {
///     friend void foo<>(T);
///   };
/// \endcode
M_template_rtpack(Xs)
struct clang::DependentFunctionTemplateSpecializationInfo::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DependentFunctionTemplateSpecializationInfo;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DependentFunctionTemplateSpecializationInfo::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DependentFunctionTemplateSpecializationInfo *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::UnresolvedSetImpl::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::UnresolvedSetImpl &)) Templates, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y2s...>), (const typename meta::clang::TemplateArgumentListInfo &)) TemplateArgs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentFunctionTemplateSpecializationInfo, reflenums::clang__DependentFunctionTemplateSpecializationInfo::Create, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  /// Returns the number of function templates that this might
  /// be a specialization of.
  constexpr unsigned int getNumTemplates() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentFunctionTemplateSpecializationInfo, reflenums::clang__DependentFunctionTemplateSpecializationInfo::getNumTemplates, Xs...); }) , (;) )
  /// Returns the i'th template candidate.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionTemplateDecl *) )
  getTemplate(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentFunctionTemplateSpecializationInfo, reflenums::clang__DependentFunctionTemplateSpecializationInfo::getTemplate, Xs..., I); }) , (;) )
  /// Returns the explicit template arguments that were given.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentLoc *) )
  getTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentFunctionTemplateSpecializationInfo, reflenums::clang__DependentFunctionTemplateSpecializationInfo::getTemplateArgs, Xs...); }) , (;) )
  /// Returns the number of explicit template arguments that were given.
  constexpr unsigned int getNumTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentFunctionTemplateSpecializationInfo, reflenums::clang__DependentFunctionTemplateSpecializationInfo::getNumTemplateArgs, Xs...); }) , (;) )
  /// Returns the nth template argument.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentLoc &) )
  getTemplateArg(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentFunctionTemplateSpecializationInfo, reflenums::clang__DependentFunctionTemplateSpecializationInfo::getTemplateArg, Xs..., I); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentFunctionTemplateSpecializationInfo, reflenums::clang__DependentFunctionTemplateSpecializationInfo::getLAngleLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentFunctionTemplateSpecializationInfo, reflenums::clang__DependentFunctionTemplateSpecializationInfo::getRAngleLoc, Xs...); }) , (;) )
};

/// Declaration of a redeclarable template.
M_template_rtpack(Xs)
struct clang::RedeclarableTemplateDecl::impl : impl_offset_t<clang::TemplateDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__RedeclarableTemplateDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::RedeclarableTemplateDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::RedeclarableTemplateDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RedeclarableTemplateDecl, reflenums::clang__RedeclarableTemplateDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::RedeclarableTemplateDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RedeclarableTemplateDecl, reflenums::clang__RedeclarableTemplateDecl::getFirstDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::RedeclarableTemplateDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RedeclarableTemplateDecl, reflenums::clang__RedeclarableTemplateDecl::getMostRecentDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::RedeclarableTemplateDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RedeclarableTemplateDecl, reflenums::clang__RedeclarableTemplateDecl::getCanonicalDecl, Xs...); }) , (;) )
  /// Determines whether this template was a specialization of a
  /// member template.
  ///
  /// In the following example, the function template \c X<int>::f and the
  /// member template \c X<int>::Inner are member specializations.
  ///
  /// \code
  /// template<typename T>
  /// struct X {
  ///   template<typename U> void f(T, U);
  ///   template<typename U> struct Inner;
  /// };
  ///
  /// template<> template<typename T>
  /// void X<int>::f(int, T);
  /// template<> template<typename T>
  /// struct X<int>::Inner { /* ... */ };
  /// \endcode
  constexpr bool isMemberSpecialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RedeclarableTemplateDecl, reflenums::clang__RedeclarableTemplateDecl::isMemberSpecialization, Xs...); }) , (;) )
  /// Retrieve the member template from which this template was
  /// instantiated, or nullptr if this template was not instantiated from a
  /// member template.
  ///
  /// A template is instantiated from a member template when the member
  /// template itself is part of a class template (or member thereof). For
  /// example, given
  ///
  /// \code
  /// template<typename T>
  /// struct X {
  ///   template<typename U> void f(T, U);
  /// };
  ///
  /// void test(X<int> x) {
  ///   x.f(1, 'a');
  /// };
  /// \endcode
  ///
  /// \c X<int>::f is a FunctionTemplateDecl that describes the function
  /// template
  ///
  /// \code
  /// template<typename U> void X<int>::f(int, U);
  /// \endcode
  ///
  /// which was itself created during the instantiation of \c X<int>. Calling
  /// getInstantiatedFromMemberTemplate() on this FunctionTemplateDecl will
  /// retrieve the FunctionTemplateDecl for the original template \c f within
  /// the class template \c X<T>, i.e.,
  ///
  /// \code
  /// template<typename T>
  /// template<typename U>
  /// void X<T>::f(T, U);
  /// \endcode
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::RedeclarableTemplateDecl *) )
  getInstantiatedFromMemberTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RedeclarableTemplateDecl, reflenums::clang__RedeclarableTemplateDecl::getInstantiatedFromMemberTemplate, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RedeclarableTemplateDecl, reflenums::clang__RedeclarableTemplateDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__RedeclarableTemplateDecl, reflenums::clang__RedeclarableTemplateDecl::classofKind, Xs..., K); }) , (;) )
};

/// Declaration of a template function.
M_template_rtpack(Xs)
struct clang::FunctionTemplateDecl::impl : impl_offset_t<clang::RedeclarableTemplateDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FunctionTemplateDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FunctionTemplateDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Load any lazily-loaded specializations from the external source.
  constexpr void LoadLazySpecializations() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__FunctionTemplateDecl, reflenums::clang__FunctionTemplateDecl::LoadLazySpecializations, Xs...); }) , (;) )
  /// Get the underlying function declaration of the template.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  getTemplatedDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateDecl, reflenums::clang__FunctionTemplateDecl::getTemplatedDecl, Xs...); }) , (;) )
  /// Returns whether this template declaration defines the primary
  /// pattern.
  constexpr bool isThisDeclarationADefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateDecl, reflenums::clang__FunctionTemplateDecl::isThisDeclarationADefinition, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionTemplateDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateDecl, reflenums::clang__FunctionTemplateDecl::getCanonicalDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionTemplateDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateDecl, reflenums::clang__FunctionTemplateDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FunctionTemplateDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateDecl, reflenums::clang__FunctionTemplateDecl::getMostRecentDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionTemplateDecl *) )
  getInstantiatedFromMemberTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateDecl, reflenums::clang__FunctionTemplateDecl::getInstantiatedFromMemberTemplate, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::FunctionTemplateDecl, specializations,
      constexpr auto specializations() const ,
      (typename meta::clang::FunctionDecl *),
      (reflenums::RK_clang__FunctionTemplateDecl, reflenums::clang__FunctionTemplateDecl::specializations, Xs...), () )
  /// Create a function template node.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionTemplateDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) L, IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::DeclarationName)) Name, IFMETA_ELSE((const clang::TemplateParameterList::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::TemplateParameterList *)) Params, IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::NamedDecl *)) Decl) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateDecl, reflenums::clang__FunctionTemplateDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionTemplateDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, ptrwrp<Y5> p5) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5.get());
  }), () )
  /// Create an empty function template node.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionTemplateDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateDecl, reflenums::clang__FunctionTemplateDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateDecl, reflenums::clang__FunctionTemplateDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionTemplateDecl, reflenums::clang__FunctionTemplateDecl::classofKind, Xs..., K); }) , (;) )
};

/// Declaration of a template type parameter.
///
/// For example, "T" in
/// \code
/// template<typename T> class vector;
/// \endcode
M_template_rtpack(Xs)
struct clang::TemplateTypeParmDecl::impl : impl_offset_t<clang::TypeDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TemplateTypeParmDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TemplateTypeParmDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateTypeParmDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) KeyLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) NameLoc, unsigned int D, unsigned int P, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Id, bool Typename, bool ParameterPack) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., D, P, Y4s..., Typename, ParameterPack); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateTypeParmDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, unsigned int p4, unsigned int p5, ptrwrp<Y4> p6, bool p7, bool p8) {
      return Create(p0, p1.get(), p2, p3, p4, p5, p6.get(), p7, p8);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateTypeParmDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// Whether this template type parameter was declared with
  /// the 'typename' keyword.
  ///
  /// If not, it was declared with the 'class' keyword.
  constexpr bool wasDeclaredWithTypename() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::wasDeclaredWithTypename, Xs...); }) , (;) )
  /// Determine whether this template parameter has a default
  /// argument.
  constexpr bool hasDefaultArgument() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::hasDefaultArgument, Xs...); }) , (;) )
  /// Retrieve the default argument, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDefaultArgument() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::getDefaultArgument, Xs...); }) , (;) )
  /// Retrieves the default argument's source information, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getDefaultArgumentInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::getDefaultArgumentInfo, Xs...); }) , (;) )
  /// Retrieves the location of the default argument declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getDefaultArgumentLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::getDefaultArgumentLoc, Xs...); }) , (;) )
  /// Determines whether the default argument was inherited
  /// from a previous declaration of this template.
  constexpr bool defaultArgumentWasInherited() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::defaultArgumentWasInherited, Xs...); }) , (;) )
  /// Retrieve the depth of the template parameter.
  constexpr unsigned int getDepth() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::getDepth, Xs...); }) , (;) )
  /// Retrieve the index of the template parameter.
  constexpr unsigned int getIndex() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::getIndex, Xs...); }) , (;) )
  /// Returns whether this is a parameter pack.
  constexpr bool isParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::isParameterPack, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTypeParmDecl, reflenums::clang__TemplateTypeParmDecl::classofKind, Xs..., K); }) , (;) )
};

/// NonTypeTemplateParmDecl - Declares a non-type template parameter,
/// e.g., "Size" in
/// @code
/// template<int Size> class array { };
/// @endcode
M_template_rtpack(Xs)
struct clang::NonTypeTemplateParmDecl::impl : impl_offset_t<clang::DeclaratorDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__NonTypeTemplateParmDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::NonTypeTemplateParmDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NonTypeTemplateParmDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) IdLoc, unsigned int D, unsigned int P, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::QualType)) T, bool ParameterPack, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., D, P, Y4s..., Y5s..., ParameterPack, Y6s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NonTypeTemplateParmDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, unsigned int p4, unsigned int p5, ptrwrp<Y4> p6, Y5 p7, bool p8, ptrwrp<Y6> p9) {
      return Create(p0, p1.get(), p2, p3, p4, p5, p6.get(), p7, p8, p9.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NonTypeTemplateParmDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::NonTypeTemplateParmDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID, unsigned int NumExpandedTypes) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::CreateDeserialized1, Xs..., Y0s..., ID, NumExpandedTypes); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::getSourceRange, Xs...); }) , (;) )
  /// Determine whether this template parameter has a default
  /// argument.
  constexpr bool hasDefaultArgument() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::hasDefaultArgument, Xs...); }) , (;) )
  /// Retrieve the default argument, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getDefaultArgument() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::getDefaultArgument, Xs...); }) , (;) )
  /// Retrieve the location of the default argument, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getDefaultArgumentLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::getDefaultArgumentLoc, Xs...); }) , (;) )
  /// Determines whether the default argument was inherited
  /// from a previous declaration of this template.
  constexpr bool defaultArgumentWasInherited() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::defaultArgumentWasInherited, Xs...); }) , (;) )
  /// Whether this parameter is a non-type template parameter pack.
  ///
  /// If the parameter is a parameter pack, the type may be a
  /// \c PackExpansionType. In the following example, the \c Dims parameter
  /// is a parameter pack (whose type is 'unsigned').
  ///
  /// \code
  /// template<typename T, unsigned ...Dims> struct multi_array;
  /// \endcode
  constexpr bool isParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::isParameterPack, Xs...); }) , (;) )
  /// Whether this parameter pack is a pack expansion.
  ///
  /// A non-type template parameter pack is a pack expansion if its type
  /// contains an unexpanded parameter pack. In this case, we will have
  /// built a PackExpansionType wrapping the type.
  constexpr bool isPackExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::isPackExpansion, Xs...); }) , (;) )
  /// Whether this parameter is a non-type template parameter pack
  /// that has a known list of different types at different positions.
  ///
  /// A parameter pack is an expanded parameter pack when the original
  /// parameter pack's type was itself a pack expansion, and that expansion
  /// has already been expanded. For example, given:
  ///
  /// \code
  /// template<typename ...Types>
  /// struct X {
  ///   template<Types ...Values>
  ///   struct Y { /* ... */ };
  /// };
  /// \endcode
  ///
  /// The parameter pack \c Values has a \c PackExpansionType as its type,
  /// which expands \c Types. When \c Types is supplied with template arguments
  /// by instantiating \c X, the instantiation of \c Values becomes an
  /// expanded parameter pack. For example, instantiating
  /// \c X<int, unsigned int> results in \c Values being an expanded parameter
  /// pack with expansion types \c int and \c unsigned int.
  ///
  /// The \c getExpansionType() and \c getExpansionTypeSourceInfo() functions
  /// return the expansion types.
  constexpr bool isExpandedParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::isExpandedParameterPack, Xs...); }) , (;) )
  /// Retrieves the number of expansion types in an expanded parameter
  /// pack.
  constexpr unsigned int getNumExpansionTypes() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::getNumExpansionTypes, Xs...); }) , (;) )
  /// Retrieve a particular expansion type within an expanded parameter
  /// pack.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getExpansionType(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::getExpansionType, Xs..., I); }) , (;) )
  /// Retrieve a particular expansion type source info within an
  /// expanded parameter pack.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getExpansionTypeSourceInfo(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::getExpansionTypeSourceInfo, Xs..., I); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__NonTypeTemplateParmDecl, reflenums::clang__NonTypeTemplateParmDecl::classofKind, Xs..., K); }) , (;) )
};

/// TemplateTemplateParmDecl - Declares a template template parameter,
/// e.g., "T" in
/// @code
/// template <template <typename> class T> class container { };
/// @endcode
/// A template template parameter is a TemplateDecl because it defines the
/// name of a template and the template parameters allowable for substitution.
M_template_rtpack(Xs)
struct clang::TemplateTemplateParmDecl::impl : impl_offset_t<clang::TemplateDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TemplateTemplateParmDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TemplateTemplateParmDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateTemplateParmDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) L, unsigned int D, unsigned int P, bool ParameterPack, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::TemplateParameterList::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::TemplateParameterList *)) Params) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., D, P, ParameterPack, Y3s..., Y4s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateTemplateParmDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, unsigned int p3, unsigned int p4, bool p5, ptrwrp<Y3> p6, ptrwrp<Y4> p7) {
      return Create(p0, p1.get(), p2, p3, p4, p5, p6.get(), p7.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateTemplateParmDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateTemplateParmDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID, unsigned int NumExpansions) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::CreateDeserialized1, Xs..., Y0s..., ID, NumExpansions); }) , (;) )
  /// Whether this template template parameter is a template
  /// parameter pack.
  ///
  /// \code
  /// template<template <class T> ...MetaFunctions> struct Apply;
  /// \endcode
  constexpr bool isParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::isParameterPack, Xs...); }) , (;) )
  /// Whether this parameter pack is a pack expansion.
  ///
  /// A template template parameter pack is a pack expansion if its template
  /// parameter list contains an unexpanded parameter pack.
  constexpr bool isPackExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::isPackExpansion, Xs...); }) , (;) )
  /// Whether this parameter is a template template parameter pack that
  /// has a known list of different template parameter lists at different
  /// positions.
  ///
  /// A parameter pack is an expanded parameter pack when the original parameter
  /// pack's template parameter list was itself a pack expansion, and that
  /// expansion has already been expanded. For exampe, given:
  ///
  /// \code
  /// template<typename...Types> struct Outer {
  ///   template<template<Types> class...Templates> struct Inner;
  /// };
  /// \endcode
  ///
  /// The parameter pack \c Templates is a pack expansion, which expands the
  /// pack \c Types. When \c Types is supplied with template arguments by
  /// instantiating \c Outer, the instantiation of \c Templates is an expanded
  /// parameter pack.
  constexpr bool isExpandedParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::isExpandedParameterPack, Xs...); }) , (;) )
  /// Retrieves the number of expansion template parameters in
  /// an expanded parameter pack.
  constexpr unsigned int getNumExpansionTemplateParameters() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::getNumExpansionTemplateParameters, Xs...); }) , (;) )
  /// Retrieve a particular expansion type within an expanded parameter
  /// pack.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateParameterList *) )
  getExpansionTemplateParameters(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::getExpansionTemplateParameters, Xs..., I); }) , (;) )
  /// Determine whether this template parameter has a default
  /// argument.
  constexpr bool hasDefaultArgument() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::hasDefaultArgument, Xs...); }) , (;) )
  /// Retrieve the default argument, if any.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentLoc &) )
  getDefaultArgument() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::getDefaultArgument, Xs...); }) , (;) )
  /// Retrieve the location of the default argument, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getDefaultArgumentLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::getDefaultArgumentLoc, Xs...); }) , (;) )
  /// Determines whether the default argument was inherited
  /// from a previous declaration of this template.
  constexpr bool defaultArgumentWasInherited() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::defaultArgumentWasInherited, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TemplateTemplateParmDecl, reflenums::clang__TemplateTemplateParmDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents the builtin template declaration which is used to
/// implement __make_integer_seq and other builtin templates.  It serves
/// no real purpose beyond existing as a place to hold template parameters.
M_template_rtpack(Xs)
struct clang::BuiltinTemplateDecl::impl : impl_offset_t<clang::TemplateDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__BuiltinTemplateDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::BuiltinTemplateDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinTemplateDecl, reflenums::clang__BuiltinTemplateDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinTemplateDecl, reflenums::clang__BuiltinTemplateDecl::classofKind, Xs..., K); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__BuiltinTemplateDecl, reflenums::clang__BuiltinTemplateDecl::getSourceRange, Xs...); }) , (;) )
};

/// Represents a class template specialization, which refers to
/// a class template with a given set of template arguments.
///
/// Class template specializations represent both explicit
/// specialization of class templates, as in the example below, and
/// implicit instantiations of class templates.
///
/// \code
/// template<typename T> class array;
///
/// template<>
/// class array<bool> { }; // class template specialization array<bool>
/// \endcode
M_template_rtpack(Xs)
struct clang::ClassTemplateSpecializationDecl::impl : impl_offset_t<clang::CXXRecordDecl, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 160 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ClassTemplateSpecializationDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ClassTemplateSpecializationDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ClassTemplateSpecializationDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void getNameForDiagnostic(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy, bool Qualified) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::getNameForDiagnostic, Xs..., Y0s..., Y1s..., Qualified); }) , (;) )
  /// Retrieve the template that this specialization specializes.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ClassTemplateDecl *) )
  getSpecializedTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::getSpecializedTemplate, Xs...); }) , (;) )
  /// Retrieve the template arguments of the class template
  /// specialization.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentList &) )
  getTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::getTemplateArgs, Xs...); }) , (;) )
  /// Determine the kind of specialization that this
  /// declaration represents.
  constexpr enum clang::TemplateSpecializationKind getSpecializationKind() const IFMETA_ELSE( ({    return (enum clang::TemplateSpecializationKind)__reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::getSpecializationKind, Xs...); }) , (;) )
  constexpr bool isExplicitSpecialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::isExplicitSpecialization, Xs...); }) , (;) )
  /// True if this declaration is an explicit specialization,
  /// explicit instantiation declaration, or explicit instantiation
  /// definition.
  constexpr bool isExplicitInstantiationOrSpecialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::isExplicitInstantiationOrSpecialization, Xs...); }) , (;) )
  /// Get the point of instantiation (if any), or null if none.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getPointOfInstantiation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::getPointOfInstantiation, Xs...); }) , (;) )
  /// Retrieve the set of template arguments that should be used
  /// to instantiate members of the class template or class template partial
  /// specialization from which this class template specialization was
  /// instantiated.
  ///
  /// \returns For a class template specialization instantiated from the primary
  /// template, this function will return the same template arguments as
  /// getTemplateArgs(). For a class template specialization instantiated from
  /// a class template partial specialization, this function will return the
  /// deduced template arguments for the class template partial specialization
  /// itself.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentList &) )
  getTemplateInstantiationArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::getTemplateInstantiationArgs, Xs...); }) , (;) )
  /// Gets the type of this specialization as it was written by
  /// the user, if it was so written.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::getTypeAsWritten, Xs...); }) , (;) )
  /// Gets the location of the extern keyword, if present.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExternLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::getExternLoc, Xs...); }) , (;) )
  /// Gets the location of the template keyword, if present.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTemplateKeywordLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::getTemplateKeywordLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::Profile, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateSpecializationDecl, reflenums::clang__ClassTemplateSpecializationDecl::classofKind, Xs..., K); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::ClassTemplatePartialSpecializationDecl::impl : impl_offset_t<clang::ClassTemplateSpecializationDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ClassTemplatePartialSpecializationDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ClassTemplatePartialSpecializationDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ClassTemplatePartialSpecializationDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplatePartialSpecializationDecl, reflenums::clang__ClassTemplatePartialSpecializationDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// Get the list of template parameters
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateParameterList *) )
  getTemplateParameters() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplatePartialSpecializationDecl, reflenums::clang__ClassTemplatePartialSpecializationDecl::getTemplateParameters, Xs...); }) , (;) )
  /// Get the template arguments as written.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ASTTemplateArgumentListInfo *) )
  getTemplateArgsAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplatePartialSpecializationDecl, reflenums::clang__ClassTemplatePartialSpecializationDecl::getTemplateArgsAsWritten, Xs...); }) , (;) )
  /// Retrieve the member class template partial specialization from
  /// which this particular class template partial specialization was
  /// instantiated.
  ///
  /// \code
  /// template<typename T>
  /// struct Outer {
  ///   template<typename U> struct Inner;
  ///   template<typename U> struct Inner<U*> { }; // #1
  /// };
  ///
  /// Outer<float>::Inner<int*> ii;
  /// \endcode
  ///
  /// In this example, the instantiation of \c Outer<float>::Inner<int*> will
  /// end up instantiating the partial specialization
  /// \c Outer<float>::Inner<U*>, which itself was instantiated from the class
  /// template partial specialization \c Outer<T>::Inner<U*>. Given
  /// \c Outer<float>::Inner<U*>, this function would return
  /// \c Outer<T>::Inner<U*>.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ClassTemplatePartialSpecializationDecl *) )
  getInstantiatedFromMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplatePartialSpecializationDecl, reflenums::clang__ClassTemplatePartialSpecializationDecl::getInstantiatedFromMember, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ClassTemplatePartialSpecializationDecl *) )
  getInstantiatedFromMemberTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplatePartialSpecializationDecl, reflenums::clang__ClassTemplatePartialSpecializationDecl::getInstantiatedFromMemberTemplate, Xs...); }) , (;) )
  /// Retrieves the injected specialization type for this partial
  /// specialization.  This is not the same as the type-decl-type for
  /// this partial specialization, which is an InjectedClassNameType.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getInjectedSpecializationType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplatePartialSpecializationDecl, reflenums::clang__ClassTemplatePartialSpecializationDecl::getInjectedSpecializationType, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplatePartialSpecializationDecl, reflenums::clang__ClassTemplatePartialSpecializationDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplatePartialSpecializationDecl, reflenums::clang__ClassTemplatePartialSpecializationDecl::classofKind, Xs..., K); }) , (;) )
};

/// Declaration of a class template.
M_template_rtpack(Xs)
struct clang::ClassTemplateDecl::impl : impl_offset_t<clang::RedeclarableTemplateDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ClassTemplateDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ClassTemplateDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Load any lazily-loaded specializations from the external source.
  constexpr void LoadLazySpecializations() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ClassTemplateDecl, reflenums::clang__ClassTemplateDecl::LoadLazySpecializations, Xs...); }) , (;) )
  /// Get the underlying class declarations of the template.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getTemplatedDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateDecl, reflenums::clang__ClassTemplateDecl::getTemplatedDecl, Xs...); }) , (;) )
  /// Returns whether this template declaration defines the primary
  /// class pattern.
  constexpr bool isThisDeclarationADefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateDecl, reflenums::clang__ClassTemplateDecl::isThisDeclarationADefinition, Xs...); }) , (;) )
  /// Create a class template node.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ClassTemplateDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) L, IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::DeclarationName)) Name, IFMETA_ELSE((const clang::TemplateParameterList::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::TemplateParameterList *)) Params, IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::NamedDecl *)) Decl, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::Expr *)) AssociatedConstraints = {}) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateDecl, reflenums::clang__ClassTemplateDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ClassTemplateDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, ptrwrp<Y5> p5, ptrwrp<Y6> p6 = {}) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5.get(), p6.get());
  }), () )
  /// Create an empty class template node.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ClassTemplateDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateDecl, reflenums::clang__ClassTemplateDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ClassTemplateDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateDecl, reflenums::clang__ClassTemplateDecl::getCanonicalDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ClassTemplateDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateDecl, reflenums::clang__ClassTemplateDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ClassTemplateDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateDecl, reflenums::clang__ClassTemplateDecl::getMostRecentDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ClassTemplateDecl *) )
  getInstantiatedFromMemberTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateDecl, reflenums::clang__ClassTemplateDecl::getInstantiatedFromMemberTemplate, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ClassTemplateDecl, specializations,
      constexpr auto specializations() const ,
      (typename meta::clang::ClassTemplateSpecializationDecl *),
      (reflenums::RK_clang__ClassTemplateDecl, reflenums::clang__ClassTemplateDecl::specializations, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateDecl, reflenums::clang__ClassTemplateDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassTemplateDecl, reflenums::clang__ClassTemplateDecl::classofKind, Xs..., K); }) , (;) )
};

/// Declaration of a friend template.
///
/// For example:
/// \code
/// template \<typename T> class A {
///   friend class MyVector<T>; // not a friend template
///   template \<typename U> friend class B; // not a friend template
///   template \<typename U> friend class Foo<T>::Nested; // friend template
/// };
/// \endcode
///
/// \note This class is not currently in use.  All of the above
/// will yield a FriendDecl, not a FriendTemplateDecl.
M_template_rtpack(Xs)
struct clang::FriendTemplateDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FriendTemplateDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FriendTemplateDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FriendTemplateDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendTemplateDecl, reflenums::clang__FriendTemplateDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// If this friend declaration names a templated type (or
  /// a dependent member type of a templated type), return that
  /// type;  otherwise return null.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getFriendType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendTemplateDecl, reflenums::clang__FriendTemplateDecl::getFriendType, Xs...); }) , (;) )
  /// If this friend declaration names a templated function (or
  /// a member function of a templated type), return that type;
  /// otherwise return null.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getFriendDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendTemplateDecl, reflenums::clang__FriendTemplateDecl::getFriendDecl, Xs...); }) , (;) )
  /// Retrieves the location of the 'friend' keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getFriendLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendTemplateDecl, reflenums::clang__FriendTemplateDecl::getFriendLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateParameterList *) )
  getTemplateParameterList(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendTemplateDecl, reflenums::clang__FriendTemplateDecl::getTemplateParameterList, Xs..., i); }) , (;) )
  constexpr unsigned int getNumTemplateParameters() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendTemplateDecl, reflenums::clang__FriendTemplateDecl::getNumTemplateParameters, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendTemplateDecl, reflenums::clang__FriendTemplateDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendTemplateDecl, reflenums::clang__FriendTemplateDecl::classofKind, Xs..., K); }) , (;) )
};

/// Declaration of an alias template.
///
/// For example:
/// \code
/// template \<typename T> using V = std::map<T*, int, MyCompare<T>>;
/// \endcode
M_template_rtpack(Xs)
struct clang::TypeAliasTemplateDecl::impl : impl_offset_t<clang::RedeclarableTemplateDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypeAliasTemplateDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypeAliasTemplateDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Get the underlying function declaration of the template.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeAliasDecl *) )
  getTemplatedDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasTemplateDecl, reflenums::clang__TypeAliasTemplateDecl::getTemplatedDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TypeAliasTemplateDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasTemplateDecl, reflenums::clang__TypeAliasTemplateDecl::getCanonicalDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TypeAliasTemplateDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasTemplateDecl, reflenums::clang__TypeAliasTemplateDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeAliasTemplateDecl *) )
  getInstantiatedFromMemberTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasTemplateDecl, reflenums::clang__TypeAliasTemplateDecl::getInstantiatedFromMemberTemplate, Xs...); }) , (;) )
  /// Create a function template node.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeAliasTemplateDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) L, IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::DeclarationName)) Name, IFMETA_ELSE((const clang::TemplateParameterList::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::TemplateParameterList *)) Params, IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::NamedDecl *)) Decl) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasTemplateDecl, reflenums::clang__TypeAliasTemplateDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeAliasTemplateDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, ptrwrp<Y5> p5) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5.get());
  }), () )
  /// Create an empty alias template node.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeAliasTemplateDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasTemplateDecl, reflenums::clang__TypeAliasTemplateDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasTemplateDecl, reflenums::clang__TypeAliasTemplateDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeAliasTemplateDecl, reflenums::clang__TypeAliasTemplateDecl::classofKind, Xs..., K); }) , (;) )
};

/// Declaration of a function specialization at template class scope.
///
/// This is a non-standard extension needed to support MSVC.
///
/// For example:
/// \code
/// template <class T>
/// class A {
///    template <class U> void foo(U a) { }
///    template<> void foo(int a) { }
/// }
/// \endcode
///
/// "template<> foo(int a)" will be saved in Specialization as a normal
/// CXXMethodDecl. Then during an instantiation of class A, it will be
/// transformed into an actual function specialization.
M_template_rtpack(Xs)
struct clang::ClassScopeFunctionSpecializationDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ClassScopeFunctionSpecializationDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ClassScopeFunctionSpecializationDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXMethodDecl *) )
  getSpecialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassScopeFunctionSpecializationDecl, reflenums::clang__ClassScopeFunctionSpecializationDecl::getSpecialization, Xs...); }) , (;) )
  constexpr bool hasExplicitTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassScopeFunctionSpecializationDecl, reflenums::clang__ClassScopeFunctionSpecializationDecl::hasExplicitTemplateArgs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentListInfo &) )
  templateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassScopeFunctionSpecializationDecl, reflenums::clang__ClassScopeFunctionSpecializationDecl::templateArgs, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ClassScopeFunctionSpecializationDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) Loc, IFMETA_ELSE((const clang::CXXMethodDecl::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::CXXMethodDecl *)) FD, bool HasExplicitTemplateArgs, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::TemplateArgumentListInfo)) TemplateArgs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassScopeFunctionSpecializationDecl, reflenums::clang__ClassScopeFunctionSpecializationDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., HasExplicitTemplateArgs, Y4s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ClassScopeFunctionSpecializationDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, ptrwrp<Y3> p3, bool p4, Y4 p5) {
      return Create(p0, p1.get(), p2, p3.get(), p4, p5);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ClassScopeFunctionSpecializationDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Context, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassScopeFunctionSpecializationDecl, reflenums::clang__ClassScopeFunctionSpecializationDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassScopeFunctionSpecializationDecl, reflenums::clang__ClassScopeFunctionSpecializationDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ClassScopeFunctionSpecializationDecl, reflenums::clang__ClassScopeFunctionSpecializationDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a variable template specialization, which refers to
/// a variable template with a given set of template arguments.
///
/// Variable template specializations represent both explicit
/// specializations of variable templates, as in the example below, and
/// implicit instantiations of variable templates.
///
/// \code
/// template<typename T> constexpr T pi = T(3.1415926535897932385);
///
/// template<>
/// constexpr float pi<float>; // variable template specialization pi<float>
/// \endcode
M_template_rtpack(Xs)
struct clang::VarTemplateSpecializationDecl::impl : impl_offset_t<clang::VarDecl, 0 M_c M_pack(Xs)>, impl_offset_t<llvm::FoldingSetBase::Node, 104 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__VarTemplateSpecializationDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::VarTemplateSpecializationDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarTemplateSpecializationDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr void getNameForDiagnostic(IFMETA_ELSE((const llvm::raw_ostream::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::raw_ostream &)) OS, IFMETA_ELSE((const clang::PrintingPolicy::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::PrintingPolicy &)) Policy, bool Qualified) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::getNameForDiagnostic, Xs..., Y0s..., Y1s..., Qualified); }) , (;) )
  /// Retrieve the template that this specialization specializes.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarTemplateDecl *) )
  getSpecializedTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::getSpecializedTemplate, Xs...); }) , (;) )
  /// Retrieve the template arguments of the variable template
  /// specialization.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentList &) )
  getTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::getTemplateArgs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentListInfo &) )
  getTemplateArgsInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::getTemplateArgsInfo, Xs...); }) , (;) )
  /// Determine the kind of specialization that this
  /// declaration represents.
  constexpr enum clang::TemplateSpecializationKind getSpecializationKind() const IFMETA_ELSE( ({    return (enum clang::TemplateSpecializationKind)__reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::getSpecializationKind, Xs...); }) , (;) )
  constexpr bool isExplicitSpecialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::isExplicitSpecialization, Xs...); }) , (;) )
  /// True if this declaration is an explicit specialization,
  /// explicit instantiation declaration, or explicit instantiation
  /// definition.
  constexpr bool isExplicitInstantiationOrSpecialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::isExplicitInstantiationOrSpecialization, Xs...); }) , (;) )
  /// Get the point of instantiation (if any), or null if none.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getPointOfInstantiation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::getPointOfInstantiation, Xs...); }) , (;) )
  /// Retrieve the set of template arguments that should be used
  /// to instantiate the initializer of the variable template or variable
  /// template partial specialization from which this variable template
  /// specialization was instantiated.
  ///
  /// \returns For a variable template specialization instantiated from the
  /// primary template, this function will return the same template arguments
  /// as getTemplateArgs(). For a variable template specialization instantiated
  /// from a variable template partial specialization, this function will the
  /// return deduced template arguments for the variable template partial
  /// specialization itself.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentList &) )
  getTemplateInstantiationArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::getTemplateInstantiationArgs, Xs...); }) , (;) )
  /// Gets the type of this specialization as it was written by
  /// the user, if it was so written.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::getTypeAsWritten, Xs...); }) , (;) )
  /// Gets the location of the extern keyword, if present.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExternLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::getExternLoc, Xs...); }) , (;) )
  /// Gets the location of the template keyword, if present.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTemplateKeywordLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::getTemplateKeywordLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void Profile(IFMETA_ELSE((const llvm::FoldingSetNodeID::template impl</*ptrorref=*/1, Y0s...>), (typename meta::llvm::FoldingSetNodeID &)) ID) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::Profile, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateSpecializationDecl, reflenums::clang__VarTemplateSpecializationDecl::classofKind, Xs..., K); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::VarTemplatePartialSpecializationDecl::impl : impl_offset_t<clang::VarTemplateSpecializationDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__VarTemplatePartialSpecializationDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::VarTemplatePartialSpecializationDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarTemplatePartialSpecializationDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplatePartialSpecializationDecl, reflenums::clang__VarTemplatePartialSpecializationDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// Get the list of template parameters
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateParameterList *) )
  getTemplateParameters() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplatePartialSpecializationDecl, reflenums::clang__VarTemplatePartialSpecializationDecl::getTemplateParameters, Xs...); }) , (;) )
  /// Get the template arguments as written.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ASTTemplateArgumentListInfo *) )
  getTemplateArgsAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplatePartialSpecializationDecl, reflenums::clang__VarTemplatePartialSpecializationDecl::getTemplateArgsAsWritten, Xs...); }) , (;) )
  /// Retrieve the member variable template partial specialization from
  /// which this particular variable template partial specialization was
  /// instantiated.
  ///
  /// \code
  /// template<typename T>
  /// struct Outer {
  ///   template<typename U> U Inner;
  ///   template<typename U> U* Inner<U*> = (U*)(0); // #1
  /// };
  ///
  /// template int* Outer<float>::Inner<int*>;
  /// \endcode
  ///
  /// In this example, the instantiation of \c Outer<float>::Inner<int*> will
  /// end up instantiating the partial specialization
  /// \c Outer<float>::Inner<U*>, which itself was instantiated from the
  /// variable template partial specialization \c Outer<T>::Inner<U*>. Given
  /// \c Outer<float>::Inner<U*>, this function would return
  /// \c Outer<T>::Inner<U*>.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarTemplatePartialSpecializationDecl *) )
  getInstantiatedFromMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplatePartialSpecializationDecl, reflenums::clang__VarTemplatePartialSpecializationDecl::getInstantiatedFromMember, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplatePartialSpecializationDecl, reflenums::clang__VarTemplatePartialSpecializationDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplatePartialSpecializationDecl, reflenums::clang__VarTemplatePartialSpecializationDecl::classofKind, Xs..., K); }) , (;) )
};

/// Declaration of a variable template.
M_template_rtpack(Xs)
struct clang::VarTemplateDecl::impl : impl_offset_t<clang::RedeclarableTemplateDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__VarTemplateDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::VarTemplateDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Load any lazily-loaded specializations from the external source.
  constexpr void LoadLazySpecializations() const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__VarTemplateDecl, reflenums::clang__VarTemplateDecl::LoadLazySpecializations, Xs...); }) , (;) )
  /// Get the underlying variable declarations of the template.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getTemplatedDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateDecl, reflenums::clang__VarTemplateDecl::getTemplatedDecl, Xs...); }) , (;) )
  /// Returns whether this template declaration defines the primary
  /// variable pattern.
  constexpr bool isThisDeclarationADefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateDecl, reflenums::clang__VarTemplateDecl::isThisDeclarationADefinition, Xs...); }) , (;) )
  /// Create a variable template node.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarTemplateDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) L, IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::DeclarationName)) Name, IFMETA_ELSE((const clang::TemplateParameterList::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::TemplateParameterList *)) Params, IFMETA_ELSE((const clang::VarDecl::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::VarDecl *)) Decl) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateDecl, reflenums::clang__VarTemplateDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarTemplateDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, ptrwrp<Y5> p5) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5.get());
  }), () )
  /// Create an empty variable template node.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarTemplateDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateDecl, reflenums::clang__VarTemplateDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarTemplateDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateDecl, reflenums::clang__VarTemplateDecl::getCanonicalDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarTemplateDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateDecl, reflenums::clang__VarTemplateDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarTemplateDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateDecl, reflenums::clang__VarTemplateDecl::getMostRecentDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarTemplateDecl *) )
  getInstantiatedFromMemberTemplate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateDecl, reflenums::clang__VarTemplateDecl::getInstantiatedFromMemberTemplate, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::VarTemplateDecl, specializations,
      constexpr auto specializations() const ,
      (typename meta::clang::VarTemplateSpecializationDecl *),
      (reflenums::RK_clang__VarTemplateDecl, reflenums::clang__VarTemplateDecl::specializations, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateDecl, reflenums::clang__VarTemplateDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__VarTemplateDecl, reflenums::clang__VarTemplateDecl::classofKind, Xs..., K); }) , (;) )
};

/// FriendDecl - Represents the declaration of a friend entity,
/// which can be a function, a type, or a templated function or type.
/// For example:
///
/// @code
/// template <typename T> class A {
///   friend int foo(T);
///   friend class B;
///   friend T; // only in C++0x
///   template <typename U> friend class C;
///   template <typename U> friend A& operator+=(A&, const U&) { ... }
/// };
/// @endcode
///
/// The semantic context of a friend decl is its declaring class.
M_template_rtpack(Xs)
struct clang::FriendDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FriendDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FriendDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FriendDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID, unsigned int FriendTypeNumTPLists) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendDecl, reflenums::clang__FriendDecl::CreateDeserialized, Xs..., Y0s..., ID, FriendTypeNumTPLists); }) , (;) )
  /// If this friend declaration names an (untemplated but possibly
  /// dependent) type, return the type; otherwise return null.  This
  /// is used for elaborated-type-specifiers and, in C++0x, for
  /// arbitrary friend type declarations.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getFriendType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendDecl, reflenums::clang__FriendDecl::getFriendType, Xs...); }) , (;) )
  constexpr unsigned int getFriendTypeNumTemplateParameterLists() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendDecl, reflenums::clang__FriendDecl::getFriendTypeNumTemplateParameterLists, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateParameterList *) )
  getFriendTypeTemplateParameterList(unsigned int N) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendDecl, reflenums::clang__FriendDecl::getFriendTypeTemplateParameterList, Xs..., N); }) , (;) )
  /// If this friend declaration doesn't name a type, return the inner
  /// declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getFriendDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendDecl, reflenums::clang__FriendDecl::getFriendDecl, Xs...); }) , (;) )
  /// Retrieves the location of the 'friend' keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getFriendLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendDecl, reflenums::clang__FriendDecl::getFriendLoc, Xs...); }) , (;) )
  /// Retrieves the source range for the friend declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendDecl, reflenums::clang__FriendDecl::getSourceRange, Xs...); }) , (;) )
  /// Determines if this friend kind is unsupported.
  constexpr bool isUnsupportedFriend() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendDecl, reflenums::clang__FriendDecl::isUnsupportedFriend, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendDecl, reflenums::clang__FriendDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FriendDecl, reflenums::clang__FriendDecl::classofKind, Xs..., K); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::ObjCListBase::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCListBase;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCListBase::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr unsigned int size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCListBase, reflenums::clang__ObjCListBase::size, Xs...); }) , (;) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCListBase, reflenums::clang__ObjCListBase::empty, Xs...); }) , (;) )
};

/// A list of Objective-C protocols, along with the source
/// locations at which they were referenced.
M_template_rtpack(Xs)
struct clang::ObjCProtocolList::impl : impl_offset_t<clang::ObjCListBase, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCProtocolList;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCProtocolList::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCProtocolDecl *) )
  operator[](unsigned int Idx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolList, reflenums::clang__ObjCProtocolList::operator_sub, Xs..., Idx); }) , (;) )
  RANGECLASS_SIZE_AND_GET(clang__ObjCProtocolList, typename meta::clang::ObjCProtocolDecl *const);
};

enum clang::ObjCMethodDecl::ImplementationControl : unsigned int {
  None,
  Required,
  Optional,
};

/// ObjCMethodDecl - Represents an instance or class method declaration.
/// ObjC methods can be declared within 4 contexts: class interfaces,
/// categories, protocols, and class implementations. While C++ member
/// functions leverage C syntax, Objective-C method syntax is modeled after
/// Smalltalk (using colons to specify argument types/expressions).
/// Here are some brief examples:
///
/// Setter/getter instance methods:
/// - (void)setMenu:(NSMenu *)menu;
/// - (NSMenu *)menu;
///
/// Instance method that takes 2 NSView arguments:
/// - (void)replaceSubview:(NSView *)oldView with:(NSView *)newView;
///
/// Getter class method:
/// + (NSMenu *)defaultMenu;
///
/// A selector represents a unique name for a method. The selector names for
/// the above methods are setMenu:, menu, replaceSubview:with:, and defaultMenu.
///
M_template_rtpack(Xs)
struct clang::ObjCMethodDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)>, impl_offset_t<clang::DeclContext, 48 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCMethodDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCMethodDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using ImplementationControl = enum refldetail::clang::ObjCMethodDecl::ImplementationControl;
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) beginLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) endLoc, IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::Selector)) SelInfo, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::TypeSourceInfo *)) ReturnTInfo, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::DeclContext *)) contextDecl, bool isInstance = true, bool isVariadic = false, bool isPropertyAccessor = false, bool isImplicitlyDeclared = false, bool isDefined = false, enum clang::ObjCMethodDecl::ImplementationControl impControl = None, bool HasRelatedResultType = false) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., isInstance, isVariadic, isPropertyAccessor, isImplicitlyDeclared, isDefined, impControl, HasRelatedResultType); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  Create(Y0 p0, Y1 p1, Y2 p2, Y3 p3, Y4 p4, ptrwrp<Y5> p5, ptrwrp<Y6> p6, bool p7 = true, bool p8 = false, bool p9 = false, bool p10 = false, bool p11 = false, enum clang::ObjCMethodDecl::ImplementationControl p12 = None, bool p13 = false) {
      return Create(p0, p1, p2, p3, p4, p5.get(), p6.get(), p7, p8, p9, p10, p11, p12, p13);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCMethodDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getCanonicalDecl, Xs...); }) , (;) )
  constexpr enum clang::Decl::ObjCDeclQualifier getObjCDeclQualifier() const IFMETA_ELSE( ({    return (enum clang::Decl::ObjCDeclQualifier)__reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getObjCDeclQualifier, Xs...); }) , (;) )
  /// Determine whether this method has a result type that is related
  /// to the message receiver's type.
  constexpr bool hasRelatedResultType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::hasRelatedResultType, Xs...); }) , (;) )
  /// True if this is a method redeclaration in the same interface.
  constexpr bool isRedeclaration() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::isRedeclaration, Xs...); }) , (;) )
  /// Returns the location where the declarator ends. It will be
  /// the location of ';' for a method declaration and the location of '{'
  /// for a method definition.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getDeclaratorEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getDeclaratorEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getSelectorStartLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getSelectorStartLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getSelectorLoc(unsigned int Index) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getSelectorLoc, Xs..., Index); }) , (;) )
  constexpr unsigned int getNumSelectorLocs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getNumSelectorLocs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  getClassInterface() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getClassInterface, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Selector) )
  getSelector() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getSelector, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getReturnType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getReturnType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getReturnTypeSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getReturnTypeSourceRange, Xs...); }) , (;) )
  /// Determine the type of an expression that sends a message to this
  /// function. This replaces the type parameters with the types they would
  /// get if the receiver was parameterless (e.g. it may replace the type
  /// parameter with 'id').
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getSendResultType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getSendResultType, Xs...); }) , (;) )
  /// Determine the type of an expression that sends a message to this
  /// function with the given receiver type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getSendResultType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) receiverType) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getSendResultType1, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getReturnTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getReturnTypeSourceInfo, Xs...); }) , (;) )
  constexpr unsigned int param_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::param_size, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ObjCMethodDecl, parameters,
      constexpr auto parameters() const ,
      (typename meta::clang::ParmVarDecl *),
      (reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::parameters, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImplicitParamDecl *) )
  getSelfDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getSelfDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ImplicitParamDecl *) )
  getCmdDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getCmdDecl, Xs...); }) , (;) )
  /// Determines the family of this method.
  constexpr enum clang::ObjCMethodFamily getMethodFamily() const IFMETA_ELSE( ({    return (enum clang::ObjCMethodFamily)__reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getMethodFamily, Xs...); }) , (;) )
  constexpr bool isInstanceMethod() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::isInstanceMethod, Xs...); }) , (;) )
  constexpr bool isVariadic() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::isVariadic, Xs...); }) , (;) )
  constexpr bool isClassMethod() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::isClassMethod, Xs...); }) , (;) )
  constexpr bool isPropertyAccessor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::isPropertyAccessor, Xs...); }) , (;) )
  constexpr bool isDefined() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::isDefined, Xs...); }) , (;) )
  /// Whether this method overrides any other in the class hierarchy.
  ///
  /// A method is said to override any method in the class's
  /// base classes, its protocols, or its categories' protocols, that has
  /// the same selector and is of the same kind (class or instance).
  /// A method in an implementation is not considered as overriding the same
  /// method in the interface or its categories.
  constexpr bool isOverriding() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::isOverriding, Xs...); }) , (;) )
  /// True if the method was a definition but its body was skipped.
  constexpr bool hasSkippedBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::hasSkippedBody, Xs...); }) , (;) )
  /// Returns the property associated with this method's selector.
  ///
  /// Note that even if this particular method is not marked as a property
  /// accessor, it is still possible for it to match a property declared in a
  /// superclass. Pass \c false if you only want to check the current class.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCPropertyDecl *) )
  findPropertyDecl(bool CheckOverrides = true) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::findPropertyDecl, Xs..., CheckOverrides); }) , (;) )
  constexpr enum clang::ObjCMethodDecl::ImplementationControl getImplementationControl() const IFMETA_ELSE( ({    return (enum clang::ObjCMethodDecl::ImplementationControl)__reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getImplementationControl, Xs...); }) , (;) )
  constexpr bool isOptional() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::isOptional, Xs...); }) , (;) )
  /// Returns true if this specific method declaration is marked with the
  /// designated initializer attribute.
  constexpr bool isThisDeclarationADesignatedInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::isThisDeclarationADesignatedInitializer, Xs...); }) , (;) )
  /// Returns true if the method selector resolves to a designated initializer
  /// in the class's interface.
  ///
  /// \param InitMethod if non-null and the function returns true, it receives
  /// the method declaration that was marked with the designated initializer
  /// attribute.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isDesignatedInitializerForTheInterface(IFMETA_ELSE((const clang::ObjCMethodDecl::template impl</*ptrorref=*/1, Y0s...> * *), (const typename meta::clang::ObjCMethodDecl **)) InitMethod = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::isDesignatedInitializerForTheInterface, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isDesignatedInitializerForTheInterface(ptrwrp<Y0> p0 = {}) const {
      return isDesignatedInitializerForTheInterface(p0.get());
  }), () )
  /// Determine whether this method has a body.
  constexpr bool hasBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::hasBody, Xs...); }) , (;) )
  /// Retrieve the body of this method, if it has one.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::getBody, Xs...); }) , (;) )
  /// Returns whether this specific method is a definition.
  constexpr bool isThisDeclarationADefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::isThisDeclarationADefinition, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMethodDecl, reflenums::clang__ObjCMethodDecl::classofKind, Xs..., K); }) , (;) )
};

/// Describes the variance of a given generic parameter.
enum class clang::ObjCTypeParamVariance : uint8_t {
  /// The parameter is invariant: must match exactly.
  Invariant,
  /// The parameter is covariant, e.g., X<T> is a subtype of X<U> when
  /// the type parameter is covariant and T is a subtype of U.
  Covariant,
  /// The parameter is contravariant, e.g., X<T> is a subtype of X<U>
  /// when the type parameter is covariant and U is a subtype of T.
  Contravariant,
};

/// Represents the declaration of an Objective-C type parameter.
///
/// \code
/// @interface NSDictionary<Key : id<NSCopying>, Value>
/// @end
/// \endcode
///
/// In the example above, both \c Key and \c Value are represented by
/// \c ObjCTypeParamDecl. \c Key has an explicit bound of \c id<NSCopying>,
/// while \c Value gets an implicit bound of \c id.
///
/// Objective-C type parameters are typedef-names in the grammar,
M_template_rtpack(Xs)
struct clang::ObjCTypeParamDecl::impl : impl_offset_t<clang::TypedefNameDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCTypeParamDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCTypeParamDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCTypeParamDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) ctx, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) dc, enum clang::ObjCTypeParamVariance variance, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) varianceLoc, unsigned int index, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) nameLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) name, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::SourceLocation)) colonLoc, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::TypeSourceInfo *)) boundInfo) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamDecl, reflenums::clang__ObjCTypeParamDecl::Create, Xs..., Y0s..., Y1s..., variance, Y2s..., index, Y3s..., Y4s..., Y5s..., Y6s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCTypeParamDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, enum clang::ObjCTypeParamVariance p2, Y2 p3, unsigned int p4, Y3 p5, ptrwrp<Y4> p6, Y5 p7, ptrwrp<Y6> p8) {
      return Create(p0, p1.get(), p2, p3, p4, p5, p6.get(), p7, p8.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCTypeParamDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) ctx, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamDecl, reflenums::clang__ObjCTypeParamDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamDecl, reflenums::clang__ObjCTypeParamDecl::getSourceRange, Xs...); }) , (;) )
  /// Determine the variance of this type parameter.
  constexpr enum clang::ObjCTypeParamVariance getVariance() const IFMETA_ELSE( ({    return (enum clang::ObjCTypeParamVariance)__reflect_prop(reflenums::RK_clang__ObjCTypeParamDecl, reflenums::clang__ObjCTypeParamDecl::getVariance, Xs...); }) , (;) )
  /// Retrieve the location of the variance keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getVarianceLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamDecl, reflenums::clang__ObjCTypeParamDecl::getVarianceLoc, Xs...); }) , (;) )
  /// Retrieve the index into its type parameter list.
  constexpr unsigned int getIndex() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamDecl, reflenums::clang__ObjCTypeParamDecl::getIndex, Xs...); }) , (;) )
  /// Whether this type parameter has an explicitly-written type bound, e.g.,
  /// "T : NSView".
  constexpr bool hasExplicitBound() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamDecl, reflenums::clang__ObjCTypeParamDecl::hasExplicitBound, Xs...); }) , (;) )
  /// Retrieve the location of the ':' separating the type parameter name
  /// from the explicitly-specified bound.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getColonLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamDecl, reflenums::clang__ObjCTypeParamDecl::getColonLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamDecl, reflenums::clang__ObjCTypeParamDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamDecl, reflenums::clang__ObjCTypeParamDecl::classofKind, Xs..., K); }) , (;) )
};

/// Stores a list of Objective-C type parameters for a parameterized class
/// or a category/extension thereof.
///
/// \code
/// @interface NSArray<T> // stores the <T>
/// @end
/// \endcode
M_template_rtpack(Xs)
struct clang::ObjCTypeParamList::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCTypeParamList;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCTypeParamList::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Determine the number of type parameters in this list.
  constexpr unsigned int size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamList, reflenums::clang__ObjCTypeParamList::size, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCTypeParamDecl *) )
  front() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamList, reflenums::clang__ObjCTypeParamList::front, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCTypeParamDecl *) )
  back() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamList, reflenums::clang__ObjCTypeParamList::back, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamList, reflenums::clang__ObjCTypeParamList::getLAngleLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamList, reflenums::clang__ObjCTypeParamList::getRAngleLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCTypeParamList, reflenums::clang__ObjCTypeParamList::getSourceRange, Xs...); }) , (;) )
  RANGECLASS_SIZE_AND_GET(clang__ObjCTypeParamList, typename meta::clang::ObjCTypeParamDecl *const);
};

enum class clang::ObjCPropertyQueryKind : uint8_t {
  OBJC_PR_query_unknown = 0,
  OBJC_PR_query_instance,
  OBJC_PR_query_class,
};

enum clang::ObjCPropertyDecl::PropertyAttributeKind : unsigned int {
  OBJC_PR_noattr = 0,
  OBJC_PR_readonly = 1,
  OBJC_PR_getter = 2,
  OBJC_PR_assign = 4,
  OBJC_PR_readwrite = 8,
  OBJC_PR_retain = 16,
  OBJC_PR_copy = 32,
  OBJC_PR_nonatomic = 64,
  OBJC_PR_setter = 128,
  OBJC_PR_atomic = 256,
  OBJC_PR_weak = 512,
  OBJC_PR_strong = 1024,
  OBJC_PR_unsafe_unretained = 2048,
  /// Indicates that the nullability of the type was spelled with a
  /// property attribute rather than a type qualifier.
  OBJC_PR_nullability = 4096,
  /// Indicates that the nullability of the type was spelled with a
  /// property attribute rather than a type qualifier.
  OBJC_PR_null_resettable = 8192,
  /// Indicates that the nullability of the type was spelled with a
  /// property attribute rather than a type qualifier.
  OBJC_PR_class = 16384,
};

enum clang::ObjCPropertyDecl::SetterKind : unsigned int {
  Assign,
  Retain,
  Copy,
  Weak,
};

enum clang::ObjCPropertyDecl::PropertyControl : unsigned int {
  None,
  Required,
  Optional,
};

/// Represents one property declaration in an Objective-C interface.
///
/// For example:
/// \code{.mm}
/// \@property (assign, readwrite) int MyProperty;
/// \endcode
M_template_rtpack(Xs)
struct clang::ObjCPropertyDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCPropertyDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCPropertyDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using PropertyAttributeKind = enum refldetail::clang::ObjCPropertyDecl::PropertyAttributeKind;
  using SetterKind = enum refldetail::clang::ObjCPropertyDecl::SetterKind;
  using PropertyControl = enum refldetail::clang::ObjCPropertyDecl::PropertyControl;
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) L, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::SourceLocation)) AtLocation, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::SourceLocation)) LParenLocation, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y7s...> *), (typename meta::clang::TypeSourceInfo *)) TSI, enum clang::ObjCPropertyDecl::PropertyControl propControl = None) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., Y7s..., propControl); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, ptrwrp<Y3> p3, Y4 p4, Y5 p5, Y6 p6, ptrwrp<Y7> p7, enum clang::ObjCPropertyDecl::PropertyControl p8 = None) {
      return Create(p0, p1.get(), p2, p3.get(), p4, p5, p6, p7.get(), p8);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAtLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getAtLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getLParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getTypeSourceInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getType, Xs...); }) , (;) )
  /// Retrieve the type when this property is used with a specific base object
  /// type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getUsageType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) objectType) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getUsageType, Xs..., Y0s...); }) , (;) )
  constexpr enum clang::ObjCPropertyDecl::PropertyAttributeKind getPropertyAttributes() const IFMETA_ELSE( ({    return (enum clang::ObjCPropertyDecl::PropertyAttributeKind)__reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getPropertyAttributes, Xs...); }) , (;) )
  constexpr enum clang::ObjCPropertyDecl::PropertyAttributeKind getPropertyAttributesAsWritten() const IFMETA_ELSE( ({    return (enum clang::ObjCPropertyDecl::PropertyAttributeKind)__reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getPropertyAttributesAsWritten, Xs...); }) , (;) )
  /// isReadOnly - Return true iff the property has a setter.
  constexpr bool isReadOnly() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::isReadOnly, Xs...); }) , (;) )
  /// isAtomic - Return true if the property is atomic.
  constexpr bool isAtomic() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::isAtomic, Xs...); }) , (;) )
  /// isRetaining - Return true if the property retains its value.
  constexpr bool isRetaining() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::isRetaining, Xs...); }) , (;) )
  constexpr bool isInstanceProperty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::isInstanceProperty, Xs...); }) , (;) )
  constexpr bool isClassProperty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::isClassProperty, Xs...); }) , (;) )
  constexpr enum clang::ObjCPropertyQueryKind getQueryKind() const IFMETA_ELSE( ({    return (enum clang::ObjCPropertyQueryKind)__reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getQueryKind, Xs...); }) , (;) )
  static constexpr enum clang::ObjCPropertyQueryKind getQueryKind(bool isClassProperty) IFMETA_ELSE( ({    return (enum clang::ObjCPropertyQueryKind)__reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getQueryKind1, Xs..., isClassProperty); }) , (;) )
  /// getSetterKind - Return the method used for doing assignment in
  /// the property setter. This is only valid if the property has been
  /// defined to have a setter.
  constexpr enum clang::ObjCPropertyDecl::SetterKind getSetterKind() const IFMETA_ELSE( ({    return (enum clang::ObjCPropertyDecl::SetterKind)__reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getSetterKind, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Selector) )
  getGetterName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getGetterName, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getGetterNameLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getGetterNameLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Selector) )
  getSetterName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getSetterName, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getSetterNameLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getSetterNameLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getGetterMethodDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getGetterMethodDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getSetterMethodDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getSetterMethodDecl, Xs...); }) , (;) )
  constexpr enum clang::ObjCPropertyDecl::PropertyControl getPropertyImplementation() const IFMETA_ELSE( ({    return (enum clang::ObjCPropertyDecl::PropertyControl)__reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getPropertyImplementation, Xs...); }) , (;) )
  constexpr bool isOptional() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::isOptional, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCIvarDecl *) )
  getPropertyIvarDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getPropertyIvarDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getSourceRange, Xs...); }) , (;) )
  /// Get the default name of the synthesized ivar.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getDefaultSynthIvarName(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::getDefaultSynthIvarName, Xs..., Y0s...); }) , (;) )
  /// Lookup a property by name in the specified DeclContext.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyDecl *) )
  findPropertyDecl(IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::IdentifierInfo *)) propertyID, enum clang::ObjCPropertyQueryKind queryKind) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::findPropertyDecl, Xs..., Y0s..., Y1s..., queryKind); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyDecl *) )
  findPropertyDecl(ptrwrp<Y0> p0, ptrwrp<Y1> p1, enum clang::ObjCPropertyQueryKind p2) {
      return findPropertyDecl(p0.get(), p1.get(), p2);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyDecl, reflenums::clang__ObjCPropertyDecl::classofKind, Xs..., K); }) , (;) )
};

/// ObjCContainerDecl - Represents a container for method declarations.
/// Current sub-classes are ObjCInterfaceDecl, ObjCCategoryDecl,
/// ObjCProtocolDecl, and ObjCImplDecl.
///
M_template_rtpack(Xs)
struct clang::ObjCContainerDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)>, impl_offset_t<clang::DeclContext, 48 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCContainerDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCContainerDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  RANGE_REFLECTION(clang::ObjCContainerDecl, properties,
      constexpr auto properties() const ,
      (typename meta::clang::ObjCPropertyDecl *),
      (reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::properties, Xs...), () )
  RANGE_REFLECTION(clang::ObjCContainerDecl, instance_properties,
      constexpr auto instance_properties() const ,
      (typename meta::clang::ObjCPropertyDecl *),
      (reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::instance_properties, Xs...), () )
  RANGE_REFLECTION(clang::ObjCContainerDecl, class_properties,
      constexpr auto class_properties() const ,
      (typename meta::clang::ObjCPropertyDecl *),
      (reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::class_properties, Xs...), () )
  RANGE_REFLECTION(clang::ObjCContainerDecl, methods,
      constexpr auto methods() const ,
      (typename meta::clang::ObjCMethodDecl *),
      (reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::methods, Xs...), () )
  RANGE_REFLECTION(clang::ObjCContainerDecl, instance_methods,
      constexpr auto instance_methods() const ,
      (typename meta::clang::ObjCMethodDecl *),
      (reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::instance_methods, Xs...), () )
  RANGE_REFLECTION(clang::ObjCContainerDecl, class_methods,
      constexpr auto class_methods() const ,
      (typename meta::clang::ObjCMethodDecl *),
      (reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::class_methods, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getMethod(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel, bool isInstance, bool AllowHidden = false) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::getMethod, Xs..., Y0s..., isInstance, AllowHidden); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getInstanceMethod(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel, bool AllowHidden = false) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::getInstanceMethod, Xs..., Y0s..., AllowHidden); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getClassMethod(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel, bool AllowHidden = false) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::getClassMethod, Xs..., Y0s..., AllowHidden); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool HasUserDeclaredSetterMethod(IFMETA_ELSE((const clang::ObjCPropertyDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ObjCPropertyDecl *)) P) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::HasUserDeclaredSetterMethod, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool HasUserDeclaredSetterMethod(ptrwrp<Y0> p0) const {
      return HasUserDeclaredSetterMethod(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCIvarDecl *) )
  getIvarDecl(IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::IdentifierInfo *)) Id) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::getIvarDecl, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCIvarDecl *) )
  getIvarDecl(ptrwrp<Y0> p0) const {
      return getIvarDecl(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyDecl *) )
  FindPropertyDeclaration(IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::IdentifierInfo *)) PropertyId, enum clang::ObjCPropertyQueryKind QueryKind) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::FindPropertyDeclaration, Xs..., Y0s..., QueryKind); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyDecl *) )
  FindPropertyDeclaration(ptrwrp<Y0> p0, enum clang::ObjCPropertyQueryKind p1) const {
      return FindPropertyDeclaration(p0.get(), p1);
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAtStartLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::getAtStartLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getAtEndRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::getAtEndRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCContainerDecl, reflenums::clang__ObjCContainerDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents an ObjC class declaration.
///
/// For example:
///
/// \code
///   // MostPrimitive declares no super class (not particularly useful).
///   \@interface MostPrimitive
///     // no instance variables or methods.
///   \@end
///
///   // NSResponder inherits from NSObject & implements NSCoding (a protocol).
///   \@interface NSResponder : NSObject \<NSCoding>
///   { // instance variables are represented by ObjCIvarDecl.
///     id nextResponder; // nextResponder instance variable.
///   }
///   - (NSResponder *)nextResponder; // return a pointer to NSResponder.
///   - (void)mouseMoved:(NSEvent *)theEvent; // return void, takes a pointer
///   \@end                                    // to an NSEvent.
/// \endcode
///
///   Unlike C/C++, forward class declarations are accomplished with \@class.
///   Unlike C/C++, \@class allows for a list of classes to be forward declared.
///   Unlike C++, ObjC is a single-rooted class model. In Cocoa, classes
///   typically inherit from NSObject (an exception is NSProxy).
///
M_template_rtpack(Xs)
struct clang::ObjCInterfaceDecl::impl : impl_offset_t<clang::ObjCContainerDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCInterfaceDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCInterfaceDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getFirstDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getMostRecentDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCInterfaceDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) atLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::ObjCTypeParamList::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::ObjCTypeParamList *)) typeParamList, IFMETA_ELSE((const clang::ObjCInterfaceDecl::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::ObjCInterfaceDecl *)) PrevDecl, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::SourceLocation)) ClassLoc = {}, bool isInternal = false) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., isInternal); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCInterfaceDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, ptrwrp<Y3> p3, ptrwrp<Y4> p4, ptrwrp<Y5> p5, Y6 p6 = {}, bool p7 = false) {
      return Create(p0, p1.get(), p2, p3.get(), p4.get(), p5.get(), p6, p7);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCInterfaceDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// Retrieve the type parameters of this class.
  ///
  /// This function looks for a type parameter list for the given
  /// class; if the class has been declared (with \c \@class) but not
  /// defined (with \c \@interface), it will search for a declaration that
  /// has type parameters, skipping any declarations that do not.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCTypeParamList *) )
  getTypeParamList() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getTypeParamList, Xs...); }) , (;) )
  /// Retrieve the type parameters written on this particular declaration of
  /// the class.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCTypeParamList *) )
  getTypeParamListAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getTypeParamListAsWritten, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getSourceRange, Xs...); }) , (;) )
  /// Returns true if this interface decl contains at least one initializer
  /// marked with the 'objc_designated_initializer' attribute.
  constexpr bool hasDesignatedInitializers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::hasDesignatedInitializers, Xs...); }) , (;) )
  /// Returns true if this interface decl declares a designated initializer
  /// or it inherites one from its super class.
  constexpr bool declaresOrInheritsDesignatedInitializers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::declaresOrInheritsDesignatedInitializers, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCProtocolList &) )
  getReferencedProtocols() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getReferencedProtocols, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCImplementationDecl *) )
  getImplementation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getImplementation, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCategoryDecl *) )
  FindCategoryDeclaration(IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::IdentifierInfo *)) CategoryId) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::FindCategoryDeclaration, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCategoryDecl *) )
  FindCategoryDeclaration(ptrwrp<Y0> p0) const {
      return FindCategoryDeclaration(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getCategoryInstanceMethod(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getCategoryInstanceMethod, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getCategoryClassMethod(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getCategoryClassMethod, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getCategoryMethod(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel, bool isInstance) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getCategoryMethod, Xs..., Y0s..., isInstance); }) , (;) )
  RANGE_REFLECTION(clang::ObjCInterfaceDecl, protocols,
      constexpr auto protocols() const ,
      (typename meta::clang::ObjCProtocolDecl *const),
      (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::protocols, Xs...), () )
  RANGE_REFLECTION(clang::ObjCInterfaceDecl, protocol_locs,
      constexpr auto protocol_locs() const ,
      (const typename meta::clang::SourceLocation),
      (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::protocol_locs, Xs...), () )
  RANGE_REFLECTION(clang::ObjCInterfaceDecl, all_referenced_protocols,
      constexpr auto all_referenced_protocols() const ,
      (typename meta::clang::ObjCProtocolDecl *const),
      (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::all_referenced_protocols, Xs...), () )
  RANGE_REFLECTION(clang::ObjCInterfaceDecl, ivars,
      constexpr auto ivars() const ,
      (typename meta::clang::ObjCIvarDecl *),
      (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::ivars, Xs...), () )
  constexpr unsigned int ivar_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::ivar_size, Xs...); }) , (;) )
  constexpr bool ivar_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::ivar_empty, Xs...); }) , (;) )
  /// Produce a name to be used for class's metadata. It comes either via
  /// objc_runtime_name attribute or class name.
  constexpr const char * getObjCRuntimeNameAsString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getObjCRuntimeNameAsString, Xs...); }) , (;) )
  /// Returns true if the given selector is a designated initializer for the
  /// interface.
  ///
  /// If this declaration does not have methods marked as designated
  /// initializers then the interface inherits the designated initializers of
  /// its super class.
  ///
  /// \param InitMethod if non-null and the function returns true, it receives
  /// the method that was marked as a designated initializer.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr bool isDesignatedInitializer(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel, IFMETA_ELSE((const clang::ObjCMethodDecl::template impl</*ptrorref=*/1, Y1s...> * *), (const typename meta::clang::ObjCMethodDecl **)) InitMethod = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::isDesignatedInitializer, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr bool isDesignatedInitializer(Y0 p0, ptrwrp<Y1> p1 = {}) const {
      return isDesignatedInitializer(p0, p1.get());
  }), () )
  /// Determine whether this particular declaration of this class is
  /// actually also a definition.
  constexpr bool isThisDeclarationADefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::isThisDeclarationADefinition, Xs...); }) , (;) )
  /// Determine whether this class has been defined.
  constexpr bool hasDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::hasDefinition, Xs...); }) , (;) )
  /// Retrieve the definition of this class, or NULL if this class
  /// has been forward-declared (with \@class) but not yet defined (with
  /// \@interface).
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  getDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getDefinition, Xs...); }) , (;) )
  /// Retrieve the superclass type.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCObjectType *) )
  getSuperClassType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getSuperClassType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getSuperClassTInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getSuperClassTInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCInterfaceDecl *) )
  getSuperClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getSuperClass, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ObjCInterfaceDecl, visible_categories,
      constexpr auto visible_categories() const ,
      (typename meta::clang::ObjCCategoryDecl *),
      (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::visible_categories, Xs...), () )
  /// Determine whether the visible-categories list is empty.
  constexpr bool visible_categories_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::visible_categories_empty, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ObjCInterfaceDecl, known_categories,
      constexpr auto known_categories() const ,
      (typename meta::clang::ObjCCategoryDecl *),
      (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::known_categories, Xs...), () )
  /// Determine whether the known-categories list is empty.
  constexpr bool known_categories_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::known_categories_empty, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ObjCInterfaceDecl, visible_extensions,
      constexpr auto visible_extensions() const ,
      (typename meta::clang::ObjCCategoryDecl *),
      (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::visible_extensions, Xs...), () )
  /// Determine whether the visible-extensions list is empty.
  constexpr bool visible_extensions_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::visible_extensions_empty, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ObjCInterfaceDecl, known_extensions,
      constexpr auto known_extensions() const ,
      (typename meta::clang::ObjCCategoryDecl *),
      (reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::known_extensions, Xs...), () )
  /// Determine whether the known-extensions list is empty.
  constexpr bool known_extensions_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::known_extensions_empty, Xs...); }) , (;) )
  /// Retrieve the raw pointer to the start of the category/extension
  /// list.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCategoryDecl *) )
  getCategoryListRaw() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getCategoryListRaw, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyDecl *) )
  FindPropertyVisibleInPrimaryClass(IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::IdentifierInfo *)) PropertyId, enum clang::ObjCPropertyQueryKind QueryKind) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::FindPropertyVisibleInPrimaryClass, Xs..., Y0s..., QueryKind); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyDecl *) )
  FindPropertyVisibleInPrimaryClass(ptrwrp<Y0> p0, enum clang::ObjCPropertyQueryKind p1) const {
      return FindPropertyVisibleInPrimaryClass(p0.get(), p1);
  }), () )
  /// isSuperClassOf - Return true if this class is the specified class or is a
  /// super class of the specified interface class.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isSuperClassOf(IFMETA_ELSE((const clang::ObjCInterfaceDecl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::ObjCInterfaceDecl *)) I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::isSuperClassOf, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isSuperClassOf(ptrwrp<Y0> p0) const {
      return isSuperClassOf(p0.get());
  }), () )
  /// isArcWeakrefUnavailable - Checks for a class or one of its super classes
  /// to be incompatible with __weak references. Returns true if it is.
  constexpr bool isArcWeakrefUnavailable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::isArcWeakrefUnavailable, Xs...); }) , (;) )
  /// isObjCRequiresPropertyDefs - Checks that a class or one of its super
  /// classes must not be auto-synthesized. Returns class decl. if it must not
  /// be; 0, otherwise.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  isObjCRequiresPropertyDefs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::isObjCRequiresPropertyDefs, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  lookupMethod(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel, bool isInstance, bool shallowCategoryLookup = false, bool followSuper = true, IFMETA_ELSE((const clang::ObjCCategoryDecl::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::ObjCCategoryDecl *)) C = {}) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::lookupMethod, Xs..., Y0s..., isInstance, shallowCategoryLookup, followSuper, Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  lookupMethod(Y0 p0, bool p1, bool p2 = false, bool p3 = true, ptrwrp<Y1> p4 = {}) const {
      return lookupMethod(p0, p1, p2, p3, p4.get());
  }), () )
  /// Lookup an instance method for a given selector.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  lookupInstanceMethod(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::lookupInstanceMethod, Xs..., Y0s...); }) , (;) )
  /// Lookup a class method for a given selector.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  lookupClassMethod(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::lookupClassMethod, Xs..., Y0s...); }) , (;) )
  /// Lookup a method in the classes implementation hierarchy.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  lookupPrivateMethod(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::Selector &)) Sel, bool Instance = true) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::lookupPrivateMethod, Xs..., Y0s..., Instance); }) , (;) )
  /// Lookup a setter or getter in the class hierarchy,
  /// including in all categories except for category passed
  /// as argument.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  lookupPropertyAccessor(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (const typename meta::clang::Selector)) Sel, IFMETA_ELSE((const clang::ObjCCategoryDecl::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::ObjCCategoryDecl *)) Cat, bool IsClassProperty) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::lookupPropertyAccessor, Xs..., Y0s..., Y1s..., IsClassProperty); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  lookupPropertyAccessor(Y0 p0, ptrwrp<Y1> p1, bool p2) const {
      return lookupPropertyAccessor(p0, p1.get(), p2);
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndOfDefinitionLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getEndOfDefinitionLoc, Xs...); }) , (;) )
  /// Retrieve the starting location of the superclass.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getSuperClassLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getSuperClassLoc, Xs...); }) , (;) )
  /// isImplicitInterfaceDecl - check that this is an implicitly declared
  /// ObjCInterfaceDecl node. This is for legacy objective-c \@implementation
  /// declaration without an \@interface declaration.
  constexpr bool isImplicitInterfaceDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::isImplicitInterfaceDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getCanonicalDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Type *) )
  getTypeForDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::getTypeForDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void setTypeForDecl(IFMETA_ELSE((const clang::Type::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Type *)) TD) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::setTypeForDecl, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr void setTypeForDecl(ptrwrp<Y0> p0) const {
      return setTypeForDecl(p0.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCInterfaceDecl, reflenums::clang__ObjCInterfaceDecl::classofKind, Xs..., K); }) , (;) )
};

enum clang::ObjCIvarDecl::AccessControl : unsigned int {
  None,
  Private,
  Protected,
  Public,
  Package,
};

/// ObjCIvarDecl - Represents an ObjC instance variable. In general, ObjC
/// instance variables are identical to C. The only exception is Objective-C
/// supports C++ style access control. For example:
///
///   \@interface IvarExample : NSObject
///   {
///     id defaultToProtected;
///   \@public:
///     id canBePublic; // same as C++.
///   \@protected:
///     id canBeProtected; // same as C++.
///   \@package:
///     id canBePackage; // framework visibility (not available in C++).
///   }
///
M_template_rtpack(Xs)
struct clang::ObjCIvarDecl::impl : impl_offset_t<clang::FieldDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCIvarDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCIvarDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using AccessControl = enum refldetail::clang::ObjCIvarDecl::AccessControl;
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCIvarDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::ObjCContainerDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::ObjCContainerDecl *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) IdLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::TypeSourceInfo *)) TInfo, enum clang::ObjCIvarDecl::AccessControl ac, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y7s...> *), (typename meta::clang::Expr *)) BW = {}, bool synthesized = false) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarDecl, reflenums::clang__ObjCIvarDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., ac, Y7s..., synthesized); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCIvarDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, Y5 p5, ptrwrp<Y6> p6, enum clang::ObjCIvarDecl::AccessControl p7, ptrwrp<Y7> p8 = {}, bool p9 = false) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5, p6.get(), p7, p8.get(), p9);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCIvarDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarDecl, reflenums::clang__ObjCIvarDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  /// Return the class interface that this ivar is logically contained
  /// in; this is either the interface where the ivar was declared, or the
  /// interface the ivar is conceptually a part of in the case of synthesized
  /// ivars.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  getContainingInterface() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarDecl, reflenums::clang__ObjCIvarDecl::getContainingInterface, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCIvarDecl *) )
  getNextIvar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarDecl, reflenums::clang__ObjCIvarDecl::getNextIvar, Xs...); }) , (;) )
  constexpr enum clang::ObjCIvarDecl::AccessControl getAccessControl() const IFMETA_ELSE( ({    return (enum clang::ObjCIvarDecl::AccessControl)__reflect_prop(reflenums::RK_clang__ObjCIvarDecl, reflenums::clang__ObjCIvarDecl::getAccessControl, Xs...); }) , (;) )
  constexpr enum clang::ObjCIvarDecl::AccessControl getCanonicalAccessControl() const IFMETA_ELSE( ({    return (enum clang::ObjCIvarDecl::AccessControl)__reflect_prop(reflenums::RK_clang__ObjCIvarDecl, reflenums::clang__ObjCIvarDecl::getCanonicalAccessControl, Xs...); }) , (;) )
  constexpr bool getSynthesize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarDecl, reflenums::clang__ObjCIvarDecl::getSynthesize, Xs...); }) , (;) )
  /// Retrieve the type of this instance variable when viewed as a member of a
  /// specific object type.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getUsageType(IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::QualType)) objectType) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarDecl, reflenums::clang__ObjCIvarDecl::getUsageType, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarDecl, reflenums::clang__ObjCIvarDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarDecl, reflenums::clang__ObjCIvarDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents a field declaration created by an \@defs(...).
M_template_rtpack(Xs)
struct clang::ObjCAtDefsFieldDecl::impl : impl_offset_t<clang::FieldDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCAtDefsFieldDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCAtDefsFieldDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCAtDefsFieldDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) IdLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::Expr *)) BW) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtDefsFieldDecl, reflenums::clang__ObjCAtDefsFieldDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCAtDefsFieldDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, Y5 p5, ptrwrp<Y6> p6) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5, p6.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCAtDefsFieldDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtDefsFieldDecl, reflenums::clang__ObjCAtDefsFieldDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtDefsFieldDecl, reflenums::clang__ObjCAtDefsFieldDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtDefsFieldDecl, reflenums::clang__ObjCAtDefsFieldDecl::classofKind, Xs..., K); }) , (;) )
};

/// Represents an Objective-C protocol declaration.
///
/// Objective-C protocols declare a pure abstract type (i.e., no instance
/// variables are permitted).  Protocols originally drew inspiration from
/// C++ pure virtual functions (a C++ feature with nice semantics and lousy
/// syntax:-). Here is an example:
///
/// \code
/// \@protocol NSDraggingInfo <refproto1, refproto2>
/// - (NSWindow *)draggingDestinationWindow;
/// - (NSImage *)draggedImage;
/// \@end
/// \endcode
///
/// This says that NSDraggingInfo requires two methods and requires everything
/// that the two "referenced protocols" 'refproto1' and 'refproto2' require as
/// well.
///
/// \code
/// \@interface ImplementsNSDraggingInfo : NSObject \<NSDraggingInfo>
/// \@end
/// \endcode
///
/// ObjC protocols inspired Java interfaces. Unlike Java, ObjC classes and
/// protocols are in distinct namespaces. For example, Cocoa defines both
/// an NSObject protocol and class (which isn't allowed in Java). As a result,
/// protocols are referenced using angle brackets as follows:
///
/// id \<NSDraggingInfo> anyObjectThatImplementsNSDraggingInfo;
M_template_rtpack(Xs)
struct clang::ObjCProtocolDecl::impl : impl_offset_t<clang::ObjCContainerDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCProtocolDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCProtocolDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCProtocolDecl *) )
  getPreviousDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::getPreviousDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCProtocolDecl *) )
  getFirstDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::getFirstDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCProtocolDecl *) )
  getMostRecentDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::getMostRecentDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCProtocolDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) nameLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::SourceLocation)) atStartLoc, IFMETA_ELSE((const clang::ObjCProtocolDecl::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::ObjCProtocolDecl *)) PrevDecl) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCProtocolDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, ptrwrp<Y2> p2, Y3 p3, Y4 p4, ptrwrp<Y5> p5) {
      return Create(p0, p1.get(), p2.get(), p3, p4, p5.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCProtocolDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCProtocolList &) )
  getReferencedProtocols() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::getReferencedProtocols, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ObjCProtocolDecl, protocols,
      constexpr auto protocols() const ,
      (typename meta::clang::ObjCProtocolDecl *const),
      (reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::protocols, Xs...), () )
  RANGE_REFLECTION(clang::ObjCProtocolDecl, protocol_locs,
      constexpr auto protocol_locs() const ,
      (const typename meta::clang::SourceLocation),
      (reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::protocol_locs, Xs...), () )
  constexpr unsigned int protocol_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::protocol_size, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  lookupMethod(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel, bool isInstance) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::lookupMethod, Xs..., Y0s..., isInstance); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  lookupInstanceMethod(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::lookupInstanceMethod, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  lookupClassMethod(IFMETA_ELSE((const clang::Selector::template impl</*ptrorref=*/0, Y0s...>), (typename meta::clang::Selector)) Sel) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::lookupClassMethod, Xs..., Y0s...); }) , (;) )
  /// Determine whether this protocol has a definition.
  constexpr bool hasDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::hasDefinition, Xs...); }) , (;) )
  /// Retrieve the definition of this protocol, if any.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCProtocolDecl *) )
  getDefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::getDefinition, Xs...); }) , (;) )
  /// Determine whether this particular declaration is also the
  /// definition.
  constexpr bool isThisDeclarationADefinition() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::isThisDeclarationADefinition, Xs...); }) , (;) )
  /// Produce a name to be used for protocol's metadata. It comes either via
  /// objc_runtime_name attribute or protocol name.
  constexpr const char * getObjCRuntimeNameAsString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::getObjCRuntimeNameAsString, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCProtocolDecl *) )
  getCanonicalDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::getCanonicalDecl, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolDecl, reflenums::clang__ObjCProtocolDecl::classofKind, Xs..., K); }) , (;) )
};

/// ObjCCategoryDecl - Represents a category declaration. A category allows
/// you to add methods to an existing class (without subclassing or modifying
/// the original class interface or implementation:-). Categories don't allow
/// you to add instance data. The following example adds "myMethod" to all
/// NSView's within a process:
///
/// \@interface NSView (MyViewMethods)
/// - myMethod;
/// \@end
///
/// Categories also allow you to split the implementation of a class across
/// several files (a feature more naturally supported in C++).
///
/// Categories were originally inspired by dynamic languages such as Common
/// Lisp and Smalltalk.  More traditional class-based languages (C++, Java)
/// don't support this level of dynamism, which is both powerful and dangerous.
M_template_rtpack(Xs)
struct clang::ObjCCategoryDecl::impl : impl_offset_t<clang::ObjCContainerDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCCategoryDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCCategoryDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_c M_rtpack(Y8s) M_c M_rtpack(Y9s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCategoryDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) AtLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) ClassNameLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::SourceLocation)) CategoryNameLoc, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::ObjCInterfaceDecl::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::ObjCInterfaceDecl *)) IDecl, IFMETA_ELSE((const clang::ObjCTypeParamList::template impl</*ptrorref=*/1, Y7s...> *), (typename meta::clang::ObjCTypeParamList *)) typeParamList, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y8s...>), (typename meta::clang::SourceLocation)) IvarLBraceLoc = {}, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y9s...>), (typename meta::clang::SourceLocation)) IvarRBraceLoc = {}) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., Y7s..., Y8s..., Y9s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7, typename Y8, typename Y9>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCategoryDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, ptrwrp<Y5> p5, ptrwrp<Y6> p6, ptrwrp<Y7> p7, Y8 p8 = {}, Y9 p9 = {}) {
      return Create(p0, p1.get(), p2, p3, p4, p5.get(), p6.get(), p7.get(), p8, p9);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCategoryDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  getClassInterface() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::getClassInterface, Xs...); }) , (;) )
  /// Retrieve the type parameter list associated with this category or
  /// extension.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCTypeParamList *) )
  getTypeParamList() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::getTypeParamList, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCategoryImplDecl *) )
  getImplementation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::getImplementation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCProtocolList &) )
  getReferencedProtocols() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::getReferencedProtocols, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ObjCCategoryDecl, protocols,
      constexpr auto protocols() const ,
      (typename meta::clang::ObjCProtocolDecl *const),
      (reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::protocols, Xs...), () )
  constexpr unsigned int protocol_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::protocol_size, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ObjCCategoryDecl, protocol_locs,
      constexpr auto protocol_locs() const ,
      (const typename meta::clang::SourceLocation),
      (reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::protocol_locs, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCategoryDecl *) )
  getNextClassCategory() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::getNextClassCategory, Xs...); }) , (;) )
  /// Retrieve the pointer to the next stored category (or extension),
  /// which may be hidden.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCategoryDecl *) )
  getNextClassCategoryRaw() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::getNextClassCategoryRaw, Xs...); }) , (;) )
  constexpr bool IsClassExtension() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::IsClassExtension, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ObjCCategoryDecl, ivars,
      constexpr auto ivars() const ,
      (typename meta::clang::ObjCIvarDecl *),
      (reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::ivars, Xs...), () )
  constexpr unsigned int ivar_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::ivar_size, Xs...); }) , (;) )
  constexpr bool ivar_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::ivar_empty, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getCategoryNameLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::getCategoryNameLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getIvarLBraceLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::getIvarLBraceLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getIvarRBraceLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::getIvarRBraceLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryDecl, reflenums::clang__ObjCCategoryDecl::classofKind, Xs..., K); }) , (;) )
};

M_template_rtpack(Xs)
struct clang::ObjCImplDecl::impl : impl_offset_t<clang::ObjCContainerDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCImplDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCImplDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  getClassInterface() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplDecl, reflenums::clang__ObjCImplDecl::getClassInterface, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyImplDecl *) )
  FindPropertyImplDecl(IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::IdentifierInfo *)) propertyId, enum clang::ObjCPropertyQueryKind queryKind) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplDecl, reflenums::clang__ObjCImplDecl::FindPropertyImplDecl, Xs..., Y0s..., queryKind); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyImplDecl *) )
  FindPropertyImplDecl(ptrwrp<Y0> p0, enum clang::ObjCPropertyQueryKind p1) const {
      return FindPropertyImplDecl(p0.get(), p1);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyImplDecl *) )
  FindPropertyImplIvarDecl(IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::IdentifierInfo *)) ivarId) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplDecl, reflenums::clang__ObjCImplDecl::FindPropertyImplIvarDecl, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyImplDecl *) )
  FindPropertyImplIvarDecl(ptrwrp<Y0> p0) const {
      return FindPropertyImplIvarDecl(p0.get());
  }), () )
  RANGE_REFLECTION(clang::ObjCImplDecl, property_impls,
      constexpr auto property_impls() const ,
      (typename meta::clang::ObjCPropertyImplDecl *),
      (reflenums::RK_clang__ObjCImplDecl, reflenums::clang__ObjCImplDecl::property_impls, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplDecl, reflenums::clang__ObjCImplDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplDecl, reflenums::clang__ObjCImplDecl::classofKind, Xs..., K); }) , (;) )
};

/// ObjCCategoryImplDecl - An object of this class encapsulates a category
/// \@implementation declaration. If a category class has declaration of a
/// property, its implementation must be specified in the category's
/// \@implementation declaration. Example:
/// \@interface I \@end
/// \@interface I(CATEGORY)
///    \@property int p1, d1;
/// \@end
/// \@implementation I(CATEGORY)
///  \@dynamic p1,d1;
/// \@end
///
/// ObjCCategoryImplDecl
M_template_rtpack(Xs)
struct clang::ObjCCategoryImplDecl::impl : impl_offset_t<clang::ObjCImplDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCCategoryImplDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCCategoryImplDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCategoryImplDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::ObjCInterfaceDecl::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::ObjCInterfaceDecl *)) classInterface, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::SourceLocation)) nameLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::SourceLocation)) atStartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::SourceLocation)) CategoryNameLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryImplDecl, reflenums::clang__ObjCCategoryImplDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCategoryImplDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, ptrwrp<Y2> p2, ptrwrp<Y3> p3, Y4 p4, Y5 p5, Y6 p6) {
      return Create(p0, p1.get(), p2.get(), p3.get(), p4, p5, p6);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCategoryImplDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryImplDecl, reflenums::clang__ObjCCategoryImplDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCategoryDecl *) )
  getCategoryDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryImplDecl, reflenums::clang__ObjCCategoryImplDecl::getCategoryDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getCategoryNameLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryImplDecl, reflenums::clang__ObjCCategoryImplDecl::getCategoryNameLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryImplDecl, reflenums::clang__ObjCCategoryImplDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCategoryImplDecl, reflenums::clang__ObjCCategoryImplDecl::classofKind, Xs..., K); }) , (;) )
};

/// ObjCImplementationDecl - Represents a class definition - this is where
/// method definitions are specified. For example:
///
/// @code
/// \@implementation MyClass
/// - (void)myMethod { /* do something */ }
/// \@end
/// @endcode
///
/// In a non-fragile runtime, instance variables can appear in the class
/// interface, class extensions (nameless categories), and in the implementation
/// itself, as well as being synthesized as backing storage for properties.
///
/// In a fragile runtime, instance variables are specified in the class
/// interface, \em not in the implementation. Nevertheless (for legacy reasons),
/// we allow instance variables to be specified in the implementation. When
/// specified, they need to be \em identical to the interface.
M_template_rtpack(Xs)
struct clang::ObjCImplementationDecl::impl : impl_offset_t<clang::ObjCImplDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCImplementationDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCImplementationDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_c M_rtpack(Y8s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCImplementationDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::ObjCInterfaceDecl::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::ObjCInterfaceDecl *)) classInterface, IFMETA_ELSE((const clang::ObjCInterfaceDecl::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::ObjCInterfaceDecl *)) superDecl, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::SourceLocation)) nameLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::SourceLocation)) atStartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::SourceLocation)) superLoc = {}, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y7s...>), (typename meta::clang::SourceLocation)) IvarLBraceLoc = {}, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y8s...>), (typename meta::clang::SourceLocation)) IvarRBraceLoc = {}) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s..., Y6s..., Y7s..., Y8s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7, typename Y8>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCImplementationDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, ptrwrp<Y2> p2, ptrwrp<Y3> p3, Y4 p4, Y5 p5, Y6 p6 = {}, Y7 p7 = {}, Y8 p8 = {}) {
      return Create(p0, p1.get(), p2.get(), p3.get(), p4, p5, p6, p7, p8);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCImplementationDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  RANGE_REFLECTION(clang::ObjCImplementationDecl, inits,
      constexpr auto inits() const ,
      (typename meta::clang::CXXCtorInitializer *const),
      (reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::inits, Xs...), () )
  /// getNumArgs - Number of ivars which must be initialized.
  constexpr unsigned int getNumIvarInitializers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::getNumIvarInitializers, Xs...); }) , (;) )
  /// Do any of the ivars of this class (not counting its base classes)
  /// require construction other than zero-initialization?
  constexpr bool hasNonZeroConstructors() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::hasNonZeroConstructors, Xs...); }) , (;) )
  /// Do any of the ivars of this class (not counting its base classes)
  /// require non-trivial destruction?
  constexpr bool hasDestructors() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::hasDestructors, Xs...); }) , (;) )
  /// getIdentifier - Get the identifier that names the class
  /// interface associated with this implementation.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::getIdentifier, Xs...); }) , (;) )
  /// getName - Get the name of identifier for the class interface associated
  /// with this implementation as a StringRef.
  constexpr const char * getName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::getName, Xs...); }) , (;) )
  /// Get the name of the class associated with this interface.
  constexpr const char * getNameAsString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::getNameAsString, Xs...); }) , (;) )
  /// Produce a name to be used for class's metadata. It comes either via
  /// class's objc_runtime_name attribute or class name.
  constexpr const char * getObjCRuntimeNameAsString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::getObjCRuntimeNameAsString, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  getSuperClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::getSuperClass, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getSuperClassLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::getSuperClassLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getIvarLBraceLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::getIvarLBraceLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getIvarRBraceLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::getIvarRBraceLoc, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ObjCImplementationDecl, ivars,
      constexpr auto ivars() const ,
      (typename meta::clang::ObjCIvarDecl *),
      (reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::ivars, Xs...), () )
  constexpr unsigned int ivar_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::ivar_size, Xs...); }) , (;) )
  constexpr bool ivar_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::ivar_empty, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCImplementationDecl, reflenums::clang__ObjCImplementationDecl::classofKind, Xs..., K); }) , (;) )
};

/// ObjCCompatibleAliasDecl - Represents alias of a class. This alias is
/// declared as \@compatibility_alias alias class.
M_template_rtpack(Xs)
struct clang::ObjCCompatibleAliasDecl::impl : impl_offset_t<clang::NamedDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCCompatibleAliasDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCCompatibleAliasDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCompatibleAliasDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) L, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::ObjCInterfaceDecl::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::ObjCInterfaceDecl *)) aliasedClass) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCompatibleAliasDecl, reflenums::clang__ObjCCompatibleAliasDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCompatibleAliasDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, ptrwrp<Y3> p3, ptrwrp<Y4> p4) {
      return Create(p0, p1.get(), p2, p3.get(), p4.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCCompatibleAliasDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCompatibleAliasDecl, reflenums::clang__ObjCCompatibleAliasDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCInterfaceDecl *) )
  getClassInterface() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCompatibleAliasDecl, reflenums::clang__ObjCCompatibleAliasDecl::getClassInterface, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCompatibleAliasDecl, reflenums::clang__ObjCCompatibleAliasDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCCompatibleAliasDecl, reflenums::clang__ObjCCompatibleAliasDecl::classofKind, Xs..., K); }) , (;) )
};

enum clang::ObjCPropertyImplDecl::Kind : unsigned int {
  Synthesize,
  Dynamic,
};

/// ObjCPropertyImplDecl - Represents implementation declaration of a property
/// in a class or category implementation block. For example:
/// \@synthesize prop1 = ivar1;
///
M_template_rtpack(Xs)
struct clang::ObjCPropertyImplDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCPropertyImplDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCPropertyImplDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using Kind = enum refldetail::clang::ObjCPropertyImplDecl::Kind;
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyImplDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) atLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) L, IFMETA_ELSE((const clang::ObjCPropertyDecl::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::ObjCPropertyDecl *)) property, enum clang::ObjCPropertyImplDecl::Kind PK, IFMETA_ELSE((const clang::ObjCIvarDecl::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::ObjCIvarDecl *)) ivarDecl, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::SourceLocation)) ivarLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., PK, Y5s..., Y6s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyImplDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4, enum clang::ObjCPropertyImplDecl::Kind p5, ptrwrp<Y5> p6, Y6 p7) {
      return Create(p0, p1.get(), p2, p3, p4.get(), p5, p6.get(), p7);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyImplDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyDecl *) )
  getPropertyDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::getPropertyDecl, Xs...); }) , (;) )
  constexpr enum clang::ObjCPropertyImplDecl::Kind getPropertyImplementation() const IFMETA_ELSE( ({    return (enum clang::ObjCPropertyImplDecl::Kind)__reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::getPropertyImplementation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCIvarDecl *) )
  getPropertyIvarDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::getPropertyIvarDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getPropertyIvarDeclLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::getPropertyIvarDeclLoc, Xs...); }) , (;) )
  /// For \@synthesize, returns true if an ivar name was explicitly
  /// specified.
  ///
  /// \code
  /// \@synthesize int a = b; // true
  /// \@synthesize int a; // false
  /// \endcode
  constexpr bool isIvarNameSpecified() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::isIvarNameSpecified, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getGetterCXXConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::getGetterCXXConstructor, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSetterCXXAssignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::getSetterCXXAssignment, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyImplDecl, reflenums::clang__ObjCPropertyImplDecl::classofKind, Xs..., K); }) , (;) )
};

/// This represents '#pragma omp threadprivate ...' directive.
/// For example, in the following, both 'a' and 'A::b' are threadprivate:
///
/// \code
/// int a;
/// #pragma omp threadprivate(a)
/// struct A {
///   static int b;
/// #pragma omp threadprivate(b)
/// };
/// \endcode
///
M_template_rtpack(Xs)
struct clang::OMPThreadPrivateDecl::impl : impl_offset_t<clang::Decl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPThreadPrivateDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPThreadPrivateDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPThreadPrivateDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID, unsigned int N) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPThreadPrivateDecl, reflenums::clang__OMPThreadPrivateDecl::CreateDeserialized, Xs..., Y0s..., ID, N); }) , (;) )
  constexpr unsigned int varlist_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPThreadPrivateDecl, reflenums::clang__OMPThreadPrivateDecl::varlist_size, Xs...); }) , (;) )
  constexpr bool varlist_empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPThreadPrivateDecl, reflenums::clang__OMPThreadPrivateDecl::varlist_empty, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::OMPThreadPrivateDecl, varlists,
      constexpr auto varlists() const ,
      (const typename meta::clang::Expr *const),
      (reflenums::RK_clang__OMPThreadPrivateDecl, reflenums::clang__OMPThreadPrivateDecl::varlists, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPThreadPrivateDecl, reflenums::clang__OMPThreadPrivateDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPThreadPrivateDecl, reflenums::clang__OMPThreadPrivateDecl::classofKind, Xs..., K); }) , (;) )
};

enum clang::OMPDeclareReductionDecl::InitKind : unsigned int {
  CallInit,
  DirectInit,
  CopyInit,
};

/// This represents '#pragma omp declare reduction ...' directive.
/// For example, in the following, declared reduction 'foo' for types 'int' and
/// 'float':
///
/// \code
/// #pragma omp declare reduction (foo : int,float : omp_out += omp_in)
///                     initializer (omp_priv = 0)
/// \endcode
///
/// Here 'omp_out += omp_in' is a combiner and 'omp_priv = 0' is an initializer.
M_template_rtpack(Xs)
struct clang::OMPDeclareReductionDecl::impl : impl_offset_t<clang::ValueDecl, 0 M_c M_pack(Xs)>, impl_offset_t<clang::DeclContext, 56 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPDeclareReductionDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPDeclareReductionDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using InitKind = enum refldetail::clang::OMPDeclareReductionDecl::InitKind;
  /// Create declare reduction node.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPDeclareReductionDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) L, IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::DeclarationName)) Name, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::OMPDeclareReductionDecl::template impl</*ptrorref=*/1, Y5s...> *), (typename meta::clang::OMPDeclareReductionDecl *)) PrevDeclInScope) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDeclareReductionDecl, reflenums::clang__OMPDeclareReductionDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., Y5s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPDeclareReductionDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, ptrwrp<Y5> p5) {
      return Create(p0, p1.get(), p2, p3, p4, p5.get());
  }), () )
  /// Create deserialized declare reduction node.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPDeclareReductionDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDeclareReductionDecl, reflenums::clang__OMPDeclareReductionDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getCombiner() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDeclareReductionDecl, reflenums::clang__OMPDeclareReductionDecl::getCombiner, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDeclareReductionDecl, reflenums::clang__OMPDeclareReductionDecl::getInitializer, Xs...); }) , (;) )
  /// Get initializer kind.
  constexpr enum clang::OMPDeclareReductionDecl::InitKind getInitializerKind() const IFMETA_ELSE( ({    return (enum clang::OMPDeclareReductionDecl::InitKind)__reflect_prop(reflenums::RK_clang__OMPDeclareReductionDecl, reflenums::clang__OMPDeclareReductionDecl::getInitializerKind, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::OMPDeclareReductionDecl *) )
  getPrevDeclInScope() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDeclareReductionDecl, reflenums::clang__OMPDeclareReductionDecl::getPrevDeclInScope, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDeclareReductionDecl, reflenums::clang__OMPDeclareReductionDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDeclareReductionDecl, reflenums::clang__OMPDeclareReductionDecl::classofKind, Xs..., K); }) , (;) )
};

/// Pseudo declaration for capturing expressions. Also is used for capturing of
/// non-static data members in non-static member functions.
///
/// Clang supports capturing of variables only, but OpenMP 4.5 allows to
/// privatize non-static members of current class in non-static member
/// functions. This pseudo-declaration allows properly handle this kind of
/// capture by wrapping captured expression into a variable-like declaration.
M_template_rtpack(Xs)
struct clang::OMPCapturedExprDecl::impl : impl_offset_t<clang::VarDecl, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPCapturedExprDecl;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPCapturedExprDecl::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPCapturedExprDecl *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) DC, IFMETA_ELSE((const clang::IdentifierInfo::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::IdentifierInfo *)) Id, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::QualType)) T, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::SourceLocation)) StartLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPCapturedExprDecl, reflenums::clang__OMPCapturedExprDecl::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPCapturedExprDecl *) )
  Create(Y0 p0, ptrwrp<Y1> p1, ptrwrp<Y2> p2, Y3 p3, Y4 p4) {
      return Create(p0, p1.get(), p2.get(), p3, p4);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPCapturedExprDecl *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) C, unsigned int ID) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPCapturedExprDecl, reflenums::clang__OMPCapturedExprDecl::CreateDeserialized, Xs..., Y0s..., ID); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPCapturedExprDecl, reflenums::clang__OMPCapturedExprDecl::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Decl::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Decl *)) D) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPCapturedExprDecl, reflenums::clang__OMPCapturedExprDecl::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  static constexpr bool classofKind(enum clang::Decl::Kind K) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPCapturedExprDecl, reflenums::clang__OMPCapturedExprDecl::classofKind, Xs..., K); }) , (;) )
};

enum clang::ExpressionTrait : unsigned int {
  ET_IsLValueExpr,
  ET_IsRValueExpr,
};

/// A call to an overloaded operator written using operator
/// syntax.
///
/// Represents a call to an overloaded operator written using operator
/// syntax, e.g., "x + y" or "*p". While semantically equivalent to a
/// normal call, this AST node provides better information about the
/// syntactic representation of the call.
///
/// In a C++ template, this expression node kind will be used whenever
/// any of the arguments are type-dependent. In this case, the
/// function itself will be a (possibly empty) set of functions and
/// function templates that were found by name lookup at template
/// definition time.
M_template_rtpack(Xs)
struct clang::CXXOperatorCallExpr::impl : impl_offset_t<clang::CallExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXOperatorCallExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXOperatorCallExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Returns the kind of overloaded operator that this
  /// expression refers to.
  constexpr enum clang::OverloadedOperatorKind getOperator() const IFMETA_ELSE( ({    return (enum clang::OverloadedOperatorKind)__reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::getOperator, Xs...); }) , (;) )
  static constexpr bool isAssignmentOp(enum clang::OverloadedOperatorKind Opc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::isAssignmentOp, Xs..., Opc); }) , (;) )
  constexpr bool isAssignmentOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::isAssignmentOp1, Xs...); }) , (;) )
  /// Is this written as an infix binary operator?
  constexpr bool isInfixBinaryOp() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::isInfixBinaryOp, Xs...); }) , (;) )
  /// Returns the location of the operator symbol in the expression.
  ///
  /// When \c getOperator()==OO_Call, this is the location of the right
  /// parentheses; when \c getOperator()==OO_Subscript, this is the location
  /// of the right bracket.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOperatorLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::getOperatorLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::getExprLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FPOptions) )
  getFPFeatures() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::getFPFeatures, Xs...); }) , (;) )
  constexpr bool isFPContractableWithinStatement() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXOperatorCallExpr, reflenums::clang__CXXOperatorCallExpr::isFPContractableWithinStatement, Xs...); }) , (;) )
};

/// Represents a call to a member function that
/// may be written either with member call syntax (e.g., "obj.func()"
/// or "objptr->func()") or with normal function-call syntax
/// ("func()") within a member function that ends up calling a member
/// function. The callee in either case is a MemberExpr that contains
/// both the object argument and the member function, while the
/// arguments are the arguments within the parentheses (not including
/// the object argument).
M_template_rtpack(Xs)
struct clang::CXXMemberCallExpr::impl : impl_offset_t<clang::CallExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXMemberCallExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXMemberCallExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieves the implicit object argument for the member call.
  ///
  /// For example, in "x.f(5)", this returns the sub-expression "x".
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getImplicitObjectArgument() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMemberCallExpr, reflenums::clang__CXXMemberCallExpr::getImplicitObjectArgument, Xs...); }) , (;) )
  /// Retrieves the declaration of the called method.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXMethodDecl *) )
  getMethodDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMemberCallExpr, reflenums::clang__CXXMemberCallExpr::getMethodDecl, Xs...); }) , (;) )
  /// Retrieves the CXXRecordDecl for the underlying type of
  /// the implicit object argument.
  ///
  /// Note that this is may not be the same declaration as that of the class
  /// context of the CXXMethodDecl which this function is calling.
  /// FIXME: Returns 0 for member pointer call exprs.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getRecordDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMemberCallExpr, reflenums::clang__CXXMemberCallExpr::getRecordDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMemberCallExpr, reflenums::clang__CXXMemberCallExpr::getExprLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMemberCallExpr, reflenums::clang__CXXMemberCallExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a call to a CUDA kernel function.
M_template_rtpack(Xs)
struct clang::CUDAKernelCallExpr::impl : impl_offset_t<clang::CallExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CUDAKernelCallExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CUDAKernelCallExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CallExpr *) )
  getConfig() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CUDAKernelCallExpr, reflenums::clang__CUDAKernelCallExpr::getConfig, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CUDAKernelCallExpr, reflenums::clang__CUDAKernelCallExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Abstract class common to all of the C++ "named"/"keyword" casts.
///
/// This abstract class is inherited by all of the classes
/// representing "named" casts: CXXStaticCastExpr for \c static_cast,
/// CXXDynamicCastExpr for \c dynamic_cast, CXXReinterpretCastExpr for
/// reinterpret_cast, and CXXConstCastExpr for \c const_cast.
M_template_rtpack(Xs)
struct clang::CXXNamedCastExpr::impl : impl_offset_t<clang::ExplicitCastExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXNamedCastExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXNamedCastExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr const char * getCastName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNamedCastExpr, reflenums::clang__CXXNamedCastExpr::getCastName, Xs...); }) , (;) )
  /// Retrieve the location of the cast operator keyword, e.g.,
  /// \c static_cast.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOperatorLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNamedCastExpr, reflenums::clang__CXXNamedCastExpr::getOperatorLoc, Xs...); }) , (;) )
  /// Retrieve the location of the closing parenthesis.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNamedCastExpr, reflenums::clang__CXXNamedCastExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNamedCastExpr, reflenums::clang__CXXNamedCastExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNamedCastExpr, reflenums::clang__CXXNamedCastExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNamedCastExpr, reflenums::clang__CXXNamedCastExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNamedCastExpr, reflenums::clang__CXXNamedCastExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getAngleBrackets() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNamedCastExpr, reflenums::clang__CXXNamedCastExpr::getAngleBrackets, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNamedCastExpr, reflenums::clang__CXXNamedCastExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A C++ \c static_cast expression (C++ [expr.static.cast]).
///
/// This expression node represents a C++ static cast, e.g.,
/// \c static_cast<int>(1.0).
M_template_rtpack(Xs)
struct clang::CXXStaticCastExpr::impl : impl_offset_t<clang::CXXNamedCastExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXStaticCastExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXStaticCastExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXStaticCastExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, unsigned int PathSize) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXStaticCastExpr, reflenums::clang__CXXStaticCastExpr::CreateEmpty, Xs..., Y0s..., PathSize); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXStaticCastExpr, reflenums::clang__CXXStaticCastExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A C++ @c dynamic_cast expression (C++ [expr.dynamic.cast]).
///
/// This expression node represents a dynamic cast, e.g.,
/// \c dynamic_cast<Derived*>(BasePtr). Such a cast may perform a run-time
/// check to determine how to perform the type conversion.
M_template_rtpack(Xs)
struct clang::CXXDynamicCastExpr::impl : impl_offset_t<clang::CXXNamedCastExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXDynamicCastExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXDynamicCastExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDynamicCastExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, unsigned int pathSize) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDynamicCastExpr, reflenums::clang__CXXDynamicCastExpr::CreateEmpty, Xs..., Y0s..., pathSize); }) , (;) )
  constexpr bool isAlwaysNull() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDynamicCastExpr, reflenums::clang__CXXDynamicCastExpr::isAlwaysNull, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDynamicCastExpr, reflenums::clang__CXXDynamicCastExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A C++ @c reinterpret_cast expression (C++ [expr.reinterpret.cast]).
///
/// This expression node represents a reinterpret cast, e.g.,
/// @c reinterpret_cast<int>(VoidPtr).
///
/// A reinterpret_cast provides a differently-typed view of a value but
/// (in Clang, as in most C++ implementations) performs no actual work at
/// run time.
M_template_rtpack(Xs)
struct clang::CXXReinterpretCastExpr::impl : impl_offset_t<clang::CXXNamedCastExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXReinterpretCastExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXReinterpretCastExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXReinterpretCastExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, unsigned int pathSize) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXReinterpretCastExpr, reflenums::clang__CXXReinterpretCastExpr::CreateEmpty, Xs..., Y0s..., pathSize); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXReinterpretCastExpr, reflenums::clang__CXXReinterpretCastExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A C++ \c const_cast expression (C++ [expr.const.cast]).
///
/// This expression node represents a const cast, e.g.,
/// \c const_cast<char*>(PtrToConstChar).
///
/// A const_cast can remove type qualifiers but does not change the underlying
/// value.
M_template_rtpack(Xs)
struct clang::CXXConstCastExpr::impl : impl_offset_t<clang::CXXNamedCastExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXConstCastExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXConstCastExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConstCastExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::QualType)) T, enum clang::ExprValueKind VK, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::Expr *)) Op, IFMETA_ELSE((const clang::TypeSourceInfo::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::TypeSourceInfo *)) WrittenTy, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::SourceLocation)) L, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::SourceLocation)) RParenLoc, IFMETA_ELSE((const clang::SourceRange::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::SourceRange)) AngleBrackets) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstCastExpr, reflenums::clang__CXXConstCastExpr::Create, Xs..., Y0s..., Y1s..., VK, Y2s..., Y3s..., Y4s..., Y5s..., Y6s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConstCastExpr *) )
  Create(Y0 p0, Y1 p1, enum clang::ExprValueKind p2, ptrwrp<Y2> p3, ptrwrp<Y3> p4, Y4 p5, Y5 p6, Y6 p7) {
      return Create(p0, p1, p2, p3.get(), p4.get(), p5, p6, p7);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConstCastExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstCastExpr, reflenums::clang__CXXConstCastExpr::CreateEmpty, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstCastExpr, reflenums::clang__CXXConstCastExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// The kind of literal operator which is invoked.
enum clang::UserDefinedLiteral::LiteralOperatorKind : unsigned int {
  /// Raw form: operator "" X (const char *)
  LOK_Raw,
  /// Raw form: operator "" X<cs...> ()
  LOK_Template,
  /// operator "" X (unsigned long long)
  LOK_Integer,
  /// operator "" X (long double)
  LOK_Floating,
  /// operator "" X (const CharT *, size_t)
  LOK_String,
  /// operator "" X (CharT)
  LOK_Character,
};

/// A call to a literal operator (C++11 [over.literal])
/// written as a user-defined literal (C++11 [lit.ext]).
///
/// Represents a user-defined literal, e.g. "foo"_bar or 1.23_xyz. While this
/// is semantically equivalent to a normal call, this AST node provides better
/// information about the syntactic representation of the literal.
///
/// Since literal operators are never found by ADL and can only be declared at
/// namespace scope, a user-defined literal is never dependent.
M_template_rtpack(Xs)
struct clang::UserDefinedLiteral::impl : impl_offset_t<clang::CallExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UserDefinedLiteral;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UserDefinedLiteral::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using LiteralOperatorKind = enum refldetail::clang::UserDefinedLiteral::LiteralOperatorKind;
  /// Returns the kind of literal operator invocation
  /// which this expression represents.
  constexpr enum clang::UserDefinedLiteral::LiteralOperatorKind getLiteralOperatorKind() const IFMETA_ELSE( ({    return (enum clang::UserDefinedLiteral::LiteralOperatorKind)__reflect_prop(reflenums::RK_clang__UserDefinedLiteral, reflenums::clang__UserDefinedLiteral::getLiteralOperatorKind, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getCookedLiteral() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UserDefinedLiteral, reflenums::clang__UserDefinedLiteral::getCookedLiteral, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UserDefinedLiteral, reflenums::clang__UserDefinedLiteral::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UserDefinedLiteral, reflenums::clang__UserDefinedLiteral::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UserDefinedLiteral, reflenums::clang__UserDefinedLiteral::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UserDefinedLiteral, reflenums::clang__UserDefinedLiteral::getEndLoc, Xs...); }) , (;) )
  /// Returns the location of a ud-suffix in the expression.
  ///
  /// For a string literal, there may be multiple identical suffixes. This
  /// returns the first.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getUDSuffixLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UserDefinedLiteral, reflenums::clang__UserDefinedLiteral::getUDSuffixLoc, Xs...); }) , (;) )
  /// Returns the ud-suffix specified for this literal.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::IdentifierInfo *) )
  getUDSuffix() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UserDefinedLiteral, reflenums::clang__UserDefinedLiteral::getUDSuffix, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) S) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UserDefinedLiteral, reflenums::clang__UserDefinedLiteral::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A boolean literal, per ([C++ lex.bool] Boolean literals).
M_template_rtpack(Xs)
struct clang::CXXBoolLiteralExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXBoolLiteralExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXBoolLiteralExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool getValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBoolLiteralExpr, reflenums::clang__CXXBoolLiteralExpr::getValue, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBoolLiteralExpr, reflenums::clang__CXXBoolLiteralExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBoolLiteralExpr, reflenums::clang__CXXBoolLiteralExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBoolLiteralExpr, reflenums::clang__CXXBoolLiteralExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBoolLiteralExpr, reflenums::clang__CXXBoolLiteralExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBoolLiteralExpr, reflenums::clang__CXXBoolLiteralExpr::getLocation, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBoolLiteralExpr, reflenums::clang__CXXBoolLiteralExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// The null pointer literal (C++11 [lex.nullptr])
///
/// Introduced in C++11, the only literal of type \c nullptr_t is \c nullptr.
M_template_rtpack(Xs)
struct clang::CXXNullPtrLiteralExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXNullPtrLiteralExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXNullPtrLiteralExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNullPtrLiteralExpr, reflenums::clang__CXXNullPtrLiteralExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNullPtrLiteralExpr, reflenums::clang__CXXNullPtrLiteralExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNullPtrLiteralExpr, reflenums::clang__CXXNullPtrLiteralExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNullPtrLiteralExpr, reflenums::clang__CXXNullPtrLiteralExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNullPtrLiteralExpr, reflenums::clang__CXXNullPtrLiteralExpr::getLocation, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNullPtrLiteralExpr, reflenums::clang__CXXNullPtrLiteralExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Implicit construction of a std::initializer_list<T> object from an
/// array temporary within list-initialization (C++11 [dcl.init.list]p5).
M_template_rtpack(Xs)
struct clang::CXXStdInitializerListExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXStdInitializerListExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXStdInitializerListExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSubExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXStdInitializerListExpr, reflenums::clang__CXXStdInitializerListExpr::getSubExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXStdInitializerListExpr, reflenums::clang__CXXStdInitializerListExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXStdInitializerListExpr, reflenums::clang__CXXStdInitializerListExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXStdInitializerListExpr, reflenums::clang__CXXStdInitializerListExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXStdInitializerListExpr, reflenums::clang__CXXStdInitializerListExpr::getEndLoc, Xs...); }) , (;) )
  /// Retrieve the source range of the expression.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXStdInitializerListExpr, reflenums::clang__CXXStdInitializerListExpr::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) S) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXStdInitializerListExpr, reflenums::clang__CXXStdInitializerListExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A C++ \c typeid expression (C++ [expr.typeid]), which gets
/// the \c type_info that corresponds to the supplied type, or the (possibly
/// dynamic) type of the supplied expression.
///
/// This represents code like \c typeid(int) or \c typeid(*objPtr)
M_template_rtpack(Xs)
struct clang::CXXTypeidExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXTypeidExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXTypeidExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Determine whether this typeid has a type operand which is potentially
  /// evaluated, per C++11 [expr.typeid]p3.
  constexpr bool isPotentiallyEvaluated() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTypeidExpr, reflenums::clang__CXXTypeidExpr::isPotentiallyEvaluated, Xs...); }) , (;) )
  constexpr bool isTypeOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTypeidExpr, reflenums::clang__CXXTypeidExpr::isTypeOperand, Xs...); }) , (;) )
  /// Retrieves the type operand of this typeid() expression after
  /// various required adjustments (removing reference types, cv-qualifiers).
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTypeOperand(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTypeidExpr, reflenums::clang__CXXTypeidExpr::getTypeOperand, Xs..., Y0s...); }) , (;) )
  /// Retrieve source information for the type operand.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeOperandSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTypeidExpr, reflenums::clang__CXXTypeidExpr::getTypeOperandSourceInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getExprOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTypeidExpr, reflenums::clang__CXXTypeidExpr::getExprOperand, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTypeidExpr, reflenums::clang__CXXTypeidExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTypeidExpr, reflenums::clang__CXXTypeidExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTypeidExpr, reflenums::clang__CXXTypeidExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTypeidExpr, reflenums::clang__CXXTypeidExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTypeidExpr, reflenums::clang__CXXTypeidExpr::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTypeidExpr, reflenums::clang__CXXTypeidExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A member reference to an MSPropertyDecl.
///
/// This expression always has pseudo-object type, and therefore it is
/// typically not encountered in a fully-typechecked expression except
/// within the syntactic form of a PseudoObjectExpr.
M_template_rtpack(Xs)
struct clang::MSPropertyRefExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__MSPropertyRefExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::MSPropertyRefExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyRefExpr, reflenums::clang__MSPropertyRefExpr::getSourceRange, Xs...); }) , (;) )
  constexpr bool isImplicitAccess() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyRefExpr, reflenums::clang__MSPropertyRefExpr::isImplicitAccess, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyRefExpr, reflenums::clang__MSPropertyRefExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyRefExpr, reflenums::clang__MSPropertyRefExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyRefExpr, reflenums::clang__MSPropertyRefExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyRefExpr, reflenums::clang__MSPropertyRefExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyRefExpr, reflenums::clang__MSPropertyRefExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getBaseExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyRefExpr, reflenums::clang__MSPropertyRefExpr::getBaseExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::MSPropertyDecl *) )
  getPropertyDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyRefExpr, reflenums::clang__MSPropertyRefExpr::getPropertyDecl, Xs...); }) , (;) )
  constexpr bool isArrow() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyRefExpr, reflenums::clang__MSPropertyRefExpr::isArrow, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getMemberLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyRefExpr, reflenums::clang__MSPropertyRefExpr::getMemberLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertyRefExpr, reflenums::clang__MSPropertyRefExpr::getQualifierLoc, Xs...); }) , (;) )
};

/// MS property subscript expression.
/// MSVC supports 'property' attribute and allows to apply it to the
/// declaration of an empty array in a class or structure definition.
/// For example:
/// \code
/// __declspec(property(get=GetX, put=PutX)) int x[];
/// \endcode
/// The above statement indicates that x[] can be used with one or more array
/// indices. In this case, i=p->x[a][b] will be turned into i=p->GetX(a, b), and
/// p->x[a][b] = i will be turned into p->PutX(a, b, i).
/// This is a syntactic pseudo-object expression.
M_template_rtpack(Xs)
struct clang::MSPropertySubscriptExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__MSPropertySubscriptExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::MSPropertySubscriptExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertySubscriptExpr, reflenums::clang__MSPropertySubscriptExpr::getBase, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getIdx() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertySubscriptExpr, reflenums::clang__MSPropertySubscriptExpr::getIdx, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertySubscriptExpr, reflenums::clang__MSPropertySubscriptExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertySubscriptExpr, reflenums::clang__MSPropertySubscriptExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertySubscriptExpr, reflenums::clang__MSPropertySubscriptExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertySubscriptExpr, reflenums::clang__MSPropertySubscriptExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRBracketLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertySubscriptExpr, reflenums::clang__MSPropertySubscriptExpr::getRBracketLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertySubscriptExpr, reflenums::clang__MSPropertySubscriptExpr::getExprLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSPropertySubscriptExpr, reflenums::clang__MSPropertySubscriptExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A Microsoft C++ @c __uuidof expression, which gets
/// the _GUID that corresponds to the supplied type or expression.
///
/// This represents code like @c __uuidof(COMTYPE) or @c __uuidof(*comPtr)
M_template_rtpack(Xs)
struct clang::CXXUuidofExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXUuidofExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXUuidofExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isTypeOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUuidofExpr, reflenums::clang__CXXUuidofExpr::isTypeOperand, Xs...); }) , (;) )
  /// Retrieves the type operand of this __uuidof() expression after
  /// various required adjustments (removing reference types, cv-qualifiers).
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTypeOperand(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Context) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUuidofExpr, reflenums::clang__CXXUuidofExpr::getTypeOperand, Xs..., Y0s...); }) , (;) )
  /// Retrieve source information for the type operand.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeOperandSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUuidofExpr, reflenums::clang__CXXUuidofExpr::getTypeOperandSourceInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getExprOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUuidofExpr, reflenums::clang__CXXUuidofExpr::getExprOperand, Xs...); }) , (;) )
  constexpr const char * getUuidStr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUuidofExpr, reflenums::clang__CXXUuidofExpr::getUuidStr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUuidofExpr, reflenums::clang__CXXUuidofExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUuidofExpr, reflenums::clang__CXXUuidofExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUuidofExpr, reflenums::clang__CXXUuidofExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUuidofExpr, reflenums::clang__CXXUuidofExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUuidofExpr, reflenums::clang__CXXUuidofExpr::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUuidofExpr, reflenums::clang__CXXUuidofExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents the \c this expression in C++.
///
/// This is a pointer to the object on which the current member function is
/// executing (C++ [expr.prim]p3). Example:
///
/// \code
/// class Foo {
/// public:
///   void bar();
///   void test() { this->bar(); }
/// };
/// \endcode
M_template_rtpack(Xs)
struct clang::CXXThisExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXThisExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXThisExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThisExpr, reflenums::clang__CXXThisExpr::getLocation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThisExpr, reflenums::clang__CXXThisExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThisExpr, reflenums::clang__CXXThisExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThisExpr, reflenums::clang__CXXThisExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThisExpr, reflenums::clang__CXXThisExpr::getEndLoc, Xs...); }) , (;) )
  constexpr bool isImplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThisExpr, reflenums::clang__CXXThisExpr::isImplicit, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThisExpr, reflenums::clang__CXXThisExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A C++ throw-expression (C++ [except.throw]).
///
/// This handles 'throw' (for re-throwing the current exception) and
/// 'throw' assignment-expression.  When assignment-expression isn't
/// present, Op will be null.
M_template_rtpack(Xs)
struct clang::CXXThrowExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXThrowExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXThrowExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSubExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThrowExpr, reflenums::clang__CXXThrowExpr::getSubExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getThrowLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThrowExpr, reflenums::clang__CXXThrowExpr::getThrowLoc, Xs...); }) , (;) )
  /// Determines whether the variable thrown by this expression (if any!)
  /// is within the innermost try block.
  ///
  /// This information is required to determine whether the NRVO can apply to
  /// this variable.
  constexpr bool isThrownVariableInScope() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThrowExpr, reflenums::clang__CXXThrowExpr::isThrownVariableInScope, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThrowExpr, reflenums::clang__CXXThrowExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThrowExpr, reflenums::clang__CXXThrowExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThrowExpr, reflenums::clang__CXXThrowExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThrowExpr, reflenums::clang__CXXThrowExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXThrowExpr, reflenums::clang__CXXThrowExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A default argument (C++ [dcl.fct.default]).
///
/// This wraps up a function call argument that was created from the
/// corresponding parameter's default argument, when the call did not
/// explicitly supply arguments for all of the parameters.
M_template_rtpack(Xs)
struct clang::CXXDefaultArgExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXDefaultArgExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXDefaultArgExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDefaultArgExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) Loc, IFMETA_ELSE((const clang::ParmVarDecl::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::ParmVarDecl *)) Param) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultArgExpr, reflenums::clang__CXXDefaultArgExpr::Create, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDefaultArgExpr *) )
  Create(Y0 p0, Y1 p1, ptrwrp<Y2> p2) {
      return Create(p0, p1, p2.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ParmVarDecl *) )
  getParam() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultArgExpr, reflenums::clang__CXXDefaultArgExpr::getParam, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultArgExpr, reflenums::clang__CXXDefaultArgExpr::getExpr, Xs...); }) , (;) )
  /// Retrieve the location where this default argument was actually
  /// used.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getUsedLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultArgExpr, reflenums::clang__CXXDefaultArgExpr::getUsedLocation, Xs...); }) , (;) )
  /// Default argument expressions have no representation in the
  /// source, so they have an empty source range.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultArgExpr, reflenums::clang__CXXDefaultArgExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultArgExpr, reflenums::clang__CXXDefaultArgExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultArgExpr, reflenums::clang__CXXDefaultArgExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultArgExpr, reflenums::clang__CXXDefaultArgExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultArgExpr, reflenums::clang__CXXDefaultArgExpr::getExprLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultArgExpr, reflenums::clang__CXXDefaultArgExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A use of a default initializer in a constructor or in aggregate
/// initialization.
///
/// This wraps a use of a C++ default initializer (technically,
/// a brace-or-equal-initializer for a non-static data member) when it
/// is implicitly used in a mem-initializer-list in a constructor
/// (C++11 [class.base.init]p8) or in aggregate initialization
/// (C++1y [dcl.init.aggr]p7).
M_template_rtpack(Xs)
struct clang::CXXDefaultInitExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXDefaultInitExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXDefaultInitExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// \p Field is the non-static data member whose default initializer is used
  /// by this expression.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDefaultInitExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) Loc, IFMETA_ELSE((const clang::FieldDecl::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::FieldDecl *)) Field) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultInitExpr, reflenums::clang__CXXDefaultInitExpr::Create, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDefaultInitExpr *) )
  Create(Y0 p0, Y1 p1, ptrwrp<Y2> p2) {
      return Create(p0, p1, p2.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::FieldDecl *) )
  getField() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultInitExpr, reflenums::clang__CXXDefaultInitExpr::getField, Xs...); }) , (;) )
  /// Get the initialization expression that will be used.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultInitExpr, reflenums::clang__CXXDefaultInitExpr::getExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultInitExpr, reflenums::clang__CXXDefaultInitExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultInitExpr, reflenums::clang__CXXDefaultInitExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultInitExpr, reflenums::clang__CXXDefaultInitExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultInitExpr, reflenums::clang__CXXDefaultInitExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDefaultInitExpr, reflenums::clang__CXXDefaultInitExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a C++ temporary.
M_template_rtpack(Xs)
struct clang::CXXTemporary::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXTemporary;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXTemporary::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXTemporary *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::CXXDestructorDecl::template impl</*ptrorref=*/1, Y1s...> *), (const typename meta::clang::CXXDestructorDecl *)) Destructor) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTemporary, reflenums::clang__CXXTemporary::Create, Xs..., Y0s..., Y1s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXTemporary *) )
  Create(Y0 p0, ptrwrp<Y1> p1) {
      return Create(p0, p1.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXDestructorDecl *) )
  getDestructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTemporary, reflenums::clang__CXXTemporary::getDestructor, Xs...); }) , (;) )
};

/// Represents binding an expression to a temporary.
///
/// This ensures the destructor is called for the temporary. It should only be
/// needed for non-POD, non-trivially destructable class types. For example:
///
/// \code
///   struct S {
///     S() { }  // User defined constructor makes S non-POD.
///     ~S() { } // User defined destructor makes it non-trivial.
///   };
///   void test() {
///     const S &s_ref = S(); // Requires a CXXBindTemporaryExpr.
///   }
/// \endcode
M_template_rtpack(Xs)
struct clang::CXXBindTemporaryExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXBindTemporaryExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXBindTemporaryExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXBindTemporaryExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::CXXTemporary::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::CXXTemporary *)) Temp, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::Expr *)) SubExpr) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBindTemporaryExpr, reflenums::clang__CXXBindTemporaryExpr::Create, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXBindTemporaryExpr *) )
  Create(Y0 p0, ptrwrp<Y1> p1, ptrwrp<Y2> p2) {
      return Create(p0, p1.get(), p2.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXTemporary *) )
  getTemporary() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBindTemporaryExpr, reflenums::clang__CXXBindTemporaryExpr::getTemporary, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSubExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBindTemporaryExpr, reflenums::clang__CXXBindTemporaryExpr::getSubExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBindTemporaryExpr, reflenums::clang__CXXBindTemporaryExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBindTemporaryExpr, reflenums::clang__CXXBindTemporaryExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBindTemporaryExpr, reflenums::clang__CXXBindTemporaryExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBindTemporaryExpr, reflenums::clang__CXXBindTemporaryExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXBindTemporaryExpr, reflenums::clang__CXXBindTemporaryExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

enum clang::CXXConstructExpr::ConstructionKind : unsigned int {
  CK_Complete,
  CK_NonVirtualBase,
  CK_VirtualBase,
  CK_Delegating,
};

/// Represents a call to a C++ constructor.
M_template_rtpack(Xs)
struct clang::CXXConstructExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXConstructExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXConstructExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using ConstructionKind = enum refldetail::clang::CXXConstructExpr::ConstructionKind;
  /// Get the constructor that this expression will (ultimately) call.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConstructorDecl *) )
  getConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::getConstructor, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::getLocation, Xs...); }) , (;) )
  /// Whether this construction is elidable.
  constexpr bool isElidable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::isElidable, Xs...); }) , (;) )
  /// Whether the referred constructor was resolved from
  /// an overloaded set having size greater than 1.
  constexpr bool hadMultipleCandidates() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::hadMultipleCandidates, Xs...); }) , (;) )
  /// Whether this constructor call was written as list-initialization.
  constexpr bool isListInitialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::isListInitialization, Xs...); }) , (;) )
  /// Whether this constructor call was written as list-initialization,
  /// but was interpreted as forming a std::initializer_list<T> from the list
  /// and passing that as a single constructor argument.
  /// See C++11 [over.match.list]p1 bullet 1.
  constexpr bool isStdInitListInitialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::isStdInitListInitialization, Xs...); }) , (;) )
  /// Whether this construction first requires
  /// zero-initialization before the initializer is called.
  constexpr bool requiresZeroInitialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::requiresZeroInitialization, Xs...); }) , (;) )
  /// Determine whether this constructor is actually constructing
  /// a base class (rather than a complete object).
  constexpr enum clang::CXXConstructExpr::ConstructionKind getConstructionKind() const IFMETA_ELSE( ({    return (enum clang::CXXConstructExpr::ConstructionKind)__reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::getConstructionKind, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CXXConstructExpr, arguments,
      constexpr auto arguments() const ,
      (const typename meta::clang::Expr *const),
      (reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::arguments, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *const *) )
  getArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::getArgs, Xs...); }) , (;) )
  constexpr unsigned int getNumArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::getNumArgs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getArg(unsigned int Arg) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::getArg, Xs..., Arg); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getParenOrBraceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::getParenOrBraceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstructExpr, reflenums::clang__CXXConstructExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a call to an inherited base class constructor from an
/// inheriting constructor. This call implicitly forwards the arguments from
/// the enclosing context (an inheriting constructor) to the specified inherited
/// base class constructor.
M_template_rtpack(Xs)
struct clang::CXXInheritedCtorInitExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXInheritedCtorInitExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXInheritedCtorInitExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Get the constructor that this expression will call.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXConstructorDecl *) )
  getConstructor() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXInheritedCtorInitExpr, reflenums::clang__CXXInheritedCtorInitExpr::getConstructor, Xs...); }) , (;) )
  /// Determine whether this constructor is actually constructing
  /// a base class (rather than a complete object).
  constexpr bool constructsVBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXInheritedCtorInitExpr, reflenums::clang__CXXInheritedCtorInitExpr::constructsVBase, Xs...); }) , (;) )
  constexpr enum clang::CXXConstructExpr::ConstructionKind getConstructionKind() const IFMETA_ELSE( ({    return (enum clang::CXXConstructExpr::ConstructionKind)__reflect_prop(reflenums::RK_clang__CXXInheritedCtorInitExpr, reflenums::clang__CXXInheritedCtorInitExpr::getConstructionKind, Xs...); }) , (;) )
  /// Determine whether the inherited constructor is inherited from a
  /// virtual base of the object we construct. If so, we are not responsible
  /// for calling the inherited constructor (the complete object constructor
  /// does that), and so we don't need to pass any arguments.
  constexpr bool inheritedFromVBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXInheritedCtorInitExpr, reflenums::clang__CXXInheritedCtorInitExpr::inheritedFromVBase, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXInheritedCtorInitExpr, reflenums::clang__CXXInheritedCtorInitExpr::getLocation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXInheritedCtorInitExpr, reflenums::clang__CXXInheritedCtorInitExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXInheritedCtorInitExpr, reflenums::clang__CXXInheritedCtorInitExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXInheritedCtorInitExpr, reflenums::clang__CXXInheritedCtorInitExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXInheritedCtorInitExpr, reflenums::clang__CXXInheritedCtorInitExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXInheritedCtorInitExpr, reflenums::clang__CXXInheritedCtorInitExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents an explicit C++ type conversion that uses "functional"
/// notation (C++ [expr.type.conv]).
///
/// Example:
/// \code
///   x = int(0.5);
/// \endcode
M_template_rtpack(Xs)
struct clang::CXXFunctionalCastExpr::impl : impl_offset_t<clang::ExplicitCastExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXFunctionalCastExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXFunctionalCastExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXFunctionalCastExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, unsigned int PathSize) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFunctionalCastExpr, reflenums::clang__CXXFunctionalCastExpr::CreateEmpty, Xs..., Y0s..., PathSize); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFunctionalCastExpr, reflenums::clang__CXXFunctionalCastExpr::getLParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFunctionalCastExpr, reflenums::clang__CXXFunctionalCastExpr::getRParenLoc, Xs...); }) , (;) )
  /// Determine whether this expression models list-initialization.
  constexpr bool isListInitialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFunctionalCastExpr, reflenums::clang__CXXFunctionalCastExpr::isListInitialization, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFunctionalCastExpr, reflenums::clang__CXXFunctionalCastExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFunctionalCastExpr, reflenums::clang__CXXFunctionalCastExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFunctionalCastExpr, reflenums::clang__CXXFunctionalCastExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFunctionalCastExpr, reflenums::clang__CXXFunctionalCastExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFunctionalCastExpr, reflenums::clang__CXXFunctionalCastExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a C++ functional cast expression that builds a
/// temporary object.
///
/// This expression type represents a C++ "functional" cast
/// (C++[expr.type.conv]) with N != 1 arguments that invokes a
/// constructor to build a temporary object. With N == 1 arguments the
/// functional cast expression will be represented by CXXFunctionalCastExpr.
/// Example:
/// \code
/// struct X { X(int, float); }
///
/// X create_X() {
///   return X(1, 3.14f); // creates a CXXTemporaryObjectExpr
/// };
/// \endcode
M_template_rtpack(Xs)
struct clang::CXXTemporaryObjectExpr::impl : impl_offset_t<clang::CXXConstructExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXTemporaryObjectExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXTemporaryObjectExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTemporaryObjectExpr, reflenums::clang__CXXTemporaryObjectExpr::getTypeSourceInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTemporaryObjectExpr, reflenums::clang__CXXTemporaryObjectExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTemporaryObjectExpr, reflenums::clang__CXXTemporaryObjectExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTemporaryObjectExpr, reflenums::clang__CXXTemporaryObjectExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTemporaryObjectExpr, reflenums::clang__CXXTemporaryObjectExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTemporaryObjectExpr, reflenums::clang__CXXTemporaryObjectExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A C++ lambda expression, which produces a function object
/// (of unspecified type) that can be invoked later.
///
/// Example:
/// \code
/// void low_pass_filter(std::vector<double> &values, double cutoff) {
///   values.erase(std::remove_if(values.begin(), values.end(),
///                               [=](double value) { return value > cutoff; });
/// }
/// \endcode
///
/// C++11 lambda expressions can capture local variables, either by copying
/// the values of those local variables at the time the function
/// object is constructed (not when it is called!) or by holding a
/// reference to the local variable. These captures can occur either
/// implicitly or can be written explicitly between the square
/// brackets ([...]) that start the lambda expression.
///
/// C++1y introduces a new form of "capture" called an init-capture that
/// includes an initializing expression (rather than capturing a variable),
/// and which can never occur implicitly.
M_template_rtpack(Xs)
struct clang::LambdaExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__LambdaExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::LambdaExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Construct a new lambda expression that will be deserialized from
  /// an external source.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::LambdaExpr *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumCaptures) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::CreateDeserialized, Xs..., Y0s..., NumCaptures); }) , (;) )
  /// Determine the default capture kind for this lambda.
  constexpr enum clang::LambdaCaptureDefault getCaptureDefault() const IFMETA_ELSE( ({    return (enum clang::LambdaCaptureDefault)__reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::getCaptureDefault, Xs...); }) , (;) )
  /// Retrieve the location of this lambda's capture-default, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getCaptureDefaultLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::getCaptureDefaultLoc, Xs...); }) , (;) )
  /// Determine whether one of this lambda's captures is an init-capture.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool isInitCapture(IFMETA_ELSE((const clang::LambdaCapture::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::LambdaCapture *)) Capture) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::isInitCapture, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  constexpr bool isInitCapture(ptrwrp<Y0> p0) const {
      return isInitCapture(p0.get());
  }), () )
  /// Retrieve this lambda's captures.
  RANGE_REFLECTION(clang::LambdaExpr, captures,
      constexpr auto captures() const ,
      (const typename meta::clang::LambdaCapture),
      (reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::captures, Xs...), () )
  /// Determine the number of captures in this lambda.
  constexpr unsigned int capture_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::capture_size, Xs...); }) , (;) )
  /// Retrieve this lambda's explicit captures.
  RANGE_REFLECTION(clang::LambdaExpr, explicit_captures,
      constexpr auto explicit_captures() const ,
      (const typename meta::clang::LambdaCapture),
      (reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::explicit_captures, Xs...), () )
  /// Retrieve this lambda's implicit captures.
  RANGE_REFLECTION(clang::LambdaExpr, implicit_captures,
      constexpr auto implicit_captures() const ,
      (const typename meta::clang::LambdaCapture),
      (reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::implicit_captures, Xs...), () )
  /// Retrieve the initialization expressions for this lambda's captures.
  RANGE_REFLECTION(clang::LambdaExpr, capture_inits,
      constexpr auto capture_inits() const ,
      (typename meta::clang::Expr *const),
      (reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::capture_inits, Xs...), () )
  /// Retrieve the source range covering the lambda introducer,
  /// which contains the explicit capture list surrounded by square
  /// brackets ([...]).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getIntroducerRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::getIntroducerRange, Xs...); }) , (;) )
  /// Retrieve the class that corresponds to the lambda.
  ///
  /// This is the "closure type" (C++1y [expr.prim.lambda]), and stores the
  /// captures in its fields and provides the various operations permitted
  /// on a lambda (copying, calling).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getLambdaClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::getLambdaClass, Xs...); }) , (;) )
  /// Retrieve the function call operator associated with this
  /// lambda expression.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXMethodDecl *) )
  getCallOperator() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::getCallOperator, Xs...); }) , (;) )
  /// If this is a generic lambda expression, retrieve the template
  /// parameter list associated with it, or else return null.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateParameterList *) )
  getTemplateParameterList() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::getTemplateParameterList, Xs...); }) , (;) )
  /// Whether this is a generic lambda.
  constexpr bool isGenericLambda() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::isGenericLambda, Xs...); }) , (;) )
  /// Retrieve the body of the lambda.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CompoundStmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::getBody, Xs...); }) , (;) )
  /// Determine whether the lambda is mutable, meaning that any
  /// captures values can be modified.
  constexpr bool isMutable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::isMutable, Xs...); }) , (;) )
  /// Determine whether this lambda has an explicit parameter
  /// list vs. an implicit (empty) parameter list.
  constexpr bool hasExplicitParameters() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::hasExplicitParameters, Xs...); }) , (;) )
  /// Whether this lambda had its result type explicitly specified.
  constexpr bool hasExplicitResultType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::hasExplicitResultType, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__LambdaExpr, reflenums::clang__LambdaExpr::getEndLoc, Xs...); }) , (;) )
};

/// An expression "T()" which creates a value-initialized rvalue of type
/// T, which is a non-class type.  See (C++98 [5.2.3p2]).
M_template_rtpack(Xs)
struct clang::CXXScalarValueInitExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXScalarValueInitExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXScalarValueInitExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXScalarValueInitExpr, reflenums::clang__CXXScalarValueInitExpr::getTypeSourceInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXScalarValueInitExpr, reflenums::clang__CXXScalarValueInitExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXScalarValueInitExpr, reflenums::clang__CXXScalarValueInitExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXScalarValueInitExpr, reflenums::clang__CXXScalarValueInitExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXScalarValueInitExpr, reflenums::clang__CXXScalarValueInitExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXScalarValueInitExpr, reflenums::clang__CXXScalarValueInitExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXScalarValueInitExpr, reflenums::clang__CXXScalarValueInitExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

enum clang::CXXNewExpr::InitializationStyle : unsigned int {
  /// New-expression has no initializer as written.
  NoInit,
  /// New-expression has a C++98 paren-delimited initializer.
  CallInit,
  /// New-expression has a C++11 list-initializer.
  ListInit,
};

/// Represents a new-expression for memory allocation and constructor
/// calls, e.g: "new CXXNewExpr(foo)".
M_template_rtpack(Xs)
struct clang::CXXNewExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXNewExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXNewExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using InitializationStyle = enum refldetail::clang::CXXNewExpr::InitializationStyle;
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAllocatedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getAllocatedType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getAllocatedTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getAllocatedTypeSourceInfo, Xs...); }) , (;) )
  /// True if the allocation result needs to be null-checked.
  ///
  /// C++11 [expr.new]p13:
  ///   If the allocation function returns null, initialization shall
  ///   not be done, the deallocation function shall not be called,
  ///   and the value of the new-expression shall be null.
  ///
  /// C++ DR1748:
  ///   If the allocation function is a reserved placement allocation
  ///   function that returns null, the behavior is undefined.
  ///
  /// An allocation function is not allowed to return null unless it
  /// has a non-throwing exception-specification.  The '03 rule is
  /// identical except that the definition of a non-throwing
  /// exception specification is just "is it throw()?".
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr bool shouldNullCheckAllocation(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::shouldNullCheckAllocation, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  getOperatorNew() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getOperatorNew, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  getOperatorDelete() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getOperatorDelete, Xs...); }) , (;) )
  constexpr bool isArray() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::isArray, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getArraySize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getArraySize, Xs...); }) , (;) )
  constexpr unsigned int getNumPlacementArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getNumPlacementArgs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getPlacementArg(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getPlacementArg, Xs..., i); }) , (;) )
  constexpr bool isParenTypeId() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::isParenTypeId, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getTypeIdParens() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getTypeIdParens, Xs...); }) , (;) )
  constexpr bool isGlobalNew() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::isGlobalNew, Xs...); }) , (;) )
  /// Whether this new-expression has any initializer at all.
  constexpr bool hasInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::hasInitializer, Xs...); }) , (;) )
  /// The kind of initializer this new-expression has.
  constexpr enum clang::CXXNewExpr::InitializationStyle getInitializationStyle() const IFMETA_ELSE( ({    return (enum clang::CXXNewExpr::InitializationStyle)__reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getInitializationStyle, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getInitializer() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getInitializer, Xs...); }) , (;) )
  /// Returns the CXXConstructExpr from this new-expression, or null.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXConstructExpr *) )
  getConstructExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getConstructExpr, Xs...); }) , (;) )
  /// Indicates whether the required alignment should be implicitly passed to
  /// the allocation function.
  constexpr bool passAlignment() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::passAlignment, Xs...); }) , (;) )
  /// Answers whether the usual array deallocation function for the
  /// allocated type expects the size of the allocation as a
  /// parameter.
  constexpr bool doesUsualArrayDeleteWantSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::doesUsualArrayDeleteWantSize, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CXXNewExpr, placement_arguments,
      constexpr auto placement_arguments() const ,
      (const typename meta::clang::Expr *const),
      (reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::placement_arguments, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getStartLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getStartLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getDirectInitRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getDirectInitRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getSourceRange, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::getLocEnd, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNewExpr, reflenums::clang__CXXNewExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a \c delete expression for memory deallocation and
/// destructor calls, e.g. "delete[] pArray".
M_template_rtpack(Xs)
struct clang::CXXDeleteExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXDeleteExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXDeleteExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isGlobalDelete() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeleteExpr, reflenums::clang__CXXDeleteExpr::isGlobalDelete, Xs...); }) , (;) )
  constexpr bool isArrayForm() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeleteExpr, reflenums::clang__CXXDeleteExpr::isArrayForm, Xs...); }) , (;) )
  constexpr bool isArrayFormAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeleteExpr, reflenums::clang__CXXDeleteExpr::isArrayFormAsWritten, Xs...); }) , (;) )
  /// Answers whether the usual array deallocation function for the
  /// allocated type expects the size of the allocation as a
  /// parameter.  This can be true even if the actual deallocation
  /// function that we're using doesn't want a size.
  constexpr bool doesUsualArrayDeleteWantSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeleteExpr, reflenums::clang__CXXDeleteExpr::doesUsualArrayDeleteWantSize, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionDecl *) )
  getOperatorDelete() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeleteExpr, reflenums::clang__CXXDeleteExpr::getOperatorDelete, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getArgument() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeleteExpr, reflenums::clang__CXXDeleteExpr::getArgument, Xs...); }) , (;) )
  /// Retrieve the type being destroyed.
  ///
  /// If the type being destroyed is a dependent type which may or may not
  /// be a pointer, return an invalid type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDestroyedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeleteExpr, reflenums::clang__CXXDeleteExpr::getDestroyedType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeleteExpr, reflenums::clang__CXXDeleteExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeleteExpr, reflenums::clang__CXXDeleteExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeleteExpr, reflenums::clang__CXXDeleteExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeleteExpr, reflenums::clang__CXXDeleteExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDeleteExpr, reflenums::clang__CXXDeleteExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a C++ pseudo-destructor (C++ [expr.pseudo]).
///
/// A pseudo-destructor is an expression that looks like a member access to a
/// destructor of a scalar type, except that scalar types don't have
/// destructors. For example:
///
/// \code
/// typedef int T;
/// void f(int *p) {
///   p->T::~T();
/// }
/// \endcode
///
/// Pseudo-destructors typically occur when instantiating templates such as:
///
/// \code
/// template<typename T>
/// void destroy(T* ptr) {
///   ptr->T::~T();
/// }
/// \endcode
///
/// for scalar types. A pseudo-destructor expression has no run-time semantics
/// beyond evaluating the base expression.
M_template_rtpack(Xs)
struct clang::CXXPseudoDestructorExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXPseudoDestructorExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXPseudoDestructorExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getBase, Xs...); }) , (;) )
  /// Determines whether this member expression actually had
  /// a C++ nested-name-specifier prior to the name of the member, e.g.,
  /// x->Base::foo.
  constexpr bool hasQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::hasQualifier, Xs...); }) , (;) )
  /// Retrieves the nested-name-specifier that qualifies the type name,
  /// with source-location information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getQualifierLoc, Xs...); }) , (;) )
  /// If the member name was qualified, retrieves the
  /// nested-name-specifier that precedes the member name. Otherwise, returns
  /// null.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getQualifier, Xs...); }) , (;) )
  /// Determine whether this pseudo-destructor expression was written
  /// using an '->' (otherwise, it used a '.').
  constexpr bool isArrow() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::isArrow, Xs...); }) , (;) )
  /// Retrieve the location of the '.' or '->' operator.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOperatorLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getOperatorLoc, Xs...); }) , (;) )
  /// Retrieve the scope type in a qualified pseudo-destructor
  /// expression.
  ///
  /// Pseudo-destructor expressions can have extra qualification within them
  /// that is not part of the nested-name-specifier, e.g., \c p->T::~T().
  /// Here, if the object type of the expression is (or may be) a scalar type,
  /// \p T may also be a scalar type and, therefore, cannot be part of a
  /// nested-name-specifier. It is stored as the "scope type" of the pseudo-
  /// destructor expression.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getScopeTypeInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getScopeTypeInfo, Xs...); }) , (;) )
  /// Retrieve the location of the '::' in a qualified pseudo-destructor
  /// expression.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getColonColonLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getColonColonLoc, Xs...); }) , (;) )
  /// Retrieve the location of the '~'.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTildeLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getTildeLoc, Xs...); }) , (;) )
  /// Retrieve the source location information for the type
  /// being destroyed.
  ///
  /// This type-source information is available for non-dependent
  /// pseudo-destructor expressions and some dependent pseudo-destructor
  /// expressions. Returns null if we only have the identifier for a
  /// dependent pseudo-destructor expression.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getDestroyedTypeInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getDestroyedTypeInfo, Xs...); }) , (;) )
  /// In a dependent pseudo-destructor expression for which we do not
  /// have full type information on the destroyed type, provides the name
  /// of the destroyed type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::IdentifierInfo *) )
  getDestroyedTypeIdentifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getDestroyedTypeIdentifier, Xs...); }) , (;) )
  /// Retrieve the type being destroyed.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getDestroyedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getDestroyedType, Xs...); }) , (;) )
  /// Retrieve the starting location of the type being destroyed.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getDestroyedTypeLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getDestroyedTypeLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPseudoDestructorExpr, reflenums::clang__CXXPseudoDestructorExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A type trait used in the implementation of various C++11 and
/// Library TR1 trait templates.
///
/// \code
///   __is_pod(int) == true
///   __is_enum(std::string) == false
///   __is_trivially_constructible(vector<int>, int*, int*)
/// \endcode
M_template_rtpack(Xs)
struct clang::TypeTraitExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__TypeTraitExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::TypeTraitExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeTraitExpr *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumArgs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeTraitExpr, reflenums::clang__TypeTraitExpr::CreateDeserialized, Xs..., Y0s..., NumArgs); }) , (;) )
  /// Determine which type trait this expression uses.
  constexpr enum clang::TypeTrait getTrait() const IFMETA_ELSE( ({    return (enum clang::TypeTrait)__reflect_prop(reflenums::RK_clang__TypeTraitExpr, reflenums::clang__TypeTraitExpr::getTrait, Xs...); }) , (;) )
  constexpr bool getValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeTraitExpr, reflenums::clang__TypeTraitExpr::getValue, Xs...); }) , (;) )
  /// Determine the number of arguments to this type trait.
  constexpr unsigned int getNumArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeTraitExpr, reflenums::clang__TypeTraitExpr::getNumArgs, Xs...); }) , (;) )
  /// Retrieve the Ith argument.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getArg(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeTraitExpr, reflenums::clang__TypeTraitExpr::getArg, Xs..., I); }) , (;) )
  /// Retrieve the argument types.
  RANGE_REFLECTION(clang::TypeTraitExpr, getArgs,
      constexpr auto getArgs() const ,
      (typename meta::clang::TypeSourceInfo *),
      (reflenums::RK_clang__TypeTraitExpr, reflenums::clang__TypeTraitExpr::getArgs, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeTraitExpr, reflenums::clang__TypeTraitExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeTraitExpr, reflenums::clang__TypeTraitExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeTraitExpr, reflenums::clang__TypeTraitExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeTraitExpr, reflenums::clang__TypeTraitExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__TypeTraitExpr, reflenums::clang__TypeTraitExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// An Embarcadero array type trait, as used in the implementation of
/// __array_rank and __array_extent.
///
/// Example:
/// \code
///   __array_rank(int[10][20]) == 2
///   __array_extent(int, 1)    == 20
/// \endcode
M_template_rtpack(Xs)
struct clang::ArrayTypeTraitExpr::impl : impl_offset_t<clang::Expr, 8 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ArrayTypeTraitExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ArrayTypeTraitExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayTypeTraitExpr, reflenums::clang__ArrayTypeTraitExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayTypeTraitExpr, reflenums::clang__ArrayTypeTraitExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayTypeTraitExpr, reflenums::clang__ArrayTypeTraitExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayTypeTraitExpr, reflenums::clang__ArrayTypeTraitExpr::getEndLoc, Xs...); }) , (;) )
  constexpr enum clang::ArrayTypeTrait getTrait() const IFMETA_ELSE( ({    return (enum clang::ArrayTypeTrait)__reflect_prop(reflenums::RK_clang__ArrayTypeTraitExpr, reflenums::clang__ArrayTypeTraitExpr::getTrait, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getQueriedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayTypeTraitExpr, reflenums::clang__ArrayTypeTraitExpr::getQueriedType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getQueriedTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayTypeTraitExpr, reflenums::clang__ArrayTypeTraitExpr::getQueriedTypeSourceInfo, Xs...); }) , (;) )
  constexpr unsigned long long getValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayTypeTraitExpr, reflenums::clang__ArrayTypeTraitExpr::getValue, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getDimensionExpression() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayTypeTraitExpr, reflenums::clang__ArrayTypeTraitExpr::getDimensionExpression, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ArrayTypeTraitExpr, reflenums::clang__ArrayTypeTraitExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// An expression trait intrinsic.
///
/// Example:
/// \code
///   __is_lvalue_expr(std::cout) == true
///   __is_lvalue_expr(1) == false
/// \endcode
M_template_rtpack(Xs)
struct clang::ExpressionTraitExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ExpressionTraitExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ExpressionTraitExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExpressionTraitExpr, reflenums::clang__ExpressionTraitExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExpressionTraitExpr, reflenums::clang__ExpressionTraitExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExpressionTraitExpr, reflenums::clang__ExpressionTraitExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExpressionTraitExpr, reflenums::clang__ExpressionTraitExpr::getEndLoc, Xs...); }) , (;) )
  constexpr enum clang::ExpressionTrait getTrait() const IFMETA_ELSE( ({    return (enum clang::ExpressionTrait)__reflect_prop(reflenums::RK_clang__ExpressionTraitExpr, reflenums::clang__ExpressionTraitExpr::getTrait, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getQueriedExpression() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExpressionTraitExpr, reflenums::clang__ExpressionTraitExpr::getQueriedExpression, Xs...); }) , (;) )
  constexpr bool getValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExpressionTraitExpr, reflenums::clang__ExpressionTraitExpr::getValue, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExpressionTraitExpr, reflenums::clang__ExpressionTraitExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A reference to an overloaded function set, either an
/// \c UnresolvedLookupExpr or an \c UnresolvedMemberExpr.
M_template_rtpack(Xs)
struct clang::OverloadExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OverloadExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OverloadExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template_rtpack(Zs) using FindResult = struct refldetail::clang::OverloadExpr::FindResult::M_template impl M_targpack(Zs);
  /// Finds the overloaded expression in the given expression \p E of
  /// OverloadTy.
  ///
  /// \return the expression (which must be there) and true if it has
  /// the particular form of a member pointer expression
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OverloadExpr::FindResult) )
  find(IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::Expr *)) E) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::find, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OverloadExpr::FindResult) )
  find(ptrwrp<Y0> p0) {
      return find(p0.get());
  }), () )
  /// Gets the naming class of this lookup, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getNamingClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::getNamingClass, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::OverloadExpr, decls,
      constexpr auto decls() const ,
      (typename meta::clang::NamedDecl *),
      (reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::decls, Xs...), () )
  /// Gets the number of declarations in the unresolved set.
  constexpr unsigned int getNumDecls() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::getNumDecls, Xs...); }) , (;) )
  /// Gets the full name info.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclarationNameInfo &) )
  getNameInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::getNameInfo, Xs...); }) , (;) )
  /// Gets the name looked up.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationName) )
  getName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::getName, Xs...); }) , (;) )
  /// Gets the location of the name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getNameLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::getNameLoc, Xs...); }) , (;) )
  /// Fetches the nested-name qualifier, if one was given.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::getQualifier, Xs...); }) , (;) )
  /// Fetches the nested-name qualifier with source-location
  /// information, if one was given.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::getQualifierLoc, Xs...); }) , (;) )
  /// Retrieve the location of the template keyword preceding
  /// this name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTemplateKeywordLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::getTemplateKeywordLoc, Xs...); }) , (;) )
  /// Retrieve the location of the left angle bracket starting the
  /// explicit template argument list following the name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::getLAngleLoc, Xs...); }) , (;) )
  /// Retrieve the location of the right angle bracket ending the
  /// explicit template argument list following the name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::getRAngleLoc, Xs...); }) , (;) )
  /// Determines whether the name was preceded by the template keyword.
  constexpr bool hasTemplateKeyword() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::hasTemplateKeyword, Xs...); }) , (;) )
  /// Determines whether this expression had explicit template arguments.
  constexpr bool hasExplicitTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::hasExplicitTemplateArgs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentLoc *) )
  getTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::getTemplateArgs, Xs...); }) , (;) )
  constexpr unsigned int getNumTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::getNumTemplateArgs, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::OverloadExpr, template_arguments,
      constexpr auto template_arguments() const ,
      (typename meta::clang::TemplateArgumentLoc),
      (reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::template_arguments, Xs...), () )
  /// Copies the template arguments into the given structure.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void copyTemplateArgumentsInto(IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::TemplateArgumentListInfo &)) List) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::copyTemplateArgumentsInto, Xs..., Y0s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OverloadExpr, reflenums::clang__OverloadExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::OverloadExpr::FindResult::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OverloadExpr__FindResult;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OverloadExpr::FindResult::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_REFLTYPED_FIELD(Expression, (typename meta::clang::OverloadExpr *), __reflect_prop(reflenums::RK_clang__OverloadExpr__FindResult, reflenums::clang__OverloadExpr__FindResult::Expression, Xs...))
  bool IsAddressOfOperand
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__OverloadExpr__FindResult, reflenums::clang__OverloadExpr__FindResult::IsAddressOfOperand, Xs...);), (;) )
  bool HasFormOfMemberPointer
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_clang__OverloadExpr__FindResult, reflenums::clang__OverloadExpr__FindResult::HasFormOfMemberPointer, Xs...);), (;) )
};

/// A reference to a name which we were able to look up during
/// parsing but could not resolve to a specific declaration.
///
/// This arises in several ways:
///   * we might be waiting for argument-dependent lookup;
///   * the name might resolve to an overloaded function;
/// and eventually:
///   * the lookup might have included a function template.
///
/// These never include UnresolvedUsingValueDecls, which are always class
/// members and therefore appear only in UnresolvedMemberLookupExprs.
M_template_rtpack(Xs)
struct clang::UnresolvedLookupExpr::impl : impl_offset_t<clang::OverloadExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UnresolvedLookupExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UnresolvedLookupExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedLookupExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::CXXRecordDecl *)) NamingClass, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::NestedNameSpecifierLoc)) QualifierLoc, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/1, Y3s...>), (const typename meta::clang::DeclarationNameInfo &)) NameInfo, bool ADL, bool Overloaded, IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::UnresolvedSetIterator)) Begin, IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::UnresolvedSetIterator)) End) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedLookupExpr, reflenums::clang__UnresolvedLookupExpr::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., ADL, Overloaded, Y4s..., Y5s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedLookupExpr *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, bool p4, bool p5, Y4 p6, Y5 p7) {
      return Create(p0, p1.get(), p2, p3, p4, p5, p6, p7);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedLookupExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::CXXRecordDecl *)) NamingClass, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::NestedNameSpecifierLoc)) QualifierLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) TemplateKWLoc, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/1, Y4s...>), (const typename meta::clang::DeclarationNameInfo &)) NameInfo, bool ADL, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y5s...> *), (const typename meta::clang::TemplateArgumentListInfo *)) Args, IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/0, Y6s...>), (typename meta::clang::UnresolvedSetIterator)) Begin, IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/0, Y7s...>), (typename meta::clang::UnresolvedSetIterator)) End) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedLookupExpr, reflenums::clang__UnresolvedLookupExpr::Create1, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s..., ADL, Y5s..., Y6s..., Y7s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedLookupExpr *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3, Y4 p4, bool p5, ptrwrp<Y5> p6, Y6 p7, Y7 p8) {
      return Create(p0, p1.get(), p2, p3, p4, p5, p6.get(), p7, p8);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedLookupExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, bool HasTemplateKWAndArgsInfo, unsigned int NumTemplateArgs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedLookupExpr, reflenums::clang__UnresolvedLookupExpr::CreateEmpty, Xs..., Y0s..., HasTemplateKWAndArgsInfo, NumTemplateArgs); }) , (;) )
  /// True if this declaration should be extended by
  /// argument-dependent lookup.
  constexpr bool requiresADL() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedLookupExpr, reflenums::clang__UnresolvedLookupExpr::requiresADL, Xs...); }) , (;) )
  /// True if this lookup is overloaded.
  constexpr bool isOverloaded() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedLookupExpr, reflenums::clang__UnresolvedLookupExpr::isOverloaded, Xs...); }) , (;) )
  /// Gets the 'naming class' (in the sense of C++0x
  /// [class.access.base]p5) of the lookup.  This is the scope
  /// that was looked in to find these results.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getNamingClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedLookupExpr, reflenums::clang__UnresolvedLookupExpr::getNamingClass, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedLookupExpr, reflenums::clang__UnresolvedLookupExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedLookupExpr, reflenums::clang__UnresolvedLookupExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedLookupExpr, reflenums::clang__UnresolvedLookupExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedLookupExpr, reflenums::clang__UnresolvedLookupExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedLookupExpr, reflenums::clang__UnresolvedLookupExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A qualified reference to a name whose declaration cannot
/// yet be resolved.
///
/// DependentScopeDeclRefExpr is similar to DeclRefExpr in that
/// it expresses a reference to a declaration such as
/// X<T>::value. The difference, however, is that an
/// DependentScopeDeclRefExpr node is used only within C++ templates when
/// the qualification (e.g., X<T>::) refers to a dependent type. In
/// this case, X<T>::value cannot resolve to a declaration because the
/// declaration will differ from one instantiation of X<T> to the
/// next. Therefore, DependentScopeDeclRefExpr keeps track of the
/// qualifier (X<T>::) and the name of the entity being referenced
/// ("value"). Such expressions will instantiate to a DeclRefExpr once the
/// declaration can be found.
M_template_rtpack(Xs)
struct clang::DependentScopeDeclRefExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DependentScopeDeclRefExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DependentScopeDeclRefExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DependentScopeDeclRefExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::NestedNameSpecifierLoc)) QualifierLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) TemplateKWLoc, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/1, Y3s...>), (const typename meta::clang::DeclarationNameInfo &)) NameInfo, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y4s...> *), (const typename meta::clang::TemplateArgumentListInfo *)) TemplateArgs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., Y4s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DependentScopeDeclRefExpr *) )
  Create(Y0 p0, Y1 p1, Y2 p2, Y3 p3, ptrwrp<Y4> p4) {
      return Create(p0, p1, p2, p3, p4.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DependentScopeDeclRefExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, bool HasTemplateKWAndArgsInfo, unsigned int NumTemplateArgs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::CreateEmpty, Xs..., Y0s..., HasTemplateKWAndArgsInfo, NumTemplateArgs); }) , (;) )
  /// Retrieve the name that this expression refers to.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclarationNameInfo &) )
  getNameInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getNameInfo, Xs...); }) , (;) )
  /// Retrieve the name that this expression refers to.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationName) )
  getDeclName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getDeclName, Xs...); }) , (;) )
  /// Retrieve the location of the name within the expression.
  ///
  /// For example, in "X<T>::value" this is the location of "value".
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getLocation, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the
  /// name, with source location information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getQualifierLoc, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies this
  /// declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getQualifier, Xs...); }) , (;) )
  /// Retrieve the location of the template keyword preceding
  /// this name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTemplateKeywordLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getTemplateKeywordLoc, Xs...); }) , (;) )
  /// Retrieve the location of the left angle bracket starting the
  /// explicit template argument list following the name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getLAngleLoc, Xs...); }) , (;) )
  /// Retrieve the location of the right angle bracket ending the
  /// explicit template argument list following the name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getRAngleLoc, Xs...); }) , (;) )
  /// Determines whether the name was preceded by the template keyword.
  constexpr bool hasTemplateKeyword() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::hasTemplateKeyword, Xs...); }) , (;) )
  /// Determines whether this lookup had explicit template arguments.
  constexpr bool hasExplicitTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::hasExplicitTemplateArgs, Xs...); }) , (;) )
  /// Copies the template arguments (if present) into the given
  /// structure.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void copyTemplateArgumentsInto(IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::TemplateArgumentListInfo &)) List) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::copyTemplateArgumentsInto, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentLoc *) )
  getTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getTemplateArgs, Xs...); }) , (;) )
  constexpr unsigned int getNumTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getNumTemplateArgs, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::DependentScopeDeclRefExpr, template_arguments,
      constexpr auto template_arguments() const ,
      (typename meta::clang::TemplateArgumentLoc),
      (reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::template_arguments, Xs...), () )
  /// Note: getLocStart() is the start of the whole DependentScopeDeclRefExpr,
  /// and differs from getLocation().getStart().
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentScopeDeclRefExpr, reflenums::clang__DependentScopeDeclRefExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents an expression -- generally a full-expression -- that
/// introduces cleanups to be run at the end of the sub-expression's
/// evaluation.  The most common source of expression-introduced
/// cleanups is temporary objects in C++, but several other kinds of
/// expressions can create cleanups, including basically every
/// call in ARC that returns an Objective-C pointer.
///
/// This expression also tracks whether the sub-expression contains a
/// potentially-evaluated block literal.  The lifetime of a block
/// literal is the extent of the enclosing scope.
M_template_rtpack(Xs)
struct clang::ExprWithCleanups::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ExprWithCleanups;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ExprWithCleanups::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ExprWithCleanups *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) empty, unsigned int numObjects) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExprWithCleanups, reflenums::clang__ExprWithCleanups::Create, Xs..., Y0s..., Y1s..., numObjects); }) , (;) )
  RANGE_REFLECTION(clang::ExprWithCleanups, getObjects,
      constexpr auto getObjects() const ,
      (typename meta::clang::BlockDecl *),
      (reflenums::RK_clang__ExprWithCleanups, reflenums::clang__ExprWithCleanups::getObjects, Xs...), () )
  constexpr unsigned int getNumObjects() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExprWithCleanups, reflenums::clang__ExprWithCleanups::getNumObjects, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::BlockDecl *) )
  getObject(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExprWithCleanups, reflenums::clang__ExprWithCleanups::getObject, Xs..., i); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSubExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExprWithCleanups, reflenums::clang__ExprWithCleanups::getSubExpr, Xs...); }) , (;) )
  constexpr bool cleanupsHaveSideEffects() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExprWithCleanups, reflenums::clang__ExprWithCleanups::cleanupsHaveSideEffects, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExprWithCleanups, reflenums::clang__ExprWithCleanups::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExprWithCleanups, reflenums::clang__ExprWithCleanups::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExprWithCleanups, reflenums::clang__ExprWithCleanups::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExprWithCleanups, reflenums::clang__ExprWithCleanups::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ExprWithCleanups, reflenums::clang__ExprWithCleanups::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Describes an explicit type conversion that uses functional
/// notion but could not be resolved because one or more arguments are
/// type-dependent.
///
/// The explicit type conversions expressed by
/// CXXUnresolvedConstructExpr have the form <tt>T(a1, a2, ..., aN)</tt>,
/// where \c T is some type and \c a1, \c a2, ..., \c aN are values, and
/// either \c T is a dependent type or one or more of the <tt>a</tt>'s is
/// type-dependent. For example, this would occur in a template such
/// as:
///
/// \code
///   template<typename T, typename A1>
///   inline T make_a(const A1& a1) {
///     return T(a1);
///   }
/// \endcode
///
/// When the returned expression is instantiated, it may resolve to a
/// constructor call, conversion function call, or some kind of type
/// conversion.
M_template_rtpack(Xs)
struct clang::CXXUnresolvedConstructExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXUnresolvedConstructExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXUnresolvedConstructExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXUnresolvedConstructExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumArgs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUnresolvedConstructExpr, reflenums::clang__CXXUnresolvedConstructExpr::CreateEmpty, Xs..., Y0s..., NumArgs); }) , (;) )
  /// Retrieve the type that is being constructed, as specified
  /// in the source code.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getTypeAsWritten() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUnresolvedConstructExpr, reflenums::clang__CXXUnresolvedConstructExpr::getTypeAsWritten, Xs...); }) , (;) )
  /// Retrieve the type source information for the type being
  /// constructed.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUnresolvedConstructExpr, reflenums::clang__CXXUnresolvedConstructExpr::getTypeSourceInfo, Xs...); }) , (;) )
  /// Retrieve the location of the left parentheses ('(') that
  /// precedes the argument list.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUnresolvedConstructExpr, reflenums::clang__CXXUnresolvedConstructExpr::getLParenLoc, Xs...); }) , (;) )
  /// Retrieve the location of the right parentheses (')') that
  /// follows the argument list.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUnresolvedConstructExpr, reflenums::clang__CXXUnresolvedConstructExpr::getRParenLoc, Xs...); }) , (;) )
  /// Determine whether this expression models list-initialization.
  /// If so, there will be exactly one subexpression, which will be
  /// an InitListExpr.
  constexpr bool isListInitialization() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUnresolvedConstructExpr, reflenums::clang__CXXUnresolvedConstructExpr::isListInitialization, Xs...); }) , (;) )
  /// Retrieve the number of arguments.
  constexpr unsigned int arg_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUnresolvedConstructExpr, reflenums::clang__CXXUnresolvedConstructExpr::arg_size, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getArg(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUnresolvedConstructExpr, reflenums::clang__CXXUnresolvedConstructExpr::getArg, Xs..., I); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUnresolvedConstructExpr, reflenums::clang__CXXUnresolvedConstructExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUnresolvedConstructExpr, reflenums::clang__CXXUnresolvedConstructExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUnresolvedConstructExpr, reflenums::clang__CXXUnresolvedConstructExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUnresolvedConstructExpr, reflenums::clang__CXXUnresolvedConstructExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXUnresolvedConstructExpr, reflenums::clang__CXXUnresolvedConstructExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a C++ member access expression where the actual
/// member referenced could not be resolved because the base
/// expression or the member name was dependent.
///
/// Like UnresolvedMemberExprs, these can be either implicit or
/// explicit accesses.  It is only possible to get one of these with
/// an implicit access if a qualifier is provided.
M_template_rtpack(Xs)
struct clang::CXXDependentScopeMemberExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXDependentScopeMemberExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXDependentScopeMemberExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_c M_rtpack(Y8s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDependentScopeMemberExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::Expr *)) Base, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) BaseType, bool IsArrow, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) OperatorLoc, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::NestedNameSpecifierLoc)) QualifierLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::SourceLocation)) TemplateKWLoc, IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y6s...> *), (typename meta::clang::NamedDecl *)) FirstQualifierFoundInScope, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/0, Y7s...>), (typename meta::clang::DeclarationNameInfo)) MemberNameInfo, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y8s...> *), (const typename meta::clang::TemplateArgumentListInfo *)) TemplateArgs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::Create, Xs..., Y0s..., Y1s..., Y2s..., IsArrow, Y3s..., Y4s..., Y5s..., Y6s..., Y7s..., Y8s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7, typename Y8>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDependentScopeMemberExpr *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, bool p3, Y3 p4, Y4 p5, Y5 p6, ptrwrp<Y6> p7, Y7 p8, ptrwrp<Y8> p9) {
      return Create(p0, p1.get(), p2, p3, p4, p5, p6, p7.get(), p8, p9.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXDependentScopeMemberExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, bool HasTemplateKWAndArgsInfo, unsigned int NumTemplateArgs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::CreateEmpty, Xs..., Y0s..., HasTemplateKWAndArgsInfo, NumTemplateArgs); }) , (;) )
  /// True if this is an implicit access, i.e. one in which the
  /// member being accessed was not written in the source.  The source
  /// location of the operator is invalid in this case.
  constexpr bool isImplicitAccess() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::isImplicitAccess, Xs...); }) , (;) )
  /// Retrieve the base object of this member expressions,
  /// e.g., the \c x in \c x.m.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getBase, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBaseType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getBaseType, Xs...); }) , (;) )
  /// Determine whether this member expression used the '->'
  /// operator; otherwise, it used the '.' operator.
  constexpr bool isArrow() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::isArrow, Xs...); }) , (;) )
  /// Retrieve the location of the '->' or '.' operator.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOperatorLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getOperatorLoc, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the member
  /// name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifier *) )
  getQualifier() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getQualifier, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies the member
  /// name, with source location information.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getQualifierLoc, Xs...); }) , (;) )
  /// Retrieve the first part of the nested-name-specifier that was
  /// found in the scope of the member access expression when the member access
  /// was initially parsed.
  ///
  /// This function only returns a useful result when member access expression
  /// uses a qualified member name, e.g., "x.Base::f". Here, the declaration
  /// returned by this function describes what was found by unqualified name
  /// lookup for the identifier "Base" within the scope of the member access
  /// expression itself. At template instantiation time, this information is
  /// combined with the results of name lookup into the type of the object
  /// expression itself (the class type of x).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getFirstQualifierFoundInScope() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getFirstQualifierFoundInScope, Xs...); }) , (;) )
  /// Retrieve the name of the member that this expression
  /// refers to.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclarationNameInfo &) )
  getMemberNameInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getMemberNameInfo, Xs...); }) , (;) )
  /// Retrieve the name of the member that this expression
  /// refers to.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationName) )
  getMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getMember, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getMemberLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getMemberLoc, Xs...); }) , (;) )
  /// Retrieve the location of the template keyword preceding the
  /// member name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTemplateKeywordLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getTemplateKeywordLoc, Xs...); }) , (;) )
  /// Retrieve the location of the left angle bracket starting the
  /// explicit template argument list following the member name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getLAngleLoc, Xs...); }) , (;) )
  /// Retrieve the location of the right angle bracket ending the
  /// explicit template argument list following the member name, if any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRAngleLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getRAngleLoc, Xs...); }) , (;) )
  /// Determines whether the member name was preceded by the template keyword.
  constexpr bool hasTemplateKeyword() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::hasTemplateKeyword, Xs...); }) , (;) )
  /// Determines whether this member expression actually had a C++
  /// template argument list explicitly specified, e.g., x.f<int>.
  constexpr bool hasExplicitTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::hasExplicitTemplateArgs, Xs...); }) , (;) )
  /// Copies the template arguments (if present) into the given
  /// structure.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr void copyTemplateArgumentsInto(IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::TemplateArgumentListInfo &)) List) const IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::copyTemplateArgumentsInto, Xs..., Y0s...); }) , (;) )
  /// Retrieve the template arguments provided as part of this
  /// template-id.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::TemplateArgumentLoc *) )
  getTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getTemplateArgs, Xs...); }) , (;) )
  /// Retrieve the number of template arguments provided as part of this
  /// template-id.
  constexpr unsigned int getNumTemplateArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getNumTemplateArgs, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CXXDependentScopeMemberExpr, template_arguments,
      constexpr auto template_arguments() const ,
      (typename meta::clang::TemplateArgumentLoc),
      (reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::template_arguments, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentScopeMemberExpr, reflenums::clang__CXXDependentScopeMemberExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a C++ member access expression for which lookup
/// produced a set of overloaded functions.
///
/// The member access may be explicit or implicit:
/// \code
///    struct A {
///      int a, b;
///      int explicitAccess() { return this->a + this->A::b; }
///      int implicitAccess() { return a + A::b; }
///    };
/// \endcode
///
/// In the final AST, an explicit access always becomes a MemberExpr.
/// An implicit access may become either a MemberExpr or a
/// DeclRefExpr, depending on whether the member is static.
M_template_rtpack(Xs)
struct clang::UnresolvedMemberExpr::impl : impl_offset_t<clang::OverloadExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__UnresolvedMemberExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::UnresolvedMemberExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_c M_rtpack(Y7s) M_c M_rtpack(Y8s) M_c M_rtpack(Y9s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedMemberExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, bool HasUnresolvedUsing, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::Expr *)) Base, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::QualType)) BaseType, bool IsArrow, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) OperatorLoc, IFMETA_ELSE((const clang::NestedNameSpecifierLoc::template impl</*ptrorref=*/0, Y4s...>), (typename meta::clang::NestedNameSpecifierLoc)) QualifierLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::SourceLocation)) TemplateKWLoc, IFMETA_ELSE((const clang::DeclarationNameInfo::template impl</*ptrorref=*/1, Y6s...>), (const typename meta::clang::DeclarationNameInfo &)) MemberNameInfo, IFMETA_ELSE((const clang::TemplateArgumentListInfo::template impl</*ptrorref=*/1, Y7s...> *), (const typename meta::clang::TemplateArgumentListInfo *)) TemplateArgs, IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/0, Y8s...>), (typename meta::clang::UnresolvedSetIterator)) Begin, IFMETA_ELSE((const clang::UnresolvedSetIterator::template impl</*ptrorref=*/0, Y9s...>), (typename meta::clang::UnresolvedSetIterator)) End) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::Create, Xs..., Y0s..., HasUnresolvedUsing, Y1s..., Y2s..., IsArrow, Y3s..., Y4s..., Y5s..., Y6s..., Y7s..., Y8s..., Y9s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6, typename Y7, typename Y8, typename Y9>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedMemberExpr *) )
  Create(Y0 p0, bool p1, ptrwrp<Y1> p2, Y2 p3, bool p4, Y3 p5, Y4 p6, Y5 p7, Y6 p8, ptrwrp<Y7> p9, Y8 p10, Y9 p11) {
      return Create(p0, p1, p2.get(), p3, p4, p5, p6, p7, p8, p9.get(), p10, p11);
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedMemberExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, bool HasTemplateKWAndArgsInfo, unsigned int NumTemplateArgs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::CreateEmpty, Xs..., Y0s..., HasTemplateKWAndArgsInfo, NumTemplateArgs); }) , (;) )
  /// True if this is an implicit access, i.e., one in which the
  /// member being accessed was not written in the source.
  ///
  /// The source location of the operator is invalid in this case.
  constexpr bool isImplicitAccess() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::isImplicitAccess, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::getBase, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBaseType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::getBaseType, Xs...); }) , (;) )
  /// Determine whether the lookup results contain an unresolved using
  /// declaration.
  constexpr bool hasUnresolvedUsing() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::hasUnresolvedUsing, Xs...); }) , (;) )
  /// Determine whether this member expression used the '->'
  /// operator; otherwise, it used the '.' operator.
  constexpr bool isArrow() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::isArrow, Xs...); }) , (;) )
  /// Retrieve the location of the '->' or '.' operator.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOperatorLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::getOperatorLoc, Xs...); }) , (;) )
  /// Retrieve the naming class of this lookup.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXRecordDecl *) )
  getNamingClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::getNamingClass, Xs...); }) , (;) )
  /// Retrieve the full name info for the member that this expression
  /// refers to.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclarationNameInfo &) )
  getMemberNameInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::getMemberNameInfo, Xs...); }) , (;) )
  /// Retrieve the name of the member that this expression
  /// refers to.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationName) )
  getMemberName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::getMemberName, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getMemberLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::getMemberLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::getExprLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__UnresolvedMemberExpr, reflenums::clang__UnresolvedMemberExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a C++11 noexcept expression (C++ [expr.unary.noexcept]).
///
/// The noexcept expression tests whether a given expression might throw. Its
/// result is a boolean constant.
M_template_rtpack(Xs)
struct clang::CXXNoexceptExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXNoexceptExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXNoexceptExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNoexceptExpr, reflenums::clang__CXXNoexceptExpr::getOperand, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNoexceptExpr, reflenums::clang__CXXNoexceptExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNoexceptExpr, reflenums::clang__CXXNoexceptExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNoexceptExpr, reflenums::clang__CXXNoexceptExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNoexceptExpr, reflenums::clang__CXXNoexceptExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNoexceptExpr, reflenums::clang__CXXNoexceptExpr::getSourceRange, Xs...); }) , (;) )
  constexpr bool getValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNoexceptExpr, reflenums::clang__CXXNoexceptExpr::getValue, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXNoexceptExpr, reflenums::clang__CXXNoexceptExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a C++11 pack expansion that produces a sequence of
/// expressions.
///
/// A pack expansion expression contains a pattern (which itself is an
/// expression) followed by an ellipsis. For example:
///
/// \code
/// template<typename F, typename ...Types>
/// void forward(F f, Types &&...args) {
///   f(static_cast<Types&&>(args)...);
/// }
/// \endcode
///
/// Here, the argument to the function object \c f is a pack expansion whose
/// pattern is \c static_cast<Types&&>(args). When the \c forward function
/// template is instantiated, the pack expansion will instantiate to zero or
/// or more function arguments to the function object \c f.
M_template_rtpack(Xs)
struct clang::PackExpansionExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__PackExpansionExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::PackExpansionExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the pattern of the pack expansion.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getPattern() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PackExpansionExpr, reflenums::clang__PackExpansionExpr::getPattern, Xs...); }) , (;) )
  /// Retrieve the location of the ellipsis that describes this pack
  /// expansion.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEllipsisLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PackExpansionExpr, reflenums::clang__PackExpansionExpr::getEllipsisLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PackExpansionExpr, reflenums::clang__PackExpansionExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PackExpansionExpr, reflenums::clang__PackExpansionExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PackExpansionExpr, reflenums::clang__PackExpansionExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PackExpansionExpr, reflenums::clang__PackExpansionExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__PackExpansionExpr, reflenums::clang__PackExpansionExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents an expression that computes the length of a parameter
/// pack.
///
/// \code
/// template<typename ...Types>
/// struct count {
///   static const unsigned value = sizeof...(Types);
/// };
/// \endcode
M_template_rtpack(Xs)
struct clang::SizeOfPackExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SizeOfPackExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SizeOfPackExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::SizeOfPackExpr *) )
  CreateDeserialized(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Context, unsigned int NumPartialArgs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::CreateDeserialized, Xs..., Y0s..., NumPartialArgs); }) , (;) )
  /// Determine the location of the 'sizeof' keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOperatorLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::getOperatorLoc, Xs...); }) , (;) )
  /// Determine the location of the parameter pack.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getPackLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::getPackLoc, Xs...); }) , (;) )
  /// Determine the location of the right parenthesis.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::getRParenLoc, Xs...); }) , (;) )
  /// Retrieve the parameter pack.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::getPack, Xs...); }) , (;) )
  /// Retrieve the length of the parameter pack.
  ///
  /// This routine may only be invoked when the expression is not
  /// value-dependent.
  constexpr unsigned int getPackLength() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::getPackLength, Xs...); }) , (;) )
  /// Determine whether this represents a partially-substituted sizeof...
  /// expression, such as is produced for:
  ///
  ///   template<typename ...Ts> using X = int[sizeof...(Ts)];
  ///   template<typename ...Us> void f(X<Us..., 1, 2, 3, Us...>);
  constexpr bool isPartiallySubstituted() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::isPartiallySubstituted, Xs...); }) , (;) )
  /// Get
  RANGE_REFLECTION(clang::SizeOfPackExpr, getPartialArguments,
      constexpr auto getPartialArguments() const ,
      (typename meta::clang::TemplateArgument),
      (reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::getPartialArguments, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SizeOfPackExpr, reflenums::clang__SizeOfPackExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a reference to a non-type template parameter
/// that has been substituted with a template argument.
M_template_rtpack(Xs)
struct clang::SubstNonTypeTemplateParmExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SubstNonTypeTemplateParmExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SubstNonTypeTemplateParmExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getNameLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmExpr, reflenums::clang__SubstNonTypeTemplateParmExpr::getNameLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmExpr, reflenums::clang__SubstNonTypeTemplateParmExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmExpr, reflenums::clang__SubstNonTypeTemplateParmExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmExpr, reflenums::clang__SubstNonTypeTemplateParmExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmExpr, reflenums::clang__SubstNonTypeTemplateParmExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getReplacement() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmExpr, reflenums::clang__SubstNonTypeTemplateParmExpr::getReplacement, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NonTypeTemplateParmDecl *) )
  getParameter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmExpr, reflenums::clang__SubstNonTypeTemplateParmExpr::getParameter, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) s) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmExpr, reflenums::clang__SubstNonTypeTemplateParmExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a reference to a non-type template parameter pack that
/// has been substituted with a non-template argument pack.
///
/// When a pack expansion in the source code contains multiple parameter packs
/// and those parameter packs correspond to different levels of template
/// parameter lists, this node is used to represent a non-type template
/// parameter pack from an outer level, which has already had its argument pack
/// substituted but that still lives within a pack expansion that itself
/// could not be instantiated. When actually performing a substitution into
/// that pack expansion (e.g., when all template parameters have corresponding
/// arguments), this type will be replaced with the appropriate underlying
/// expression at the current pack substitution index.
M_template_rtpack(Xs)
struct clang::SubstNonTypeTemplateParmPackExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__SubstNonTypeTemplateParmPackExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::SubstNonTypeTemplateParmPackExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the non-type template parameter pack being substituted.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NonTypeTemplateParmDecl *) )
  getParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmPackExpr, reflenums::clang__SubstNonTypeTemplateParmPackExpr::getParameterPack, Xs...); }) , (;) )
  /// Retrieve the location of the parameter pack name.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getParameterPackLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmPackExpr, reflenums::clang__SubstNonTypeTemplateParmPackExpr::getParameterPackLocation, Xs...); }) , (;) )
  /// Retrieve the template argument pack containing the substituted
  /// template arguments.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TemplateArgument) )
  getArgumentPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmPackExpr, reflenums::clang__SubstNonTypeTemplateParmPackExpr::getArgumentPack, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmPackExpr, reflenums::clang__SubstNonTypeTemplateParmPackExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmPackExpr, reflenums::clang__SubstNonTypeTemplateParmPackExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmPackExpr, reflenums::clang__SubstNonTypeTemplateParmPackExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmPackExpr, reflenums::clang__SubstNonTypeTemplateParmPackExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__SubstNonTypeTemplateParmPackExpr, reflenums::clang__SubstNonTypeTemplateParmPackExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a reference to a function parameter pack that has been
/// substituted but not yet expanded.
///
/// When a pack expansion contains multiple parameter packs at different levels,
/// this node is used to represent a function parameter pack at an outer level
/// which we have already substituted to refer to expanded parameters, but where
/// the containing pack expansion cannot yet be expanded.
///
/// \code
/// template<typename...Ts> struct S {
///   template<typename...Us> auto f(Ts ...ts) -> decltype(g(Us(ts)...));
/// };
/// template struct S<int, int>;
/// \endcode
M_template_rtpack(Xs)
struct clang::FunctionParmPackExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__FunctionParmPackExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::FunctionParmPackExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::FunctionParmPackExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, unsigned int NumParams) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionParmPackExpr, reflenums::clang__FunctionParmPackExpr::CreateEmpty, Xs..., Y0s..., NumParams); }) , (;) )
  /// Get the parameter pack which this expression refers to.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ParmVarDecl *) )
  getParameterPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionParmPackExpr, reflenums::clang__FunctionParmPackExpr::getParameterPack, Xs...); }) , (;) )
  /// Get the location of the parameter pack.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getParameterPackLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionParmPackExpr, reflenums::clang__FunctionParmPackExpr::getParameterPackLocation, Xs...); }) , (;) )
  /// Get the number of parameters in this parameter pack.
  constexpr unsigned int getNumExpansions() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionParmPackExpr, reflenums::clang__FunctionParmPackExpr::getNumExpansions, Xs...); }) , (;) )
  /// Get an expansion of the parameter pack by index.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ParmVarDecl *) )
  getExpansion(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionParmPackExpr, reflenums::clang__FunctionParmPackExpr::getExpansion, Xs..., I); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionParmPackExpr, reflenums::clang__FunctionParmPackExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionParmPackExpr, reflenums::clang__FunctionParmPackExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionParmPackExpr, reflenums::clang__FunctionParmPackExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionParmPackExpr, reflenums::clang__FunctionParmPackExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__FunctionParmPackExpr, reflenums::clang__FunctionParmPackExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGECLASS_SIZE_AND_GET(clang__FunctionParmPackExpr, typename meta::clang::ParmVarDecl *const);
};

/// Represents a prvalue temporary that is written into memory so that
/// a reference can bind to it.
///
/// Prvalue expressions are materialized when they need to have an address
/// in memory for a reference to bind to. This happens when binding a
/// reference to the result of a conversion, e.g.,
///
/// \code
/// const int &r = 1.0;
/// \endcode
///
/// Here, 1.0 is implicitly converted to an \c int. That resulting \c int is
/// then materialized via a \c MaterializeTemporaryExpr, and the reference
/// binds to the temporary. \c MaterializeTemporaryExprs are always glvalues
/// (either an lvalue or an xvalue, depending on the kind of reference binding
/// to it), maintaining the invariant that references always bind to glvalues.
///
/// Reference binding and copy-elision can both extend the lifetime of a
/// temporary. When either happens, the expression will also track the
/// declaration which is responsible for the lifetime extension.
M_template_rtpack(Xs)
struct clang::MaterializeTemporaryExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__MaterializeTemporaryExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::MaterializeTemporaryExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getTemporary() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MaterializeTemporaryExpr, reflenums::clang__MaterializeTemporaryExpr::getTemporary, Xs...); }) , (;) )
  /// Retrieve the temporary-generating subexpression whose value will
  /// be materialized into a glvalue.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  GetTemporaryExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MaterializeTemporaryExpr, reflenums::clang__MaterializeTemporaryExpr::GetTemporaryExpr, Xs...); }) , (;) )
  /// Retrieve the storage duration for the materialized temporary.
  constexpr enum clang::StorageDuration getStorageDuration() const IFMETA_ELSE( ({    return (enum clang::StorageDuration)__reflect_prop(reflenums::RK_clang__MaterializeTemporaryExpr, reflenums::clang__MaterializeTemporaryExpr::getStorageDuration, Xs...); }) , (;) )
  /// Get the declaration which triggered the lifetime-extension of this
  /// temporary, if any.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ValueDecl *) )
  getExtendingDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MaterializeTemporaryExpr, reflenums::clang__MaterializeTemporaryExpr::getExtendingDecl, Xs...); }) , (;) )
  constexpr unsigned int getManglingNumber() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MaterializeTemporaryExpr, reflenums::clang__MaterializeTemporaryExpr::getManglingNumber, Xs...); }) , (;) )
  /// Determine whether this materialized temporary is bound to an
  /// lvalue reference; otherwise, it's bound to an rvalue reference.
  constexpr bool isBoundToLvalueReference() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MaterializeTemporaryExpr, reflenums::clang__MaterializeTemporaryExpr::isBoundToLvalueReference, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MaterializeTemporaryExpr, reflenums::clang__MaterializeTemporaryExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MaterializeTemporaryExpr, reflenums::clang__MaterializeTemporaryExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MaterializeTemporaryExpr, reflenums::clang__MaterializeTemporaryExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MaterializeTemporaryExpr, reflenums::clang__MaterializeTemporaryExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MaterializeTemporaryExpr, reflenums::clang__MaterializeTemporaryExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a folding of a pack over an operator.
///
/// This expression is always dependent and represents a pack expansion of the
/// forms:
///
///    ( expr op ... )
///    ( ... op expr )
///    ( expr op ... op expr )
M_template_rtpack(Xs)
struct clang::CXXFoldExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXFoldExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXFoldExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getLHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFoldExpr, reflenums::clang__CXXFoldExpr::getLHS, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getRHS() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFoldExpr, reflenums::clang__CXXFoldExpr::getRHS, Xs...); }) , (;) )
  /// Does this produce a right-associated sequence of operators?
  constexpr bool isRightFold() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFoldExpr, reflenums::clang__CXXFoldExpr::isRightFold, Xs...); }) , (;) )
  /// Does this produce a left-associated sequence of operators?
  constexpr bool isLeftFold() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFoldExpr, reflenums::clang__CXXFoldExpr::isLeftFold, Xs...); }) , (;) )
  /// Get the pattern, that is, the operand that contains an unexpanded pack.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getPattern() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFoldExpr, reflenums::clang__CXXFoldExpr::getPattern, Xs...); }) , (;) )
  /// Get the operand that doesn't contain a pack, for a binary fold.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFoldExpr, reflenums::clang__CXXFoldExpr::getInit, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEllipsisLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFoldExpr, reflenums::clang__CXXFoldExpr::getEllipsisLoc, Xs...); }) , (;) )
  constexpr enum clang::BinaryOperatorKind getOperator() const IFMETA_ELSE( ({    return (enum clang::BinaryOperatorKind)__reflect_prop(reflenums::RK_clang__CXXFoldExpr, reflenums::clang__CXXFoldExpr::getOperator, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFoldExpr, reflenums::clang__CXXFoldExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFoldExpr, reflenums::clang__CXXFoldExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFoldExpr, reflenums::clang__CXXFoldExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFoldExpr, reflenums::clang__CXXFoldExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXFoldExpr, reflenums::clang__CXXFoldExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents an expression that might suspend coroutine execution;
/// either a co_await or co_yield expression.
///
/// Evaluation of this expression first evaluates its 'ready' expression. If
/// that returns 'false':
///  -- execution of the coroutine is suspended
///  -- the 'suspend' expression is evaluated
///     -- if the 'suspend' expression returns 'false', the coroutine is
///        resumed
///     -- otherwise, control passes back to the resumer.
/// If the coroutine is not suspended, or when it is resumed, the 'resume'
/// expression is evaluated, and its result is the result of the overall
/// expression.
M_template_rtpack(Xs)
struct clang::CoroutineSuspendExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CoroutineSuspendExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CoroutineSuspendExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getKeywordLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineSuspendExpr, reflenums::clang__CoroutineSuspendExpr::getKeywordLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCommonExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineSuspendExpr, reflenums::clang__CoroutineSuspendExpr::getCommonExpr, Xs...); }) , (;) )
  /// getOpaqueValue - Return the opaque value placeholder.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::OpaqueValueExpr *) )
  getOpaqueValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineSuspendExpr, reflenums::clang__CoroutineSuspendExpr::getOpaqueValue, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getReadyExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineSuspendExpr, reflenums::clang__CoroutineSuspendExpr::getReadyExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getSuspendExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineSuspendExpr, reflenums::clang__CoroutineSuspendExpr::getSuspendExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getResumeExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineSuspendExpr, reflenums::clang__CoroutineSuspendExpr::getResumeExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineSuspendExpr, reflenums::clang__CoroutineSuspendExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineSuspendExpr, reflenums::clang__CoroutineSuspendExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineSuspendExpr, reflenums::clang__CoroutineSuspendExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineSuspendExpr, reflenums::clang__CoroutineSuspendExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineSuspendExpr, reflenums::clang__CoroutineSuspendExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a 'co_await' expression.
M_template_rtpack(Xs)
struct clang::CoawaitExpr::impl : impl_offset_t<clang::CoroutineSuspendExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CoawaitExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CoawaitExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoawaitExpr, reflenums::clang__CoawaitExpr::getOperand, Xs...); }) , (;) )
  constexpr bool isImplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoawaitExpr, reflenums::clang__CoawaitExpr::isImplicit, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoawaitExpr, reflenums::clang__CoawaitExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a 'co_await' expression while the type of the promise
/// is dependent.
M_template_rtpack(Xs)
struct clang::DependentCoawaitExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DependentCoawaitExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DependentCoawaitExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentCoawaitExpr, reflenums::clang__DependentCoawaitExpr::getOperand, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::UnresolvedLookupExpr *) )
  getOperatorCoawaitLookup() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentCoawaitExpr, reflenums::clang__DependentCoawaitExpr::getOperatorCoawaitLookup, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getKeywordLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentCoawaitExpr, reflenums::clang__DependentCoawaitExpr::getKeywordLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentCoawaitExpr, reflenums::clang__DependentCoawaitExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentCoawaitExpr, reflenums::clang__DependentCoawaitExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentCoawaitExpr, reflenums::clang__DependentCoawaitExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentCoawaitExpr, reflenums::clang__DependentCoawaitExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentCoawaitExpr, reflenums::clang__DependentCoawaitExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a 'co_yield' expression.
M_template_rtpack(Xs)
struct clang::CoyieldExpr::impl : impl_offset_t<clang::CoroutineSuspendExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CoyieldExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CoyieldExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoyieldExpr, reflenums::clang__CoyieldExpr::getOperand, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoyieldExpr, reflenums::clang__CoyieldExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// \brief An expression denoting the reflection of a dependent name, type, or
/// expression.
///
/// These are used only to preserve dependent expressions in templates.
///
M_template_rtpack(Xs)
struct clang::ReflectionExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ReflectionExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ReflectionExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// \brief Returns \c true if the expression is spelled \c reflexpr.
    /// This is the case when the parentheses' locations are valid.
  constexpr bool isReflexpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionExpr, reflenums::clang__ReflectionExpr::isReflexpr, Xs...); }) , (;) )
  /// Returns \c true if the operand is a type.
  constexpr bool hasTypeOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionExpr, reflenums::clang__ReflectionExpr::hasTypeOperand, Xs...); }) , (;) )
  /// Returns \c true if the operand is an expression.
  constexpr bool hasExpressionOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionExpr, reflenums::clang__ReflectionExpr::hasExpressionOperand, Xs...); }) , (;) )
  /// Returns the type operand.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getTypeOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionExpr, reflenums::clang__ReflectionExpr::getTypeOperand, Xs...); }) , (;) )
  /// Returns the expression operand.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getExpressionOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionExpr, reflenums::clang__ReflectionExpr::getExpressionOperand, Xs...); }) , (;) )
  /// Returns the source code location of the \c $ or \c reflexpr operator
    /// keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOperatorLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionExpr, reflenums::clang__ReflectionExpr::getOperatorLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionExpr, reflenums::clang__ReflectionExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionExpr, reflenums::clang__ReflectionExpr::getLocEnd, Xs...); }) , (;) )
};

/// Represents a call to the builtin function \c __compiler_debug
///
/// This AST node provides support for issuing a compile-time message. It takes a
/// single constant string argument.
M_template_rtpack(Xs)
struct clang::CompilerMessageExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CompilerMessageExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CompilerMessageExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Construct a \c __compiler_error expression.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CompilerMessageExpr *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::Expr *)) Message, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) KWLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y3s...>), (typename meta::clang::SourceLocation)) RParenLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerMessageExpr, reflenums::clang__CompilerMessageExpr::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CompilerMessageExpr *) )
  Create(Y0 p0, ptrwrp<Y1> p1, Y2 p2, Y3 p3) {
      return Create(p0, p1.get(), p2, p3);
  }), () )
  /// Construct an empty \c __compiler_error expression.
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CompilerMessageExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) Empty) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerMessageExpr, reflenums::clang__CompilerMessageExpr::CreateEmpty, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Return the string to be included in the diagnostic message.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getMessage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerMessageExpr, reflenums::clang__CompilerMessageExpr::getMessage, Xs...); }) , (;) )
  /// Return the location of the \c __compiler_error token.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getKWLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerMessageExpr, reflenums::clang__CompilerMessageExpr::getKWLoc, Xs...); }) , (;) )
  /// Return the location of final right parenthesis.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerMessageExpr, reflenums::clang__CompilerMessageExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerMessageExpr, reflenums::clang__CompilerMessageExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerMessageExpr, reflenums::clang__CompilerMessageExpr::getLocEnd, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerMessageExpr, reflenums::clang__CompilerMessageExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::CompilerDiagnosticExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CompilerDiagnosticExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CompilerDiagnosticExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CompilerDiagnosticExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumArgs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerDiagnosticExpr, reflenums::clang__CompilerDiagnosticExpr::CreateEmpty, Xs..., Y0s..., NumArgs); }) , (;) )
  /// Retrieve the location of the __compiler_diagnostic keyword that
  /// precedes the '(' and argument list.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getKWLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerDiagnosticExpr, reflenums::clang__CompilerDiagnosticExpr::getKWLoc, Xs...); }) , (;) )
  /// Retrieve the location of the right parentheses (')') that
  /// follows the argument list.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerDiagnosticExpr, reflenums::clang__CompilerDiagnosticExpr::getRParenLoc, Xs...); }) , (;) )
  /// Retrieve the number of arguments.
  constexpr unsigned int arg_size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerDiagnosticExpr, reflenums::clang__CompilerDiagnosticExpr::arg_size, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CompilerDiagnosticExpr, getArgs,
      constexpr auto getArgs() const ,
      (const typename meta::clang::Expr *),
      (reflenums::RK_clang__CompilerDiagnosticExpr, reflenums::clang__CompilerDiagnosticExpr::getArgs, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getArg(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerDiagnosticExpr, reflenums::clang__CompilerDiagnosticExpr::getArg, Xs..., I); }) , (;) )
  constexpr bool isError() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerDiagnosticExpr, reflenums::clang__CompilerDiagnosticExpr::isError, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerDiagnosticExpr, reflenums::clang__CompilerDiagnosticExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerDiagnosticExpr, reflenums::clang__CompilerDiagnosticExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerDiagnosticExpr, reflenums::clang__CompilerDiagnosticExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerDiagnosticExpr, reflenums::clang__CompilerDiagnosticExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CompilerDiagnosticExpr, reflenums::clang__CompilerDiagnosticExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a C++ __metaparse expression.
///
/// As soon as its argument string is non-dependent, evaluates and parses that string,
/// WITHIN the constexpr context in which it is declared.  (Contrast this
/// with __queue_metaparse, which evaluates the argument string AFTER the enclosing
/// constexpr decl.)
/// These are useful for passing data from a higher "meta level" to a lower one,
/// usually within a constexpr decl.
/// However, you must provide the type of the expression as the second argument.
/// (You cannot provide auto.)
/// For now, you cannot even provide a slightly different int type from that of the
/// expression -- make sure they are exactly the same, perhaps with a static
/// cast within the expression string. (DWR FIXME -- just needs a proper ImplicitCastExpr...)
///
/// Example:
///
///     constexpr int i = __metaparse_expr("3", int);
///     constexpr unsigned char u = __metaparse_expr("static_cast<unsigned char>(3)", unsigned char);
///
M_template_rtpack(Xs)
struct clang::CXXMetaparseExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXMetaparseExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXMetaparseExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// \brief The string literal source code to parse into an expression.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getExprSrcCode() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMetaparseExpr, reflenums::clang__CXXMetaparseExpr::getExprSrcCode, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMetaparseExpr, reflenums::clang__CXXMetaparseExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMetaparseExpr, reflenums::clang__CXXMetaparseExpr::getLocEnd, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXMetaparseExpr, reflenums::clang__CXXMetaparseExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Holds the reflection trait kind and arguments, with special
/// status given to the first three arguments, for a
/// __reflect_prop, __reflect_cast, __reflect_range_nth,
/// or __reflect_range_size call.
///
/// When all of the first three arguments are non-dependent (generally
/// true right away during parsing, but if not after sufficient
/// Transformations), we set the ObjKind, MemNum, and IsPtr variables
/// with their evaluated values and then OMIT them from the Args array --
/// i.e. when callbacksAreSet(), the Args array supplies only the expressions
/// for the queried reflection obj pointer/value data itself and any
/// arguments required, omitting the first three args given in the actual
/// trait.
///
/// Note that the type of this expression
/// will still be a Dependent whenever the returned object type
/// is a non-primitive, e.g. Decl*, because in such instances
/// we need to know the exact pointer value, i.e. the type AND the object,
/// to build the client reflection template instance.
///
/// In such cases we will provide a nonnull getTypeFromRemArgs_CB callback
/// that will be called whenever the type is DependentTy to try to update
/// it to a non-dependent type.
///
/// Otherwise -- when the type is non-dependent -- the
/// getTypeFromRemArgs_CB will be null and unused.
///
M_template_rtpack(Xs)
struct clang::ReflectionTraitExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ReflectionTraitExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ReflectionTraitExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr enum clang::ReflectionTraitKind getTraitKind() const IFMETA_ELSE( ({    return (enum clang::ReflectionTraitKind)__reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::getTraitKind, Xs...); }) , (;) )
  /// Returns the arity of the trait.
  constexpr unsigned int getNumArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::getNumArgs, Xs...); }) , (;) )
  /// Returns the ith argument of the reflection trait.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getArg(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::getArg, Xs..., I); }) , (;) )
  /// \brief Returns the array of arguments.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr **) )
  getArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::getArgs, Xs...); }) , (;) )
  /// Returns the source code location of the trait keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getKWLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::getKWLoc, Xs...); }) , (;) )
  /// Returns the source code location of the closing parenthesis.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ASTContext *) )
  getASTContext_p() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::getASTContext_p, Xs...); }) , (;) )
  /// Identifies the Clang class of the object being queried.
  constexpr unsigned int getObjKind() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::getObjKind, Xs...); }) , (;) )
  /// When the first three args of the reflection trait are non-dependent
  /// (the ObjKind, MemNum, and IsPtr status), then we will set the
  /// CB_getTypeFromArgs and CB_getResultFromArgs callbacks; this tells
  /// us if that has been done (true), or if even those basic parameters
  /// are still dependent (false): e.g.
  /// \code
  /// template<typename T, uintptr_t... Xs>
  /// auto myfcn() {
  ///   return __reflect_prop(Xs...); //callbacksAreSet() = false
  /// }
  /// \endcode
  /// Note that we can't just infer this from getType()->isDependentType(),
  /// because any class-returning reflections will still be dependent typed
  /// right up until all of their arguments are determined, because
  /// the return type of such reflection traits will be a template instance
  /// specific to the exact return value or pointer.
  constexpr bool callbacksAreSet() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::callbacksAreSet, Xs...); }) , (;) )
  /// @returns whether the type is a string literal type AND the Args are all
  /// non-dependent (in which case the callbacks should also be set).
  /// isa<StringLiteral>(this) will return true if this is true.
  constexpr bool readyToConvertToStringLiteral() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::readyToConvertToStringLiteral, Xs...); }) , (;) )
  ///Is the queried object a pointer or a value? (E.g. querying
  /// a Decl *: IsPtr=true, querying a SourceLocation: IsPtr=false)
  constexpr unsigned int getMemNum() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::getMemNum, Xs...); }) , (;) )
  ///Is the queried object a pointer or a value? (E.g. querying
  /// a Decl *: IsPtr=true, querying a SourceLocation: IsPtr=false)
  constexpr bool isPtr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::isPtr, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectionTraitExpr, reflenums::clang__ReflectionTraitExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// An expression allocating and reflecting a new object,
/// for now always a container of some sort (vector, map, set)
M_template_rtpack(Xs)
struct clang::ReflectNewExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ReflectNewExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ReflectNewExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Returns the arity of the trait.
  constexpr unsigned int getNumArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectNewExpr, reflenums::clang__ReflectNewExpr::getNumArgs, Xs...); }) , (;) )
  /// Returns the ith argument of the reflection trait.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getArg(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectNewExpr, reflenums::clang__ReflectNewExpr::getArg, Xs..., I); }) , (;) )
  /// \brief Returns the array of arguments.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr **) )
  getArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectNewExpr, reflenums::clang__ReflectNewExpr::getArgs, Xs...); }) , (;) )
  constexpr unsigned int getObjKind() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectNewExpr, reflenums::clang__ReflectNewExpr::getObjKind, Xs...); }) , (;) )
  /// Returns the source code location of the trait keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTraitLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectNewExpr, reflenums::clang__ReflectNewExpr::getTraitLoc, Xs...); }) , (;) )
  /// Returns the source code location of the closing parenthesis.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectNewExpr, reflenums::clang__ReflectNewExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectNewExpr, reflenums::clang__ReflectNewExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectNewExpr, reflenums::clang__ReflectNewExpr::getLocEnd, Xs...); }) , (;) )
};

/// An expression deleting a pointer allocated via a
/// ReflectNewExpr.
M_template_rtpack(Xs)
struct clang::ReflectDeleteExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ReflectDeleteExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ReflectDeleteExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Returns the arity of the trait.
  constexpr unsigned int getNumArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectDeleteExpr, reflenums::clang__ReflectDeleteExpr::getNumArgs, Xs...); }) , (;) )
  /// Returns the ith argument of the reflection trait.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getArg(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectDeleteExpr, reflenums::clang__ReflectDeleteExpr::getArg, Xs..., I); }) , (;) )
  /// \brief Returns the array of arguments.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr **) )
  getArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectDeleteExpr, reflenums::clang__ReflectDeleteExpr::getArgs, Xs...); }) , (;) )
  constexpr unsigned int getObjKind() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectDeleteExpr, reflenums::clang__ReflectDeleteExpr::getObjKind, Xs...); }) , (;) )
  /// Returns the source code location of the trait keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTraitLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectDeleteExpr, reflenums::clang__ReflectDeleteExpr::getTraitLoc, Xs...); }) , (;) )
  /// Returns the source code location of the closing parenthesis.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectDeleteExpr, reflenums::clang__ReflectDeleteExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectDeleteExpr, reflenums::clang__ReflectDeleteExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ReflectDeleteExpr, reflenums::clang__ReflectDeleteExpr::getLocEnd, Xs...); }) , (;) )
};

/// \brief Represents a compile-time value that was computed by a constant
//// expression.
M_template_rtpack(Xs)
struct clang::CXXConstantExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXConstantExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXConstantExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// \brief Returns the evaluated expression.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getExpression() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstantExpr, reflenums::clang__CXXConstantExpr::getExpression, Xs...); }) , (;) )
  /// \brief Returns the computed value.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::APValue &) )
  getValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstantExpr, reflenums::clang__CXXConstantExpr::getValue, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstantExpr, reflenums::clang__CXXConstantExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstantExpr, reflenums::clang__CXXConstantExpr::getLocEnd, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CXXConstantExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__CXXConstantExpr, reflenums::clang__CXXConstantExpr::children, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConstantExpr, reflenums::clang__CXXConstantExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// \brief Represents an id-expression of the form 'idexpr(args)'. Some
/// of the arguments in args are dependent.
M_template_rtpack(Xs)
struct clang::CXXDependentIdExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXDependentIdExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXDependentIdExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// \brief Returns the evaluated expression.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationNameInfo) )
  getNameInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentIdExpr, reflenums::clang__CXXDependentIdExpr::getNameInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentIdExpr, reflenums::clang__CXXDependentIdExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentIdExpr, reflenums::clang__CXXDependentIdExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentIdExpr, reflenums::clang__CXXDependentIdExpr::getSourceRange, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CXXDependentIdExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__CXXDependentIdExpr, reflenums::clang__CXXDependentIdExpr::children, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXDependentIdExpr, reflenums::clang__CXXDependentIdExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents the expression __concatenate(...)
M_template_rtpack(Xs)
struct clang::CXXConcatenateExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXConcatenateExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXConcatenateExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// \brief The number of captured declarations.
  constexpr unsigned long getNumOperands() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConcatenateExpr, reflenums::clang__CXXConcatenateExpr::getNumOperands, Xs...); }) , (;) )
  /// \brief The Ith capture of the injection statement.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getOperand(unsigned long I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConcatenateExpr, reflenums::clang__CXXConcatenateExpr::getOperand, Xs..., I); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *const *) )
  getOperands() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConcatenateExpr, reflenums::clang__CXXConcatenateExpr::getOperands, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CXXConcatenateExpr, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__CXXConcatenateExpr, reflenums::clang__CXXConcatenateExpr::children, Xs...), () )
  /// \brief The location of the introducer token.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getIntroLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConcatenateExpr, reflenums::clang__CXXConcatenateExpr::getIntroLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConcatenateExpr, reflenums::clang__CXXConcatenateExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConcatenateExpr, reflenums::clang__CXXConcatenateExpr::getLocEnd, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXConcatenateExpr, reflenums::clang__CXXConcatenateExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ObjCStringLiteral, used for Objective-C string literals
/// i.e. @"foo".
M_template_rtpack(Xs)
struct clang::ObjCStringLiteral::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCStringLiteral;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCStringLiteral::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::StringLiteral *) )
  getString() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCStringLiteral, reflenums::clang__ObjCStringLiteral::getString, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAtLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCStringLiteral, reflenums::clang__ObjCStringLiteral::getAtLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCStringLiteral, reflenums::clang__ObjCStringLiteral::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCStringLiteral, reflenums::clang__ObjCStringLiteral::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCStringLiteral, reflenums::clang__ObjCStringLiteral::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCStringLiteral, reflenums::clang__ObjCStringLiteral::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCStringLiteral, reflenums::clang__ObjCStringLiteral::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ObjCBoolLiteralExpr - Objective-C Boolean Literal.
M_template_rtpack(Xs)
struct clang::ObjCBoolLiteralExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCBoolLiteralExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCBoolLiteralExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool getValue() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoolLiteralExpr, reflenums::clang__ObjCBoolLiteralExpr::getValue, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoolLiteralExpr, reflenums::clang__ObjCBoolLiteralExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoolLiteralExpr, reflenums::clang__ObjCBoolLiteralExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoolLiteralExpr, reflenums::clang__ObjCBoolLiteralExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoolLiteralExpr, reflenums::clang__ObjCBoolLiteralExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoolLiteralExpr, reflenums::clang__ObjCBoolLiteralExpr::getLocation, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoolLiteralExpr, reflenums::clang__ObjCBoolLiteralExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ObjCBoxedExpr - used for generalized expression boxing.
/// as in: @(strdup("hello world")), @(random()) or @(view.frame)
/// Also used for boxing non-parenthesized numeric literals;
/// as in: @42 or \@true (c++/objc++) or \@__objc_yes (c/objc).
M_template_rtpack(Xs)
struct clang::ObjCBoxedExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCBoxedExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCBoxedExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSubExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoxedExpr, reflenums::clang__ObjCBoxedExpr::getSubExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getBoxingMethod() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoxedExpr, reflenums::clang__ObjCBoxedExpr::getBoxingMethod, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAtLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoxedExpr, reflenums::clang__ObjCBoxedExpr::getAtLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoxedExpr, reflenums::clang__ObjCBoxedExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoxedExpr, reflenums::clang__ObjCBoxedExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoxedExpr, reflenums::clang__ObjCBoxedExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoxedExpr, reflenums::clang__ObjCBoxedExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoxedExpr, reflenums::clang__ObjCBoxedExpr::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBoxedExpr, reflenums::clang__ObjCBoxedExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ObjCArrayLiteral - used for objective-c array containers; as in:
/// @[@"Hello", NSApp, [NSNumber numberWithInt:42]];
M_template_rtpack(Xs)
struct clang::ObjCArrayLiteral::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCArrayLiteral;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCArrayLiteral::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCArrayLiteral *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumElements) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCArrayLiteral, reflenums::clang__ObjCArrayLiteral::CreateEmpty, Xs..., Y0s..., NumElements); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCArrayLiteral, reflenums::clang__ObjCArrayLiteral::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCArrayLiteral, reflenums::clang__ObjCArrayLiteral::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCArrayLiteral, reflenums::clang__ObjCArrayLiteral::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCArrayLiteral, reflenums::clang__ObjCArrayLiteral::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCArrayLiteral, reflenums::clang__ObjCArrayLiteral::getSourceRange, Xs...); }) , (;) )
  /// Retrieve elements of array of literals.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *const *) )
  getElements() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCArrayLiteral, reflenums::clang__ObjCArrayLiteral::getElements, Xs...); }) , (;) )
  /// getNumElements - Return number of elements of objective-c array literal.
  constexpr unsigned int getNumElements() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCArrayLiteral, reflenums::clang__ObjCArrayLiteral::getNumElements, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getElement(unsigned int Index) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCArrayLiteral, reflenums::clang__ObjCArrayLiteral::getElement, Xs..., Index); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getArrayWithObjectsMethod() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCArrayLiteral, reflenums::clang__ObjCArrayLiteral::getArrayWithObjectsMethod, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCArrayLiteral, reflenums::clang__ObjCArrayLiteral::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// An element in an Objective-C dictionary literal.
///
M_template_rtpack(Xs)
struct clang::ObjCDictionaryElement::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCDictionaryElement;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCDictionaryElement::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// The key for the dictionary element.
  M_REFLTYPED_FIELD(Key, (typename meta::clang::Expr *), __reflect_prop(reflenums::RK_clang__ObjCDictionaryElement, reflenums::clang__ObjCDictionaryElement::Key, Xs...))
  /// The value of the dictionary element.
  M_REFLTYPED_FIELD(Value, (typename meta::clang::Expr *), __reflect_prop(reflenums::RK_clang__ObjCDictionaryElement, reflenums::clang__ObjCDictionaryElement::Value, Xs...))
  /// The location of the ellipsis, if this is a pack expansion.
  M_REFLTYPED_FIELD(EllipsisLoc, (typename meta::clang::SourceLocation), __reflect_prop(reflenums::RK_clang__ObjCDictionaryElement, reflenums::clang__ObjCDictionaryElement::EllipsisLoc, Xs...))
  /// Determines whether this dictionary element is a pack expansion.
  constexpr bool isPackExpansion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCDictionaryElement, reflenums::clang__ObjCDictionaryElement::isPackExpansion, Xs...); }) , (;) )
};

/// ObjCDictionaryLiteral - AST node to represent objective-c dictionary
/// literals; as in:  @{@"name" : NSUserName(), @"date" : [NSDate date] };
M_template_rtpack(Xs)
struct clang::ObjCDictionaryLiteral::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCDictionaryLiteral;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCDictionaryLiteral::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCDictionaryLiteral *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumElements, bool HasPackExpansions) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCDictionaryLiteral, reflenums::clang__ObjCDictionaryLiteral::CreateEmpty, Xs..., Y0s..., NumElements, HasPackExpansions); }) , (;) )
  /// getNumElements - Return number of elements of objective-c dictionary
  /// literal.
  constexpr unsigned int getNumElements() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCDictionaryLiteral, reflenums::clang__ObjCDictionaryLiteral::getNumElements, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCDictionaryElement) )
  getKeyValueElement(unsigned int Index) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCDictionaryLiteral, reflenums::clang__ObjCDictionaryLiteral::getKeyValueElement, Xs..., Index); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getDictWithObjectsMethod() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCDictionaryLiteral, reflenums::clang__ObjCDictionaryLiteral::getDictWithObjectsMethod, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCDictionaryLiteral, reflenums::clang__ObjCDictionaryLiteral::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCDictionaryLiteral, reflenums::clang__ObjCDictionaryLiteral::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCDictionaryLiteral, reflenums::clang__ObjCDictionaryLiteral::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCDictionaryLiteral, reflenums::clang__ObjCDictionaryLiteral::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCDictionaryLiteral, reflenums::clang__ObjCDictionaryLiteral::getSourceRange, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCDictionaryLiteral, reflenums::clang__ObjCDictionaryLiteral::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ObjCEncodeExpr, used for \@encode in Objective-C.  \@encode has the same
/// type and behavior as StringLiteral except that the string initializer is
/// obtained from ASTContext with the encoding type as an argument.
M_template_rtpack(Xs)
struct clang::ObjCEncodeExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCEncodeExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCEncodeExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAtLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCEncodeExpr, reflenums::clang__ObjCEncodeExpr::getAtLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCEncodeExpr, reflenums::clang__ObjCEncodeExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getEncodedType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCEncodeExpr, reflenums::clang__ObjCEncodeExpr::getEncodedType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getEncodedTypeSourceInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCEncodeExpr, reflenums::clang__ObjCEncodeExpr::getEncodedTypeSourceInfo, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCEncodeExpr, reflenums::clang__ObjCEncodeExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCEncodeExpr, reflenums::clang__ObjCEncodeExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCEncodeExpr, reflenums::clang__ObjCEncodeExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCEncodeExpr, reflenums::clang__ObjCEncodeExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCEncodeExpr, reflenums::clang__ObjCEncodeExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ObjCSelectorExpr used for \@selector in Objective-C.
M_template_rtpack(Xs)
struct clang::ObjCSelectorExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCSelectorExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCSelectorExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Selector) )
  getSelector() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSelectorExpr, reflenums::clang__ObjCSelectorExpr::getSelector, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAtLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSelectorExpr, reflenums::clang__ObjCSelectorExpr::getAtLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSelectorExpr, reflenums::clang__ObjCSelectorExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSelectorExpr, reflenums::clang__ObjCSelectorExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSelectorExpr, reflenums::clang__ObjCSelectorExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSelectorExpr, reflenums::clang__ObjCSelectorExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSelectorExpr, reflenums::clang__ObjCSelectorExpr::getEndLoc, Xs...); }) , (;) )
  /// getNumArgs - Return the number of actual arguments to this call.
  constexpr unsigned int getNumArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSelectorExpr, reflenums::clang__ObjCSelectorExpr::getNumArgs, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSelectorExpr, reflenums::clang__ObjCSelectorExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ObjCProtocolExpr used for protocol expression in Objective-C.
///
/// This is used as: \@protocol(foo), as in:
/// \code
///   [obj conformsToProtocol:@protocol(foo)]
/// \endcode
///
/// The return type is "Protocol*".
M_template_rtpack(Xs)
struct clang::ObjCProtocolExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCProtocolExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCProtocolExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCProtocolDecl *) )
  getProtocol() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolExpr, reflenums::clang__ObjCProtocolExpr::getProtocol, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getProtocolIdLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolExpr, reflenums::clang__ObjCProtocolExpr::getProtocolIdLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAtLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolExpr, reflenums::clang__ObjCProtocolExpr::getAtLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolExpr, reflenums::clang__ObjCProtocolExpr::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolExpr, reflenums::clang__ObjCProtocolExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolExpr, reflenums::clang__ObjCProtocolExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolExpr, reflenums::clang__ObjCProtocolExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolExpr, reflenums::clang__ObjCProtocolExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCProtocolExpr, reflenums::clang__ObjCProtocolExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ObjCIvarRefExpr - A reference to an ObjC instance variable.
M_template_rtpack(Xs)
struct clang::ObjCIvarRefExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCIvarRefExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCIvarRefExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCIvarDecl *) )
  getDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarRefExpr, reflenums::clang__ObjCIvarRefExpr::getDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarRefExpr, reflenums::clang__ObjCIvarRefExpr::getBase, Xs...); }) , (;) )
  constexpr bool isArrow() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarRefExpr, reflenums::clang__ObjCIvarRefExpr::isArrow, Xs...); }) , (;) )
  constexpr bool isFreeIvar() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarRefExpr, reflenums::clang__ObjCIvarRefExpr::isFreeIvar, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarRefExpr, reflenums::clang__ObjCIvarRefExpr::getLocation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarRefExpr, reflenums::clang__ObjCIvarRefExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarRefExpr, reflenums::clang__ObjCIvarRefExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarRefExpr, reflenums::clang__ObjCIvarRefExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarRefExpr, reflenums::clang__ObjCIvarRefExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOpLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarRefExpr, reflenums::clang__ObjCIvarRefExpr::getOpLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIvarRefExpr, reflenums::clang__ObjCIvarRefExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ObjCPropertyRefExpr - A dot-syntax expression to access an ObjC
/// property.
M_template_rtpack(Xs)
struct clang::ObjCPropertyRefExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCPropertyRefExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCPropertyRefExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool isImplicitProperty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::isImplicitProperty, Xs...); }) , (;) )
  constexpr bool isExplicitProperty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::isExplicitProperty, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCPropertyDecl *) )
  getExplicitProperty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getExplicitProperty, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getImplicitPropertyGetter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getImplicitPropertyGetter, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getImplicitPropertySetter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getImplicitPropertySetter, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Selector) )
  getGetterSelector() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getGetterSelector, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Selector) )
  getSetterSelector() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getSetterSelector, Xs...); }) , (;) )
  /// True if the property reference will result in a message to the
  /// getter.
  /// This applies to both implicit and explicit property references.
  constexpr bool isMessagingGetter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::isMessagingGetter, Xs...); }) , (;) )
  /// True if the property reference will result in a message to the
  /// setter.
  /// This applies to both implicit and explicit property references.
  constexpr bool isMessagingSetter() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::isMessagingSetter, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getBase, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getLocation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getReceiverLocation() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getReceiverLocation, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getSuperReceiverType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getSuperReceiverType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCInterfaceDecl *) )
  getClassReceiver() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getClassReceiver, Xs...); }) , (;) )
  constexpr bool isObjectReceiver() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::isObjectReceiver, Xs...); }) , (;) )
  constexpr bool isSuperReceiver() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::isSuperReceiver, Xs...); }) , (;) )
  constexpr bool isClassReceiver() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::isClassReceiver, Xs...); }) , (;) )
  /// Determine the type of the base, regardless of the kind of receiver.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getReceiverType(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) ctx) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getReceiverType, Xs..., Y0s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCPropertyRefExpr, reflenums::clang__ObjCPropertyRefExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ObjCSubscriptRefExpr - used for array and dictionary subscripting.
/// array[4] = array[3]; dictionary[key] = dictionary[alt_key];
M_template_rtpack(Xs)
struct clang::ObjCSubscriptRefExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCSubscriptRefExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCSubscriptRefExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRBracket() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSubscriptRefExpr, reflenums::clang__ObjCSubscriptRefExpr::getRBracket, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSubscriptRefExpr, reflenums::clang__ObjCSubscriptRefExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSubscriptRefExpr, reflenums::clang__ObjCSubscriptRefExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSubscriptRefExpr, reflenums::clang__ObjCSubscriptRefExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSubscriptRefExpr, reflenums::clang__ObjCSubscriptRefExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getBaseExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSubscriptRefExpr, reflenums::clang__ObjCSubscriptRefExpr::getBaseExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getKeyExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSubscriptRefExpr, reflenums::clang__ObjCSubscriptRefExpr::getKeyExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  getAtIndexMethodDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSubscriptRefExpr, reflenums::clang__ObjCSubscriptRefExpr::getAtIndexMethodDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMethodDecl *) )
  setAtIndexMethodDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSubscriptRefExpr, reflenums::clang__ObjCSubscriptRefExpr::setAtIndexMethodDecl, Xs...); }) , (;) )
  constexpr bool isArraySubscriptRefExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSubscriptRefExpr, reflenums::clang__ObjCSubscriptRefExpr::isArraySubscriptRefExpr, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCSubscriptRefExpr, reflenums::clang__ObjCSubscriptRefExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// The kind of receiver this message is sending to.
enum clang::ObjCMessageExpr::ReceiverKind : unsigned int {
  /// The receiver is a class.
  Class = 0,
  /// The receiver is an object instance.
  Instance,
  /// The receiver is a superclass.
  SuperClass,
  /// The receiver is the instance of the superclass object.
  SuperInstance,
};

/// An expression that sends a message to the given Objective-C
/// object or class.
///
/// The following contains two message send expressions:
///
/// \code
///   [[NSString alloc] initWithString:@"Hello"]
/// \endcode
///
/// The innermost message send invokes the "alloc" class method on the
/// NSString class, while the outermost message send invokes the
/// "initWithString" instance method on the object returned from
/// NSString's "alloc". In all, an Objective-C message send can take
/// on four different (although related) forms:
///
///   1. Send to an object instance.
///   2. Send to a class.
///   3. Send to the superclass instance of the current class.
///   4. Send to the superclass of the current class.
///
/// All four kinds of message sends are modeled by the ObjCMessageExpr
/// class, and can be distinguished via \c getReceiverKind(). Example:
///
/// The "void *" trailing objects are actually ONE void * (the
/// receiver pointer), and NumArgs Expr *. But due to the
/// implementation of children(), these must be together contiguously.
M_template_rtpack(Xs)
struct clang::ObjCMessageExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCMessageExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCMessageExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using ReceiverKind = enum refldetail::clang::ObjCMessageExpr::ReceiverKind;
  /// Create an empty Objective-C message expression, to be
  /// filled in by subsequent calls.
  ///
  /// \param Context The context in which the message send will be created.
  ///
  /// \param NumArgs The number of message arguments, not including
  /// the receiver.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCMessageExpr *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, unsigned int NumArgs, unsigned int NumStoredSelLocs) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::CreateEmpty, Xs..., Y0s..., NumArgs, NumStoredSelLocs); }) , (;) )
  /// Indicates whether the message send was implicitly
  /// generated by the implementation. If false, it was written explicitly
  /// in the source code.
  constexpr bool isImplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::isImplicit, Xs...); }) , (;) )
  /// Determine the kind of receiver that this message is being
  /// sent to.
  constexpr enum clang::ObjCMessageExpr::ReceiverKind getReceiverKind() const IFMETA_ELSE( ({    return (enum clang::ObjCMessageExpr::ReceiverKind)__reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getReceiverKind, Xs...); }) , (;) )
  /// Source range of the receiver.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getReceiverRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getReceiverRange, Xs...); }) , (;) )
  /// Determine whether this is an instance message to either a
  /// computed object or to super.
  constexpr bool isInstanceMessage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::isInstanceMessage, Xs...); }) , (;) )
  /// Determine whether this is an class message to either a
  /// specified class or to super.
  constexpr bool isClassMessage() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::isClassMessage, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getInstanceReceiver() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getInstanceReceiver, Xs...); }) , (;) )
  /// Returns the type of a class message send, or NULL if the
  /// message is not a class message.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getClassReceiver() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getClassReceiver, Xs...); }) , (;) )
  /// Returns a type-source information of a class message
  /// send, or nullptr if the message is not a class message.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::TypeSourceInfo *) )
  getClassReceiverTypeInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getClassReceiverTypeInfo, Xs...); }) , (;) )
  /// Retrieve the location of the 'super' keyword for a class
  /// or instance message to 'super', otherwise an invalid source location.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getSuperLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getSuperLoc, Xs...); }) , (;) )
  /// Retrieve the receiver type to which this message is being directed.
  ///
  /// This routine cross-cuts all of the different kinds of message
  /// sends to determine what the underlying (statically known) type
  /// of the receiver will be; use \c getReceiverKind() to determine
  /// whether the message is a class or an instance method, whether it
  /// is a send to super or not, etc.
  ///
  /// \returns The type of the receiver.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getReceiverType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getReceiverType, Xs...); }) , (;) )
  /// Retrieve the Objective-C interface to which this message
  /// is being directed, if known.
  ///
  /// This routine cross-cuts all of the different kinds of message
  /// sends to determine what the underlying (statically known) type
  /// of the receiver will be; use \c getReceiverKind() to determine
  /// whether the message is a class or an instance method, whether it
  /// is a send to super or not, etc.
  ///
  /// \returns The Objective-C interface if known, otherwise nullptr.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCInterfaceDecl *) )
  getReceiverInterface() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getReceiverInterface, Xs...); }) , (;) )
  /// Retrieve the type referred to by 'super'.
  ///
  /// The returned type will either be an ObjCInterfaceType (for an
  /// class message to super) or an ObjCObjectPointerType that refers
  /// to a class (for an instance message to super);
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getSuperType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getSuperType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Selector) )
  getSelector() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getSelector, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCMethodDecl *) )
  getMethodDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getMethodDecl, Xs...); }) , (;) )
  constexpr enum clang::ObjCMethodFamily getMethodFamily() const IFMETA_ELSE( ({    return (enum clang::ObjCMethodFamily)__reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getMethodFamily, Xs...); }) , (;) )
  /// Return the number of actual arguments in this message,
  /// not counting the receiver.
  constexpr unsigned int getNumArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getNumArgs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *const *) )
  getArgs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getArgs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getArg(unsigned int Arg) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getArg, Xs..., Arg); }) , (;) )
  /// isDelegateInitCall - Answers whether this message send has been
  /// tagged as a "delegate init call", i.e. a call to a method in the
  /// -init family on self from within an -init method implementation.
  constexpr bool isDelegateInitCall() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::isDelegateInitCall, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLeftLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getLeftLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRightLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getRightLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getSelectorStartLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getSelectorStartLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getSelectorLoc(unsigned int Index) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getSelectorLoc, Xs..., Index); }) , (;) )
  constexpr unsigned int getNumSelectorLocs() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getNumSelectorLocs, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::getEndLoc, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::ObjCMessageExpr, arguments,
      constexpr auto arguments() const ,
      (const typename meta::clang::Expr *const),
      (reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::arguments, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCMessageExpr, reflenums::clang__ObjCMessageExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ObjCIsaExpr - Represent X->isa and X.isa when X is an ObjC 'id' type.
/// (similar in spirit to MemberExpr).
M_template_rtpack(Xs)
struct clang::ObjCIsaExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCIsaExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCIsaExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIsaExpr, reflenums::clang__ObjCIsaExpr::getBase, Xs...); }) , (;) )
  constexpr bool isArrow() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIsaExpr, reflenums::clang__ObjCIsaExpr::isArrow, Xs...); }) , (;) )
  /// getMemberLoc - Return the location of the "member", in X->F, it is the
  /// location of 'F'.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getIsaMemberLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIsaExpr, reflenums::clang__ObjCIsaExpr::getIsaMemberLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getOpLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIsaExpr, reflenums::clang__ObjCIsaExpr::getOpLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIsaExpr, reflenums::clang__ObjCIsaExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIsaExpr, reflenums::clang__ObjCIsaExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBaseLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIsaExpr, reflenums::clang__ObjCIsaExpr::getBaseLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIsaExpr, reflenums::clang__ObjCIsaExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIsaExpr, reflenums::clang__ObjCIsaExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIsaExpr, reflenums::clang__ObjCIsaExpr::getExprLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIsaExpr, reflenums::clang__ObjCIsaExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// ObjCIndirectCopyRestoreExpr - Represents the passing of a function
/// argument by indirect copy-restore in ARC.  This is used to support
/// passing indirect arguments with the wrong lifetime, e.g. when
/// passing the address of a __strong local variable to an 'out'
/// parameter.  This expression kind is only valid in an "argument"
/// position to some sort of call expression.
///
/// The parameter must have type 'pointer to T', and the argument must
/// have type 'pointer to U', where T and U agree except possibly in
/// qualification.  If the argument value is null, then a null pointer
/// is passed;  otherwise it points to an object A, and:
/// 1. A temporary object B of type T is initialized, either by
///    zero-initialization (used when initializing an 'out' parameter)
///    or copy-initialization (used when initializing an 'inout'
///    parameter).
/// 2. The address of the temporary is passed to the function.
/// 3. If the call completes normally, A is move-assigned from B.
/// 4. Finally, A is destroyed immediately.
///
/// Currently 'T' must be a retainable object lifetime and must be
/// __autoreleasing;  this qualifier is ignored when initializing
/// the value.
M_template_rtpack(Xs)
struct clang::ObjCIndirectCopyRestoreExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCIndirectCopyRestoreExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCIndirectCopyRestoreExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSubExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIndirectCopyRestoreExpr, reflenums::clang__ObjCIndirectCopyRestoreExpr::getSubExpr, Xs...); }) , (;) )
  /// shouldCopy - True if we should do the 'copy' part of the
  /// copy-restore.  If false, the temporary will be zero-initialized.
  constexpr bool shouldCopy() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIndirectCopyRestoreExpr, reflenums::clang__ObjCIndirectCopyRestoreExpr::shouldCopy, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIndirectCopyRestoreExpr, reflenums::clang__ObjCIndirectCopyRestoreExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIndirectCopyRestoreExpr, reflenums::clang__ObjCIndirectCopyRestoreExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIndirectCopyRestoreExpr, reflenums::clang__ObjCIndirectCopyRestoreExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIndirectCopyRestoreExpr, reflenums::clang__ObjCIndirectCopyRestoreExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIndirectCopyRestoreExpr, reflenums::clang__ObjCIndirectCopyRestoreExpr::getExprLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) s) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCIndirectCopyRestoreExpr, reflenums::clang__ObjCIndirectCopyRestoreExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// An Objective-C "bridged" cast expression, which casts between
/// Objective-C pointers and C pointers, transferring ownership in the process.
///
/// \code
/// NSString *str = (__bridge_transfer NSString *)CFCreateString();
/// \endcode
M_template_rtpack(Xs)
struct clang::ObjCBridgedCastExpr::impl : impl_offset_t<clang::ExplicitCastExpr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCBridgedCastExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCBridgedCastExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBridgedCastExpr, reflenums::clang__ObjCBridgedCastExpr::getLParenLoc, Xs...); }) , (;) )
  /// Determine which kind of bridge is being performed via this cast.
  constexpr enum clang::ObjCBridgeCastKind getBridgeKind() const IFMETA_ELSE( ({    return (enum clang::ObjCBridgeCastKind)__reflect_prop(reflenums::RK_clang__ObjCBridgedCastExpr, reflenums::clang__ObjCBridgedCastExpr::getBridgeKind, Xs...); }) , (;) )
  /// Retrieve the kind of bridge being performed as a string.
  constexpr const char * getBridgeKindName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBridgedCastExpr, reflenums::clang__ObjCBridgedCastExpr::getBridgeKindName, Xs...); }) , (;) )
  /// The location of the bridge keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBridgeKeywordLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBridgedCastExpr, reflenums::clang__ObjCBridgedCastExpr::getBridgeKeywordLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBridgedCastExpr, reflenums::clang__ObjCBridgedCastExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBridgedCastExpr, reflenums::clang__ObjCBridgedCastExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBridgedCastExpr, reflenums::clang__ObjCBridgedCastExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBridgedCastExpr, reflenums::clang__ObjCBridgedCastExpr::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCBridgedCastExpr, reflenums::clang__ObjCBridgedCastExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// A runtime availability query.
///
/// There are 2 ways to spell this node:
/// \code
///   @available(macos 10.10, ios 8, *); // Objective-C
///   __builtin_available(macos 10.10, ios 8, *); // C, C++, and Objective-C
/// \endcode
///
/// Note that we only need to keep track of one \c VersionTuple here, which is
/// the one that corresponds to the current deployment target. This is meant to
/// be used in the condition of an \c if, but it is also usable as top level
/// expressions.
///
M_template_rtpack(Xs)
struct clang::ObjCAvailabilityCheckExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCAvailabilityCheckExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCAvailabilityCheckExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAvailabilityCheckExpr, reflenums::clang__ObjCAvailabilityCheckExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAvailabilityCheckExpr, reflenums::clang__ObjCAvailabilityCheckExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAvailabilityCheckExpr, reflenums::clang__ObjCAvailabilityCheckExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAvailabilityCheckExpr, reflenums::clang__ObjCAvailabilityCheckExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceRange) )
  getSourceRange() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAvailabilityCheckExpr, reflenums::clang__ObjCAvailabilityCheckExpr::getSourceRange, Xs...); }) , (;) )
  /// This may be '*', in which case this should fold to true.
  constexpr bool hasVersion() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAvailabilityCheckExpr, reflenums::clang__ObjCAvailabilityCheckExpr::hasVersion, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAvailabilityCheckExpr, reflenums::clang__ObjCAvailabilityCheckExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// OpenMP 4.0 [2.4, Array Sections].
/// To specify an array section in an OpenMP construct, array subscript
/// expressions are extended with the following syntax:
/// \code
/// [ lower-bound : length ]
/// [ lower-bound : ]
/// [ : length ]
/// [ : ]
/// \endcode
/// The array section must be a subset of the original array.
/// Array sections are allowed on multidimensional arrays. Base language array
/// subscript expressions can be used to specify length-one dimensions of
/// multidimensional array sections.
/// The lower-bound and length are integral type expressions. When evaluated
/// they represent a set of integer values as follows:
/// \code
/// { lower-bound, lower-bound + 1, lower-bound + 2,... , lower-bound + length -
/// 1 }
/// \endcode
/// The lower-bound and length must evaluate to non-negative integers.
/// When the size of the array dimension is not known, the length must be
/// specified explicitly.
/// When the length is absent, it defaults to the size of the array dimension
/// minus the lower-bound.
/// When the lower-bound is absent it defaults to 0.
M_template_rtpack(Xs)
struct clang::OMPArraySectionExpr::impl : impl_offset_t<clang::Expr, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPArraySectionExpr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPArraySectionExpr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getBase() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPArraySectionExpr, reflenums::clang__OMPArraySectionExpr::getBase, Xs...); }) , (;) )
  /// Return original type of the base expression for array section.
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBaseOriginalType(IFMETA_ELSE((const clang::Expr::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Expr *)) Base) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPArraySectionExpr, reflenums::clang__OMPArraySectionExpr::getBaseOriginalType, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getBaseOriginalType(ptrwrp<Y0> p0) {
      return getBaseOriginalType(p0.get());
  }), () )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getLowerBound() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPArraySectionExpr, reflenums::clang__OMPArraySectionExpr::getLowerBound, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getLength() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPArraySectionExpr, reflenums::clang__OMPArraySectionExpr::getLength, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPArraySectionExpr, reflenums::clang__OMPArraySectionExpr::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPArraySectionExpr, reflenums::clang__OMPArraySectionExpr::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPArraySectionExpr, reflenums::clang__OMPArraySectionExpr::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPArraySectionExpr, reflenums::clang__OMPArraySectionExpr::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getColonLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPArraySectionExpr, reflenums::clang__OMPArraySectionExpr::getColonLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRBracketLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPArraySectionExpr, reflenums::clang__OMPArraySectionExpr::getRBracketLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getExprLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPArraySectionExpr, reflenums::clang__OMPArraySectionExpr::getExprLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPArraySectionExpr, reflenums::clang__OMPArraySectionExpr::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// CXXCatchStmt - This represents a C++ catch block.
///
M_template_rtpack(Xs)
struct clang::CXXCatchStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXCatchStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXCatchStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCatchStmt, reflenums::clang__CXXCatchStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCatchStmt, reflenums::clang__CXXCatchStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCatchStmt, reflenums::clang__CXXCatchStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCatchStmt, reflenums::clang__CXXCatchStmt::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getCatchLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCatchStmt, reflenums::clang__CXXCatchStmt::getCatchLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getExceptionDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCatchStmt, reflenums::clang__CXXCatchStmt::getExceptionDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getCaughtType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCatchStmt, reflenums::clang__CXXCatchStmt::getCaughtType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getHandlerBlock() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCatchStmt, reflenums::clang__CXXCatchStmt::getHandlerBlock, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXCatchStmt, reflenums::clang__CXXCatchStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// CXXTryStmt - A C++ try block, including all handlers.
///
M_template_rtpack(Xs)
struct clang::CXXTryStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXTryStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXTryStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CXXTryStmt *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) Empty, unsigned int numHandlers) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTryStmt, reflenums::clang__CXXTryStmt::Create, Xs..., Y0s..., Y1s..., numHandlers); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTryStmt, reflenums::clang__CXXTryStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTryStmt, reflenums::clang__CXXTryStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTryStmt, reflenums::clang__CXXTryStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getTryLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTryStmt, reflenums::clang__CXXTryStmt::getTryLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTryStmt, reflenums::clang__CXXTryStmt::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CompoundStmt *) )
  getTryBlock() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTryStmt, reflenums::clang__CXXTryStmt::getTryBlock, Xs...); }) , (;) )
  constexpr unsigned int getNumHandlers() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTryStmt, reflenums::clang__CXXTryStmt::getNumHandlers, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CXXCatchStmt *) )
  getHandler(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTryStmt, reflenums::clang__CXXTryStmt::getHandler, Xs..., i); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTryStmt, reflenums::clang__CXXTryStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// CXXForRangeStmt - This represents C++0x [stmt.ranged]'s ranged for
/// statement, represented as 'for (range-declarator : range-expression)'.
///
/// This is stored in a partially-desugared form to allow full semantic
/// analysis of the constituent components. The original syntactic components
/// can be extracted using getLoopVariable and getRangeInit.
M_template_rtpack(Xs)
struct clang::CXXForRangeStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXForRangeStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXForRangeStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarDecl *) )
  getLoopVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getLoopVariable, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getRangeInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getRangeInit, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclStmt *) )
  getRangeStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getRangeStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclStmt *) )
  getBeginStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getBeginStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclStmt *) )
  getEndStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getEndStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getCond() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getCond, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getInc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getInc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::DeclStmt *) )
  getLoopVarStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getLoopVarStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getBody, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getForLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getForLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getCoawaitLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getCoawaitLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getColonLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getColonLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXForRangeStmt, reflenums::clang__CXXForRangeStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// \brief The base class of tuple and pack expansion statements.
///
/// Tuple and pack expansion statements have the following form:
///
/// \verbatim
///   for (auto x : expandable) statement
/// \endverbatim
///
/// The "expandable" expression is either a tuple-like construct or an
/// unexpanded parameter pack.
M_template_rtpack(Xs)
struct clang::CXXExpansionStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXExpansionStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXExpansionStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// \brief Returns the statement containing the range declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getRangeVarStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getRangeVarStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarDecl *) )
  getRangeVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getRangeVariable, Xs...); }) , (;) )
  /// \brief Returns the dependent loop variable declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclStmt *) )
  getLoopVarStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getLoopVarStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarDecl *) )
  getLoopVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getLoopVariable, Xs...); }) , (;) )
  /// \brief Returns the parsed body of the loop.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getBody, Xs...); }) , (;) )
  /// \brief Returns the number of instantiated statements.
  constexpr unsigned long getSize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getSize, Xs...); }) , (;) )
  /// \brief Returns the sequence of instantiated statements.
  RANGE_REFLECTION(clang::CXXExpansionStmt, getInstantiatedStatements,
      constexpr auto getInstantiatedStatements() const ,
      (typename meta::clang::Stmt *),
      (reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getInstantiatedStatements, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getForLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getForLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEllipsisLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getEllipsisLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getColonLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getColonLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::getLocEnd, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXExpansionStmt, reflenums::clang__CXXExpansionStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// \brief Represents the expansion of a loop body for each element of a tuple.
///
/// For example:
///
/// \code
///   for (auto x : make_tuple(0, 1.2, "3"_s)) cout << x;
/// \endcode
///
/// Internally, the statement is represented in a partially desugared form like
/// this:
///
/// \verbatim
///   {
///     auto&& __tuple = range-init;
///     for<int __N> {
///       for-range-declaration = get<__N>(__tuple);
///       statement
///   }
/// \endverbatim
///
/// When the loop is finished (i.e., after parsing or instantiation), the
/// inner block of the \c for\<\> is expanded for each value \c __N from 0 to
/// the number of elements determined from the type of \c __tuple.
M_template_rtpack(Xs)
struct clang::CXXTupleExpansionStmt::impl : impl_offset_t<clang::CXXExpansionStmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXTupleExpansionStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXTupleExpansionStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// \brief Returns the statement containing the range declaration.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclStmt *) )
  getRangeVarStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTupleExpansionStmt, reflenums::clang__CXXTupleExpansionStmt::getRangeVarStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getRangeInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTupleExpansionStmt, reflenums::clang__CXXTupleExpansionStmt::getRangeInit, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXTupleExpansionStmt, reflenums::clang__CXXTupleExpansionStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// \brief Represents the expansion of a parameter pack over a loop body.
M_template_rtpack(Xs)
struct clang::CXXPackExpansionStmt::impl : impl_offset_t<clang::CXXExpansionStmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXPackExpansionStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXPackExpansionStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getUnexpandedPack() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPackExpansionStmt, reflenums::clang__CXXPackExpansionStmt::getUnexpandedPack, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXPackExpansionStmt, reflenums::clang__CXXPackExpansionStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Representation of a Microsoft __if_exists or __if_not_exists
/// statement with a dependent name.
///
/// The __if_exists statement can be used to include a sequence of statements
/// in the program only when a particular dependent name does not exist. For
/// example:
///
/// \code
/// template<typename T>
/// void call_foo(T &t) {
///   __if_exists (T::foo) {
///     t.foo(); // okay: only called when T::foo exists.
///   }
/// }
/// \endcode
///
/// Similarly, the __if_not_exists statement can be used to include the
/// statements when a particular name does not exist.
///
/// Note that this statement only captures __if_exists and __if_not_exists
/// statements whose name is dependent. All non-dependent cases are handled
/// directly in the parser, so that they don't introduce a new scope. Clang
/// introduces scopes in the dependent case to keep names inside the compound
/// statement from leaking out into the surround statements, which would
/// compromise the template instantiation model. This behavior differs from
/// Visual C++ (which never introduces a scope), but is a fairly reasonable
/// approximation of the VC++ behavior.
M_template_rtpack(Xs)
struct clang::MSDependentExistsStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__MSDependentExistsStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::MSDependentExistsStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Retrieve the location of the __if_exists or __if_not_exists
  /// keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getKeywordLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSDependentExistsStmt, reflenums::clang__MSDependentExistsStmt::getKeywordLoc, Xs...); }) , (;) )
  /// Determine whether this is an __if_exists statement.
  constexpr bool isIfExists() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSDependentExistsStmt, reflenums::clang__MSDependentExistsStmt::isIfExists, Xs...); }) , (;) )
  /// Determine whether this is an __if_exists statement.
  constexpr bool isIfNotExists() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSDependentExistsStmt, reflenums::clang__MSDependentExistsStmt::isIfNotExists, Xs...); }) , (;) )
  /// Retrieve the nested-name-specifier that qualifies this name, if
  /// any.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NestedNameSpecifierLoc) )
  getQualifierLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSDependentExistsStmt, reflenums::clang__MSDependentExistsStmt::getQualifierLoc, Xs...); }) , (;) )
  /// Retrieve the name of the entity we're testing for, along with
  /// location information
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationNameInfo) )
  getNameInfo() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSDependentExistsStmt, reflenums::clang__MSDependentExistsStmt::getNameInfo, Xs...); }) , (;) )
  /// Retrieve the compound statement that will be included in the
  /// program only if the existence of the symbol matches the initial keyword.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::CompoundStmt *) )
  getSubStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSDependentExistsStmt, reflenums::clang__MSDependentExistsStmt::getSubStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSDependentExistsStmt, reflenums::clang__MSDependentExistsStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSDependentExistsStmt, reflenums::clang__MSDependentExistsStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSDependentExistsStmt, reflenums::clang__MSDependentExistsStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSDependentExistsStmt, reflenums::clang__MSDependentExistsStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__MSDependentExistsStmt, reflenums::clang__MSDependentExistsStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents the body of a coroutine. This wraps the normal function
/// body and holds the additional semantic context required to set up and tear
/// down the coroutine frame.
M_template_rtpack(Xs)
struct clang::CoroutineBodyStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CoroutineBodyStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CoroutineBodyStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template_rtpack(Zs) using CtorArgs = struct refldetail::clang::CoroutineBodyStmt::CtorArgs::M_template impl M_targpack(Zs);
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CoroutineBodyStmt *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::CoroutineBodyStmt::CtorArgs::template impl</*ptrorref=*/1, Y1s...>), (const typename meta::clang::CoroutineBodyStmt::CtorArgs &)) Args) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::Create, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::CoroutineBodyStmt *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p1, unsigned int NumParams) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::Create1, Xs..., Y0s..., Y1s..., NumParams); }) , (;) )
  constexpr bool hasDependentPromiseType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::hasDependentPromiseType, Xs...); }) , (;) )
  /// Retrieve the body of the coroutine as written. This will be either
  /// a CompoundStmt or a TryStmt.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getBody, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getPromiseDeclStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getPromiseDeclStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::VarDecl *) )
  getPromiseDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getPromiseDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getInitSuspendStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getInitSuspendStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getFinalSuspendStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getFinalSuspendStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getExceptionHandler() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getExceptionHandler, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getFallthroughHandler() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getFallthroughHandler, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getAllocate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getAllocate, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getDeallocate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getDeallocate, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getReturnValueInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getReturnValueInit, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getResultDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getResultDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getReturnStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getReturnStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Stmt *) )
  getReturnStmtOnAllocFailure() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getReturnStmtOnAllocFailure, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::CoroutineBodyStmt, getParamMoves,
      constexpr auto getParamMoves() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getParamMoves, Xs...), () )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt, reflenums::clang__CoroutineBodyStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::CoroutineBodyStmt::CtorArgs::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CoroutineBodyStmt__CtorArgs;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CoroutineBodyStmt::CtorArgs::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_REFLTYPED_FIELD(Body, (typename meta::clang::Stmt *), __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt__CtorArgs, reflenums::clang__CoroutineBodyStmt__CtorArgs::Body, Xs...))
  M_REFLTYPED_FIELD(Promise, (typename meta::clang::Stmt *), __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt__CtorArgs, reflenums::clang__CoroutineBodyStmt__CtorArgs::Promise, Xs...))
  M_REFLTYPED_FIELD(InitialSuspend, (typename meta::clang::Expr *), __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt__CtorArgs, reflenums::clang__CoroutineBodyStmt__CtorArgs::InitialSuspend, Xs...))
  M_REFLTYPED_FIELD(FinalSuspend, (typename meta::clang::Expr *), __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt__CtorArgs, reflenums::clang__CoroutineBodyStmt__CtorArgs::FinalSuspend, Xs...))
  M_REFLTYPED_FIELD(OnException, (typename meta::clang::Stmt *), __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt__CtorArgs, reflenums::clang__CoroutineBodyStmt__CtorArgs::OnException, Xs...))
  M_REFLTYPED_FIELD(OnFallthrough, (typename meta::clang::Stmt *), __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt__CtorArgs, reflenums::clang__CoroutineBodyStmt__CtorArgs::OnFallthrough, Xs...))
  M_REFLTYPED_FIELD(Allocate, (typename meta::clang::Expr *), __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt__CtorArgs, reflenums::clang__CoroutineBodyStmt__CtorArgs::Allocate, Xs...))
  M_REFLTYPED_FIELD(Deallocate, (typename meta::clang::Expr *), __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt__CtorArgs, reflenums::clang__CoroutineBodyStmt__CtorArgs::Deallocate, Xs...))
  M_REFLTYPED_FIELD(ReturnValue, (typename meta::clang::Expr *), __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt__CtorArgs, reflenums::clang__CoroutineBodyStmt__CtorArgs::ReturnValue, Xs...))
  M_REFLTYPED_FIELD(ResultDecl, (typename meta::clang::Stmt *), __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt__CtorArgs, reflenums::clang__CoroutineBodyStmt__CtorArgs::ResultDecl, Xs...))
  M_REFLTYPED_FIELD(ReturnStmt, (typename meta::clang::Stmt *), __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt__CtorArgs, reflenums::clang__CoroutineBodyStmt__CtorArgs::ReturnStmt, Xs...))
  M_REFLTYPED_FIELD(ReturnStmtOnAllocFailure, (typename meta::clang::Stmt *), __reflect_prop(reflenums::RK_clang__CoroutineBodyStmt__CtorArgs, reflenums::clang__CoroutineBodyStmt__CtorArgs::ReturnStmtOnAllocFailure, Xs...))
};

/// Represents a 'co_return' statement in the C++ Coroutines TS.
///
/// This statament models the initialization of the coroutine promise
/// (encapsulating the eventual notional return value) from an expression
/// (or braced-init-list), followed by termination of the coroutine.
///
/// This initialization is modeled by the evaluation of the operand
/// followed by a call to one of:
///   <promise>.return_value(<operand>)
///   <promise>.return_void()
/// which we name the "promise call".
M_template_rtpack(Xs)
struct clang::CoreturnStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CoreturnStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CoreturnStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getKeywordLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoreturnStmt, reflenums::clang__CoreturnStmt::getKeywordLoc, Xs...); }) , (;) )
  /// Retrieve the operand of the 'co_return' statement. Will be nullptr
  /// if none was specified.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getOperand() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoreturnStmt, reflenums::clang__CoreturnStmt::getOperand, Xs...); }) , (;) )
  /// Retrieve the promise call that results from this 'co_return'
  /// statement. Will be nullptr if either the coroutine has not yet been
  /// finalized or the coroutine has no eventual return type.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getPromiseCall() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoreturnStmt, reflenums::clang__CoreturnStmt::getPromiseCall, Xs...); }) , (;) )
  constexpr bool isImplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoreturnStmt, reflenums::clang__CoreturnStmt::isImplicit, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoreturnStmt, reflenums::clang__CoreturnStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoreturnStmt, reflenums::clang__CoreturnStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoreturnStmt, reflenums::clang__CoreturnStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoreturnStmt, reflenums::clang__CoreturnStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CoreturnStmt, reflenums::clang__CoreturnStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents a C++ __queue_metaparse statement.
///
/// When evaluated, queues the new source code to be
/// lexed and processed at the end of the enclosing
/// constexpr declaration.
///
/// Example:
///
///     __queue_metaparse("int i = 3;");
///
M_template_rtpack(Xs)
struct clang::CXXQueueMetaparseStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__CXXQueueMetaparseStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::CXXQueueMetaparseStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// \brief The introduced source code as an expression (of a string literal/static char array).
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getNewSrcCode() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXQueueMetaparseStmt, reflenums::clang__CXXQueueMetaparseStmt::getNewSrcCode, Xs...); }) , (;) )
  /// \brief The location of introducer token.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getIntroLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXQueueMetaparseStmt, reflenums::clang__CXXQueueMetaparseStmt::getIntroLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXQueueMetaparseStmt, reflenums::clang__CXXQueueMetaparseStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXQueueMetaparseStmt, reflenums::clang__CXXQueueMetaparseStmt::getLocEnd, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__CXXQueueMetaparseStmt, reflenums::clang__CXXQueueMetaparseStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents Objective-C's collection statement.
///
/// This is represented as 'for (element 'in' collection-expression)' stmt.
M_template_rtpack(Xs)
struct clang::ObjCForCollectionStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCForCollectionStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCForCollectionStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getElement() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCForCollectionStmt, reflenums::clang__ObjCForCollectionStmt::getElement, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getCollection() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCForCollectionStmt, reflenums::clang__ObjCForCollectionStmt::getCollection, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCForCollectionStmt, reflenums::clang__ObjCForCollectionStmt::getBody, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getForLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCForCollectionStmt, reflenums::clang__ObjCForCollectionStmt::getForLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCForCollectionStmt, reflenums::clang__ObjCForCollectionStmt::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCForCollectionStmt, reflenums::clang__ObjCForCollectionStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCForCollectionStmt, reflenums::clang__ObjCForCollectionStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCForCollectionStmt, reflenums::clang__ObjCForCollectionStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCForCollectionStmt, reflenums::clang__ObjCForCollectionStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCForCollectionStmt, reflenums::clang__ObjCForCollectionStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents Objective-C's \@catch statement.
M_template_rtpack(Xs)
struct clang::ObjCAtCatchStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCAtCatchStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCAtCatchStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getCatchBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtCatchStmt, reflenums::clang__ObjCAtCatchStmt::getCatchBody, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::VarDecl *) )
  getCatchParamDecl() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtCatchStmt, reflenums::clang__ObjCAtCatchStmt::getCatchParamDecl, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAtCatchLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtCatchStmt, reflenums::clang__ObjCAtCatchStmt::getAtCatchLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getRParenLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtCatchStmt, reflenums::clang__ObjCAtCatchStmt::getRParenLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtCatchStmt, reflenums::clang__ObjCAtCatchStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtCatchStmt, reflenums::clang__ObjCAtCatchStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtCatchStmt, reflenums::clang__ObjCAtCatchStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtCatchStmt, reflenums::clang__ObjCAtCatchStmt::getEndLoc, Xs...); }) , (;) )
  constexpr bool hasEllipsis() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtCatchStmt, reflenums::clang__ObjCAtCatchStmt::hasEllipsis, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtCatchStmt, reflenums::clang__ObjCAtCatchStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents Objective-C's \@finally statement
M_template_rtpack(Xs)
struct clang::ObjCAtFinallyStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCAtFinallyStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCAtFinallyStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getFinallyBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtFinallyStmt, reflenums::clang__ObjCAtFinallyStmt::getFinallyBody, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtFinallyStmt, reflenums::clang__ObjCAtFinallyStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtFinallyStmt, reflenums::clang__ObjCAtFinallyStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtFinallyStmt, reflenums::clang__ObjCAtFinallyStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtFinallyStmt, reflenums::clang__ObjCAtFinallyStmt::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAtFinallyLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtFinallyStmt, reflenums::clang__ObjCAtFinallyStmt::getAtFinallyLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtFinallyStmt, reflenums::clang__ObjCAtFinallyStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents Objective-C's \@try ... \@catch ... \@finally statement.
M_template_rtpack(Xs)
struct clang::ObjCAtTryStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCAtTryStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCAtTryStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCAtTryStmt *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) atTryLoc, IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y2s...> *), (typename meta::clang::Stmt *)) atTryStmt, IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y3s...> * *), (typename meta::clang::Stmt **)) CatchStmts, unsigned int NumCatchStmts, IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::Stmt *)) atFinallyStmt) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtTryStmt, reflenums::clang__ObjCAtTryStmt::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., NumCatchStmts, Y4s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCAtTryStmt *) )
  Create(Y0 p0, Y1 p1, ptrwrp<Y2> p2, ptrwrp<Y3> p3, unsigned int p4, ptrwrp<Y4> p5) {
      return Create(p0, p1, p2.get(), p3.get(), p4, p5.get());
  }), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::ObjCAtTryStmt *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) Context, unsigned int NumCatchStmts, bool HasFinally) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtTryStmt, reflenums::clang__ObjCAtTryStmt::CreateEmpty, Xs..., Y0s..., NumCatchStmts, HasFinally); }) , (;) )
  /// Retrieve the location of the @ in the \@try.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAtTryLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtTryStmt, reflenums::clang__ObjCAtTryStmt::getAtTryLoc, Xs...); }) , (;) )
  /// Retrieve the \@try body.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getTryBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtTryStmt, reflenums::clang__ObjCAtTryStmt::getTryBody, Xs...); }) , (;) )
  /// Retrieve the number of \@catch statements in this try-catch-finally
  /// block.
  constexpr unsigned int getNumCatchStmts() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtTryStmt, reflenums::clang__ObjCAtTryStmt::getNumCatchStmts, Xs...); }) , (;) )
  /// Retrieve a \@catch statement.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCAtCatchStmt *) )
  getCatchStmt(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtTryStmt, reflenums::clang__ObjCAtTryStmt::getCatchStmt, Xs..., I); }) , (;) )
  /// Retrieve the \@finally statement, if any.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::ObjCAtFinallyStmt *) )
  getFinallyStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtTryStmt, reflenums::clang__ObjCAtTryStmt::getFinallyStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtTryStmt, reflenums::clang__ObjCAtTryStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtTryStmt, reflenums::clang__ObjCAtTryStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtTryStmt, reflenums::clang__ObjCAtTryStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtTryStmt, reflenums::clang__ObjCAtTryStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtTryStmt, reflenums::clang__ObjCAtTryStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents Objective-C's \@synchronized statement.
///
/// Example:
/// \code
///   @synchronized (sem) {
///     do-something;
///   }
/// \endcode
M_template_rtpack(Xs)
struct clang::ObjCAtSynchronizedStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCAtSynchronizedStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCAtSynchronizedStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAtSynchronizedLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtSynchronizedStmt, reflenums::clang__ObjCAtSynchronizedStmt::getAtSynchronizedLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CompoundStmt *) )
  getSynchBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtSynchronizedStmt, reflenums::clang__ObjCAtSynchronizedStmt::getSynchBody, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getSynchExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtSynchronizedStmt, reflenums::clang__ObjCAtSynchronizedStmt::getSynchExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtSynchronizedStmt, reflenums::clang__ObjCAtSynchronizedStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtSynchronizedStmt, reflenums::clang__ObjCAtSynchronizedStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtSynchronizedStmt, reflenums::clang__ObjCAtSynchronizedStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtSynchronizedStmt, reflenums::clang__ObjCAtSynchronizedStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtSynchronizedStmt, reflenums::clang__ObjCAtSynchronizedStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents Objective-C's \@throw statement.
M_template_rtpack(Xs)
struct clang::ObjCAtThrowStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCAtThrowStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCAtThrowStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getThrowExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtThrowStmt, reflenums::clang__ObjCAtThrowStmt::getThrowExpr, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getThrowLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtThrowStmt, reflenums::clang__ObjCAtThrowStmt::getThrowLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtThrowStmt, reflenums::clang__ObjCAtThrowStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtThrowStmt, reflenums::clang__ObjCAtThrowStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtThrowStmt, reflenums::clang__ObjCAtThrowStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtThrowStmt, reflenums::clang__ObjCAtThrowStmt::getEndLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAtThrowStmt, reflenums::clang__ObjCAtThrowStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// Represents Objective-C's \@autoreleasepool Statement
M_template_rtpack(Xs)
struct clang::ObjCAutoreleasePoolStmt::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__ObjCAutoreleasePoolStmt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::ObjCAutoreleasePoolStmt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getSubStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAutoreleasePoolStmt, reflenums::clang__ObjCAutoreleasePoolStmt::getSubStmt, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAutoreleasePoolStmt, reflenums::clang__ObjCAutoreleasePoolStmt::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAutoreleasePoolStmt, reflenums::clang__ObjCAutoreleasePoolStmt::getBeginLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAutoreleasePoolStmt, reflenums::clang__ObjCAutoreleasePoolStmt::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAutoreleasePoolStmt, reflenums::clang__ObjCAutoreleasePoolStmt::getEndLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAtLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAutoreleasePoolStmt, reflenums::clang__ObjCAutoreleasePoolStmt::getAtLoc, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__ObjCAutoreleasePoolStmt, reflenums::clang__ObjCAutoreleasePoolStmt::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This is a basic class for representing single OpenMP clause.
M_template_rtpack(Xs)
struct clang::OMPClause::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPClause;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPClause::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Returns the starting location of the clause.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPClause, reflenums::clang__OMPClause::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPClause, reflenums::clang__OMPClause::getBeginLoc, Xs...); }) , (;) )
  /// Returns the ending location of the clause.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPClause, reflenums::clang__OMPClause::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPClause, reflenums::clang__OMPClause::getEndLoc, Xs...); }) , (;) )
  /// Returns kind of OpenMP clause (private, shared, reduction, etc.).
  constexpr enum clang::OpenMPClauseKind getClauseKind() const IFMETA_ELSE( ({    return (enum clang::OpenMPClauseKind)__reflect_prop(reflenums::RK_clang__OMPClause, reflenums::clang__OMPClause::getClauseKind, Xs...); }) , (;) )
  constexpr bool isImplicit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPClause, reflenums::clang__OMPClause::isImplicit, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::OMPClause, children,
      constexpr auto children() const ,
      (const typename meta::clang::Stmt *),
      (reflenums::RK_clang__OMPClause, reflenums::clang__OMPClause::children, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::OMPClause::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::OMPClause *)) p0) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPClause, reflenums::clang__OMPClause::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This is a basic class for representing single OpenMP executable
/// directive.
///
M_template_rtpack(Xs)
struct clang::OMPExecutableDirective::impl : impl_offset_t<clang::Stmt, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPExecutableDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPExecutableDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Returns starting location of directive kind.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocStart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::getLocStart, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getBeginLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::getBeginLoc, Xs...); }) , (;) )
  /// Returns ending location of directive.
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getLocEnd() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::getLocEnd, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getEndLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::getEndLoc, Xs...); }) , (;) )
  /// Get number of clauses.
  constexpr unsigned int getNumClauses() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::getNumClauses, Xs...); }) , (;) )
  /// Returns specified clause.
  ///
  /// \param i Number of clause.
  ///
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPClause *) )
  getClause(unsigned int i) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::getClause, Xs..., i); }) , (;) )
  /// Returns true if directive has associated statement.
  constexpr bool hasAssociatedStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::hasAssociatedStmt, Xs...); }) , (;) )
  /// Returns statement associated with the directive.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getAssociatedStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::getAssociatedStmt, Xs...); }) , (;) )
  /// Returns the captured statement associated with the
  /// component region within the (combined) directive.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CapturedStmt *) )
  getCapturedStmt(enum clang::OpenMPDirectiveKind RegionKind) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::getCapturedStmt, Xs..., RegionKind); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::CapturedStmt *) )
  getInnermostCapturedStmt() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::getInnermostCapturedStmt, Xs...); }) , (;) )
  constexpr enum clang::OpenMPDirectiveKind getDirectiveKind() const IFMETA_ELSE( ({    return (enum clang::OpenMPDirectiveKind)__reflect_prop(reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::getDirectiveKind, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) S) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
  RANGE_REFLECTION(clang::OMPExecutableDirective, clauses,
      constexpr auto clauses() const ,
      (typename meta::clang::OMPClause *),
      (reflenums::RK_clang__OMPExecutableDirective, reflenums::clang__OMPExecutableDirective::clauses, Xs...), () )
};

/// This represents '#pragma omp parallel' directive.
///
/// \code
/// #pragma omp parallel private(a,b) reduction(+: c,d)
/// \endcode
/// In this example directive '#pragma omp parallel' has clauses 'private'
/// with the variables 'a' and 'b' and 'reduction' with operator '+' and
/// variables 'c' and 'd'.
///
M_template_rtpack(Xs)
struct clang::OMPParallelDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPParallelDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPParallelDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a N clauses.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPParallelDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPParallelDirective, reflenums::clang__OMPParallelDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  /// Return true if current directive has inner cancel directive.
  constexpr bool hasCancel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPParallelDirective, reflenums::clang__OMPParallelDirective::hasCancel, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPParallelDirective, reflenums::clang__OMPParallelDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This is a common base class for loop directives ('omp simd', 'omp
/// for', 'omp for simd' etc.). It is responsible for the loop code generation.
///
M_template_rtpack(Xs)
struct clang::OMPLoopDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPLoopDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPLoopDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Get number of collapsed loops.
  constexpr unsigned int getCollapsedNumber() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getCollapsedNumber, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getIterationVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getIterationVariable, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getLastIteration() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getLastIteration, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCalcLastIteration() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getCalcLastIteration, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getPreCond() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getPreCond, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCond() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getCond, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getInit, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getInc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getInc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getPreInits() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getPreInits, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getIsLastIterVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getIsLastIterVariable, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getLowerBoundVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getLowerBoundVariable, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getUpperBoundVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getUpperBoundVariable, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getStrideVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getStrideVariable, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getEnsureUpperBound() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getEnsureUpperBound, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getNextLowerBound() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getNextLowerBound, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getNextUpperBound() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getNextUpperBound, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getNumIterations() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getNumIterations, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getPrevLowerBoundVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getPrevLowerBoundVariable, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getPrevUpperBoundVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getPrevUpperBoundVariable, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getDistInc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getDistInc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getPrevEnsureUpperBound() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getPrevEnsureUpperBound, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCombinedLowerBoundVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getCombinedLowerBoundVariable, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCombinedUpperBoundVariable() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getCombinedUpperBoundVariable, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCombinedEnsureUpperBound() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getCombinedEnsureUpperBound, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCombinedInit() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getCombinedInit, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCombinedCond() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getCombinedCond, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCombinedNextLowerBound() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getCombinedNextLowerBound, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::Expr *) )
  getCombinedNextUpperBound() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getCombinedNextUpperBound, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Stmt *) )
  getBody() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::getBody, Xs...); }) , (;) )
  RANGE_REFLECTION(clang::OMPLoopDirective, counters,
      constexpr auto counters() const ,
      (typename meta::clang::Expr *),
      (reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::counters, Xs...), () )
  RANGE_REFLECTION(clang::OMPLoopDirective, private_counters,
      constexpr auto private_counters() const ,
      (typename meta::clang::Expr *),
      (reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::private_counters, Xs...), () )
  RANGE_REFLECTION(clang::OMPLoopDirective, inits,
      constexpr auto inits() const ,
      (typename meta::clang::Expr *),
      (reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::inits, Xs...), () )
  RANGE_REFLECTION(clang::OMPLoopDirective, updates,
      constexpr auto updates() const ,
      (typename meta::clang::Expr *),
      (reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::updates, Xs...), () )
  RANGE_REFLECTION(clang::OMPLoopDirective, finals,
      constexpr auto finals() const ,
      (typename meta::clang::Expr *),
      (reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::finals, Xs...), () )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPLoopDirective, reflenums::clang__OMPLoopDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp simd' directive.
///
/// \code
/// #pragma omp simd private(a,b) linear(i,j:s) reduction(+:c,d)
/// \endcode
/// In this example directive '#pragma omp simd' has clauses 'private'
/// with the variables 'a' and 'b', 'linear' with variables 'i', 'j' and
/// linear step 's', 'reduction' with operator '+' and variables 'c' and 'd'.
///
M_template_rtpack(Xs)
struct clang::OMPSimdDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPSimdDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPSimdDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place
  /// for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPSimdDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPSimdDirective, reflenums::clang__OMPSimdDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPSimdDirective, reflenums::clang__OMPSimdDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp for' directive.
///
/// \code
/// #pragma omp for private(a,b) reduction(+:c,d)
/// \endcode
/// In this example directive '#pragma omp for' has clauses 'private' with the
/// variables 'a' and 'b' and 'reduction' with operator '+' and variables 'c'
/// and 'd'.
///
M_template_rtpack(Xs)
struct clang::OMPForDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPForDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPForDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place
  /// for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPForDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPForDirective, reflenums::clang__OMPForDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  /// Return true if current directive has inner cancel directive.
  constexpr bool hasCancel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPForDirective, reflenums::clang__OMPForDirective::hasCancel, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPForDirective, reflenums::clang__OMPForDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp for simd' directive.
///
/// \code
/// #pragma omp for simd private(a,b) linear(i,j:s) reduction(+:c,d)
/// \endcode
/// In this example directive '#pragma omp for simd' has clauses 'private'
/// with the variables 'a' and 'b', 'linear' with variables 'i', 'j' and
/// linear step 's', 'reduction' with operator '+' and variables 'c' and 'd'.
///
M_template_rtpack(Xs)
struct clang::OMPForSimdDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPForSimdDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPForSimdDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place
  /// for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPForSimdDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPForSimdDirective, reflenums::clang__OMPForSimdDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPForSimdDirective, reflenums::clang__OMPForSimdDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp sections' directive.
///
/// \code
/// #pragma omp sections private(a,b) reduction(+:c,d)
/// \endcode
/// In this example directive '#pragma omp sections' has clauses 'private' with
/// the variables 'a' and 'b' and 'reduction' with operator '+' and variables
/// 'c' and 'd'.
///
M_template_rtpack(Xs)
struct clang::OMPSectionsDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPSectionsDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPSectionsDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses
  /// clauses.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPSectionsDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPSectionsDirective, reflenums::clang__OMPSectionsDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  /// Return true if current directive has inner cancel directive.
  constexpr bool hasCancel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPSectionsDirective, reflenums::clang__OMPSectionsDirective::hasCancel, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPSectionsDirective, reflenums::clang__OMPSectionsDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp section' directive.
///
/// \code
/// #pragma omp section
/// \endcode
///
M_template_rtpack(Xs)
struct clang::OMPSectionDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPSectionDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPSectionDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates directive.
  ///
  /// \param C AST context.
  /// \param StartLoc Starting location of the directive kind.
  /// \param EndLoc Ending Location of the directive.
  /// \param AssociatedStmt Statement, associated with the directive.
  /// \param HasCancel true if current directive has inner directive.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPSectionDirective *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) EndLoc, IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::Stmt *)) AssociatedStmt, bool HasCancel) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPSectionDirective, reflenums::clang__OMPSectionDirective::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s..., HasCancel); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPSectionDirective *) )
  Create(Y0 p0, Y1 p1, Y2 p2, ptrwrp<Y3> p3, bool p4) {
      return Create(p0, p1, p2, p3.get(), p4);
  }), () )
  /// Creates an empty directive.
  ///
  /// \param C AST context.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPSectionDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p1) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPSectionDirective, reflenums::clang__OMPSectionDirective::CreateEmpty, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Return true if current directive has inner cancel directive.
  constexpr bool hasCancel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPSectionDirective, reflenums::clang__OMPSectionDirective::hasCancel, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPSectionDirective, reflenums::clang__OMPSectionDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp single' directive.
///
/// \code
/// #pragma omp single private(a,b) copyprivate(c,d)
/// \endcode
/// In this example directive '#pragma omp single' has clauses 'private' with
/// the variables 'a' and 'b' and 'copyprivate' with variables 'c' and 'd'.
///
M_template_rtpack(Xs)
struct clang::OMPSingleDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPSingleDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPSingleDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses
  /// clauses.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPSingleDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPSingleDirective, reflenums::clang__OMPSingleDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPSingleDirective, reflenums::clang__OMPSingleDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp master' directive.
///
/// \code
/// #pragma omp master
/// \endcode
///
M_template_rtpack(Xs)
struct clang::OMPMasterDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPMasterDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPMasterDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates directive.
  ///
  /// \param C AST context.
  /// \param StartLoc Starting location of the directive kind.
  /// \param EndLoc Ending Location of the directive.
  /// \param AssociatedStmt Statement, associated with the directive.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPMasterDirective *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) EndLoc, IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::Stmt *)) AssociatedStmt) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPMasterDirective, reflenums::clang__OMPMasterDirective::Create, Xs..., Y0s..., Y1s..., Y2s..., Y3s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPMasterDirective *) )
  Create(Y0 p0, Y1 p1, Y2 p2, ptrwrp<Y3> p3) {
      return Create(p0, p1, p2, p3.get());
  }), () )
  /// Creates an empty directive.
  ///
  /// \param C AST context.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPMasterDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p1) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPMasterDirective, reflenums::clang__OMPMasterDirective::CreateEmpty, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPMasterDirective, reflenums::clang__OMPMasterDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp critical' directive.
///
/// \code
/// #pragma omp critical
/// \endcode
///
M_template_rtpack(Xs)
struct clang::OMPCriticalDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPCriticalDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPCriticalDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPCriticalDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPCriticalDirective, reflenums::clang__OMPCriticalDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  /// Return name of the directive.
  ///
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::DeclarationNameInfo) )
  getDirectiveName() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPCriticalDirective, reflenums::clang__OMPCriticalDirective::getDirectiveName, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPCriticalDirective, reflenums::clang__OMPCriticalDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp parallel for' directive.
///
/// \code
/// #pragma omp parallel for private(a,b) reduction(+:c,d)
/// \endcode
/// In this example directive '#pragma omp parallel for' has clauses 'private'
/// with the variables 'a' and 'b' and 'reduction' with operator '+' and
/// variables 'c' and 'd'.
///
M_template_rtpack(Xs)
struct clang::OMPParallelForDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPParallelForDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPParallelForDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place
  /// for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPParallelForDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPParallelForDirective, reflenums::clang__OMPParallelForDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  /// Return true if current directive has inner cancel directive.
  constexpr bool hasCancel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPParallelForDirective, reflenums::clang__OMPParallelForDirective::hasCancel, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPParallelForDirective, reflenums::clang__OMPParallelForDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp parallel for simd' directive.
///
/// \code
/// #pragma omp parallel for simd private(a,b) linear(i,j:s) reduction(+:c,d)
/// \endcode
/// In this example directive '#pragma omp parallel for simd' has clauses
/// 'private' with the variables 'a' and 'b', 'linear' with variables 'i', 'j'
/// and linear step 's', 'reduction' with operator '+' and variables 'c' and
/// 'd'.
///
M_template_rtpack(Xs)
struct clang::OMPParallelForSimdDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPParallelForSimdDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPParallelForSimdDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place
  /// for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPParallelForSimdDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPParallelForSimdDirective, reflenums::clang__OMPParallelForSimdDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPParallelForSimdDirective, reflenums::clang__OMPParallelForSimdDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp parallel sections' directive.
///
/// \code
/// #pragma omp parallel sections private(a,b) reduction(+:c,d)
/// \endcode
/// In this example directive '#pragma omp parallel sections' has clauses
/// 'private' with the variables 'a' and 'b' and 'reduction' with operator '+'
/// and variables 'c' and 'd'.
///
M_template_rtpack(Xs)
struct clang::OMPParallelSectionsDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPParallelSectionsDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPParallelSectionsDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses
  /// clauses.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPParallelSectionsDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPParallelSectionsDirective, reflenums::clang__OMPParallelSectionsDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  /// Return true if current directive has inner cancel directive.
  constexpr bool hasCancel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPParallelSectionsDirective, reflenums::clang__OMPParallelSectionsDirective::hasCancel, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPParallelSectionsDirective, reflenums::clang__OMPParallelSectionsDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp task' directive.
///
/// \code
/// #pragma omp task private(a,b) final(d)
/// \endcode
/// In this example directive '#pragma omp task' has clauses 'private' with the
/// variables 'a' and 'b' and 'final' with condition 'd'.
///
M_template_rtpack(Xs)
struct clang::OMPTaskDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTaskDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTaskDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses
  /// clauses.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTaskDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskDirective, reflenums::clang__OMPTaskDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  /// Return true if current directive has inner cancel directive.
  constexpr bool hasCancel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskDirective, reflenums::clang__OMPTaskDirective::hasCancel, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskDirective, reflenums::clang__OMPTaskDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp taskyield' directive.
///
/// \code
/// #pragma omp taskyield
/// \endcode
///
M_template_rtpack(Xs)
struct clang::OMPTaskyieldDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTaskyieldDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTaskyieldDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates directive.
  ///
  /// \param C AST context.
  /// \param StartLoc Starting location of the directive kind.
  /// \param EndLoc Ending Location of the directive.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTaskyieldDirective *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) EndLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskyieldDirective, reflenums::clang__OMPTaskyieldDirective::Create, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  /// Creates an empty directive.
  ///
  /// \param C AST context.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTaskyieldDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p1) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskyieldDirective, reflenums::clang__OMPTaskyieldDirective::CreateEmpty, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskyieldDirective, reflenums::clang__OMPTaskyieldDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp barrier' directive.
///
/// \code
/// #pragma omp barrier
/// \endcode
///
M_template_rtpack(Xs)
struct clang::OMPBarrierDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPBarrierDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPBarrierDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates directive.
  ///
  /// \param C AST context.
  /// \param StartLoc Starting location of the directive kind.
  /// \param EndLoc Ending Location of the directive.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPBarrierDirective *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) EndLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPBarrierDirective, reflenums::clang__OMPBarrierDirective::Create, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  /// Creates an empty directive.
  ///
  /// \param C AST context.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPBarrierDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p1) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPBarrierDirective, reflenums::clang__OMPBarrierDirective::CreateEmpty, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPBarrierDirective, reflenums::clang__OMPBarrierDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp taskwait' directive.
///
/// \code
/// #pragma omp taskwait
/// \endcode
///
M_template_rtpack(Xs)
struct clang::OMPTaskwaitDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTaskwaitDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTaskwaitDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates directive.
  ///
  /// \param C AST context.
  /// \param StartLoc Starting location of the directive kind.
  /// \param EndLoc Ending Location of the directive.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTaskwaitDirective *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) EndLoc) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskwaitDirective, reflenums::clang__OMPTaskwaitDirective::Create, Xs..., Y0s..., Y1s..., Y2s...); }) , (;) )
  /// Creates an empty directive.
  ///
  /// \param C AST context.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTaskwaitDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p1) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskwaitDirective, reflenums::clang__OMPTaskwaitDirective::CreateEmpty, Xs..., Y0s..., Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskwaitDirective, reflenums::clang__OMPTaskwaitDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp taskgroup' directive.
///
/// \code
/// #pragma omp taskgroup
/// \endcode
///
M_template_rtpack(Xs)
struct clang::OMPTaskgroupDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTaskgroupDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTaskgroupDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTaskgroupDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskgroupDirective, reflenums::clang__OMPTaskgroupDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  /// Returns reference to the task_reduction return variable.
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getReductionRef() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskgroupDirective, reflenums::clang__OMPTaskgroupDirective::getReductionRef, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskgroupDirective, reflenums::clang__OMPTaskgroupDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp flush' directive.
///
/// \code
/// #pragma omp flush(a,b)
/// \endcode
/// In this example directive '#pragma omp flush' has 2 arguments- variables 'a'
/// and 'b'.
/// 'omp flush' directive does not have clauses but have an optional list of
/// variables to flush. This list of variables is stored within some fake clause
/// FlushClause.
M_template_rtpack(Xs)
struct clang::OMPFlushDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPFlushDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPFlushDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses
  /// clauses.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPFlushDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPFlushDirective, reflenums::clang__OMPFlushDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPFlushDirective, reflenums::clang__OMPFlushDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp ordered' directive.
///
/// \code
/// #pragma omp ordered
/// \endcode
///
M_template_rtpack(Xs)
struct clang::OMPOrderedDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPOrderedDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPOrderedDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPOrderedDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPOrderedDirective, reflenums::clang__OMPOrderedDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPOrderedDirective, reflenums::clang__OMPOrderedDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp atomic' directive.
///
/// \code
/// #pragma omp atomic capture
/// \endcode
/// In this example directive '#pragma omp atomic' has clause 'capture'.
///
M_template_rtpack(Xs)
struct clang::OMPAtomicDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPAtomicDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPAtomicDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses
  /// clauses.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPAtomicDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPAtomicDirective, reflenums::clang__OMPAtomicDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getX() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPAtomicDirective, reflenums::clang__OMPAtomicDirective::getX, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getUpdateExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPAtomicDirective, reflenums::clang__OMPAtomicDirective::getUpdateExpr, Xs...); }) , (;) )
  /// Return true if helper update expression has form
  /// 'OpaqueValueExpr(x) binop OpaqueValueExpr(expr)' and false if it has form
  /// 'OpaqueValueExpr(expr) binop OpaqueValueExpr(x)'.
  constexpr bool isXLHSInRHSPart() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPAtomicDirective, reflenums::clang__OMPAtomicDirective::isXLHSInRHSPart, Xs...); }) , (;) )
  /// Return true if 'v' expression must be updated to original value of
  /// 'x', false if 'v' must be updated to the new value of 'x'.
  constexpr bool isPostfixUpdate() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPAtomicDirective, reflenums::clang__OMPAtomicDirective::isPostfixUpdate, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getV() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPAtomicDirective, reflenums::clang__OMPAtomicDirective::getV, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::Expr *) )
  getExpr() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPAtomicDirective, reflenums::clang__OMPAtomicDirective::getExpr, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPAtomicDirective, reflenums::clang__OMPAtomicDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target' directive.
///
/// \code
/// #pragma omp target if(a)
/// \endcode
/// In this example directive '#pragma omp target' has clause 'if' with
/// condition 'a'.
///
M_template_rtpack(Xs)
struct clang::OMPTargetDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses
  /// clauses.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetDirective, reflenums::clang__OMPTargetDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetDirective, reflenums::clang__OMPTargetDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target data' directive.
///
/// \code
/// #pragma omp target data device(0) if(a) map(b[:])
/// \endcode
/// In this example directive '#pragma omp target data' has clauses 'device'
/// with the value '0', 'if' with condition 'a' and 'map' with array
/// section 'b[:]'.
///
M_template_rtpack(Xs)
struct clang::OMPTargetDataDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetDataDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetDataDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a N clauses.
  ///
  /// \param C AST context.
  /// \param N The number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetDataDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int N, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetDataDirective, reflenums::clang__OMPTargetDataDirective::CreateEmpty, Xs..., Y0s..., N, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetDataDirective, reflenums::clang__OMPTargetDataDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target enter data' directive.
///
/// \code
/// #pragma omp target enter data device(0) if(a) map(b[:])
/// \endcode
/// In this example directive '#pragma omp target enter data' has clauses
/// 'device' with the value '0', 'if' with condition 'a' and 'map' with array
/// section 'b[:]'.
///
M_template_rtpack(Xs)
struct clang::OMPTargetEnterDataDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetEnterDataDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetEnterDataDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a N clauses.
  ///
  /// \param C AST context.
  /// \param N The number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetEnterDataDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int N, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetEnterDataDirective, reflenums::clang__OMPTargetEnterDataDirective::CreateEmpty, Xs..., Y0s..., N, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetEnterDataDirective, reflenums::clang__OMPTargetEnterDataDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target exit data' directive.
///
/// \code
/// #pragma omp target exit data device(0) if(a) map(b[:])
/// \endcode
/// In this example directive '#pragma omp target exit data' has clauses
/// 'device' with the value '0', 'if' with condition 'a' and 'map' with array
/// section 'b[:]'.
///
M_template_rtpack(Xs)
struct clang::OMPTargetExitDataDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetExitDataDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetExitDataDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a N clauses.
  ///
  /// \param C AST context.
  /// \param N The number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetExitDataDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int N, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetExitDataDirective, reflenums::clang__OMPTargetExitDataDirective::CreateEmpty, Xs..., Y0s..., N, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetExitDataDirective, reflenums::clang__OMPTargetExitDataDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target parallel' directive.
///
/// \code
/// #pragma omp target parallel if(a)
/// \endcode
/// In this example directive '#pragma omp target parallel' has clause 'if' with
/// condition 'a'.
///
M_template_rtpack(Xs)
struct clang::OMPTargetParallelDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetParallelDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetParallelDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses
  /// clauses.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetParallelDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetParallelDirective, reflenums::clang__OMPTargetParallelDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetParallelDirective, reflenums::clang__OMPTargetParallelDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target parallel for' directive.
///
/// \code
/// #pragma omp target parallel for private(a,b) reduction(+:c,d)
/// \endcode
/// In this example directive '#pragma omp target parallel for' has clauses
/// 'private' with the variables 'a' and 'b' and 'reduction' with operator '+'
/// and variables 'c' and 'd'.
///
M_template_rtpack(Xs)
struct clang::OMPTargetParallelForDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetParallelForDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetParallelForDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place
  /// for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetParallelForDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetParallelForDirective, reflenums::clang__OMPTargetParallelForDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  /// Return true if current directive has inner cancel directive.
  constexpr bool hasCancel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetParallelForDirective, reflenums::clang__OMPTargetParallelForDirective::hasCancel, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetParallelForDirective, reflenums::clang__OMPTargetParallelForDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp teams' directive.
///
/// \code
/// #pragma omp teams if(a)
/// \endcode
/// In this example directive '#pragma omp teams' has clause 'if' with
/// condition 'a'.
///
M_template_rtpack(Xs)
struct clang::OMPTeamsDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTeamsDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTeamsDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses
  /// clauses.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTeamsDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTeamsDirective, reflenums::clang__OMPTeamsDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTeamsDirective, reflenums::clang__OMPTeamsDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp cancellation point' directive.
///
/// \code
/// #pragma omp cancellation point for
/// \endcode
///
/// In this example a cancellation point is created for innermost 'for' region.
M_template_rtpack(Xs)
struct clang::OMPCancellationPointDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPCancellationPointDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPCancellationPointDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates directive.
  ///
  /// \param C AST context.
  /// \param StartLoc Starting location of the directive kind.
  /// \param EndLoc Ending Location of the directive.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPCancellationPointDirective *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::SourceLocation)) StartLoc, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) EndLoc, enum clang::OpenMPDirectiveKind CancelRegion) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPCancellationPointDirective, reflenums::clang__OMPCancellationPointDirective::Create, Xs..., Y0s..., Y1s..., Y2s..., CancelRegion); }) , (;) )
  /// Creates an empty directive.
  ///
  /// \param C AST context.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPCancellationPointDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p1) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPCancellationPointDirective, reflenums::clang__OMPCancellationPointDirective::CreateEmpty, Xs..., Y0s..., Y1s...); }) , (;) )
  /// Get cancellation region for the current cancellation point.
  constexpr enum clang::OpenMPDirectiveKind getCancelRegion() const IFMETA_ELSE( ({    return (enum clang::OpenMPDirectiveKind)__reflect_prop(reflenums::RK_clang__OMPCancellationPointDirective, reflenums::clang__OMPCancellationPointDirective::getCancelRegion, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPCancellationPointDirective, reflenums::clang__OMPCancellationPointDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp cancel' directive.
///
/// \code
/// #pragma omp cancel for
/// \endcode
///
/// In this example a cancel is created for innermost 'for' region.
M_template_rtpack(Xs)
struct clang::OMPCancelDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPCancelDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPCancelDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPCancelDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPCancelDirective, reflenums::clang__OMPCancelDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  /// Get cancellation region for the current cancellation point.
  constexpr enum clang::OpenMPDirectiveKind getCancelRegion() const IFMETA_ELSE( ({    return (enum clang::OpenMPDirectiveKind)__reflect_prop(reflenums::RK_clang__OMPCancelDirective, reflenums::clang__OMPCancelDirective::getCancelRegion, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPCancelDirective, reflenums::clang__OMPCancelDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp taskloop' directive.
///
/// \code
/// #pragma omp taskloop private(a,b) grainsize(val) num_tasks(num)
/// \endcode
/// In this example directive '#pragma omp taskloop' has clauses 'private'
/// with the variables 'a' and 'b', 'grainsize' with expression 'val' and
/// 'num_tasks' with expression 'num'.
///
M_template_rtpack(Xs)
struct clang::OMPTaskLoopDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTaskLoopDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTaskLoopDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place
  /// for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTaskLoopDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskLoopDirective, reflenums::clang__OMPTaskLoopDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskLoopDirective, reflenums::clang__OMPTaskLoopDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp taskloop simd' directive.
///
/// \code
/// #pragma omp taskloop simd private(a,b) grainsize(val) num_tasks(num)
/// \endcode
/// In this example directive '#pragma omp taskloop simd' has clauses 'private'
/// with the variables 'a' and 'b', 'grainsize' with expression 'val' and
/// 'num_tasks' with expression 'num'.
///
M_template_rtpack(Xs)
struct clang::OMPTaskLoopSimdDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTaskLoopSimdDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTaskLoopSimdDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place
  /// for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTaskLoopSimdDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskLoopSimdDirective, reflenums::clang__OMPTaskLoopSimdDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTaskLoopSimdDirective, reflenums::clang__OMPTaskLoopSimdDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp distribute' directive.
///
/// \code
/// #pragma omp distribute private(a,b)
/// \endcode
/// In this example directive '#pragma omp distribute' has clauses 'private'
/// with the variables 'a' and 'b'
///
M_template_rtpack(Xs)
struct clang::OMPDistributeDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPDistributeDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPDistributeDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place
  /// for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPDistributeDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDistributeDirective, reflenums::clang__OMPDistributeDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDistributeDirective, reflenums::clang__OMPDistributeDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target update' directive.
///
/// \code
/// #pragma omp target update to(a) from(b) device(1)
/// \endcode
/// In this example directive '#pragma omp target update' has clause 'to' with
/// argument 'a', clause 'from' with argument 'b' and clause 'device' with
/// argument '1'.
///
M_template_rtpack(Xs)
struct clang::OMPTargetUpdateDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetUpdateDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetUpdateDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses
  /// clauses.
  ///
  /// \param C AST context.
  /// \param NumClauses The number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetUpdateDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetUpdateDirective, reflenums::clang__OMPTargetUpdateDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetUpdateDirective, reflenums::clang__OMPTargetUpdateDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp distribute parallel for' composite
///  directive.
///
/// \code
/// #pragma omp distribute parallel for private(a,b)
/// \endcode
/// In this example directive '#pragma omp distribute parallel for' has clause
/// 'private' with the variables 'a' and 'b'
///
M_template_rtpack(Xs)
struct clang::OMPDistributeParallelForDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPDistributeParallelForDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPDistributeParallelForDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place
  /// for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPDistributeParallelForDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDistributeParallelForDirective, reflenums::clang__OMPDistributeParallelForDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  /// Return true if current directive has inner cancel directive.
  constexpr bool hasCancel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDistributeParallelForDirective, reflenums::clang__OMPDistributeParallelForDirective::hasCancel, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDistributeParallelForDirective, reflenums::clang__OMPDistributeParallelForDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp distribute parallel for simd' composite
/// directive.
///
/// \code
/// #pragma omp distribute parallel for simd private(x)
/// \endcode
/// In this example directive '#pragma omp distribute parallel for simd' has
/// clause 'private' with the variables 'x'
///
M_template_rtpack(Xs)
struct clang::OMPDistributeParallelForSimdDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPDistributeParallelForSimdDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPDistributeParallelForSimdDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPDistributeParallelForSimdDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDistributeParallelForSimdDirective, reflenums::clang__OMPDistributeParallelForSimdDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDistributeParallelForSimdDirective, reflenums::clang__OMPDistributeParallelForSimdDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp distribute simd' composite directive.
///
/// \code
/// #pragma omp distribute simd private(x)
/// \endcode
/// In this example directive '#pragma omp distribute simd' has clause
/// 'private' with the variables 'x'
///
M_template_rtpack(Xs)
struct clang::OMPDistributeSimdDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPDistributeSimdDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPDistributeSimdDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPDistributeSimdDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDistributeSimdDirective, reflenums::clang__OMPDistributeSimdDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPDistributeSimdDirective, reflenums::clang__OMPDistributeSimdDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target parallel for simd' directive.
///
/// \code
/// #pragma omp target parallel for simd private(a) map(b) safelen(c)
/// \endcode
/// In this example directive '#pragma omp target parallel for simd' has clauses
/// 'private' with the variable 'a', 'map' with the variable 'b' and 'safelen'
/// with the variable 'c'.
///
M_template_rtpack(Xs)
struct clang::OMPTargetParallelForSimdDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetParallelForSimdDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetParallelForSimdDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetParallelForSimdDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetParallelForSimdDirective, reflenums::clang__OMPTargetParallelForSimdDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetParallelForSimdDirective, reflenums::clang__OMPTargetParallelForSimdDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target simd' directive.
///
/// \code
/// #pragma omp target simd private(a) map(b) safelen(c)
/// \endcode
/// In this example directive '#pragma omp target simd' has clauses 'private'
/// with the variable 'a', 'map' with the variable 'b' and 'safelen' with
/// the variable 'c'.
///
M_template_rtpack(Xs)
struct clang::OMPTargetSimdDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetSimdDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetSimdDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetSimdDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetSimdDirective, reflenums::clang__OMPTargetSimdDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetSimdDirective, reflenums::clang__OMPTargetSimdDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp teams distribute' directive.
///
/// \code
/// #pragma omp teams distribute private(a,b)
/// \endcode
/// In this example directive '#pragma omp teams distribute' has clauses
/// 'private' with the variables 'a' and 'b'
///
M_template_rtpack(Xs)
struct clang::OMPTeamsDistributeDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTeamsDistributeDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTeamsDistributeDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTeamsDistributeDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTeamsDistributeDirective, reflenums::clang__OMPTeamsDistributeDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTeamsDistributeDirective, reflenums::clang__OMPTeamsDistributeDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp teams distribute simd'
/// combined directive.
///
/// \code
/// #pragma omp teams distribute simd private(a,b)
/// \endcode
/// In this example directive '#pragma omp teams distribute simd'
/// has clause 'private' with the variables 'a' and 'b'
///
M_template_rtpack(Xs)
struct clang::OMPTeamsDistributeSimdDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTeamsDistributeSimdDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTeamsDistributeSimdDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place
  /// for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTeamsDistributeSimdDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTeamsDistributeSimdDirective, reflenums::clang__OMPTeamsDistributeSimdDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTeamsDistributeSimdDirective, reflenums::clang__OMPTeamsDistributeSimdDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp teams distribute parallel for simd' composite
/// directive.
///
/// \code
/// #pragma omp teams distribute parallel for simd private(x)
/// \endcode
/// In this example directive '#pragma omp teams distribute parallel for simd'
/// has clause 'private' with the variables 'x'
///
M_template_rtpack(Xs)
struct clang::OMPTeamsDistributeParallelForSimdDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTeamsDistributeParallelForSimdDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTeamsDistributeParallelForSimdDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTeamsDistributeParallelForSimdDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTeamsDistributeParallelForSimdDirective, reflenums::clang__OMPTeamsDistributeParallelForSimdDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTeamsDistributeParallelForSimdDirective, reflenums::clang__OMPTeamsDistributeParallelForSimdDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp teams distribute parallel for' composite
/// directive.
///
/// \code
/// #pragma omp teams distribute parallel for private(x)
/// \endcode
/// In this example directive '#pragma omp teams distribute parallel for'
/// has clause 'private' with the variables 'x'
///
M_template_rtpack(Xs)
struct clang::OMPTeamsDistributeParallelForDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTeamsDistributeParallelForDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTeamsDistributeParallelForDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTeamsDistributeParallelForDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTeamsDistributeParallelForDirective, reflenums::clang__OMPTeamsDistributeParallelForDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  /// Return true if current directive has inner cancel directive.
  constexpr bool hasCancel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTeamsDistributeParallelForDirective, reflenums::clang__OMPTeamsDistributeParallelForDirective::hasCancel, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTeamsDistributeParallelForDirective, reflenums::clang__OMPTeamsDistributeParallelForDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target teams' directive.
///
/// \code
/// #pragma omp target teams if(a>0)
/// \endcode
/// In this example directive '#pragma omp target teams' has clause 'if' with
/// condition 'a>0'.
///
M_template_rtpack(Xs)
struct clang::OMPTargetTeamsDirective::impl : impl_offset_t<clang::OMPExecutableDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetTeamsDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetTeamsDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetTeamsDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p2) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetTeamsDirective, reflenums::clang__OMPTargetTeamsDirective::CreateEmpty, Xs..., Y0s..., NumClauses, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetTeamsDirective, reflenums::clang__OMPTargetTeamsDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target teams distribute' combined directive.
///
/// \code
/// #pragma omp target teams distribute private(x)
/// \endcode
/// In this example directive '#pragma omp target teams distribute' has clause
/// 'private' with the variables 'x'
///
M_template_rtpack(Xs)
struct clang::OMPTargetTeamsDistributeDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetTeamsDistributeDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetTeamsDistributeDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetTeamsDistributeDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetTeamsDistributeDirective, reflenums::clang__OMPTargetTeamsDistributeDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetTeamsDistributeDirective, reflenums::clang__OMPTargetTeamsDistributeDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target teams distribute parallel for' combined
/// directive.
///
/// \code
/// #pragma omp target teams distribute parallel for private(x)
/// \endcode
/// In this example directive '#pragma omp target teams distribute parallel
/// for' has clause 'private' with the variables 'x'
///
M_template_rtpack(Xs)
struct clang::OMPTargetTeamsDistributeParallelForDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetTeamsDistributeParallelForDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetTeamsDistributeParallelForDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetTeamsDistributeParallelForDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetTeamsDistributeParallelForDirective, reflenums::clang__OMPTargetTeamsDistributeParallelForDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  /// Return true if current directive has inner cancel directive.
  constexpr bool hasCancel() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetTeamsDistributeParallelForDirective, reflenums::clang__OMPTargetTeamsDistributeParallelForDirective::hasCancel, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetTeamsDistributeParallelForDirective, reflenums::clang__OMPTargetTeamsDistributeParallelForDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target teams distribute parallel for simd'
/// combined directive.
///
/// \code
/// #pragma omp target teams distribute parallel for simd private(x)
/// \endcode
/// In this example directive '#pragma omp target teams distribute parallel
/// for simd' has clause 'private' with the variables 'x'
///
M_template_rtpack(Xs)
struct clang::OMPTargetTeamsDistributeParallelForSimdDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetTeamsDistributeParallelForSimdDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetTeamsDistributeParallelForSimdDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetTeamsDistributeParallelForSimdDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetTeamsDistributeParallelForSimdDirective, reflenums::clang__OMPTargetTeamsDistributeParallelForSimdDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetTeamsDistributeParallelForSimdDirective, reflenums::clang__OMPTargetTeamsDistributeParallelForSimdDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

/// This represents '#pragma omp target teams distribute simd' combined
/// directive.
///
/// \code
/// #pragma omp target teams distribute simd private(x)
/// \endcode
/// In this example directive '#pragma omp target teams distribute simd'
/// has clause 'private' with the variables 'x'
///
M_template_rtpack(Xs)
struct clang::OMPTargetTeamsDistributeSimdDirective::impl : impl_offset_t<clang::OMPLoopDirective, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__OMPTargetTeamsDistributeSimdDirective;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::OMPTargetTeamsDistributeSimdDirective::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  /// Creates an empty directive with the place for \a NumClauses clauses.
  ///
  /// \param C AST context.
  /// \param CollapsedNum Number of collapsed nested loops.
  /// \param NumClauses Number of clauses.
  ///
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::OMPTargetTeamsDistributeSimdDirective *) )
  CreateEmpty(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::ASTContext &)) C, unsigned int NumClauses, unsigned int CollapsedNum, IFMETA_ELSE((const clang::Stmt::EmptyShell::template impl</*ptrorref=*/0, Y1s...>), (typename meta::clang::Stmt::EmptyShell)) p3) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetTeamsDistributeSimdDirective, reflenums::clang__OMPTargetTeamsDistributeSimdDirective::CreateEmpty, Xs..., Y0s..., NumClauses, CollapsedNum, Y1s...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr bool classof(IFMETA_ELSE((const clang::Stmt::template impl</*ptrorref=*/1, Y0s...> *), (const typename meta::clang::Stmt *)) T) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__OMPTargetTeamsDistributeSimdDirective, reflenums::clang__OMPTargetTeamsDistributeSimdDirective::classof, Xs..., Y0s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr bool classof(ptrwrp<Y0> p0) {
      return classof(p0.get());
  }), () )
};

M_template_rtpack(Xs)
struct clang::StoredDeclsMap::impl : impl_offset_t<llvm::DebugEpochBase, 0 M_c M_pack(Xs)> {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__StoredDeclsMap;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::StoredDeclsMap::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StoredDeclsMap, reflenums::clang__StoredDeclsMap::empty, Xs...); }) , (;) )
  constexpr unsigned int size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StoredDeclsMap, reflenums::clang__StoredDeclsMap::size, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  constexpr unsigned int count(IFMETA_ELSE((const clang::DeclarationName::template impl</*ptrorref=*/1, Y0s...>), (const typename meta::clang::DeclarationName &)) Val) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StoredDeclsMap, reflenums::clang__StoredDeclsMap::count, Xs..., Y0s...); }) , (;) )
  constexpr bool isPointerIntoBucketsArray(const void * Ptr) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StoredDeclsMap, reflenums::clang__StoredDeclsMap::isPointerIntoBucketsArray, Xs..., Ptr); }) , (;) )
  constexpr const void * getPointerIntoBucketsArray() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StoredDeclsMap, reflenums::clang__StoredDeclsMap::getPointerIntoBucketsArray, Xs...); }) , (;) )
  constexpr unsigned long getMemorySize() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__StoredDeclsMap, reflenums::clang__StoredDeclsMap::getMemorySize, Xs...); }) , (;) )
  M_template M_tbeg M_rtpack(Y0s) M_tend
  static constexpr void DestroyAll(IFMETA_ELSE((const clang::StoredDeclsMap::template impl</*ptrorref=*/1, Y0s...> *), (typename meta::clang::StoredDeclsMap *)) Map, bool Dependent) IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_clang__StoredDeclsMap, reflenums::clang__StoredDeclsMap::DestroyAll, Xs..., Y0s..., Dependent); }) , (;) )
  IFMETA_ELSE( (template<typename Y0>
  static constexpr void DestroyAll(ptrwrp<Y0> p0, bool p1) {
      return DestroyAll(p0.get(), p1);
  }), () )
};

enum clang::DependentDiagnostic::AccessNonce : unsigned int {
  Access = 0,
};

/// A dependently-generated diagnostic.
M_template_rtpack(Xs)
struct clang::DependentDiagnostic::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_clang__DependentDiagnostic;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::clang::DependentDiagnostic::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  using AccessNonce = enum refldetail::clang::DependentDiagnostic::AccessNonce;
  M_template M_tbeg M_rtpack(Y0s) M_c M_rtpack(Y1s) M_c M_rtpack(Y2s) M_c M_rtpack(Y3s) M_c M_rtpack(Y4s) M_c M_rtpack(Y5s) M_c M_rtpack(Y6s) M_tend
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DependentDiagnostic *) )
  Create(IFMETA_ELSE((const clang::ASTContext::template impl</*ptrorref=*/1, Y0s...>), (typename meta::clang::ASTContext &)) Context, IFMETA_ELSE((const clang::DeclContext::template impl</*ptrorref=*/1, Y1s...> *), (typename meta::clang::DeclContext *)) Parent, enum clang::DependentDiagnostic::AccessNonce _, IFMETA_ELSE((const clang::SourceLocation::template impl</*ptrorref=*/0, Y2s...>), (typename meta::clang::SourceLocation)) Loc, bool IsMemberAccess, enum clang::AccessSpecifier AS, IFMETA_ELSE((const clang::NamedDecl::template impl</*ptrorref=*/1, Y3s...> *), (typename meta::clang::NamedDecl *)) TargetDecl, IFMETA_ELSE((const clang::CXXRecordDecl::template impl</*ptrorref=*/1, Y4s...> *), (typename meta::clang::CXXRecordDecl *)) NamingClass, IFMETA_ELSE((const clang::QualType::template impl</*ptrorref=*/0, Y5s...>), (typename meta::clang::QualType)) BaseObjectType, IFMETA_ELSE((const clang::PartialDiagnostic::template impl</*ptrorref=*/1, Y6s...>), (const typename meta::clang::PartialDiagnostic &)) PDiag) IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentDiagnostic, reflenums::clang__DependentDiagnostic::Create, Xs..., Y0s..., Y1s..., _, Y2s..., IsMemberAccess, AS, Y3s..., Y4s..., Y5s..., Y6s...); }) , (;) )
  IFMETA_ELSE( (template<typename Y0, typename Y1, typename Y2, typename Y3, typename Y4, typename Y5, typename Y6>
  static constexpr IFMETA_ELSE( (auto), (typename meta::clang::DependentDiagnostic *) )
  Create(Y0 p0, ptrwrp<Y1> p1, enum clang::DependentDiagnostic::AccessNonce p2, Y2 p3, bool p4, enum clang::AccessSpecifier p5, ptrwrp<Y3> p6, ptrwrp<Y4> p7, Y5 p8, Y6 p9) {
      return Create(p0, p1.get(), p2, p3, p4, p5, p6.get(), p7.get(), p8, p9);
  }), () )
  constexpr unsigned int getKind() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentDiagnostic, reflenums::clang__DependentDiagnostic::getKind, Xs...); }) , (;) )
  constexpr bool isAccessToMember() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentDiagnostic, reflenums::clang__DependentDiagnostic::isAccessToMember, Xs...); }) , (;) )
  constexpr enum clang::AccessSpecifier getAccess() const IFMETA_ELSE( ({    return (enum clang::AccessSpecifier)__reflect_prop(reflenums::RK_clang__DependentDiagnostic, reflenums::clang__DependentDiagnostic::getAccess, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::SourceLocation) )
  getAccessLoc() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentDiagnostic, reflenums::clang__DependentDiagnostic::getAccessLoc, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getAccessTarget() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentDiagnostic, reflenums::clang__DependentDiagnostic::getAccessTarget, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::NamedDecl *) )
  getAccessNamingClass() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentDiagnostic, reflenums::clang__DependentDiagnostic::getAccessNamingClass, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::clang::QualType) )
  getAccessBaseObjectType() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentDiagnostic, reflenums::clang__DependentDiagnostic::getAccessBaseObjectType, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (const typename meta::clang::PartialDiagnostic &) )
  getDiagnostic() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_clang__DependentDiagnostic, reflenums::clang__DependentDiagnostic::getDiagnostic, Xs...); }) , (;) )
};

M_template_rtpack(Xs)
struct reflcontainers::VectorStr::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_reflcontainers__VectorStr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::reflcontainers::VectorStr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr long clone() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::clone, Xs...); }) , (;) )
  constexpr unsigned long size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::size, Xs...); }) , (;) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::empty, Xs...); }) , (;) )
  constexpr void clear() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::clear, Xs...); }) , (;) )
  constexpr void resize(unsigned long N) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::resize, Xs..., N); }) , (;) )
  constexpr unsigned long capacity() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::capacity, Xs...); }) , (;) )
  constexpr void reserve(unsigned long N) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::reserve, Xs..., N); }) , (;) )
  constexpr void shrink_to_fit() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::shrink_to_fit, Xs...); }) , (;) )
  constexpr void push_back(const char * x) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::push_back, Xs..., x); }) , (;) )
  constexpr void pop_back() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::pop_back, Xs...); }) , (;) )
  constexpr void dealloc() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::dealloc, Xs...); }) , (;) )
  constexpr const char * at(unsigned long I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::at, Xs..., I); }) , (;) )
  constexpr void assign(unsigned long I, const char * val) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::assign, Xs..., I, val); }) , (;) )
  constexpr const char * front() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::front, Xs...); }) , (;) )
  constexpr const char * back() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorStr, reflenums::reflcontainers__VectorStr::back, Xs...); }) , (;) )
  RANGECLASS_SIZE_AND_GET(reflcontainers__VectorStr, const char *);
};

M_template_rtpack(Xs)
struct reflcontainers::VectorInt::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_reflcontainers__VectorInt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::reflcontainers::VectorInt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr long clone() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::clone, Xs...); }) , (;) )
  constexpr unsigned long size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::size, Xs...); }) , (;) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::empty, Xs...); }) , (;) )
  constexpr void clear() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::clear, Xs...); }) , (;) )
  constexpr void resize(unsigned long N) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::resize, Xs..., N); }) , (;) )
  constexpr unsigned long capacity() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::capacity, Xs...); }) , (;) )
  constexpr void reserve(unsigned long N) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::reserve, Xs..., N); }) , (;) )
  constexpr void shrink_to_fit() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::shrink_to_fit, Xs...); }) , (;) )
  constexpr void push_back(long x) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::push_back, Xs..., x); }) , (;) )
  constexpr void pop_back() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::pop_back, Xs...); }) , (;) )
  constexpr void dealloc() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::dealloc, Xs...); }) , (;) )
  constexpr long at(unsigned long I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::at, Xs..., I); }) , (;) )
  constexpr void assign(unsigned long I, long val) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::assign, Xs..., I, val); }) , (;) )
  constexpr long front() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::front, Xs...); }) , (;) )
  constexpr long back() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::back, Xs...); }) , (;) )
  constexpr void assign(unsigned long I, void * val) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::assign1, Xs..., I, val); }) , (;) )
  constexpr void push_back(void * x) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__VectorInt, reflenums::reflcontainers__VectorInt::push_back1, Xs..., x); }) , (;) )
  RANGECLASS_SIZE_AND_GET(reflcontainers__VectorInt, const long);
};

M_template_rtpack(Xs)
struct reflcontainers::SetInt::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_reflcontainers__SetInt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::reflcontainers::SetInt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr long clone() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetInt, reflenums::reflcontainers__SetInt::clone, Xs...); }) , (;) )
  constexpr unsigned long size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetInt, reflenums::reflcontainers__SetInt::size, Xs...); }) , (;) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetInt, reflenums::reflcontainers__SetInt::empty, Xs...); }) , (;) )
  constexpr void clear() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__SetInt, reflenums::reflcontainers__SetInt::clear, Xs...); }) , (;) )
  constexpr bool contains(long key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetInt, reflenums::reflcontainers__SetInt::contains, Xs..., key); }) , (;) )
  constexpr bool insert(long key) /*NON-CONST*/ IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetInt, reflenums::reflcontainers__SetInt::insert, Xs..., key); }) , (;) )
  constexpr void erase(long key) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__SetInt, reflenums::reflcontainers__SetInt::erase, Xs..., key); }) , (;) )
  constexpr long at_ith(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetInt, reflenums::reflcontainers__SetInt::at_ith, Xs..., I); }) , (;) )
  constexpr void dealloc() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__SetInt, reflenums::reflcontainers__SetInt::dealloc, Xs...); }) , (;) )
  constexpr bool contains(void * key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetInt, reflenums::reflcontainers__SetInt::contains1, Xs..., key); }) , (;) )
  /// @returns whether key was inserted.
  constexpr bool insert(void * key) /*NON-CONST*/ IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetInt, reflenums::reflcontainers__SetInt::insert1, Xs..., key); }) , (;) )
  constexpr void erase(void * key) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__SetInt, reflenums::reflcontainers__SetInt::erase1, Xs..., key); }) , (;) )
  RANGECLASS_SIZE_AND_GET(reflcontainers__SetInt, const long);
};

M_template_rtpack(Xs)
struct reflcontainers::SetStr::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_reflcontainers__SetStr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::reflcontainers::SetStr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr long clone() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetStr, reflenums::reflcontainers__SetStr::clone, Xs...); }) , (;) )
  constexpr unsigned long size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetStr, reflenums::reflcontainers__SetStr::size, Xs...); }) , (;) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetStr, reflenums::reflcontainers__SetStr::empty, Xs...); }) , (;) )
  constexpr void clear() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__SetStr, reflenums::reflcontainers__SetStr::clear, Xs...); }) , (;) )
  constexpr bool contains(const char * key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetStr, reflenums::reflcontainers__SetStr::contains, Xs..., key); }) , (;) )
  constexpr bool insert(const char * key) /*NON-CONST*/ IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetStr, reflenums::reflcontainers__SetStr::insert, Xs..., key); }) , (;) )
  constexpr void erase(const char * key) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__SetStr, reflenums::reflcontainers__SetStr::erase, Xs..., key); }) , (;) )
  constexpr const char * at_ith(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__SetStr, reflenums::reflcontainers__SetStr::at_ith, Xs..., I); }) , (;) )
  constexpr void dealloc() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__SetStr, reflenums::reflcontainers__SetStr::dealloc, Xs...); }) , (;) )
  RANGECLASS_SIZE_AND_GET(reflcontainers__SetStr, const char *);
};

/**/
M_template_rtpack(Xs)
struct reflcontainers::IntIntPair::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_reflcontainers__IntIntPair;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::reflcontainers::IntIntPair::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  long first
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_reflcontainers__IntIntPair, reflenums::reflcontainers__IntIntPair::first, Xs...);), (;) )
  long second
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_reflcontainers__IntIntPair, reflenums::reflcontainers__IntIntPair::second, Xs...);), (;) )
};

M_template_rtpack(Xs)
struct reflcontainers::IntStrPair::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_reflcontainers__IntStrPair;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::reflcontainers::IntStrPair::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  long first
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_reflcontainers__IntStrPair, reflenums::reflcontainers__IntStrPair::first, Xs...);), (;) )
  const char * second
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_reflcontainers__IntStrPair, reflenums::reflcontainers__IntStrPair::second, Xs...);), (;) )
};

M_template_rtpack(Xs)
struct reflcontainers::StrIntPair::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_reflcontainers__StrIntPair;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::reflcontainers::StrIntPair::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  const char * first
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_reflcontainers__StrIntPair, reflenums::reflcontainers__StrIntPair::first, Xs...);), (;) )
  long second
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_reflcontainers__StrIntPair, reflenums::reflcontainers__StrIntPair::second, Xs...);), (;) )
};

M_template_rtpack(Xs)
struct reflcontainers::StrStrPair::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_reflcontainers__StrStrPair;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::reflcontainers::StrStrPair::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  const char * first
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_reflcontainers__StrStrPair, reflenums::reflcontainers__StrStrPair::first, Xs...);), (;) )
  const char * second
      IFMETA_ELSE( (= __reflect_prop(reflenums::RK_reflcontainers__StrStrPair, reflenums::reflcontainers__StrStrPair::second, Xs...);), (;) )
};

M_template_rtpack(Xs)
struct reflcontainers::MapIntStr::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_reflcontainers__MapIntStr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::reflcontainers::MapIntStr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr long clone() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::clone, Xs...); }) , (;) )
  constexpr unsigned long size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::size, Xs...); }) , (;) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::empty, Xs...); }) , (;) )
  constexpr void clear() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::clear, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::reflcontainers::IntStrPair) )
  at_ith(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::at_ith, Xs..., I); }) , (;) )
  constexpr long at_ith_key(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::at_ith_key, Xs..., I); }) , (;) )
  constexpr const char * at_ith_val(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::at_ith_val, Xs..., I); }) , (;) )
  constexpr void dealloc() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::dealloc, Xs...); }) , (;) )
  constexpr bool contains(long key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::contains, Xs..., key); }) , (;) )
  constexpr const char * at(long key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::at, Xs..., key); }) , (;) )
  constexpr void assign(long key, const char * val) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::assign, Xs..., key, val); }) , (;) )
  constexpr void erase(long key) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::erase, Xs..., key); }) , (;) )
  constexpr void erase(void * key) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::erase1, Xs..., key); }) , (;) )
  constexpr bool contains(void * key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::contains1, Xs..., key); }) , (;) )
  constexpr const char * at(void * key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::at1, Xs..., key); }) , (;) )
  constexpr void assign(void * key, const char * val) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntStr, reflenums::reflcontainers__MapIntStr::assign1, Xs..., key, val); }) , (;) )
  RANGECLASS_SIZE_AND_GET(reflcontainers__MapIntStr, typename meta::reflcontainers::IntStrPair);
};

M_template_rtpack(Xs)
struct reflcontainers::MapStrInt::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_reflcontainers__MapStrInt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::reflcontainers::MapStrInt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr long clone() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrInt, reflenums::reflcontainers__MapStrInt::clone, Xs...); }) , (;) )
  constexpr unsigned long size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrInt, reflenums::reflcontainers__MapStrInt::size, Xs...); }) , (;) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrInt, reflenums::reflcontainers__MapStrInt::empty, Xs...); }) , (;) )
  constexpr void clear() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapStrInt, reflenums::reflcontainers__MapStrInt::clear, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::reflcontainers::StrIntPair) )
  at_ith(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrInt, reflenums::reflcontainers__MapStrInt::at_ith, Xs..., I); }) , (;) )
  constexpr const char * at_ith_key(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrInt, reflenums::reflcontainers__MapStrInt::at_ith_key, Xs..., I); }) , (;) )
  constexpr long at_ith_val(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrInt, reflenums::reflcontainers__MapStrInt::at_ith_val, Xs..., I); }) , (;) )
  constexpr void dealloc() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapStrInt, reflenums::reflcontainers__MapStrInt::dealloc, Xs...); }) , (;) )
  constexpr bool contains(const char * key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrInt, reflenums::reflcontainers__MapStrInt::contains, Xs..., key); }) , (;) )
  constexpr long at(const char * key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrInt, reflenums::reflcontainers__MapStrInt::at, Xs..., key); }) , (;) )
  constexpr void assign(const char * key, long val) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapStrInt, reflenums::reflcontainers__MapStrInt::assign, Xs..., key, val); }) , (;) )
  constexpr void erase(const char * key) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapStrInt, reflenums::reflcontainers__MapStrInt::erase, Xs..., key); }) , (;) )
  constexpr void assign(const char * key, void * val) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapStrInt, reflenums::reflcontainers__MapStrInt::assign1, Xs..., key, val); }) , (;) )
  RANGECLASS_SIZE_AND_GET(reflcontainers__MapStrInt, typename meta::reflcontainers::StrIntPair);
};

M_template_rtpack(Xs)
struct reflcontainers::MapStrStr::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_reflcontainers__MapStrStr;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::reflcontainers::MapStrStr::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr long clone() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrStr, reflenums::reflcontainers__MapStrStr::clone, Xs...); }) , (;) )
  constexpr unsigned long size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrStr, reflenums::reflcontainers__MapStrStr::size, Xs...); }) , (;) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrStr, reflenums::reflcontainers__MapStrStr::empty, Xs...); }) , (;) )
  constexpr void clear() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapStrStr, reflenums::reflcontainers__MapStrStr::clear, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::reflcontainers::StrStrPair) )
  at_ith(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrStr, reflenums::reflcontainers__MapStrStr::at_ith, Xs..., I); }) , (;) )
  constexpr const char * at_ith_key(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrStr, reflenums::reflcontainers__MapStrStr::at_ith_key, Xs..., I); }) , (;) )
  constexpr const char * at_ith_val(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrStr, reflenums::reflcontainers__MapStrStr::at_ith_val, Xs..., I); }) , (;) )
  constexpr void dealloc() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapStrStr, reflenums::reflcontainers__MapStrStr::dealloc, Xs...); }) , (;) )
  constexpr bool contains(const char * key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrStr, reflenums::reflcontainers__MapStrStr::contains, Xs..., key); }) , (;) )
  constexpr const char * at(const char * key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapStrStr, reflenums::reflcontainers__MapStrStr::at, Xs..., key); }) , (;) )
  constexpr void assign(const char * key, const char * val) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapStrStr, reflenums::reflcontainers__MapStrStr::assign, Xs..., key, val); }) , (;) )
  constexpr void erase(const char * key) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapStrStr, reflenums::reflcontainers__MapStrStr::erase, Xs..., key); }) , (;) )
  RANGECLASS_SIZE_AND_GET(reflcontainers__MapStrStr, typename meta::reflcontainers::StrStrPair);
};

M_template_rtpack(Xs)
struct reflcontainers::MapIntInt::impl {
  static constexpr reflenums::ReflectionObjKind ReflObjKind = reflenums::ReflectionObjKind::RK_reflcontainers__MapIntInt;
  constexpr explicit operator const char *() const IFMETA_ELSE( ({
    return __concatenate("cppx::meta::refldetail::reflcontainers::MapIntInt::impl<",
                         concat_ints_w_commas<Xs...>::value, ">()");
  }) , ( {return "";} ) )
  constexpr long clone() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::clone, Xs...); }) , (;) )
  constexpr unsigned long size() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::size, Xs...); }) , (;) )
  constexpr bool empty() const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::empty, Xs...); }) , (;) )
  constexpr void clear() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::clear, Xs...); }) , (;) )
  constexpr IFMETA_ELSE( (auto), (typename meta::reflcontainers::IntIntPair) )
  at_ith(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::at_ith, Xs..., I); }) , (;) )
  constexpr long at_ith_key(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::at_ith_key, Xs..., I); }) , (;) )
  constexpr long at_ith_val(unsigned int I) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::at_ith_val, Xs..., I); }) , (;) )
  constexpr void dealloc() /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::dealloc, Xs...); }) , (;) )
  constexpr bool contains(long key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::contains, Xs..., key); }) , (;) )
  constexpr long at(long key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::at, Xs..., key); }) , (;) )
  constexpr void assign(long key, long val) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::assign, Xs..., key, val); }) , (;) )
  constexpr void erase(long key) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::erase, Xs..., key); }) , (;) )
  constexpr void erase(void * key) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::erase1, Xs..., key); }) , (;) )
  constexpr bool contains(void * key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::contains1, Xs..., key); }) , (;) )
  constexpr long at(void * key) const IFMETA_ELSE( ({    return __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::at1, Xs..., key); }) , (;) )
  constexpr void assign(void * key, long val) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::assign1, Xs..., key, val); }) , (;) )
  constexpr void assign(long key, void * val) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::assign2, Xs..., key, val); }) , (;) )
  constexpr void assign(void * key, void * val) /*NON-CONST*/ IFMETA_ELSE( ({    __reflect_prop(reflenums::RK_reflcontainers__MapIntInt, reflenums::reflcontainers__MapIntInt::assign3, Xs..., key, val); }) , (;) )
  RANGECLASS_SIZE_AND_GET(reflcontainers__MapIntInt, typename meta::reflcontainers::IntIntPair);
};

} //namespace refldetail

/////////// reflnew //////////////

#ifdef __CONSUMER_SUPPORTS_REFLECTION_AND_META__
# define reflnew(T)  __reflect_new(cppx::meta::refldetail::GetReflectionObjKind<cppx::meta::refldetail::T>::value)

  namespace refldetail {
    template<typename T>
    struct GetReflectionObjKind;

    template<> struct GetReflectionObjKind<llvm::APInt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__APInt; };
    template<> struct GetReflectionObjKind<llvm::APInt::ms>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__APInt__ms; };
    template<> struct GetReflectionObjKind<llvm::APInt::mu>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__APInt__mu; };
    template<> struct GetReflectionObjKind<llvm::APFloatBase>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__APFloatBase; };
    template<> struct GetReflectionObjKind<llvm::APFloat>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__APFloat; };
    template<> struct GetReflectionObjKind<llvm::APSInt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__APSInt; };
    template<> struct GetReflectionObjKind<clang::APValue>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__APValue; };
    template<> struct GetReflectionObjKind<clang::APValue::LValueBase>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__APValue__LValueBase; };
    template<> struct GetReflectionObjKind<clang::DiagnosticOptions>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DiagnosticOptions; };
    template<> struct GetReflectionObjKind<clang::FileID>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FileID; };
    template<> struct GetReflectionObjKind<clang::SourceLocation>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SourceLocation; };
    template<> struct GetReflectionObjKind<clang::SourceRange>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SourceRange; };
    template<> struct GetReflectionObjKind<clang::CharSourceRange>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CharSourceRange; };
    template<> struct GetReflectionObjKind<clang::PresumedLoc>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__PresumedLoc; };
    template<> struct GetReflectionObjKind<clang::FullSourceLoc>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FullSourceLoc; };
    template<> struct GetReflectionObjKind<llvm::DebugEpochBase>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__DebugEpochBase; };
    template<> struct GetReflectionObjKind<clang::FixItHint>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FixItHint; };
    template<> struct GetReflectionObjKind<clang::DiagnosticsEngine>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DiagnosticsEngine; };
    template<> struct GetReflectionObjKind<clang::DiagnosticBuilder>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DiagnosticBuilder; };
    template<> struct GetReflectionObjKind<clang::DiagnosticConsumer>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DiagnosticConsumer; };
    template<> struct GetReflectionObjKind<clang::IdentifierInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__IdentifierInfo; };
    template<> struct GetReflectionObjKind<clang::IdentifierInfoLookup>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__IdentifierInfoLookup; };
    template<> struct GetReflectionObjKind<clang::IdentifierTable>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__IdentifierTable; };
    template<> struct GetReflectionObjKind<clang::Selector>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Selector; };
    template<> struct GetReflectionObjKind<clang::SelectorTable>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SelectorTable; };
    template<> struct GetReflectionObjKind<clang::PartialDiagnostic>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__PartialDiagnostic; };
    template<> struct GetReflectionObjKind<clang::DeclarationName>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DeclarationName; };
    template<> struct GetReflectionObjKind<clang::DeclarationNameLoc>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DeclarationNameLoc; };
    template<> struct GetReflectionObjKind<clang::DeclarationNameInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DeclarationNameInfo; };
    template<> struct GetReflectionObjKind<llvm::raw_ostream>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__raw_ostream; };
    template<> struct GetReflectionObjKind<llvm::VersionTuple>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__VersionTuple; };
    template<> struct GetReflectionObjKind<clang::Decl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Decl; };
    template<> struct GetReflectionObjKind<clang::DeclContextLookupResult>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DeclContextLookupResult; };
    template<> struct GetReflectionObjKind<clang::DeclContext>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DeclContext; };
    template<> struct GetReflectionObjKind<clang::CharUnits>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CharUnits; };
    template<> struct GetReflectionObjKind<clang::FileSystemOptions>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FileSystemOptions; };
    template<> struct GetReflectionObjKind<llvm::Twine>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__Twine; };
    template<> struct GetReflectionObjKind<llvm::sys::fs::UniqueID>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__sys__fs__UniqueID; };
    template<> struct GetReflectionObjKind<llvm::MemoryBuffer>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__MemoryBuffer; };
    template<> struct GetReflectionObjKind<llvm::MemoryBufferRef>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__MemoryBufferRef; };
    template<> struct GetReflectionObjKind<clang::DirectoryEntry>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DirectoryEntry; };
    template<> struct GetReflectionObjKind<clang::FileEntry>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FileEntry; };
    template<> struct GetReflectionObjKind<clang::FileManager>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FileManager; };
    template<> struct GetReflectionObjKind<clang::ASTFileSignature>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ASTFileSignature; };
    template<> struct GetReflectionObjKind<clang::Module>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Module; };
    template<> struct GetReflectionObjKind<clang::Module::Header>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Module__Header; };
    template<> struct GetReflectionObjKind<clang::Module::DirectoryName>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Module__DirectoryName; };
    template<> struct GetReflectionObjKind<clang::ExternalASTSource>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ExternalASTSource; };
    template<> struct GetReflectionObjKind<clang::ExternalASTSource::MemoryBufferSizes>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ExternalASTSource__MemoryBufferSizes; };
    template<> struct GetReflectionObjKind<llvm::FoldingSetBase>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__FoldingSetBase; };
    template<> struct GetReflectionObjKind<llvm::FoldingSetBase::Node>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__FoldingSetBase__Node; };
    template<> struct GetReflectionObjKind<llvm::FoldingSetNodeIDRef>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__FoldingSetNodeIDRef; };
    template<> struct GetReflectionObjKind<llvm::FoldingSetNodeID>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__FoldingSetNodeID; };
    template<> struct GetReflectionObjKind<clang::NestedNameSpecifier>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__NestedNameSpecifier; };
    template<> struct GetReflectionObjKind<clang::NestedNameSpecifierLoc>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__NestedNameSpecifierLoc; };
    template<> struct GetReflectionObjKind<clang::UncommonTemplateNameStorage>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UncommonTemplateNameStorage; };
    template<> struct GetReflectionObjKind<clang::OverloadedTemplateStorage>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OverloadedTemplateStorage; };
    template<> struct GetReflectionObjKind<clang::SubstTemplateTemplateParmPackStorage>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SubstTemplateTemplateParmPackStorage; };
    template<> struct GetReflectionObjKind<clang::TemplateName>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TemplateName; };
    template<> struct GetReflectionObjKind<clang::SubstTemplateTemplateParmStorage>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SubstTemplateTemplateParmStorage; };
    template<> struct GetReflectionObjKind<clang::QualifiedTemplateName>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__QualifiedTemplateName; };
    template<> struct GetReflectionObjKind<clang::DependentTemplateName>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DependentTemplateName; };
    template<> struct GetReflectionObjKind<clang::LinkageInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__LinkageInfo; };
    template<> struct GetReflectionObjKind<clang::Qualifiers>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Qualifiers; };
    template<> struct GetReflectionObjKind<clang::SplitQualType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SplitQualType; };
    template<> struct GetReflectionObjKind<clang::QualType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__QualType; };
    template<> struct GetReflectionObjKind<clang::ExtQualsTypeCommonBase>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ExtQualsTypeCommonBase; };
    template<> struct GetReflectionObjKind<clang::Type>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Type; };
    template<> struct GetReflectionObjKind<clang::BuiltinType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__BuiltinType; };
    template<> struct GetReflectionObjKind<clang::ComplexType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ComplexType; };
    template<> struct GetReflectionObjKind<clang::ParenType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ParenType; };
    template<> struct GetReflectionObjKind<clang::PointerType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__PointerType; };
    template<> struct GetReflectionObjKind<clang::AdjustedType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__AdjustedType; };
    template<> struct GetReflectionObjKind<clang::DecayedType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DecayedType; };
    template<> struct GetReflectionObjKind<clang::BlockPointerType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__BlockPointerType; };
    template<> struct GetReflectionObjKind<clang::ReferenceType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ReferenceType; };
    template<> struct GetReflectionObjKind<clang::LValueReferenceType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__LValueReferenceType; };
    template<> struct GetReflectionObjKind<clang::RValueReferenceType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__RValueReferenceType; };
    template<> struct GetReflectionObjKind<clang::MemberPointerType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__MemberPointerType; };
    template<> struct GetReflectionObjKind<clang::ArrayType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ArrayType; };
    template<> struct GetReflectionObjKind<clang::ConstantArrayType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ConstantArrayType; };
    template<> struct GetReflectionObjKind<clang::IncompleteArrayType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__IncompleteArrayType; };
    template<> struct GetReflectionObjKind<clang::VariableArrayType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__VariableArrayType; };
    template<> struct GetReflectionObjKind<clang::DependentSizedArrayType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DependentSizedArrayType; };
    template<> struct GetReflectionObjKind<clang::DependentAddressSpaceType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DependentAddressSpaceType; };
    template<> struct GetReflectionObjKind<clang::DependentSizedExtVectorType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DependentSizedExtVectorType; };
    template<> struct GetReflectionObjKind<clang::VectorType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__VectorType; };
    template<> struct GetReflectionObjKind<clang::DependentVectorType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DependentVectorType; };
    template<> struct GetReflectionObjKind<clang::ExtVectorType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ExtVectorType; };
    template<> struct GetReflectionObjKind<clang::FunctionType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FunctionType; };
    template<> struct GetReflectionObjKind<clang::FunctionType::ExtInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FunctionType__ExtInfo; };
    template<> struct GetReflectionObjKind<clang::FunctionNoProtoType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FunctionNoProtoType; };
    template<> struct GetReflectionObjKind<clang::FunctionProtoType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FunctionProtoType; };
    template<> struct GetReflectionObjKind<clang::FunctionProtoType::ExtParameterInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FunctionProtoType__ExtParameterInfo; };
    template<> struct GetReflectionObjKind<clang::FunctionProtoType::ExceptionSpecInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FunctionProtoType__ExceptionSpecInfo; };
    template<> struct GetReflectionObjKind<clang::FunctionProtoType::ExtProtoInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FunctionProtoType__ExtProtoInfo; };
    template<> struct GetReflectionObjKind<clang::UnresolvedUsingType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UnresolvedUsingType; };
    template<> struct GetReflectionObjKind<clang::TypedefType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypedefType; };
    template<> struct GetReflectionObjKind<clang::TypeOfExprType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypeOfExprType; };
    template<> struct GetReflectionObjKind<clang::TypeOfType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypeOfType; };
    template<> struct GetReflectionObjKind<clang::DecltypeType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DecltypeType; };
    template<> struct GetReflectionObjKind<clang::ReflectedType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ReflectedType; };
    template<> struct GetReflectionObjKind<clang::UnaryTransformType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UnaryTransformType; };
    template<> struct GetReflectionObjKind<clang::TagType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TagType; };
    template<> struct GetReflectionObjKind<clang::RecordType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__RecordType; };
    template<> struct GetReflectionObjKind<clang::EnumType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__EnumType; };
    template<> struct GetReflectionObjKind<clang::AttributedType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__AttributedType; };
    template<> struct GetReflectionObjKind<clang::TemplateTypeParmType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TemplateTypeParmType; };
    template<> struct GetReflectionObjKind<clang::SubstTemplateTypeParmType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SubstTemplateTypeParmType; };
    template<> struct GetReflectionObjKind<clang::SubstTemplateTypeParmPackType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SubstTemplateTypeParmPackType; };
    template<> struct GetReflectionObjKind<clang::DeducedType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DeducedType; };
    template<> struct GetReflectionObjKind<clang::AutoType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__AutoType; };
    template<> struct GetReflectionObjKind<clang::DeducedTemplateSpecializationType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DeducedTemplateSpecializationType; };
    template<> struct GetReflectionObjKind<clang::TemplateSpecializationType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TemplateSpecializationType; };
    template<> struct GetReflectionObjKind<clang::InjectedClassNameType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__InjectedClassNameType; };
    template<> struct GetReflectionObjKind<clang::TypeWithKeyword>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypeWithKeyword; };
    template<> struct GetReflectionObjKind<clang::ElaboratedType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ElaboratedType; };
    template<> struct GetReflectionObjKind<clang::DependentNameType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DependentNameType; };
    template<> struct GetReflectionObjKind<clang::DependentTemplateSpecializationType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DependentTemplateSpecializationType; };
    template<> struct GetReflectionObjKind<clang::PackExpansionType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__PackExpansionType; };
    template<> struct GetReflectionObjKind<clang::ObjCTypeParamType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCTypeParamType; };
    template<> struct GetReflectionObjKind<clang::ObjCObjectType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCObjectType; };
    template<> struct GetReflectionObjKind<clang::ObjCInterfaceType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCInterfaceType; };
    template<> struct GetReflectionObjKind<clang::ObjCObjectPointerType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCObjectPointerType; };
    template<> struct GetReflectionObjKind<clang::AtomicType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__AtomicType; };
    template<> struct GetReflectionObjKind<clang::PipeType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__PipeType; };
    template<> struct GetReflectionObjKind<clang::TypeSourceInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypeSourceInfo; };
    template<> struct GetReflectionObjKind<clang::TranslationUnitDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TranslationUnitDecl; };
    template<> struct GetReflectionObjKind<clang::PragmaCommentDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__PragmaCommentDecl; };
    template<> struct GetReflectionObjKind<clang::PragmaDetectMismatchDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__PragmaDetectMismatchDecl; };
    template<> struct GetReflectionObjKind<clang::ExternCContextDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ExternCContextDecl; };
    template<> struct GetReflectionObjKind<clang::NamedDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__NamedDecl; };
    template<> struct GetReflectionObjKind<clang::LabelDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__LabelDecl; };
    template<> struct GetReflectionObjKind<clang::NamespaceDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__NamespaceDecl; };
    template<> struct GetReflectionObjKind<clang::ValueDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ValueDecl; };
    template<> struct GetReflectionObjKind<clang::DeclaratorDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DeclaratorDecl; };
    template<> struct GetReflectionObjKind<clang::EvaluatedStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__EvaluatedStmt; };
    template<> struct GetReflectionObjKind<clang::VarDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__VarDecl; };
    template<> struct GetReflectionObjKind<clang::ImplicitParamDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ImplicitParamDecl; };
    template<> struct GetReflectionObjKind<clang::ParmVarDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ParmVarDecl; };
    template<> struct GetReflectionObjKind<clang::FunctionDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FunctionDecl; };
    template<> struct GetReflectionObjKind<clang::FieldDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FieldDecl; };
    template<> struct GetReflectionObjKind<clang::EnumConstantDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__EnumConstantDecl; };
    template<> struct GetReflectionObjKind<clang::IndirectFieldDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__IndirectFieldDecl; };
    template<> struct GetReflectionObjKind<clang::TypeDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypeDecl; };
    template<> struct GetReflectionObjKind<clang::TypedefNameDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypedefNameDecl; };
    template<> struct GetReflectionObjKind<clang::TypedefDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypedefDecl; };
    template<> struct GetReflectionObjKind<clang::TypeAliasDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypeAliasDecl; };
    template<> struct GetReflectionObjKind<clang::TagDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TagDecl; };
    template<> struct GetReflectionObjKind<clang::EnumDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__EnumDecl; };
    template<> struct GetReflectionObjKind<clang::RecordDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__RecordDecl; };
    template<> struct GetReflectionObjKind<clang::FileScopeAsmDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FileScopeAsmDecl; };
    template<> struct GetReflectionObjKind<clang::BlockDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__BlockDecl; };
    template<> struct GetReflectionObjKind<clang::BlockDecl::Capture>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__BlockDecl__Capture; };
    template<> struct GetReflectionObjKind<clang::CapturedDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CapturedDecl; };
    template<> struct GetReflectionObjKind<clang::ImportDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ImportDecl; };
    template<> struct GetReflectionObjKind<clang::ExportDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ExportDecl; };
    template<> struct GetReflectionObjKind<clang::EmptyDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__EmptyDecl; };
    template<> struct GetReflectionObjKind<clang::DeclGroup>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DeclGroup; };
    template<> struct GetReflectionObjKind<clang::DeclGroupRef>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DeclGroupRef; };
    template<> struct GetReflectionObjKind<clang::Stmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Stmt; };
    template<> struct GetReflectionObjKind<clang::Stmt::EmptyShell>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Stmt__EmptyShell; };
    template<> struct GetReflectionObjKind<clang::DeclStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DeclStmt; };
    template<> struct GetReflectionObjKind<clang::NullStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__NullStmt; };
    template<> struct GetReflectionObjKind<clang::CompoundStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CompoundStmt; };
    template<> struct GetReflectionObjKind<clang::SwitchCase>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SwitchCase; };
    template<> struct GetReflectionObjKind<clang::CaseStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CaseStmt; };
    template<> struct GetReflectionObjKind<clang::DefaultStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DefaultStmt; };
    template<> struct GetReflectionObjKind<clang::LabelStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__LabelStmt; };
    template<> struct GetReflectionObjKind<clang::AttributedStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__AttributedStmt; };
    template<> struct GetReflectionObjKind<clang::IfStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__IfStmt; };
    template<> struct GetReflectionObjKind<clang::SwitchStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SwitchStmt; };
    template<> struct GetReflectionObjKind<clang::WhileStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__WhileStmt; };
    template<> struct GetReflectionObjKind<clang::DoStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DoStmt; };
    template<> struct GetReflectionObjKind<clang::ForStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ForStmt; };
    template<> struct GetReflectionObjKind<clang::GotoStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__GotoStmt; };
    template<> struct GetReflectionObjKind<clang::IndirectGotoStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__IndirectGotoStmt; };
    template<> struct GetReflectionObjKind<clang::ContinueStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ContinueStmt; };
    template<> struct GetReflectionObjKind<clang::BreakStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__BreakStmt; };
    template<> struct GetReflectionObjKind<clang::ReturnStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ReturnStmt; };
    template<> struct GetReflectionObjKind<clang::AsmStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__AsmStmt; };
    template<> struct GetReflectionObjKind<clang::GCCAsmStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__GCCAsmStmt; };
    template<> struct GetReflectionObjKind<clang::MSAsmStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__MSAsmStmt; };
    template<> struct GetReflectionObjKind<clang::SEHExceptStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SEHExceptStmt; };
    template<> struct GetReflectionObjKind<clang::SEHFinallyStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SEHFinallyStmt; };
    template<> struct GetReflectionObjKind<clang::SEHTryStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SEHTryStmt; };
    template<> struct GetReflectionObjKind<clang::SEHLeaveStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SEHLeaveStmt; };
    template<> struct GetReflectionObjKind<clang::CapturedStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CapturedStmt; };
    template<> struct GetReflectionObjKind<clang::CapturedStmt::Capture>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CapturedStmt__Capture; };
    template<> struct GetReflectionObjKind<clang::TemplateArgument>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TemplateArgument; };
    template<> struct GetReflectionObjKind<clang::TemplateArgumentLocInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TemplateArgumentLocInfo; };
    template<> struct GetReflectionObjKind<clang::TemplateArgumentLoc>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TemplateArgumentLoc; };
    template<> struct GetReflectionObjKind<clang::TemplateArgumentListInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TemplateArgumentListInfo; };
    template<> struct GetReflectionObjKind<clang::ASTTemplateArgumentListInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ASTTemplateArgumentListInfo; };
    template<> struct GetReflectionObjKind<clang::TypeLoc>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypeLoc; };
    template<> struct GetReflectionObjKind<clang::UnqualTypeLoc>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UnqualTypeLoc; };
    template<> struct GetReflectionObjKind<clang::CommentOptions>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CommentOptions; };
    template<> struct GetReflectionObjKind<clang::comments::CommandInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__comments__CommandInfo; };
    template<> struct GetReflectionObjKind<clang::comments::CommandTraits>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__comments__CommandTraits; };
    template<> struct GetReflectionObjKind<llvm::Triple>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__Triple; };
    template<> struct GetReflectionObjKind<clang::ObjCRuntime>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCRuntime; };
    template<> struct GetReflectionObjKind<clang::SanitizerSet>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SanitizerSet; };
    template<> struct GetReflectionObjKind<clang::LangOptionsBase>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__LangOptionsBase; };
    template<> struct GetReflectionObjKind<clang::LangOptions>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__LangOptions; };
    template<> struct GetReflectionObjKind<clang::FPOptions>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FPOptions; };
    template<> struct GetReflectionObjKind<clang::PrinterHelper>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__PrinterHelper; };
    template<> struct GetReflectionObjKind<clang::PrintingPolicy>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__PrintingPolicy; };
    template<> struct GetReflectionObjKind<clang::SrcMgr::ContentCache>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SrcMgr__ContentCache; };
    template<> struct GetReflectionObjKind<clang::SrcMgr::FileInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SrcMgr__FileInfo; };
    template<> struct GetReflectionObjKind<clang::SrcMgr::ExpansionInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SrcMgr__ExpansionInfo; };
    template<> struct GetReflectionObjKind<clang::SrcMgr::SLocEntry>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SrcMgr__SLocEntry; };
    template<> struct GetReflectionObjKind<clang::SourceManager>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SourceManager; };
    template<> struct GetReflectionObjKind<clang::RawComment>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__RawComment; };
    template<> struct GetReflectionObjKind<clang::SanitizerBlacklist>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SanitizerBlacklist; };
    template<> struct GetReflectionObjKind<clang::TargetCXXABI>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TargetCXXABI; };
    template<> struct GetReflectionObjKind<clang::OpenCLOptions>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OpenCLOptions; };
    template<> struct GetReflectionObjKind<clang::TargetOptions>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TargetOptions; };
    template<> struct GetReflectionObjKind<llvm::Type>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__Type; };
    template<> struct GetReflectionObjKind<llvm::IntegerType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__IntegerType; };
    template<> struct GetReflectionObjKind<llvm::CompositeType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__CompositeType; };
    template<> struct GetReflectionObjKind<llvm::StructType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__StructType; };
    template<> struct GetReflectionObjKind<llvm::PointerType>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__PointerType; };
    template<> struct GetReflectionObjKind<llvm::DataLayout>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__DataLayout; };
    template<> struct GetReflectionObjKind<llvm::StructLayout>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_llvm__StructLayout; };
    template<> struct GetReflectionObjKind<clang::TargetInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TargetInfo; };
    template<> struct GetReflectionObjKind<clang::TargetInfo::ConstraintInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TargetInfo__ConstraintInfo; };
    template<> struct GetReflectionObjKind<clang::XRayFunctionFilter>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__XRayFunctionFilter; };
    template<> struct GetReflectionObjKind<clang::TypeInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypeInfo; };
    template<> struct GetReflectionObjKind<clang::ASTContext>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ASTContext; };
    template<> struct GetReflectionObjKind<clang::DeclAccessPair>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DeclAccessPair; };
    template<> struct GetReflectionObjKind<clang::UnresolvedSetIterator>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UnresolvedSetIterator; };
    template<> struct GetReflectionObjKind<clang::UnresolvedSetImpl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UnresolvedSetImpl; };
    template<> struct GetReflectionObjKind<clang::Expr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Expr; };
    template<> struct GetReflectionObjKind<clang::Expr::Classification>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Expr__Classification; };
    template<> struct GetReflectionObjKind<clang::Expr::EvalStatus>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Expr__EvalStatus; };
    template<> struct GetReflectionObjKind<clang::Expr::EvalResult>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Expr__EvalResult; };
    template<> struct GetReflectionObjKind<clang::OpaqueValueExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OpaqueValueExpr; };
    template<> struct GetReflectionObjKind<clang::DeclRefExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DeclRefExpr; };
    template<> struct GetReflectionObjKind<clang::PredefinedExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__PredefinedExpr; };
    template<> struct GetReflectionObjKind<clang::APIntStorage>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__APIntStorage; };
    template<> struct GetReflectionObjKind<clang::IntegerLiteral>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__IntegerLiteral; };
    template<> struct GetReflectionObjKind<clang::FixedPointLiteral>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FixedPointLiteral; };
    template<> struct GetReflectionObjKind<clang::CharacterLiteral>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CharacterLiteral; };
    template<> struct GetReflectionObjKind<clang::FloatingLiteral>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FloatingLiteral; };
    template<> struct GetReflectionObjKind<clang::ImaginaryLiteral>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ImaginaryLiteral; };
    template<> struct GetReflectionObjKind<clang::StringLiteral>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__StringLiteral; };
    template<> struct GetReflectionObjKind<clang::ParenExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ParenExpr; };
    template<> struct GetReflectionObjKind<clang::UnaryOperator>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UnaryOperator; };
    template<> struct GetReflectionObjKind<clang::OffsetOfNode>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OffsetOfNode; };
    template<> struct GetReflectionObjKind<clang::OffsetOfExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OffsetOfExpr; };
    template<> struct GetReflectionObjKind<clang::UnaryExprOrTypeTraitExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UnaryExprOrTypeTraitExpr; };
    template<> struct GetReflectionObjKind<clang::ArraySubscriptExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ArraySubscriptExpr; };
    template<> struct GetReflectionObjKind<clang::CallExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CallExpr; };
    template<> struct GetReflectionObjKind<clang::MemberExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__MemberExpr; };
    template<> struct GetReflectionObjKind<clang::CompoundLiteralExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CompoundLiteralExpr; };
    template<> struct GetReflectionObjKind<clang::CastExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CastExpr; };
    template<> struct GetReflectionObjKind<clang::ImplicitCastExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ImplicitCastExpr; };
    template<> struct GetReflectionObjKind<clang::ExplicitCastExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ExplicitCastExpr; };
    template<> struct GetReflectionObjKind<clang::CStyleCastExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CStyleCastExpr; };
    template<> struct GetReflectionObjKind<clang::BinaryOperator>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__BinaryOperator; };
    template<> struct GetReflectionObjKind<clang::CompoundAssignOperator>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CompoundAssignOperator; };
    template<> struct GetReflectionObjKind<clang::AbstractConditionalOperator>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__AbstractConditionalOperator; };
    template<> struct GetReflectionObjKind<clang::ConditionalOperator>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ConditionalOperator; };
    template<> struct GetReflectionObjKind<clang::BinaryConditionalOperator>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__BinaryConditionalOperator; };
    template<> struct GetReflectionObjKind<clang::AddrLabelExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__AddrLabelExpr; };
    template<> struct GetReflectionObjKind<clang::StmtExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__StmtExpr; };
    template<> struct GetReflectionObjKind<clang::ShuffleVectorExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ShuffleVectorExpr; };
    template<> struct GetReflectionObjKind<clang::ConvertVectorExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ConvertVectorExpr; };
    template<> struct GetReflectionObjKind<clang::ChooseExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ChooseExpr; };
    template<> struct GetReflectionObjKind<clang::GNUNullExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__GNUNullExpr; };
    template<> struct GetReflectionObjKind<clang::VAArgExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__VAArgExpr; };
    template<> struct GetReflectionObjKind<clang::InitListExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__InitListExpr; };
    template<> struct GetReflectionObjKind<clang::DesignatedInitExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DesignatedInitExpr; };
    template<> struct GetReflectionObjKind<clang::DesignatedInitExpr::Designator>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DesignatedInitExpr__Designator; };
    template<> struct GetReflectionObjKind<clang::NoInitExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__NoInitExpr; };
    template<> struct GetReflectionObjKind<clang::DesignatedInitUpdateExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DesignatedInitUpdateExpr; };
    template<> struct GetReflectionObjKind<clang::ArrayInitLoopExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ArrayInitLoopExpr; };
    template<> struct GetReflectionObjKind<clang::ArrayInitIndexExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ArrayInitIndexExpr; };
    template<> struct GetReflectionObjKind<clang::ImplicitValueInitExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ImplicitValueInitExpr; };
    template<> struct GetReflectionObjKind<clang::ParenListExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ParenListExpr; };
    template<> struct GetReflectionObjKind<clang::GenericSelectionExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__GenericSelectionExpr; };
    template<> struct GetReflectionObjKind<clang::ExtVectorElementExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ExtVectorElementExpr; };
    template<> struct GetReflectionObjKind<clang::BlockExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__BlockExpr; };
    template<> struct GetReflectionObjKind<clang::AsTypeExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__AsTypeExpr; };
    template<> struct GetReflectionObjKind<clang::PseudoObjectExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__PseudoObjectExpr; };
    template<> struct GetReflectionObjKind<clang::AtomicExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__AtomicExpr; };
    template<> struct GetReflectionObjKind<clang::TypoExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypoExpr; };
    template<> struct GetReflectionObjKind<clang::Attr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__Attr; };
    template<> struct GetReflectionObjKind<clang::InheritableAttr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__InheritableAttr; };
    template<> struct GetReflectionObjKind<clang::ExternalSourceSymbolAttr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ExternalSourceSymbolAttr; };
    template<> struct GetReflectionObjKind<clang::MSInheritanceAttr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__MSInheritanceAttr; };
    template<> struct GetReflectionObjKind<clang::MSVtorDispAttr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__MSVtorDispAttr; };
    template<> struct GetReflectionObjKind<clang::LambdaCapture>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__LambdaCapture; };
    template<> struct GetReflectionObjKind<clang::AccessSpecDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__AccessSpecDecl; };
    template<> struct GetReflectionObjKind<clang::CXXBaseSpecifier>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXBaseSpecifier; };
    template<> struct GetReflectionObjKind<clang::CXXRecordDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXRecordDecl; };
    template<> struct GetReflectionObjKind<clang::CXXDeductionGuideDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXDeductionGuideDecl; };
    template<> struct GetReflectionObjKind<clang::CXXMethodDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXMethodDecl; };
    template<> struct GetReflectionObjKind<clang::CXXCtorInitializer>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXCtorInitializer; };
    template<> struct GetReflectionObjKind<clang::InheritedConstructor>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__InheritedConstructor; };
    template<> struct GetReflectionObjKind<clang::CXXConstructorDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXConstructorDecl; };
    template<> struct GetReflectionObjKind<clang::CXXDestructorDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXDestructorDecl; };
    template<> struct GetReflectionObjKind<clang::CXXConversionDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXConversionDecl; };
    template<> struct GetReflectionObjKind<clang::LinkageSpecDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__LinkageSpecDecl; };
    template<> struct GetReflectionObjKind<clang::UsingDirectiveDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UsingDirectiveDecl; };
    template<> struct GetReflectionObjKind<clang::NamespaceAliasDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__NamespaceAliasDecl; };
    template<> struct GetReflectionObjKind<clang::UsingShadowDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UsingShadowDecl; };
    template<> struct GetReflectionObjKind<clang::ConstructorUsingShadowDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ConstructorUsingShadowDecl; };
    template<> struct GetReflectionObjKind<clang::UsingDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UsingDecl; };
    template<> struct GetReflectionObjKind<clang::UsingPackDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UsingPackDecl; };
    template<> struct GetReflectionObjKind<clang::UnresolvedUsingValueDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UnresolvedUsingValueDecl; };
    template<> struct GetReflectionObjKind<clang::UnresolvedUsingTypenameDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UnresolvedUsingTypenameDecl; };
    template<> struct GetReflectionObjKind<clang::StaticAssertDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__StaticAssertDecl; };
    template<> struct GetReflectionObjKind<clang::BindingDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__BindingDecl; };
    template<> struct GetReflectionObjKind<clang::DecompositionDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DecompositionDecl; };
    template<> struct GetReflectionObjKind<clang::MSPropertyDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__MSPropertyDecl; };
    template<> struct GetReflectionObjKind<clang::ConstexprDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ConstexprDecl; };
    template<> struct GetReflectionObjKind<clang::TemplateParameterList>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TemplateParameterList; };
    template<> struct GetReflectionObjKind<clang::TemplateArgumentList>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TemplateArgumentList; };
    template<> struct GetReflectionObjKind<clang::TemplateDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TemplateDecl; };
    template<> struct GetReflectionObjKind<clang::FunctionTemplateSpecializationInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FunctionTemplateSpecializationInfo; };
    template<> struct GetReflectionObjKind<clang::MemberSpecializationInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__MemberSpecializationInfo; };
    template<> struct GetReflectionObjKind<clang::DependentFunctionTemplateSpecializationInfo>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DependentFunctionTemplateSpecializationInfo; };
    template<> struct GetReflectionObjKind<clang::RedeclarableTemplateDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__RedeclarableTemplateDecl; };
    template<> struct GetReflectionObjKind<clang::FunctionTemplateDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FunctionTemplateDecl; };
    template<> struct GetReflectionObjKind<clang::TemplateTypeParmDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TemplateTypeParmDecl; };
    template<> struct GetReflectionObjKind<clang::NonTypeTemplateParmDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__NonTypeTemplateParmDecl; };
    template<> struct GetReflectionObjKind<clang::TemplateTemplateParmDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TemplateTemplateParmDecl; };
    template<> struct GetReflectionObjKind<clang::BuiltinTemplateDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__BuiltinTemplateDecl; };
    template<> struct GetReflectionObjKind<clang::ClassTemplateSpecializationDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ClassTemplateSpecializationDecl; };
    template<> struct GetReflectionObjKind<clang::ClassTemplatePartialSpecializationDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ClassTemplatePartialSpecializationDecl; };
    template<> struct GetReflectionObjKind<clang::ClassTemplateDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ClassTemplateDecl; };
    template<> struct GetReflectionObjKind<clang::FriendTemplateDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FriendTemplateDecl; };
    template<> struct GetReflectionObjKind<clang::TypeAliasTemplateDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypeAliasTemplateDecl; };
    template<> struct GetReflectionObjKind<clang::ClassScopeFunctionSpecializationDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ClassScopeFunctionSpecializationDecl; };
    template<> struct GetReflectionObjKind<clang::VarTemplateSpecializationDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__VarTemplateSpecializationDecl; };
    template<> struct GetReflectionObjKind<clang::VarTemplatePartialSpecializationDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__VarTemplatePartialSpecializationDecl; };
    template<> struct GetReflectionObjKind<clang::VarTemplateDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__VarTemplateDecl; };
    template<> struct GetReflectionObjKind<clang::FriendDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FriendDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCListBase>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCListBase; };
    template<> struct GetReflectionObjKind<clang::ObjCProtocolList>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCProtocolList; };
    template<> struct GetReflectionObjKind<clang::ObjCMethodDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCMethodDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCTypeParamDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCTypeParamDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCTypeParamList>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCTypeParamList; };
    template<> struct GetReflectionObjKind<clang::ObjCPropertyDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCPropertyDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCContainerDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCContainerDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCInterfaceDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCInterfaceDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCIvarDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCIvarDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCAtDefsFieldDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCAtDefsFieldDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCProtocolDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCProtocolDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCCategoryDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCCategoryDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCImplDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCImplDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCCategoryImplDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCCategoryImplDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCImplementationDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCImplementationDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCCompatibleAliasDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCCompatibleAliasDecl; };
    template<> struct GetReflectionObjKind<clang::ObjCPropertyImplDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCPropertyImplDecl; };
    template<> struct GetReflectionObjKind<clang::OMPThreadPrivateDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPThreadPrivateDecl; };
    template<> struct GetReflectionObjKind<clang::OMPDeclareReductionDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPDeclareReductionDecl; };
    template<> struct GetReflectionObjKind<clang::OMPCapturedExprDecl>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPCapturedExprDecl; };
    template<> struct GetReflectionObjKind<clang::CXXOperatorCallExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXOperatorCallExpr; };
    template<> struct GetReflectionObjKind<clang::CXXMemberCallExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXMemberCallExpr; };
    template<> struct GetReflectionObjKind<clang::CUDAKernelCallExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CUDAKernelCallExpr; };
    template<> struct GetReflectionObjKind<clang::CXXNamedCastExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXNamedCastExpr; };
    template<> struct GetReflectionObjKind<clang::CXXStaticCastExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXStaticCastExpr; };
    template<> struct GetReflectionObjKind<clang::CXXDynamicCastExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXDynamicCastExpr; };
    template<> struct GetReflectionObjKind<clang::CXXReinterpretCastExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXReinterpretCastExpr; };
    template<> struct GetReflectionObjKind<clang::CXXConstCastExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXConstCastExpr; };
    template<> struct GetReflectionObjKind<clang::UserDefinedLiteral>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UserDefinedLiteral; };
    template<> struct GetReflectionObjKind<clang::CXXBoolLiteralExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXBoolLiteralExpr; };
    template<> struct GetReflectionObjKind<clang::CXXNullPtrLiteralExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXNullPtrLiteralExpr; };
    template<> struct GetReflectionObjKind<clang::CXXStdInitializerListExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXStdInitializerListExpr; };
    template<> struct GetReflectionObjKind<clang::CXXTypeidExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXTypeidExpr; };
    template<> struct GetReflectionObjKind<clang::MSPropertyRefExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__MSPropertyRefExpr; };
    template<> struct GetReflectionObjKind<clang::MSPropertySubscriptExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__MSPropertySubscriptExpr; };
    template<> struct GetReflectionObjKind<clang::CXXUuidofExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXUuidofExpr; };
    template<> struct GetReflectionObjKind<clang::CXXThisExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXThisExpr; };
    template<> struct GetReflectionObjKind<clang::CXXThrowExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXThrowExpr; };
    template<> struct GetReflectionObjKind<clang::CXXDefaultArgExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXDefaultArgExpr; };
    template<> struct GetReflectionObjKind<clang::CXXDefaultInitExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXDefaultInitExpr; };
    template<> struct GetReflectionObjKind<clang::CXXTemporary>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXTemporary; };
    template<> struct GetReflectionObjKind<clang::CXXBindTemporaryExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXBindTemporaryExpr; };
    template<> struct GetReflectionObjKind<clang::CXXConstructExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXConstructExpr; };
    template<> struct GetReflectionObjKind<clang::CXXInheritedCtorInitExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXInheritedCtorInitExpr; };
    template<> struct GetReflectionObjKind<clang::CXXFunctionalCastExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXFunctionalCastExpr; };
    template<> struct GetReflectionObjKind<clang::CXXTemporaryObjectExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXTemporaryObjectExpr; };
    template<> struct GetReflectionObjKind<clang::LambdaExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__LambdaExpr; };
    template<> struct GetReflectionObjKind<clang::CXXScalarValueInitExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXScalarValueInitExpr; };
    template<> struct GetReflectionObjKind<clang::CXXNewExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXNewExpr; };
    template<> struct GetReflectionObjKind<clang::CXXDeleteExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXDeleteExpr; };
    template<> struct GetReflectionObjKind<clang::CXXPseudoDestructorExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXPseudoDestructorExpr; };
    template<> struct GetReflectionObjKind<clang::TypeTraitExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__TypeTraitExpr; };
    template<> struct GetReflectionObjKind<clang::ArrayTypeTraitExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ArrayTypeTraitExpr; };
    template<> struct GetReflectionObjKind<clang::ExpressionTraitExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ExpressionTraitExpr; };
    template<> struct GetReflectionObjKind<clang::OverloadExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OverloadExpr; };
    template<> struct GetReflectionObjKind<clang::OverloadExpr::FindResult>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OverloadExpr__FindResult; };
    template<> struct GetReflectionObjKind<clang::UnresolvedLookupExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UnresolvedLookupExpr; };
    template<> struct GetReflectionObjKind<clang::DependentScopeDeclRefExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DependentScopeDeclRefExpr; };
    template<> struct GetReflectionObjKind<clang::ExprWithCleanups>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ExprWithCleanups; };
    template<> struct GetReflectionObjKind<clang::CXXUnresolvedConstructExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXUnresolvedConstructExpr; };
    template<> struct GetReflectionObjKind<clang::CXXDependentScopeMemberExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXDependentScopeMemberExpr; };
    template<> struct GetReflectionObjKind<clang::UnresolvedMemberExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__UnresolvedMemberExpr; };
    template<> struct GetReflectionObjKind<clang::CXXNoexceptExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXNoexceptExpr; };
    template<> struct GetReflectionObjKind<clang::PackExpansionExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__PackExpansionExpr; };
    template<> struct GetReflectionObjKind<clang::SizeOfPackExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SizeOfPackExpr; };
    template<> struct GetReflectionObjKind<clang::SubstNonTypeTemplateParmExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SubstNonTypeTemplateParmExpr; };
    template<> struct GetReflectionObjKind<clang::SubstNonTypeTemplateParmPackExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__SubstNonTypeTemplateParmPackExpr; };
    template<> struct GetReflectionObjKind<clang::FunctionParmPackExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__FunctionParmPackExpr; };
    template<> struct GetReflectionObjKind<clang::MaterializeTemporaryExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__MaterializeTemporaryExpr; };
    template<> struct GetReflectionObjKind<clang::CXXFoldExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXFoldExpr; };
    template<> struct GetReflectionObjKind<clang::CoroutineSuspendExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CoroutineSuspendExpr; };
    template<> struct GetReflectionObjKind<clang::CoawaitExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CoawaitExpr; };
    template<> struct GetReflectionObjKind<clang::DependentCoawaitExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DependentCoawaitExpr; };
    template<> struct GetReflectionObjKind<clang::CoyieldExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CoyieldExpr; };
    template<> struct GetReflectionObjKind<clang::ReflectionExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ReflectionExpr; };
    template<> struct GetReflectionObjKind<clang::CompilerMessageExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CompilerMessageExpr; };
    template<> struct GetReflectionObjKind<clang::CompilerDiagnosticExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CompilerDiagnosticExpr; };
    template<> struct GetReflectionObjKind<clang::CXXMetaparseExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXMetaparseExpr; };
    template<> struct GetReflectionObjKind<clang::ReflectionTraitExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ReflectionTraitExpr; };
    template<> struct GetReflectionObjKind<clang::ReflectNewExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ReflectNewExpr; };
    template<> struct GetReflectionObjKind<clang::ReflectDeleteExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ReflectDeleteExpr; };
    template<> struct GetReflectionObjKind<clang::CXXConstantExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXConstantExpr; };
    template<> struct GetReflectionObjKind<clang::CXXDependentIdExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXDependentIdExpr; };
    template<> struct GetReflectionObjKind<clang::CXXConcatenateExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXConcatenateExpr; };
    template<> struct GetReflectionObjKind<clang::ObjCStringLiteral>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCStringLiteral; };
    template<> struct GetReflectionObjKind<clang::ObjCBoolLiteralExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCBoolLiteralExpr; };
    template<> struct GetReflectionObjKind<clang::ObjCBoxedExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCBoxedExpr; };
    template<> struct GetReflectionObjKind<clang::ObjCArrayLiteral>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCArrayLiteral; };
    template<> struct GetReflectionObjKind<clang::ObjCDictionaryElement>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCDictionaryElement; };
    template<> struct GetReflectionObjKind<clang::ObjCDictionaryLiteral>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCDictionaryLiteral; };
    template<> struct GetReflectionObjKind<clang::ObjCEncodeExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCEncodeExpr; };
    template<> struct GetReflectionObjKind<clang::ObjCSelectorExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCSelectorExpr; };
    template<> struct GetReflectionObjKind<clang::ObjCProtocolExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCProtocolExpr; };
    template<> struct GetReflectionObjKind<clang::ObjCIvarRefExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCIvarRefExpr; };
    template<> struct GetReflectionObjKind<clang::ObjCPropertyRefExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCPropertyRefExpr; };
    template<> struct GetReflectionObjKind<clang::ObjCSubscriptRefExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCSubscriptRefExpr; };
    template<> struct GetReflectionObjKind<clang::ObjCMessageExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCMessageExpr; };
    template<> struct GetReflectionObjKind<clang::ObjCIsaExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCIsaExpr; };
    template<> struct GetReflectionObjKind<clang::ObjCIndirectCopyRestoreExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCIndirectCopyRestoreExpr; };
    template<> struct GetReflectionObjKind<clang::ObjCBridgedCastExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCBridgedCastExpr; };
    template<> struct GetReflectionObjKind<clang::ObjCAvailabilityCheckExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCAvailabilityCheckExpr; };
    template<> struct GetReflectionObjKind<clang::OMPArraySectionExpr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPArraySectionExpr; };
    template<> struct GetReflectionObjKind<clang::CXXCatchStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXCatchStmt; };
    template<> struct GetReflectionObjKind<clang::CXXTryStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXTryStmt; };
    template<> struct GetReflectionObjKind<clang::CXXForRangeStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXForRangeStmt; };
    template<> struct GetReflectionObjKind<clang::CXXExpansionStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXExpansionStmt; };
    template<> struct GetReflectionObjKind<clang::CXXTupleExpansionStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXTupleExpansionStmt; };
    template<> struct GetReflectionObjKind<clang::CXXPackExpansionStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXPackExpansionStmt; };
    template<> struct GetReflectionObjKind<clang::MSDependentExistsStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__MSDependentExistsStmt; };
    template<> struct GetReflectionObjKind<clang::CoroutineBodyStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CoroutineBodyStmt; };
    template<> struct GetReflectionObjKind<clang::CoroutineBodyStmt::CtorArgs>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CoroutineBodyStmt__CtorArgs; };
    template<> struct GetReflectionObjKind<clang::CoreturnStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CoreturnStmt; };
    template<> struct GetReflectionObjKind<clang::CXXQueueMetaparseStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__CXXQueueMetaparseStmt; };
    template<> struct GetReflectionObjKind<clang::ObjCForCollectionStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCForCollectionStmt; };
    template<> struct GetReflectionObjKind<clang::ObjCAtCatchStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCAtCatchStmt; };
    template<> struct GetReflectionObjKind<clang::ObjCAtFinallyStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCAtFinallyStmt; };
    template<> struct GetReflectionObjKind<clang::ObjCAtTryStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCAtTryStmt; };
    template<> struct GetReflectionObjKind<clang::ObjCAtSynchronizedStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCAtSynchronizedStmt; };
    template<> struct GetReflectionObjKind<clang::ObjCAtThrowStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCAtThrowStmt; };
    template<> struct GetReflectionObjKind<clang::ObjCAutoreleasePoolStmt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__ObjCAutoreleasePoolStmt; };
    template<> struct GetReflectionObjKind<clang::OMPClause>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPClause; };
    template<> struct GetReflectionObjKind<clang::OMPExecutableDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPExecutableDirective; };
    template<> struct GetReflectionObjKind<clang::OMPParallelDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPParallelDirective; };
    template<> struct GetReflectionObjKind<clang::OMPLoopDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPLoopDirective; };
    template<> struct GetReflectionObjKind<clang::OMPSimdDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPSimdDirective; };
    template<> struct GetReflectionObjKind<clang::OMPForDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPForDirective; };
    template<> struct GetReflectionObjKind<clang::OMPForSimdDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPForSimdDirective; };
    template<> struct GetReflectionObjKind<clang::OMPSectionsDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPSectionsDirective; };
    template<> struct GetReflectionObjKind<clang::OMPSectionDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPSectionDirective; };
    template<> struct GetReflectionObjKind<clang::OMPSingleDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPSingleDirective; };
    template<> struct GetReflectionObjKind<clang::OMPMasterDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPMasterDirective; };
    template<> struct GetReflectionObjKind<clang::OMPCriticalDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPCriticalDirective; };
    template<> struct GetReflectionObjKind<clang::OMPParallelForDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPParallelForDirective; };
    template<> struct GetReflectionObjKind<clang::OMPParallelForSimdDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPParallelForSimdDirective; };
    template<> struct GetReflectionObjKind<clang::OMPParallelSectionsDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPParallelSectionsDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTaskDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTaskDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTaskyieldDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTaskyieldDirective; };
    template<> struct GetReflectionObjKind<clang::OMPBarrierDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPBarrierDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTaskwaitDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTaskwaitDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTaskgroupDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTaskgroupDirective; };
    template<> struct GetReflectionObjKind<clang::OMPFlushDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPFlushDirective; };
    template<> struct GetReflectionObjKind<clang::OMPOrderedDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPOrderedDirective; };
    template<> struct GetReflectionObjKind<clang::OMPAtomicDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPAtomicDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetDataDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetDataDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetEnterDataDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetEnterDataDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetExitDataDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetExitDataDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetParallelDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetParallelDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetParallelForDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetParallelForDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTeamsDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTeamsDirective; };
    template<> struct GetReflectionObjKind<clang::OMPCancellationPointDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPCancellationPointDirective; };
    template<> struct GetReflectionObjKind<clang::OMPCancelDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPCancelDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTaskLoopDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTaskLoopDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTaskLoopSimdDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTaskLoopSimdDirective; };
    template<> struct GetReflectionObjKind<clang::OMPDistributeDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPDistributeDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetUpdateDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetUpdateDirective; };
    template<> struct GetReflectionObjKind<clang::OMPDistributeParallelForDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPDistributeParallelForDirective; };
    template<> struct GetReflectionObjKind<clang::OMPDistributeParallelForSimdDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPDistributeParallelForSimdDirective; };
    template<> struct GetReflectionObjKind<clang::OMPDistributeSimdDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPDistributeSimdDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetParallelForSimdDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetParallelForSimdDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetSimdDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetSimdDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTeamsDistributeDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTeamsDistributeDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTeamsDistributeSimdDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTeamsDistributeSimdDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTeamsDistributeParallelForSimdDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTeamsDistributeParallelForSimdDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTeamsDistributeParallelForDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTeamsDistributeParallelForDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetTeamsDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetTeamsDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetTeamsDistributeDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetTeamsDistributeDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetTeamsDistributeParallelForDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetTeamsDistributeParallelForDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetTeamsDistributeParallelForSimdDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetTeamsDistributeParallelForSimdDirective; };
    template<> struct GetReflectionObjKind<clang::OMPTargetTeamsDistributeSimdDirective>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__OMPTargetTeamsDistributeSimdDirective; };
    template<> struct GetReflectionObjKind<clang::StoredDeclsMap>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__StoredDeclsMap; };
    template<> struct GetReflectionObjKind<clang::DependentDiagnostic>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_clang__DependentDiagnostic; };
    template<> struct GetReflectionObjKind<reflcontainers::VectorStr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_reflcontainers__VectorStr; };
    template<> struct GetReflectionObjKind<reflcontainers::VectorInt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_reflcontainers__VectorInt; };
    template<> struct GetReflectionObjKind<reflcontainers::SetInt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_reflcontainers__SetInt; };
    template<> struct GetReflectionObjKind<reflcontainers::SetStr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_reflcontainers__SetStr; };
    template<> struct GetReflectionObjKind<reflcontainers::IntIntPair>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_reflcontainers__IntIntPair; };
    template<> struct GetReflectionObjKind<reflcontainers::IntStrPair>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_reflcontainers__IntStrPair; };
    template<> struct GetReflectionObjKind<reflcontainers::StrIntPair>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_reflcontainers__StrIntPair; };
    template<> struct GetReflectionObjKind<reflcontainers::StrStrPair>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_reflcontainers__StrStrPair; };
    template<> struct GetReflectionObjKind<reflcontainers::MapIntStr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_reflcontainers__MapIntStr; };
    template<> struct GetReflectionObjKind<reflcontainers::MapStrInt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_reflcontainers__MapStrInt; };
    template<> struct GetReflectionObjKind<reflcontainers::MapStrStr>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_reflcontainers__MapStrStr; };
    template<> struct GetReflectionObjKind<reflcontainers::MapIntInt>
    { static constexpr reflenums::ReflectionObjKind value = reflenums::RK_reflcontainers__MapIntInt; };
  } //namespace refldetail

#else
# define reflnew(T)  (cppx::meta::refldetail::ptrwrp<T>())
#endif //!__CONSUMER_SUPPORTS_REFLECTION_AND_META__

/////////// CUSTOM DIAGNOSTICS //////////////
  
#ifdef __CONSUMER_SUPPORTS_REFLECTION_AND_META__
  
  template<template<intptr_t...> class TMPL, intptr_t ISPTR, intptr_t X>
  constexpr intptr_t getReflVal(TMPL<ISPTR, X>) {
    return X;
  }
  template<typename T>
  constexpr intptr_t getReflVal(refldetail::ptrwrp<T>) {
    return getReflVal(T());
  }
  constexpr intptr_t getReflVal(intptr_t X) {
    return X;
  }
  
  namespace user {
    
    /// A trivial tuple used to represent a source range,
    /// constructed by the user rather than returned by reflection.
    template<intptr_t Y0, intptr_t Y1>
    struct SourceRange {
      constexpr SourceRange(clang::SourceLocation<0, Y0> begin,
                            clang::SourceLocation<0, Y1> end)
      {}
    };
    // Deduction guide
    template<intptr_t Y0, intptr_t Y1>
    SourceRange(clang::SourceLocation<0, Y0> begin,
                clang::SourceLocation<0, Y1> end) -> SourceRange<Y0, Y1>;
    
    /// Represents a character-granular source range, constructed by the user
    /// rather than returned via reflection.
    ///
    /// The underlying SourceRange can either specify the starting/ending character
    /// of the range, or it can specify the start of the range and the start of the
    /// last token of the range (a "token range").  In the token range case, the
    /// size of the last token must be measured to determine the actual end of the
    /// range.
    template<intptr_t Y0, intptr_t Y1>
    struct CharSourceRange {
      bool IsTokenRange;
      
      /// @param EndToken1Char0 -- true if the "end" location is to
      /// (the starting char of) the last token; false if the end
      /// is to the very last char (of the last token).
      constexpr CharSourceRange(clang::SourceLocation<0, Y0> begin,
                                clang::SourceLocation<0, Y1> end,
                                bool EndToken1Char0)
          : IsTokenRange(EndToken1Char0)
      {}
    };
    // Deduction guide
    template<intptr_t Y0, intptr_t Y1>
    CharSourceRange(clang::SourceLocation<0, Y0> begin,
                    clang::SourceLocation<0, Y1> end,
                    bool EndToken1Char0) -> CharSourceRange<Y0, Y1>;
    
    
    /// Annotates a diagnostic with some code that should be
    /// inserted, removed, or replaced to fix a user-defined
    /// problem with code that is otherwise acceptable to the compiler;
    /// e.g. a policy that the user wants to apply in a certain namespace,
    /// etc.
    ///
    /// These will behave identically to compiler-defined FixItHints (you will
    /// see the replacement suggestions in your IDE, can automatically apply
    /// them by running clang with certain flags, etc.), except that the message
    /// will be ((surrounded in double-parentheses)), to visually distinguish it from
    /// compiler-defined fixits.
    class FixItHint {
      template<typename THIRD_FIELD_T>
      struct fixitdata {
        /*[0]*/intptr_t locA;
        /*[1]*/intptr_t locB;
        /*[2]*/THIRD_FIELD_T locC_or_Str;
        /*[3]*/unsigned IsTokenRange = 2; //2 = unset
        constexpr fixitdata(intptr_t locA, intptr_t locB, THIRD_FIELD_T locC_or_Str, unsigned IsTokenRange)
                : locA(locA), locB(locB), locC_or_Str(locC_or_Str), IsTokenRange(IsTokenRange)
        {}
      };
      //Deduction guide
      template<typename THIRD_FIELD_T>
      fixitdata(intptr_t, intptr_t, THIRD_FIELD_T, unsigned itr = 2) -> fixitdata<THIRD_FIELD_T>;
      
    public:
      /// Create a code modification hint that inserts the given
      /// code string at a specific location.
      template<intptr_t X>
      static constexpr auto CreateInsertion(clang::SourceLocation</*IsPtr=*/0, X> InsLoc,
                                            const char *Code) {
        return fixitdata(X, 0, Code, 2);
      }
      
      /// Create a code modification hint that inserts the given
      /// code from \p FromRange at a specific location.
      template<intptr_t X0, intptr_t... X1s>
      static constexpr auto CreateInsertionFromRange(clang::SourceLocation</*IsPtr=*/0, X0> InsLoc,
                                                     clang::CharSourceRange<0, X1s...> Range) {
        return fixitdata(X0, getReflVal(Range.getBegin()), getReflVal(Range.getEnd()), Range.isTokenRange());
      }
      /// Create a code modification hint that inserts the given
      /// code from \p FromRange at a specific location.
      /// This overload takes a user-constructed CharSourceRange.
      template<intptr_t X0, intptr_t X1, intptr_t X2>
      static constexpr auto CreateInsertionFromRange(clang::SourceLocation<0, X0> InsLoc,
                                                     user::CharSourceRange<X1, X2> CustomRange) {
        return fixitdata(X0, X1, X2, CustomRange.IsTokenRange);
      }
      
      /// Create a code modification hint that removes the given
      /// source range.
      template<intptr_t... Xs>
      static constexpr auto CreateRemoval(clang::CharSourceRange<0, Xs...> Range) {
        return fixitdata(getReflVal(Range.getBegin()), getReflVal(Range.getEnd()), 0, Range.isTokenRange());
      }
      /// Create a code modification hint that removes the given
      /// source range.
      /// This overload takes a reflected clang::SourceRange.
      template<intptr_t... Xs>
      static constexpr auto CreateRemoval(clang::SourceRange<0, Xs...> Range) {
        return fixitdata(getReflVal(Range.getBegin()), getReflVal(Range.getEnd()), 0, 2);
      }
      /// Create a code modification hint that removes the given
      /// source range.
      /// This overload takes a user-constructed CharSourceRange.
      template<intptr_t X0, intptr_t X1>
      static constexpr auto CreateRemoval(user::CharSourceRange<X0, X1> CustomRange) {
        return fixitdata(X0, X1, 0, CustomRange.IsTokenRange);
      }
      /// Create a code modification hint that removes the given
      /// source range.
      /// This overload takes a user-constructed SourceRange.
      template<intptr_t X0, intptr_t X1>
      static constexpr auto CreateRemoval(user::SourceRange<X0, X1> CustomRange) {
        return fixitdata(X0, X1, 0, 2);
      }
      
      /// Create a code modification hint that replaces the given
      /// source range with the given code string.
      template<intptr_t... Xs>
      static constexpr auto CreateReplacement(clang::CharSourceRange<0, Xs...> Range, const char *Code) {
        return fixitdata(getReflVal(Range.getBegin()), getReflVal(Range.getEnd()), Code, Range.isTokenRange());
      }
      /// Create a code modification hint that replaces the given
      /// source range with the given code string.
      /// This overload takes a reflected clang::SourceRange.
      template<intptr_t... Xs>
      static constexpr auto CreateReplacement(clang::SourceRange<0, Xs...> Range, const char *Code) {
        return fixitdata(getReflVal(Range.getBegin()), getReflVal(Range.getEnd()), Code, 2);
      }
      /// Create a code modification hint that replaces the given
      /// source range with the given code string.
      /// This overload takes a user-constructed CharSourceRange.
      template<intptr_t X0, intptr_t X1>
      static constexpr auto CreateReplacement(user::CharSourceRange<X0, X1> CustomRange, const char *Code) {
        return fixitdata(X0, X1, Code, CustomRange.IsTokenRange);
      }
      /// Create a code modification hint that replaces the given
      /// source range with the given code string.
      /// This overload takes a user-constructed SourceRange.
      template<intptr_t X0, intptr_t X1>
      static constexpr auto CreateReplacement(user::SourceRange<X0, X1> CustomRange, const char *Code) {
        return fixitdata(X0, X1, Code, 2);
      }
    };
  } //namespace user

# define ce_diag(Kind, Loc, ...) __compiler_diag(Kind, cppx::meta::getReflVal(Loc), __VA_ARGS__)
  
#else //!__CONSUMER_SUPPORTS_REFLECTION_AND_META__
  
  template<typename T> constexpr intptr_t getReflVal(T t) { return 0; }
  
  namespace user {
    /// A trivial tuple used to represent a source range,
    /// constructed by the user rather than returned by reflection.
    struct SourceRange {
      constexpr SourceRange(clang::SourceLocation begin, clang::SourceLocation end) {}
    };
    
    /// Represents a character-granular source range, constructed by the user
    /// rather than returned via reflection.
    ///
    /// The underlying SourceRange can either specify the starting/ending character
    /// of the range, or it can specify the start of the range and the start of the
    /// last token of the range (a "token range").  In the token range case, the
    /// size of the last token must be measured to determine the actual end of the
    /// range.
    struct CharSourceRange {
      bool IsTokenRange;
      
      /// @param EndToken1Char0 -- true if the "end" location is to
      /// (the starting char of) the last token; false if the end
      /// is to the very last char (of the last token).
      constexpr CharSourceRange(clang::SourceLocation begin,
                                clang::SourceLocation end,
                                bool EndToken1Char0)
          : IsTokenRange(EndToken1Char0)
      {}
    };
    
    /// Annotates a diagnostic with some code that should be
    /// inserted, removed, or replaced to fix a user-defined
    /// problem with code that is otherwise acceptable to the compiler;
    /// e.g. a policy that the user wants to apply in a certain namespace,
    /// etc.
    ///
    /// These will behave identically to compiler-defined FixItHints (you will
    /// see the replacement suggestions in your IDE, can automatically apply
    /// them by running clang with certain flags, etc.), except that the message
    /// will be surrounded in parentheses, to visually distinguish it from
    /// compiler-defined fixits.
    class FixItHint {
      struct fixitdata {};
    public:
      /// Create a code modification hint that inserts the given
      /// code string at a specific location.
      static constexpr auto CreateInsertion(clang::SourceLocation InsLoc,
                                            const char *Code) {
        return fixitdata();
      }
      
      /// Create a code modification hint that inserts the given
      /// code from \p FromRange at a specific location.
      /// This overload takes a reflected clang::CharSourceRange.
      static constexpr auto CreateInsertionFromRange(clang::SourceLocation InsLoc,
                                                     clang::CharSourceRange Range) {
        return fixitdata();
      }
      
      /// Create a code modification hint that inserts the given
      /// code from \p FromRange at a specific location.
      /// This overload takes a user-constructed CharSourceRange.
      static constexpr auto CreateInsertionFromRange(clang::SourceLocation InsLoc,
                                                     user::CharSourceRange CustomRange) {
        return fixitdata();
      }
      
      /// Create a code modification hint that removes the given
      /// source range.
      static constexpr auto CreateRemoval(clang::CharSourceRange Range) {
        return fixitdata();
      }
      /// Create a code modification hint that removes the given
      /// source range.
      /// This overload takes a reflected clang::SourceRange.
      static constexpr auto CreateRemoval(clang::SourceRange Range) {
        return fixitdata();
      }
      /// Create a code modification hint that removes the given
      /// source range.
      /// This overload takes a user-constructed CharSourceRange.
      static constexpr auto CreateRemoval(user::CharSourceRange CustomRange) {
        return fixitdata();
      }
      /// Create a code modification hint that removes the given
      /// source range.
      /// This overload takes a user-constructed SourceRange.
      static constexpr auto CreateRemoval(user::SourceRange CustomRange) {
        return fixitdata();
      }
      
      /// Create a code modification hint that replaces the given
      /// source range with the given code string.
      static constexpr auto CreateReplacement(clang::CharSourceRange Range, const char *Code) {
        return fixitdata();
      }
      /// Create a code modification hint that replaces the given
      /// source range with the given code string.
      /// This overload takes a reflected clang::SourceRange.
      static constexpr auto CreateReplacement(clang::SourceRange Range, const char *Code) {
        return fixitdata();
      }
      /// Create a code modification hint that replaces the given
      /// source range with the given code string.
      /// This overload takes a user-constructed CharSourceRange.
      static constexpr auto CreateReplacement(user::CharSourceRange CustomRange, const char *Code) {
        return fixitdata();
      }
      /// Create a code modification hint that replaces the given
      /// source range with the given code string.
      /// This overload takes a user-constructed SourceRange.
      static constexpr auto CreateReplacement(user::SourceRange CustomRange, const char *Code) {
        return fixitdata();
      }
    };
  } //namespace user

# define ce_diag(Kind, Loc, ...)
  
#endif


} // namespace meta 

} //namespace cppx


#ifdef __CONSUMER_SUPPORTS_REFLECTION_AND_META__
namespace std {
  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::APValue::getMemberPointerPath_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::APValue::getMemberPointerPath_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::APValue::getMemberPointerPath_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::APValue::getMemberPointerPath_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DeclarationName::getCXXIdExprArguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DeclarationName::getCXXIdExprArguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DeclarationName::getCXXIdExprArguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DeclarationName::getCXXIdExprArguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::Decl::attrs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::Decl::attrs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::Decl::attrs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::Decl::attrs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::Decl::redecls_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::Decl::redecls_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::Decl::redecls_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::Decl::redecls_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DeclContextLookupResult::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DeclContextLookupResult::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DeclContextLookupResult::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DeclContextLookupResult::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DeclContext::decls_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DeclContext::decls_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DeclContext::decls_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DeclContext::decls_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DeclContext::noload_decls_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DeclContext::noload_decls_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DeclContext::noload_decls_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DeclContext::noload_decls_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DeclContext::lookups_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DeclContext::lookups_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DeclContext::lookups_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DeclContext::lookups_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DeclContext::ddiags_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DeclContext::ddiags_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DeclContext::ddiags_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DeclContext::ddiags_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ASTFileSignature::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ASTFileSignature::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ASTFileSignature::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ASTFileSignature::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::Module::submodules_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::Module::submodules_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::Module::submodules_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::Module::submodules_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::OverloadedTemplateStorage::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::OverloadedTemplateStorage::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::OverloadedTemplateStorage::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::OverloadedTemplateStorage::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::FunctionProtoType::getParamTypes_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::FunctionProtoType::getParamTypes_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::FunctionProtoType::getParamTypes_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::FunctionProtoType::getParamTypes_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::FunctionProtoType::param_types_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::FunctionProtoType::param_types_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::FunctionProtoType::param_types_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::FunctionProtoType::param_types_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::FunctionProtoType::exceptions_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::FunctionProtoType::exceptions_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::FunctionProtoType::exceptions_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::FunctionProtoType::exceptions_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::FunctionProtoType::getExtParameterInfos_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::FunctionProtoType::getExtParameterInfos_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::FunctionProtoType::getExtParameterInfos_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::FunctionProtoType::getExtParameterInfos_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::TemplateSpecializationType::template_arguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::TemplateSpecializationType::template_arguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::TemplateSpecializationType::template_arguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::TemplateSpecializationType::template_arguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::TemplateSpecializationType::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::TemplateSpecializationType::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::TemplateSpecializationType::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::TemplateSpecializationType::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DependentTemplateSpecializationType::template_arguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DependentTemplateSpecializationType::template_arguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DependentTemplateSpecializationType::template_arguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DependentTemplateSpecializationType::template_arguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DependentTemplateSpecializationType::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DependentTemplateSpecializationType::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DependentTemplateSpecializationType::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DependentTemplateSpecializationType::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCTypeParamType::quals_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCTypeParamType::quals_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCTypeParamType::quals_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCTypeParamType::quals_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCTypeParamType::getProtocols_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCTypeParamType::getProtocols_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCTypeParamType::getProtocols_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCTypeParamType::getProtocols_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCObjectType::quals_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCObjectType::quals_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCObjectType::quals_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCObjectType::quals_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCObjectType::getProtocols_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCObjectType::getProtocols_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCObjectType::getProtocols_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCObjectType::getProtocols_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCObjectType::getTypeArgs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCObjectType::getTypeArgs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCObjectType::getTypeArgs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCObjectType::getTypeArgs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCObjectType::getTypeArgsAsWritten_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCObjectType::getTypeArgsAsWritten_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCObjectType::getTypeArgsAsWritten_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCObjectType::getTypeArgsAsWritten_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCObjectPointerType::getTypeArgs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCObjectPointerType::getTypeArgs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCObjectPointerType::getTypeArgs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCObjectPointerType::getTypeArgs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCObjectPointerType::getTypeArgsAsWritten_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCObjectPointerType::getTypeArgsAsWritten_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCObjectPointerType::getTypeArgsAsWritten_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCObjectPointerType::getTypeArgsAsWritten_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCObjectPointerType::quals_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCObjectPointerType::quals_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCObjectPointerType::quals_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCObjectPointerType::quals_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::FunctionDecl::parameters_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::FunctionDecl::parameters_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::FunctionDecl::parameters_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::FunctionDecl::parameters_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::IndirectFieldDecl::chain_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::IndirectFieldDecl::chain_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::IndirectFieldDecl::chain_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::IndirectFieldDecl::chain_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::EnumDecl::enumerators_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::EnumDecl::enumerators_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::EnumDecl::enumerators_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::EnumDecl::enumerators_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::RecordDecl::fields_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::RecordDecl::fields_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::RecordDecl::fields_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::RecordDecl::fields_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::BlockDecl::parameters_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::BlockDecl::parameters_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::BlockDecl::parameters_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::BlockDecl::parameters_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::BlockDecl::captures_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::BlockDecl::captures_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::BlockDecl::captures_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::BlockDecl::captures_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CapturedDecl::parameters_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CapturedDecl::parameters_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CapturedDecl::parameters_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CapturedDecl::parameters_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ImportDecl::getIdentifierLocs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ImportDecl::getIdentifierLocs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ImportDecl::getIdentifierLocs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ImportDecl::getIdentifierLocs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DeclGroupRef::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DeclGroupRef::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DeclGroupRef::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DeclGroupRef::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::Stmt::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::Stmt::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::Stmt::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::Stmt::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DeclStmt::decls_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DeclStmt::decls_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DeclStmt::decls_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DeclStmt::decls_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CompoundStmt::body_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CompoundStmt::body_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CompoundStmt::body_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CompoundStmt::body_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CompoundStmt::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CompoundStmt::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CompoundStmt::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CompoundStmt::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::AttributedStmt::getAttrs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::AttributedStmt::getAttrs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::AttributedStmt::getAttrs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::AttributedStmt::getAttrs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::AsmStmt::inputs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::AsmStmt::inputs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::AsmStmt::inputs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::AsmStmt::inputs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::AsmStmt::outputs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::AsmStmt::outputs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::AsmStmt::outputs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::AsmStmt::outputs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::MSAsmStmt::getAllConstraints_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::MSAsmStmt::getAllConstraints_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::MSAsmStmt::getAllConstraints_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::MSAsmStmt::getAllConstraints_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::MSAsmStmt::getClobbers_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::MSAsmStmt::getClobbers_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::MSAsmStmt::getClobbers_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::MSAsmStmt::getClobbers_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::MSAsmStmt::getAllExprs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::MSAsmStmt::getAllExprs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::MSAsmStmt::getAllExprs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::MSAsmStmt::getAllExprs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CapturedStmt::captures_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CapturedStmt::captures_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CapturedStmt::captures_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CapturedStmt::captures_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CapturedStmt::capture_inits_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CapturedStmt::capture_inits_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CapturedStmt::capture_inits_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CapturedStmt::capture_inits_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::TemplateArgument::pack_elements_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::TemplateArgument::pack_elements_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::TemplateArgument::pack_elements_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::TemplateArgument::pack_elements_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::TemplateArgument::getPackAsArray_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::TemplateArgument::getPackAsArray_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::TemplateArgument::getPackAsArray_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::TemplateArgument::getPackAsArray_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::TemplateArgumentListInfo::arguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::TemplateArgumentListInfo::arguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::TemplateArgumentListInfo::arguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::TemplateArgumentListInfo::arguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ASTTemplateArgumentListInfo::arguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ASTTemplateArgumentListInfo::arguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ASTTemplateArgumentListInfo::arguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ASTTemplateArgumentListInfo::arguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::llvm::Type::subtypes_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::llvm::Type::subtypes_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::llvm::Type::subtypes_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::llvm::Type::subtypes_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::llvm::StructType::elements_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::llvm::StructType::elements_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::llvm::StructType::elements_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::llvm::StructType::elements_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::llvm::DataLayout::getNonIntegralAddressSpaces_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::llvm::DataLayout::getNonIntegralAddressSpaces_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::llvm::DataLayout::getNonIntegralAddressSpaces_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::llvm::DataLayout::getNonIntegralAddressSpaces_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ASTContext::local_imports_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ASTContext::local_imports_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ASTContext::local_imports_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ASTContext::local_imports_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::UnresolvedSetImpl::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::UnresolvedSetImpl::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::UnresolvedSetImpl::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::UnresolvedSetImpl::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::OpaqueValueExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::OpaqueValueExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::OpaqueValueExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::OpaqueValueExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DeclRefExpr::template_arguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DeclRefExpr::template_arguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DeclRefExpr::template_arguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DeclRefExpr::template_arguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DeclRefExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DeclRefExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DeclRefExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DeclRefExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::PredefinedExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::PredefinedExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::PredefinedExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::PredefinedExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::IntegerLiteral::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::IntegerLiteral::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::IntegerLiteral::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::IntegerLiteral::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::FixedPointLiteral::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::FixedPointLiteral::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::FixedPointLiteral::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::FixedPointLiteral::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CharacterLiteral::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CharacterLiteral::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CharacterLiteral::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CharacterLiteral::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::FloatingLiteral::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::FloatingLiteral::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::FloatingLiteral::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::FloatingLiteral::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ImaginaryLiteral::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ImaginaryLiteral::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ImaginaryLiteral::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ImaginaryLiteral::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::StringLiteral::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::StringLiteral::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::StringLiteral::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::StringLiteral::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ParenExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ParenExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ParenExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ParenExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::UnaryOperator::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::UnaryOperator::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::UnaryOperator::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::UnaryOperator::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::OffsetOfExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::OffsetOfExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::OffsetOfExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::OffsetOfExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::UnaryExprOrTypeTraitExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::UnaryExprOrTypeTraitExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::UnaryExprOrTypeTraitExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::UnaryExprOrTypeTraitExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ArraySubscriptExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ArraySubscriptExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ArraySubscriptExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ArraySubscriptExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CallExpr::arguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CallExpr::arguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CallExpr::arguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CallExpr::arguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CallExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CallExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CallExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CallExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::MemberExpr::template_arguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::MemberExpr::template_arguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::MemberExpr::template_arguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::MemberExpr::template_arguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::MemberExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::MemberExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::MemberExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::MemberExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CompoundLiteralExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CompoundLiteralExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CompoundLiteralExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CompoundLiteralExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CastExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CastExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CastExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CastExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::BinaryOperator::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::BinaryOperator::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::BinaryOperator::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::BinaryOperator::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ConditionalOperator::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ConditionalOperator::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ConditionalOperator::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ConditionalOperator::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::BinaryConditionalOperator::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::BinaryConditionalOperator::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::BinaryConditionalOperator::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::BinaryConditionalOperator::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::AddrLabelExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::AddrLabelExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::AddrLabelExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::AddrLabelExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::StmtExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::StmtExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::StmtExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::StmtExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ShuffleVectorExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ShuffleVectorExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ShuffleVectorExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ShuffleVectorExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ConvertVectorExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ConvertVectorExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ConvertVectorExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ConvertVectorExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ChooseExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ChooseExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ChooseExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ChooseExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::GNUNullExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::GNUNullExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::GNUNullExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::GNUNullExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::VAArgExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::VAArgExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::VAArgExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::VAArgExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::InitListExpr::inits_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::InitListExpr::inits_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::InitListExpr::inits_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::InitListExpr::inits_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::InitListExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::InitListExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::InitListExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::InitListExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::InitListExpr::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::InitListExpr::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::InitListExpr::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::InitListExpr::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DesignatedInitExpr::designators_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DesignatedInitExpr::designators_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DesignatedInitExpr::designators_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DesignatedInitExpr::designators_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DesignatedInitExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DesignatedInitExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DesignatedInitExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DesignatedInitExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::NoInitExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::NoInitExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::NoInitExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::NoInitExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DesignatedInitUpdateExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DesignatedInitUpdateExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DesignatedInitUpdateExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DesignatedInitUpdateExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ArrayInitLoopExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ArrayInitLoopExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ArrayInitLoopExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ArrayInitLoopExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ArrayInitIndexExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ArrayInitIndexExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ArrayInitIndexExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ArrayInitIndexExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ImplicitValueInitExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ImplicitValueInitExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ImplicitValueInitExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ImplicitValueInitExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ParenListExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ParenListExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ParenListExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ParenListExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::GenericSelectionExpr::getAssocExprs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::GenericSelectionExpr::getAssocExprs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::GenericSelectionExpr::getAssocExprs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::GenericSelectionExpr::getAssocExprs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::GenericSelectionExpr::getAssocTypeSourceInfos_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::GenericSelectionExpr::getAssocTypeSourceInfos_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::GenericSelectionExpr::getAssocTypeSourceInfos_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::GenericSelectionExpr::getAssocTypeSourceInfos_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::GenericSelectionExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::GenericSelectionExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::GenericSelectionExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::GenericSelectionExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ExtVectorElementExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ExtVectorElementExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ExtVectorElementExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ExtVectorElementExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::BlockExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::BlockExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::BlockExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::BlockExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::AsTypeExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::AsTypeExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::AsTypeExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::AsTypeExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::PseudoObjectExpr::semantics_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::PseudoObjectExpr::semantics_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::PseudoObjectExpr::semantics_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::PseudoObjectExpr::semantics_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::PseudoObjectExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::PseudoObjectExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::PseudoObjectExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::PseudoObjectExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::AtomicExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::AtomicExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::AtomicExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::AtomicExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::TypoExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::TypoExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::TypoExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::TypoExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXRecordDecl::bases_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXRecordDecl::bases_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXRecordDecl::bases_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXRecordDecl::bases_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXRecordDecl::vbases_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXRecordDecl::vbases_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXRecordDecl::vbases_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXRecordDecl::vbases_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXRecordDecl::methods_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXRecordDecl::methods_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXRecordDecl::methods_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXRecordDecl::methods_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXRecordDecl::ctors_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXRecordDecl::ctors_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXRecordDecl::ctors_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXRecordDecl::ctors_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXRecordDecl::friends_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXRecordDecl::friends_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXRecordDecl::friends_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXRecordDecl::friends_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXRecordDecl::captures_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXRecordDecl::captures_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXRecordDecl::captures_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXRecordDecl::captures_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXConstructorDecl::inits_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXConstructorDecl::inits_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXConstructorDecl::inits_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXConstructorDecl::inits_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::UsingDecl::shadows_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::UsingDecl::shadows_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::UsingDecl::shadows_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::UsingDecl::shadows_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::UsingPackDecl::expansions_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::UsingPackDecl::expansions_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::UsingPackDecl::expansions_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::UsingPackDecl::expansions_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DecompositionDecl::bindings_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DecompositionDecl::bindings_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DecompositionDecl::bindings_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DecompositionDecl::bindings_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::TemplateParameterList::asArray_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::TemplateParameterList::asArray_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::TemplateParameterList::asArray_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::TemplateParameterList::asArray_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::TemplateParameterList::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::TemplateParameterList::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::TemplateParameterList::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::TemplateParameterList::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::TemplateArgumentList::asArray_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::TemplateArgumentList::asArray_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::TemplateArgumentList::asArray_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::TemplateArgumentList::asArray_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::FunctionTemplateDecl::specializations_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::FunctionTemplateDecl::specializations_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::FunctionTemplateDecl::specializations_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::FunctionTemplateDecl::specializations_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ClassTemplateDecl::specializations_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ClassTemplateDecl::specializations_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ClassTemplateDecl::specializations_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ClassTemplateDecl::specializations_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::VarTemplateDecl::specializations_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::VarTemplateDecl::specializations_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::VarTemplateDecl::specializations_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::VarTemplateDecl::specializations_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCProtocolList::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCProtocolList::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCProtocolList::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCProtocolList::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCMethodDecl::parameters_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCMethodDecl::parameters_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCMethodDecl::parameters_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCMethodDecl::parameters_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCTypeParamList::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCTypeParamList::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCTypeParamList::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCTypeParamList::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCContainerDecl::properties_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCContainerDecl::properties_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCContainerDecl::properties_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCContainerDecl::properties_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCContainerDecl::instance_properties_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCContainerDecl::instance_properties_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCContainerDecl::instance_properties_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCContainerDecl::instance_properties_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCContainerDecl::class_properties_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCContainerDecl::class_properties_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCContainerDecl::class_properties_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCContainerDecl::class_properties_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCContainerDecl::methods_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCContainerDecl::methods_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCContainerDecl::methods_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCContainerDecl::methods_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCContainerDecl::instance_methods_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCContainerDecl::instance_methods_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCContainerDecl::instance_methods_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCContainerDecl::instance_methods_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCContainerDecl::class_methods_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCContainerDecl::class_methods_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCContainerDecl::class_methods_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCContainerDecl::class_methods_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCInterfaceDecl::protocols_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCInterfaceDecl::protocols_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCInterfaceDecl::protocols_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCInterfaceDecl::protocols_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCInterfaceDecl::protocol_locs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCInterfaceDecl::protocol_locs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCInterfaceDecl::protocol_locs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCInterfaceDecl::protocol_locs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCInterfaceDecl::all_referenced_protocols_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCInterfaceDecl::all_referenced_protocols_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCInterfaceDecl::all_referenced_protocols_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCInterfaceDecl::all_referenced_protocols_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCInterfaceDecl::ivars_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCInterfaceDecl::ivars_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCInterfaceDecl::ivars_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCInterfaceDecl::ivars_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCInterfaceDecl::visible_categories_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCInterfaceDecl::visible_categories_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCInterfaceDecl::visible_categories_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCInterfaceDecl::visible_categories_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCInterfaceDecl::known_categories_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCInterfaceDecl::known_categories_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCInterfaceDecl::known_categories_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCInterfaceDecl::known_categories_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCInterfaceDecl::visible_extensions_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCInterfaceDecl::visible_extensions_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCInterfaceDecl::visible_extensions_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCInterfaceDecl::visible_extensions_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCInterfaceDecl::known_extensions_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCInterfaceDecl::known_extensions_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCInterfaceDecl::known_extensions_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCInterfaceDecl::known_extensions_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCProtocolDecl::protocols_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCProtocolDecl::protocols_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCProtocolDecl::protocols_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCProtocolDecl::protocols_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCProtocolDecl::protocol_locs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCProtocolDecl::protocol_locs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCProtocolDecl::protocol_locs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCProtocolDecl::protocol_locs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCCategoryDecl::protocols_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCCategoryDecl::protocols_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCCategoryDecl::protocols_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCCategoryDecl::protocols_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCCategoryDecl::protocol_locs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCCategoryDecl::protocol_locs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCCategoryDecl::protocol_locs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCCategoryDecl::protocol_locs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCCategoryDecl::ivars_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCCategoryDecl::ivars_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCCategoryDecl::ivars_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCCategoryDecl::ivars_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCImplDecl::property_impls_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCImplDecl::property_impls_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCImplDecl::property_impls_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCImplDecl::property_impls_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCImplementationDecl::inits_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCImplementationDecl::inits_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCImplementationDecl::inits_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCImplementationDecl::inits_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCImplementationDecl::ivars_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCImplementationDecl::ivars_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCImplementationDecl::ivars_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCImplementationDecl::ivars_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::OMPThreadPrivateDecl::varlists_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::OMPThreadPrivateDecl::varlists_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::OMPThreadPrivateDecl::varlists_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::OMPThreadPrivateDecl::varlists_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXConstructExpr::arguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXConstructExpr::arguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXConstructExpr::arguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXConstructExpr::arguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::LambdaExpr::captures_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::LambdaExpr::captures_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::LambdaExpr::captures_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::LambdaExpr::captures_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::LambdaExpr::explicit_captures_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::LambdaExpr::explicit_captures_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::LambdaExpr::explicit_captures_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::LambdaExpr::explicit_captures_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::LambdaExpr::implicit_captures_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::LambdaExpr::implicit_captures_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::LambdaExpr::implicit_captures_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::LambdaExpr::implicit_captures_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::LambdaExpr::capture_inits_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::LambdaExpr::capture_inits_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::LambdaExpr::capture_inits_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::LambdaExpr::capture_inits_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXNewExpr::placement_arguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXNewExpr::placement_arguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXNewExpr::placement_arguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXNewExpr::placement_arguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::TypeTraitExpr::getArgs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::TypeTraitExpr::getArgs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::TypeTraitExpr::getArgs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::TypeTraitExpr::getArgs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::OverloadExpr::decls_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::OverloadExpr::decls_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::OverloadExpr::decls_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::OverloadExpr::decls_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::OverloadExpr::template_arguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::OverloadExpr::template_arguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::OverloadExpr::template_arguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::OverloadExpr::template_arguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::DependentScopeDeclRefExpr::template_arguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::DependentScopeDeclRefExpr::template_arguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::DependentScopeDeclRefExpr::template_arguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::DependentScopeDeclRefExpr::template_arguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ExprWithCleanups::getObjects_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ExprWithCleanups::getObjects_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ExprWithCleanups::getObjects_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ExprWithCleanups::getObjects_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXDependentScopeMemberExpr::template_arguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXDependentScopeMemberExpr::template_arguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXDependentScopeMemberExpr::template_arguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXDependentScopeMemberExpr::template_arguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::SizeOfPackExpr::getPartialArguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::SizeOfPackExpr::getPartialArguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::SizeOfPackExpr::getPartialArguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::SizeOfPackExpr::getPartialArguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::FunctionParmPackExpr::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::FunctionParmPackExpr::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::FunctionParmPackExpr::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::FunctionParmPackExpr::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CompilerDiagnosticExpr::getArgs_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CompilerDiagnosticExpr::getArgs_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CompilerDiagnosticExpr::getArgs_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CompilerDiagnosticExpr::getArgs_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXConstantExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXConstantExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXConstantExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXConstantExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXDependentIdExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXDependentIdExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXDependentIdExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXDependentIdExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXConcatenateExpr::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXConcatenateExpr::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXConcatenateExpr::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXConcatenateExpr::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::ObjCMessageExpr::arguments_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::ObjCMessageExpr::arguments_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::ObjCMessageExpr::arguments_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::ObjCMessageExpr::arguments_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CXXExpansionStmt::getInstantiatedStatements_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CXXExpansionStmt::getInstantiatedStatements_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CXXExpansionStmt::getInstantiatedStatements_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CXXExpansionStmt::getInstantiatedStatements_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::CoroutineBodyStmt::getParamMoves_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::CoroutineBodyStmt::getParamMoves_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::CoroutineBodyStmt::getParamMoves_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::CoroutineBodyStmt::getParamMoves_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::OMPClause::children_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::OMPClause::children_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::OMPClause::children_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::OMPClause::children_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::OMPExecutableDirective::clauses_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::OMPExecutableDirective::clauses_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::OMPExecutableDirective::clauses_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::OMPExecutableDirective::clauses_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::OMPLoopDirective::counters_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::OMPLoopDirective::counters_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::OMPLoopDirective::counters_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::OMPLoopDirective::counters_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::OMPLoopDirective::private_counters_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::OMPLoopDirective::private_counters_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::OMPLoopDirective::private_counters_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::OMPLoopDirective::private_counters_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::OMPLoopDirective::inits_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::OMPLoopDirective::inits_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::OMPLoopDirective::inits_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::OMPLoopDirective::inits_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::OMPLoopDirective::updates_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::OMPLoopDirective::updates_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::OMPLoopDirective::updates_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::OMPLoopDirective::updates_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::clang::OMPLoopDirective::finals_tuple<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::clang::OMPLoopDirective::finals_tuple<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::clang::OMPLoopDirective::finals_tuple<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::clang::OMPLoopDirective::finals_tuple<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::reflcontainers::VectorStr::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::reflcontainers::VectorStr::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::reflcontainers::VectorStr::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::reflcontainers::VectorStr::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::reflcontainers::VectorInt::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::reflcontainers::VectorInt::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::reflcontainers::VectorInt::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::reflcontainers::VectorInt::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::reflcontainers::SetInt::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::reflcontainers::SetInt::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::reflcontainers::SetInt::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::reflcontainers::SetInt::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::reflcontainers::SetStr::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::reflcontainers::SetStr::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::reflcontainers::SetStr::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::reflcontainers::SetStr::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::reflcontainers::MapIntStr::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::reflcontainers::MapIntStr::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::reflcontainers::MapIntStr::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::reflcontainers::MapIntStr::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::reflcontainers::MapStrInt::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::reflcontainers::MapStrInt::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::reflcontainers::MapStrInt::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::reflcontainers::MapStrInt::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::reflcontainers::MapStrStr::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::reflcontainers::MapStrStr::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::reflcontainers::MapStrStr::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::reflcontainers::MapStrStr::impl<Xs...>::template _get_<I>());
  };

  template<intptr_t... Xs>
  struct tuple_size<cppx::meta::refldetail::reflcontainers::MapIntInt::impl<Xs...>>
      : std::integral_constant<std::size_t, cppx::meta::refldetail::reflcontainers::MapIntInt::impl<Xs...>::_size_()>
  { };
  template<std::size_t I, intptr_t... Xs>
  struct tuple_element<I, cppx::meta::refldetail::reflcontainers::MapIntInt::impl<Xs...>>
  {
    using type = decltype(cppx::meta::refldetail::reflcontainers::MapIntInt::impl<Xs...>::template _get_<I>());
  };


} // namespace std
#endif //__CONSUMER_SUPPORTS_REFLECTION_AND_META__

#endif //CPPX_META_client_reflection_impl_HPP